/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/error-stack-parser/error-stack-parser.js":
/*!***************************************************************!*\
  !*** ./node_modules/error-stack-parser/error-stack-parser.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function ErrorStackParser(StackFrame) {
    'use strict';

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;

    function _map(array, fn, thisArg) {
        if (typeof Array.prototype.map === 'function') {
            return array.map(fn, thisArg);
        } else {
            var output = new Array(array.length);
            for (var i = 0; i < array.length; i++) {
                output[i] = fn.call(thisArg, array[i]);
            }
            return output;
        }
    }

    function _filter(array, fn, thisArg) {
        if (typeof Array.prototype.filter === 'function') {
            return array.filter(fn, thisArg);
        } else {
            var output = [];
            for (var i = 0; i < array.length; i++) {
                if (fn.call(thisArg, array[i])) {
                    output.push(array[i]);
                }
            }
            return output;
        }
    }

    function _indexOf(array, target) {
        if (typeof Array.prototype.indexOf === 'function') {
            return array.indexOf(target);
        } else {
            for (var i = 0; i < array.length; i++) {
                if (array[i] === target) {
                    return i;
                }
            }
            return -1;
        }
    }

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = _filter(error.stack.split('\n'), function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return _map(filtered, function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
                }
                var tokens = line.replace(/^\s+/, '').replace(/\(eval code/g, '(').split(/\s+/).slice(1);
                var locationParts = this.extractLocation(tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = _indexOf(['eval', '<anonymous>'], locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame(functionName, undefined, fileName, locationParts[1], locationParts[2], line);
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = _filter(error.stack.split('\n'), function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return _map(filtered, function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame(line);
                } else {
                    var tokens = line.split('@');
                    var locationParts = this.extractLocation(tokens.pop());
                    var functionName = tokens.join('@') || undefined;
                    return new StackFrame(functionName,
                        undefined,
                        locationParts[0],
                        locationParts[1],
                        locationParts[2],
                        line);
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame(undefined, undefined, match[2], match[1], undefined, lines[i]));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame(
                            match[3] || undefined,
                            undefined,
                            match[2],
                            match[1],
                            undefined,
                            lines[i]
                        )
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = _filter(error.stack.split('\n'), function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return _map(filtered, function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                        .replace(/<anonymous function(: (\w+))?>/, '$2')
                        .replace(/\([^\)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^\)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');
                return new StackFrame(
                    functionName,
                    args,
                    locationParts[0],
                    locationParts[1],
                    locationParts[2],
                    line);
            }, this);
        }
    };
}));



/***/ }),

/***/ "./node_modules/query-selector-shadow-dom/src/normalize.js":
/*!*****************************************************************!*\
  !*** ./node_modules/query-selector-shadow-dom/src/normalize.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normalizeSelector": () => (/* binding */ normalizeSelector)
/* harmony export */ });
/* istanbul ignore file */


// normalize-selector-rev-02.js
/*
  author: kyle simpson (@getify)
  original source: https://gist.github.com/getify/9679380

  modified for tests by david kaye (@dfkaye)
  21 march 2014

  rev-02 incorporate kyle's changes 3/2/42014
*/

function normalizeSelector(sel) {
  // save unmatched text, if any
  function saveUnmatched() {
    if (unmatched) {
      // whitespace needed after combinator?
      if (tokens.length > 0 && /^[~+>]$/.test(tokens[tokens.length - 1])) {
        tokens.push(" ");
      }

      // save unmatched text
      tokens.push(unmatched);
    }
  }

  var tokens = [],
    match,
    unmatched,
    regex,
    state = [0],
    next_match_idx = 0,
    prev_match_idx,
    not_escaped_pattern = /(?:[^\\]|(?:^|[^\\])(?:\\\\)+)$/,
    whitespace_pattern = /^\s+$/,
    state_patterns = [
      /\s+|\/\*|["'>~+[(]/g, // general
      /\s+|\/\*|["'[\]()]/g, // [..] set
      /\s+|\/\*|["'[\]()]/g, // (..) set
      null, // string literal (placeholder)
      /\*\//g, // comment
    ];
  sel = sel.trim();

  // eslint-disable-next-line no-constant-condition
  while (true) {
    unmatched = "";

    regex = state_patterns[state[state.length - 1]];

    regex.lastIndex = next_match_idx;
    match = regex.exec(sel);

    // matched text to process?
    if (match) {
      prev_match_idx = next_match_idx;
      next_match_idx = regex.lastIndex;

      // collect the previous string chunk not matched before this token
      if (prev_match_idx < next_match_idx - match[0].length) {
        unmatched = sel.substring(
          prev_match_idx,
          next_match_idx - match[0].length
        );
      }

      // general, [ ] pair, ( ) pair?
      if (state[state.length - 1] < 3) {
        saveUnmatched();

        // starting a [ ] pair?
        if (match[0] === "[") {
          state.push(1);
        }
        // starting a ( ) pair?
        else if (match[0] === "(") {
          state.push(2);
        }
        // starting a string literal?
        else if (/^["']$/.test(match[0])) {
          state.push(3);
          state_patterns[3] = new RegExp(match[0], "g");
        }
        // starting a comment?
        else if (match[0] === "/*") {
          state.push(4);
        }
        // ending a [ ] or ( ) pair?
        else if (/^[\])]$/.test(match[0]) && state.length > 0) {
          state.pop();
        }
        // handling whitespace or a combinator?
        else if (/^(?:\s+|[~+>])$/.test(match[0])) {
          // need to insert whitespace before?
          if (
            tokens.length > 0 &&
            !whitespace_pattern.test(tokens[tokens.length - 1]) &&
            state[state.length - 1] === 0
          ) {
            // add normalized whitespace
            tokens.push(" ");
          }

          // case-insensitive attribute selector CSS L4
          if (
            state[state.length - 1] === 1 &&
            tokens.length === 5 &&
            tokens[2].charAt(tokens[2].length - 1) === "="
          ) {
            tokens[4] = " " + tokens[4];
          }

          // whitespace token we can skip?
          if (whitespace_pattern.test(match[0])) {
            continue;
          }
        }

        // save matched text
        tokens.push(match[0]);
      }
      // otherwise, string literal or comment
      else {
        // save unmatched text
        tokens[tokens.length - 1] += unmatched;

        // unescaped terminator to string literal or comment?
        if (not_escaped_pattern.test(tokens[tokens.length - 1])) {
          // comment terminator?
          if (state[state.length - 1] === 4) {
            // ok to drop comment?
            if (
              tokens.length < 2 ||
              whitespace_pattern.test(tokens[tokens.length - 2])
            ) {
              tokens.pop();
            }
            // otherwise, turn comment into whitespace
            else {
              tokens[tokens.length - 1] = " ";
            }

            // handled already
            match[0] = "";
          }

          state.pop();
        }

        // append matched text to existing token
        tokens[tokens.length - 1] += match[0];
      }
    }
    // otherwise, end of processing (no more matches)
    else {
      unmatched = sel.substr(next_match_idx);
      saveUnmatched();

      break;
    }
  }

  return tokens.join("").trim();
}


/***/ }),

/***/ "./node_modules/query-selector-shadow-dom/src/querySelectorDeep.js":
/*!*************************************************************************!*\
  !*** ./node_modules/query-selector-shadow-dom/src/querySelectorDeep.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "collectAllElementsDeep": () => (/* binding */ collectAllElementsDeep),
/* harmony export */   "querySelectorAllDeep": () => (/* binding */ querySelectorAllDeep),
/* harmony export */   "querySelectorDeep": () => (/* binding */ querySelectorDeep)
/* harmony export */ });
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normalize */ "./node_modules/query-selector-shadow-dom/src/normalize.js");
/**
 * @author Georgegriff@ (George Griffiths)
 * License Apache-2.0
 */



/**
* Finds first matching elements on the page that may be in a shadow root using a complex selector of n-depth
*
* Don't have to specify all shadow roots to button, tree is travered to find the correct element
*
* Example querySelectorAllDeep('downloads-item:nth-child(4) #remove');
*
* Example should work on chrome://downloads outputting the remove button inside of a download card component
*
* Example find first active download link element querySelectorDeep('#downloads-list .is-active a[href^="https://"]');
*
* Another example querySelectorAllDeep('#downloads-list div#title-area + a');
e.g.
*/
function querySelectorAllDeep(selector, root = document, allElements = null) {
    return _querySelectorDeep(selector, true, root, allElements);
}

function querySelectorDeep(selector, root = document, allElements = null) {
    return _querySelectorDeep(selector, false, root, allElements);
}

function _querySelectorDeep(selector, findMany, root, allElements = null) {
    selector = (0,_normalize__WEBPACK_IMPORTED_MODULE_0__.normalizeSelector)(selector);
    let lightElement = root.querySelector(selector);

    if (document.head.createShadowRoot || document.head.attachShadow) {
        // no need to do any special if selector matches something specific in light-dom
        if (!findMany && lightElement) {
            return lightElement;
        }

        // split on commas because those are a logical divide in the operation
        const selectionsToMake = splitByCharacterUnlessQuoted(selector, ',');

        return selectionsToMake.reduce((acc, minimalSelector) => {
            // if not finding many just reduce the first match
            if (!findMany && acc) {
                return acc;
            }
            // do best to support complex selectors and split the query
            const splitSelector = splitByCharacterUnlessQuoted(minimalSelector
                    //remove white space at start of selector
                    .replace(/^\s+/g, '')
                    .replace(/\s*([>+~]+)\s*/g, '$1'), ' ')
                    // filter out entry white selectors
                    .filter((entry) => !!entry)
                    // convert "a > b" to ["a", "b"]
                    .map((entry) => splitByCharacterUnlessQuoted(entry, '>'));

            const possibleElementsIndex = splitSelector.length - 1;
            const lastSplitPart = splitSelector[possibleElementsIndex][splitSelector[possibleElementsIndex].length - 1];
            const possibleElements = collectAllElementsDeep(lastSplitPart, root, allElements);
            const findElements = findMatchingElement(splitSelector, possibleElementsIndex, root);
            if (findMany) {
                acc = acc.concat(possibleElements.filter(findElements));
                return acc;
            } else {
                acc = possibleElements.find(findElements);
                return acc || null;
            }
        }, findMany ? [] : null);


    } else {
        if (!findMany) {
            return lightElement;
        } else {
            return root.querySelectorAll(selector);
        }
    }

}

function findMatchingElement(splitSelector, possibleElementsIndex, root) {
    return (element) => {
        let position = possibleElementsIndex;
        let parent = element;
        let foundElement = false;
        while (parent && !isDocumentNode(parent)) {
            let foundMatch = true;
            if (splitSelector[position].length === 1) {
                foundMatch = parent.matches(splitSelector[position]);
            } else {
                // selector is in the format "a > b"
                // make sure a few parents match in order
                const reversedParts = ([]).concat(splitSelector[position]).reverse();
                let newParent = parent;
                for (const part of reversedParts) {
                    if (!newParent || !newParent.matches(part)) {
                        foundMatch = false;
                        break;
                    }
                    newParent = findParentOrHost(newParent, root);
                }
            }

            if (foundMatch && position === 0) {
                foundElement = true;
                break;
            }
            if (foundMatch) {
                position--;
            }
            parent = findParentOrHost(parent, root);
        }
        return foundElement;
    };

}

function splitByCharacterUnlessQuoted(selector, character) {
    return selector.match(/\\?.|^$/g).reduce((p, c) => {
        if (c === '"' && !p.sQuote) {
            p.quote ^= 1;
            p.a[p.a.length - 1] += c;
        } else if (c === '\'' && !p.quote) {
            p.sQuote ^= 1;
            p.a[p.a.length - 1] += c;

        } else if (!p.quote && !p.sQuote && c === character) {
            p.a.push('');
        } else {
            p.a[p.a.length - 1] += c;
        }
        return p;
    }, { a: [''] }).a;
}

/**
 * Checks if the node is a document node or not.
 * @param {Node} node
 * @returns {node is Document | DocumentFragment}
 */
function isDocumentNode(node) {
    return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.DOCUMENT_NODE;
}

function findParentOrHost(element, root) {
    const parentNode = element.parentNode;
    return (parentNode && parentNode.host && parentNode.nodeType === 11) ? parentNode.host : parentNode === root ? null : parentNode;
}

/**
 * Finds all elements on the page, inclusive of those within shadow roots.
 * @param {string=} selector Simple selector to filter the elements by. e.g. 'a', 'div.main'
 * @return {!Array<string>} List of anchor hrefs.
 * @author ebidel@ (Eric Bidelman)
 * License Apache-2.0
 */
function collectAllElementsDeep(selector = null, root, cachedElements = null) {
    let allElements = [];

    if (cachedElements) {
        allElements = cachedElements;
    } else {
        const findAllElements = function(nodes) {
            for (let i = 0; i < nodes.length; i++) {
                const el = nodes[i];
                allElements.push(el);
                // If the element has a shadow root, dig deeper.
                if (el.shadowRoot) {
                    findAllElements(el.shadowRoot.querySelectorAll('*'));
                }
            }
        };
        if(root.shadowRoot) {
            findAllElements(root.shadowRoot.querySelectorAll('*'));
        }
        findAllElements(root.querySelectorAll('*'));
    }

    return selector ? allElements.filter(el => el.matches(selector)) : allElements;	}



/***/ }),

/***/ "./node_modules/source-map/lib/array-set.js":
/*!**************************************************!*\
  !*** ./node_modules/source-map/lib/array-set.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var has = Object.prototype.hasOwnProperty;

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = util.toSetString(aStr);
  var isDuplicate = has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    this._set[sStr] = idx;
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  var sStr = util.toSetString(aStr);
  return has.call(this._set, sStr);
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  var sStr = util.toSetString(aStr);
  if (has.call(this._set, sStr)) {
    return this._set[sStr];
  }
  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;


/***/ }),

/***/ "./node_modules/source-map/lib/base64-vlq.js":
/*!***************************************************!*\
  !*** ./node_modules/source-map/lib/base64-vlq.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(/*! ./base64 */ "./node_modules/source-map/lib/base64.js");

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),

/***/ "./node_modules/source-map/lib/base64.js":
/*!***********************************************!*\
  !*** ./node_modules/source-map/lib/base64.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),

/***/ "./node_modules/source-map/lib/binary-search.js":
/*!******************************************************!*\
  !*** ./node_modules/source-map/lib/binary-search.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ "./node_modules/source-map/lib/mapping-list.js":
/*!*****************************************************!*\
  !*** ./node_modules/source-map/lib/mapping-list.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;


/***/ }),

/***/ "./node_modules/source-map/lib/quick-sort.js":
/*!***************************************************!*\
  !*** ./node_modules/source-map/lib/quick-sort.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),

/***/ "./node_modules/source-map/lib/source-map-consumer.js":
/*!************************************************************!*\
  !*** ./node_modules/source-map/lib/source-map-consumer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var binarySearch = __webpack_require__(/*! ./binary-search */ "./node_modules/source-map/lib/binary-search.js");
var ArraySet = (__webpack_require__(/*! ./array-set */ "./node_modules/source-map/lib/array-set.js").ArraySet);
var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/source-map/lib/base64-vlq.js");
var quickSort = (__webpack_require__(/*! ./quick-sort */ "./node_modules/source-map/lib/quick-sort.js").quickSort);

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),

/***/ "./node_modules/source-map/lib/source-map-generator.js":
/*!*************************************************************!*\
  !*** ./node_modules/source-map/lib/source-map-generator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/source-map/lib/base64-vlq.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var ArraySet = (__webpack_require__(/*! ./array-set */ "./node_modules/source-map/lib/array-set.js").ArraySet);
var MappingList = (__webpack_require__(/*! ./mapping-list */ "./node_modules/source-map/lib/mapping-list.js").MappingList);

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),

/***/ "./node_modules/source-map/lib/source-node.js":
/*!****************************************************!*\
  !*** ./node_modules/source-map/lib/source-node.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = (__webpack_require__(/*! ./source-map-generator */ "./node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator);
var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are removed from this array, by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var shiftNextLine = function() {
      var lineContents = remainingLines.shift();
      // The last line of a file might not have a newline.
      var newLine = remainingLines.shift() || "";
      return lineContents + newLine;
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[0];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[0];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[0] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLines.length > 0) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),

/***/ "./node_modules/source-map/lib/util.js":
/*!*********************************************!*\
  !*** ./node_modules/source-map/lib/util.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


/***/ }),

/***/ "./node_modules/source-map/source-map.js":
/*!***********************************************!*\
  !*** ./node_modules/source-map/source-map.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ "./node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ "./node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer;
exports.SourceNode = __webpack_require__(/*! ./lib/source-node */ "./node_modules/source-map/lib/source-node.js").SourceNode;


/***/ }),

/***/ "./node_modules/stack-generator/node_modules/stackframe/stackframe.js":
/*!****************************************************************************!*\
  !*** ./node_modules/stack-generator/node_modules/stackframe/stackframe.js ***!
  \****************************************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function() {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];
    var objectProps = ['evalOrigin'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);

    function StackFrame(obj) {
        if (!obj) return;
        for (var i = 0; i < props.length; i++) {
            if (obj[props[i]] !== undefined) {
                this['set' + _capitalize(props[i])](obj[props[i]]);
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var fileName = this.getFileName() || '';
            var lineNumber = this.getLineNumber() || '';
            var columnNumber = this.getColumnNumber() || '';
            var functionName = this.getFunctionName() || '';
            if (this.getIsEval()) {
                if (fileName) {
                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
                }
                return '[eval]:' + lineNumber + ':' + columnNumber;
            }
            if (functionName) {
                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
            }
            return fileName + ':' + lineNumber + ':' + columnNumber;
        }
    };

    StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf('(');
        var argsEndIndex = str.lastIndexOf(')');

        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
        var locationString = str.substring(argsEndIndex + 1);

        if (locationString.indexOf('@') === 0) {
            var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
            var fileName = parts[1];
            var lineNumber = parts[2];
            var columnNumber = parts[3];
        }

        return new StackFrame({
            functionName: functionName,
            args: args || undefined,
            fileName: fileName,
            lineNumber: lineNumber || undefined,
            columnNumber: columnNumber || undefined
        });
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));


/***/ }),

/***/ "./node_modules/stack-generator/stack-generator.js":
/*!*********************************************************!*\
  !*** ./node_modules/stack-generator/stack-generator.js ***!
  \*********************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/stack-generator/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function (StackFrame) {
    return {
        backtrace: function StackGenerator$$backtrace(opts) {
            var stack = [];
            var maxStackSize = 10;

            if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {
                maxStackSize = opts.maxStackSize;
            }

            var curr = arguments.callee;
            while (curr && stack.length < maxStackSize) {
                // Allow V8 optimizations
                var args = new Array(curr['arguments'].length);
                for(var i = 0; i < args.length; ++i) {
                    args[i] = curr['arguments'][i];
                }
                if (/function(?:\s+([\w$]+))+\s*\(/.test(curr.toString())) {
                    stack.push(new StackFrame({functionName: RegExp.$1 || undefined, args: args}));
                } else {
                    stack.push(new StackFrame({args: args}));
                }

                try {
                    curr = curr.caller;
                } catch (e) {
                    break;
                }
            }
            return stack;
        }
    };
}));


/***/ }),

/***/ "./node_modules/stackframe/stackframe.js":
/*!***********************************************!*\
  !*** ./node_modules/stackframe/stackframe.js ***!
  \***********************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function StackFrame(functionName, args, fileName, lineNumber, columnNumber, source) {
        if (functionName !== undefined) {
            this.setFunctionName(functionName);
        }
        if (args !== undefined) {
            this.setArgs(args);
        }
        if (fileName !== undefined) {
            this.setFileName(fileName);
        }
        if (lineNumber !== undefined) {
            this.setLineNumber(lineNumber);
        }
        if (columnNumber !== undefined) {
            this.setColumnNumber(columnNumber);
        }
        if (source !== undefined) {
            this.setSource(source);
        }
    }

    StackFrame.prototype = {
        getFunctionName: function () {
            return this.functionName;
        },
        setFunctionName: function (v) {
            this.functionName = String(v);
        },

        getArgs: function () {
            return this.args;
        },
        setArgs: function (v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        // NOTE: Property name may be misleading as it includes the path,
        // but it somewhat mirrors V8's JavaScriptStackTraceApi
        // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi and Gecko's
        // http://mxr.mozilla.org/mozilla-central/source/xpcom/base/nsIException.idl#14
        getFileName: function () {
            return this.fileName;
        },
        setFileName: function (v) {
            this.fileName = String(v);
        },

        getLineNumber: function () {
            return this.lineNumber;
        },
        setLineNumber: function (v) {
            if (!_isNumber(v)) {
                throw new TypeError('Line Number must be a Number');
            }
            this.lineNumber = Number(v);
        },

        getColumnNumber: function () {
            return this.columnNumber;
        },
        setColumnNumber: function (v) {
            if (!_isNumber(v)) {
                throw new TypeError('Column Number must be a Number');
            }
            this.columnNumber = Number(v);
        },

        getSource: function () {
            return this.source;
        },
        setSource: function (v) {
            this.source = String(v);
        },

        toString: function() {
            var functionName = this.getFunctionName() || '{anonymous}';
            var args = '(' + (this.getArgs() || []).join(',') + ')';
            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';
            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';
            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';
            return functionName + args + fileName + lineNumber + columnNumber;
        }
    };

    return StackFrame;
}));


/***/ }),

/***/ "./node_modules/stacktrace-gps/stacktrace-gps.js":
/*!*******************************************************!*\
  !*** ./node_modules/stacktrace-gps/stacktrace-gps.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! source-map */ "./node_modules/source-map/source-map.js"), __webpack_require__(/*! stackframe */ "./node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function(SourceMap, StackFrame) {
    'use strict';

    /**
     * Make a X-Domain request to url and callback.
     *
     * @param {String} url
     * @returns {Promise} with response text if fulfilled
     */
    function _xdr(url) {
        return new Promise(function(resolve, reject) {
            var req = new XMLHttpRequest();
            req.open('get', url);
            req.onerror = reject;
            req.onreadystatechange = function onreadystatechange() {
                if (req.readyState === 4) {
                    if (req.status >= 200 && req.status < 300) {
                        resolve(req.responseText);
                    } else {
                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));
                    }
                }
            };
            req.send();
        });

    }

    /**
     * Convert a Base64-encoded string into its original representation.
     * Used for inline sourcemaps.
     *
     * @param {String} b64str Base-64 encoded string
     * @returns {String} original representation of the base64-encoded string.
     */
    function _atob(b64str) {
        if (typeof window !== 'undefined' && window.atob) {
            return window.atob(b64str);
        } else {
            throw new Error('You must supply a polyfill for window.atob in this environment');
        }
    }

    function _parseJson(string) {
        if (typeof JSON !== 'undefined' && JSON.parse) {
            return JSON.parse(string);
        } else {
            throw new Error('You must supply a polyfill for JSON.parse in this environment');
        }
    }

    function _findFunctionName(source, lineNumber/*, columnNumber*/) {
        // function {name}({args}) m[1]=name m[2]=args
        var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
        // {name} = function ({args}) TODO args capture
        var reFunctionExpression = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*function\b/;
        // {name} = eval()
        var reFunctionEvaluation = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
        var lines = source.split('\n');

        // Walk backwards in the source lines until we find the line which matches one of the patterns above
        var code = '';
        var maxLines = Math.min(lineNumber, 20);
        var m;
        for (var i = 0; i < maxLines; ++i) {
            // lineNo is 1-based, source[] is 0-based
            var line = lines[lineNumber - i - 1];
            var commentPos = line.indexOf('//');
            if (commentPos >= 0) {
                line = line.substr(0, commentPos);
            }

            if (line) {
                code = line + code;
                m = reFunctionExpression.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
                m = reFunctionDeclaration.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
                m = reFunctionEvaluation.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
            }
        }
        return undefined;
    }

    function _ensureSupportedEnvironment() {
        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {
            throw new Error('Unable to consume source maps in older browsers');
        }
    }

    function _ensureStackFrameIsLegit(stackframe) {
        if (typeof stackframe !== 'object') {
            throw new TypeError('Given StackFrame is not an object');
        } else if (typeof stackframe.fileName !== 'string') {
            throw new TypeError('Given file name is not a String');
        } else if (typeof stackframe.lineNumber !== 'number' ||
            stackframe.lineNumber % 1 !== 0 ||
            stackframe.lineNumber < 1) {
            throw new TypeError('Given line number must be a positive integer');
        } else if (typeof stackframe.columnNumber !== 'number' ||
            stackframe.columnNumber % 1 !== 0 ||
            stackframe.columnNumber < 0) {
            throw new TypeError('Given column number must be a non-negative integer');
        }
        return true;
    }

    function _findSourceMappingURL(source) {
        var m = /\/\/[#@] ?sourceMappingURL=([^\s'"]+)\s*$/.exec(source);
        if (m && m[1]) {
            return m[1];
        } else {
            throw new Error('sourceMappingURL not found');
        }
    }

    function _extractLocationInfoFromSourceMap(stackframe, rawSourceMap, sourceCache) {
        return new Promise(function(resolve, reject) {
            var mapConsumer = new SourceMap.SourceMapConsumer(rawSourceMap);

            var loc = mapConsumer.originalPositionFor({
                line: stackframe.lineNumber,
                column: stackframe.columnNumber
            });

            if (loc.source) {
                var mappedSource = mapConsumer.sourceContentFor(loc.source);
                if (mappedSource) {
                    sourceCache[loc.source] = mappedSource;
                }
                resolve(
                    new StackFrame(
                        loc.name || stackframe.functionName,
                        stackframe.args,
                        loc.source,
                        loc.line,
                        loc.column));
            } else {
                reject(new Error('Could not get original source for given stackframe and source map'));
            }
        });
    }

    /**
     * @constructor
     * @param {Object} opts
     *      opts.sourceCache = {url: "Source String"} => preload source cache
     *      opts.offline = True to prevent network requests.
     *              Best effort without sources or source maps.
     *      opts.ajax = Promise returning function to make X-Domain requests
     */
    return function StackTraceGPS(opts) {
        if (!(this instanceof StackTraceGPS)) {
            return new StackTraceGPS(opts);
        }
        opts = opts || {};

        this.sourceCache = opts.sourceCache || {};

        this.ajax = opts.ajax || _xdr;

        this._atob = opts.atob || _atob;

        this._get = function _get(location) {
            return new Promise(function(resolve, reject) {
                var isDataUrl = location.substr(0, 5) === 'data:';
                if (this.sourceCache[location]) {
                    resolve(this.sourceCache[location]);
                } else if (opts.offline && !isDataUrl) {
                    reject(new Error('Cannot make network requests in offline mode'));
                } else {
                    if (isDataUrl) {
                        // data URLs can have parameters.
                        // see http://tools.ietf.org/html/rfc2397
                        var supportedEncodingRegexp =
                            /^data:application\/json;([\w=:"-]+;)*base64,/;
                        var match = location.match(supportedEncodingRegexp);
                        if (match) {
                            var sourceMapStart = match[0].length;
                            var encodedSource = location.substr(sourceMapStart);
                            var source = this._atob(encodedSource);
                            this.sourceCache[location] = source;
                            resolve(source);
                        } else {
                            reject(new Error('The encoding of the inline sourcemap is not supported'));
                        }
                    } else {
                        var xhrPromise = this.ajax(location, {method: 'get'});
                        // Cache the Promise to prevent duplicate in-flight requests
                        this.sourceCache[location] = xhrPromise;
                        xhrPromise.then(resolve, reject);
                    }
                }
            }.bind(this));
        };

        /**
         * Given a StackFrame, enhance function name and use source maps for a
         * better StackFrame.
         *
         * @param {StackFrame} stackframe object
         * @returns {Promise} that resolves with with source-mapped StackFrame
         */
        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {
            return new Promise(function(resolve, reject) {
                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {
                    function resolveMappedStackFrame() {
                        resolve(mappedStackFrame);
                    }

                    this.findFunctionName(mappedStackFrame)
                        .then(resolve, resolveMappedStackFrame)
                        ['catch'](resolveMappedStackFrame);
                }.bind(this), reject);
            }.bind(this));
        };

        /**
         * Given a StackFrame, guess function name from location information.
         *
         * @param {StackFrame} stackframe
         * @returns {Promise} that resolves with enhanced StackFrame.
         */
        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {
            return new Promise(function(resolve, reject) {
                _ensureStackFrameIsLegit(stackframe);
                this._get(stackframe.fileName).then(function getSourceCallback(source) {
                    var lineNumber = stackframe.lineNumber;
                    var columnNumber = stackframe.columnNumber;
                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);
                    // Only replace functionName if we found something
                    if (guessedFunctionName) {
                        resolve(new StackFrame(guessedFunctionName,
                            stackframe.args,
                            stackframe.fileName,
                            lineNumber,
                            columnNumber));
                    } else {
                        resolve(stackframe);
                    }
                }, reject)['catch'](reject);
            }.bind(this));
        };

        /**
         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.
         *
         * @param {StackFrame} stackframe
         * @returns {Promise} that resolves with enhanced StackFrame.
         */
        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {
            return new Promise(function(resolve, reject) {
                _ensureSupportedEnvironment();
                _ensureStackFrameIsLegit(stackframe);

                var sourceCache = this.sourceCache;
                var fileName = stackframe.fileName;
                this._get(fileName).then(function(source) {
                    var sourceMappingURL = _findSourceMappingURL(source);
                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';
                    var base = fileName.substring(0, fileName.lastIndexOf('/') + 1);

                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\/\/|^\/\//i).test(sourceMappingURL)) {
                        sourceMappingURL = base + sourceMappingURL;
                    }

                    this._get(sourceMappingURL).then(function(sourceMap) {
                        if (typeof sourceMap === 'string') {
                            sourceMap = _parseJson(sourceMap.replace(/^\)\]\}'/, ''));
                        }
                        if (typeof sourceMap.sourceRoot === 'undefined') {
                            sourceMap.sourceRoot = base;
                        }

                        _extractLocationInfoFromSourceMap(stackframe, sourceMap, sourceCache)
                            .then(resolve)['catch'](function() {
                            resolve(stackframe);
                        });
                    }, reject)['catch'](reject);
                }.bind(this), reject)['catch'](reject);
            }.bind(this));
        };
    };
}));


/***/ }),

/***/ "./node_modules/stacktrace-js/stacktrace.js":
/*!**************************************************!*\
  !*** ./node_modules/stacktrace-js/stacktrace.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! error-stack-parser */ "./node_modules/error-stack-parser/error-stack-parser.js"), __webpack_require__(/*! stack-generator */ "./node_modules/stack-generator/stack-generator.js"), __webpack_require__(/*! stacktrace-gps */ "./node_modules/stacktrace-gps/stacktrace-gps.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {
    var _options = {
        filter: function(stackframe) {
            // Filter out stackframes for this library by default
            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&
                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&
                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&
                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;
        },
        sourceCache: {}
    };

    var _generateError = function StackTrace$$GenerateError() {
        try {
            // Error must be thrown to get stack in IE
            throw new Error();
        } catch (err) {
            return err;
        }
    };

    /**
     * Merge 2 given Objects. If a conflict occurs the second object wins.
     * Does not do deep merges.
     *
     * @param {Object} first base object
     * @param {Object} second overrides
     * @returns {Object} merged first and second
     * @private
     */
    function _merge(first, second) {
        var target = {};

        [first, second].forEach(function(obj) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    target[prop] = obj[prop];
                }
            }
            return target;
        });

        return target;
    }

    function _isShapedLikeParsableError(err) {
        return err.stack || err['opera#sourceloc'];
    }

    function _filtered(stackframes, filter) {
        if (typeof filter === 'function') {
            return stackframes.filter(filter);
        }
        return stackframes;
    }

    return {
        /**
         * Get a backtrace from invocation point.
         *
         * @param {Object} opts
         * @returns {Array} of StackFrame
         */
        get: function StackTrace$$get(opts) {
            var err = _generateError();
            return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);
        },

        /**
         * Get a backtrace from invocation point.
         * IMPORTANT: Does not handle source maps or guess function names!
         *
         * @param {Object} opts
         * @returns {Array} of StackFrame
         */
        getSync: function StackTrace$$getSync(opts) {
            opts = _merge(_options, opts);
            var err = _generateError();
            var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);
            return _filtered(stack, opts.filter);
        },

        /**
         * Given an error object, parse it.
         *
         * @param {Error} error object
         * @param {Object} opts
         * @returns {Promise} for Array[StackFrame}
         */
        fromError: function StackTrace$$fromError(error, opts) {
            opts = _merge(_options, opts);
            var gps = new StackTraceGPS(opts);
            return new Promise(function(resolve) {
                var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);
                resolve(Promise.all(stackframes.map(function(sf) {
                    return new Promise(function(resolve) {
                        function resolveOriginal() {
                            resolve(sf);
                        }

                        gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);
                    });
                })));
            }.bind(this));
        },

        /**
         * Use StackGenerator to generate a backtrace.
         *
         * @param {Object} opts
         * @returns {Promise} of Array[StackFrame]
         */
        generateArtificially: function StackTrace$$generateArtificially(opts) {
            opts = _merge(_options, opts);
            var stackFrames = StackGenerator.backtrace(opts);
            if (typeof opts.filter === 'function') {
                stackFrames = stackFrames.filter(opts.filter);
            }
            return Promise.resolve(stackFrames);
        },

        /**
         * Given a function, wrap it such that invocations trigger a callback that
         * is called with a stack trace.
         *
         * @param {Function} fn to be instrumented
         * @param {Function} callback function to call with a stack trace on invocation
         * @param {Function} errback optional function to call with error if unable to get stack trace.
         * @param {Object} thisArg optional context object (e.g. window)
         */
        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot instrument non-function object');
            } else if (typeof fn.__stacktraceOriginalFn === 'function') {
                // Already instrumented, return given Function
                return fn;
            }

            var instrumented = function StackTrace$$instrumented() {
                try {
                    this.get().then(callback, errback)['catch'](errback);
                    return fn.apply(thisArg || this, arguments);
                } catch (e) {
                    if (_isShapedLikeParsableError(e)) {
                        this.fromError(e).then(callback, errback)['catch'](errback);
                    }
                    throw e;
                }
            }.bind(this);
            instrumented.__stacktraceOriginalFn = fn;

            return instrumented;
        },

        /**
         * Given a function that has been instrumented,
         * revert the function to it's original (non-instrumented) state.
         *
         * @param {Function} fn to de-instrument
         */
        deinstrument: function StackTrace$$deinstrument(fn) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot de-instrument non-function object');
            } else if (typeof fn.__stacktraceOriginalFn === 'function') {
                return fn.__stacktraceOriginalFn;
            } else {
                // Function not instrumented, return original
                return fn;
            }
        },

        /**
         * Given an error message and Array of StackFrames, serialize and POST to given URL.
         *
         * @param {Array} stackframes
         * @param {String} url
         * @param {String} errorMsg
         */
        report: function StackTrace$$report(stackframes, url, errorMsg) {
            return new Promise(function(resolve, reject) {
                var req = new XMLHttpRequest();
                req.onerror = reject;
                req.onreadystatechange = function onreadystatechange() {
                    if (req.readyState === 4) {
                        if (req.status >= 200 && req.status < 400) {
                            resolve(req.responseText);
                        } else {
                            reject(new Error('POST to ' + url + ' failed with status: ' + req.status));
                        }
                    }
                };
                req.open('post', url);
                req.setRequestHeader('Content-Type', 'application/json');

                var reportPayload = {stack: stackframes};
                if (errorMsg !== undefined) {
                    reportPayload.message = errorMsg;
                }

                req.send(JSON.stringify(reportPayload));
            });
        }
    };
}));


/***/ }),

/***/ "./src/_infra/AifexServiceHTTP.ts":
/*!****************************************!*\
  !*** ./src/_infra/AifexServiceHTTP.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Website_1 = __importDefault(__webpack_require__(/*! ../domain/Website */ "./src/domain/Website.ts"));
const Session_1 = __importDefault(__webpack_require__(/*! ../domain/Session */ "./src/domain/Session.ts"));
const AifexPluginInfo_1 = __importDefault(__webpack_require__(/*! ../domain/AifexPluginInfo */ "./src/domain/AifexPluginInfo.ts"));
const OK_STATUS = 200;
const INVALID_PARAMETERS_STATUS = 400;
const FORBIDDEN_STATUS = 403;
const NOT_FOUND_STATUS = 404;
const INTERNAL_SERVER_ERROR_STATUS = 500;
class AifexServiceHTTP {
    ping(serverURL) {
        return fetch(`${serverURL}/api/ping`, {
            method: "GET",
            headers: { "Content-Type": "application/json" },
        })
            .then(response => {
            console.log(response);
            if (response.ok) {
                console.log('ok');
                return;
            }
            else {
                console.log('error');
                throw new Error(response.statusText);
            }
        });
    }
    getPluginInfo(serverURL) {
        const option = {
            method: "GET",
            headers: { "Content-Type": "application/json" },
        };
        return fetch(`${serverURL}/api/plugin-info`, option)
            .then(response => {
            if (!response.ok) {
                throw new Error(response.statusText);
            }
            return response.json();
        })
            .then(details => {
            details.url = `${serverURL}/download`;
            return new AifexPluginInfo_1.default(details.version, details.name, details.description, details.url);
        });
    }
    getSession(serverURL, sessionId, token) {
        const SESSION_URL = serverURL + '/api/sessions/' + sessionId;
        return fetch(SESSION_URL, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json', "Authorization": `Bearer ${token === null || token === void 0 ? void 0 : token.token}` },
        })
            .then((response) => {
            if (response.status === OK_STATUS) {
                return response
                    .json()
                    .then((session) => {
                    return new Session_1.default(session.id, session.webSite.id, session.baseURL, session.name, session.description, session.overlayType, session.recordingMode);
                });
            }
            if (response.status === INVALID_PARAMETERS_STATUS) {
                return undefined;
            }
            if (response.status === NOT_FOUND_STATUS) {
                return undefined;
            }
            if (response.status === FORBIDDEN_STATUS) {
                return "Unauthorized";
            }
            if (response.status === INTERNAL_SERVER_ERROR_STATUS) {
                return Promise.reject(`server error`);
            }
        });
    }
    getWebSite(serverURL, webSiteId, token) {
        return fetch(`${serverURL}/api/websites/${webSiteId}`, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json', "Authorization": `Bearer ${token === null || token === void 0 ? void 0 : token.token}` },
        })
            .then((response) => {
            if (response.status === OK_STATUS) {
                return response
                    .json()
                    .then(websiteData => {
                    return new Website_1.default(websiteData.id, websiteData.name, websiteData.mappingList);
                });
            }
            if (response.status === INVALID_PARAMETERS_STATUS) {
                return Promise.reject(`sessionId is malformed`);
            }
            if (response.status === NOT_FOUND_STATUS) {
                return;
            }
            if (response.status === INTERNAL_SERVER_ERROR_STATUS) {
                return Promise.reject(`server error`);
            }
        });
    }
    createEmptyExploration(testerName, serverURL, sessionId) {
        const body = {
            testerName,
            interactionList: [],
        };
        const option = {
            method: "POST",
            body: JSON.stringify(body),
            headers: { "Content-Type": "application/json" },
        };
        return fetch(`${serverURL}/api/sessions/${sessionId}/explorations`, option)
            .then((response) => {
            if (response.status === OK_STATUS) {
                return response.json().then(data => {
                    return data.explorationNumber;
                });
            }
            if (response.status === NOT_FOUND_STATUS) {
                return Promise.reject(new Error(`no session not found for Id`));
            }
            if (response.status === INVALID_PARAMETERS_STATUS) {
                return Promise.reject(new Error(`sessionId and/or exploration is malformed`));
            }
            if (response.status === INTERNAL_SERVER_ERROR_STATUS) {
                return Promise.reject(new Error(`server error`));
            }
        });
    }
    sendAction(explorationNumber, action, serverURL, sessionId) {
        const body = {
            interactionList: [{
                    concreteType: action.getConcreteType(),
                    kind: action.prefix,
                    value: action.suffix,
                    date: action.date
                }]
        };
        const option = {
            method: "POST",
            body: JSON.stringify(body),
            headers: { "Content-Type": "application/json" },
        };
        return fetch(`${serverURL}/api/sessions/${sessionId}/explorations/${explorationNumber}/interactions`, option)
            .then((response) => {
            if (response.status === OK_STATUS) {
                return;
            }
            if (response.status === NOT_FOUND_STATUS) {
                return Promise.reject(new Error(`sessionId not found`));
            }
            if (response.status === INVALID_PARAMETERS_STATUS) {
                return Promise.reject(new Error(`sessionId and/or exploration is malformed`));
            }
            if (response.status === INTERNAL_SERVER_ERROR_STATUS) {
                return Promise.reject(new Error(`server error`));
            }
        }).catch(error => {
            console.error(error);
            throw new Error("Service Failed to push new action");
        });
    }
}
exports["default"] = AifexServiceHTTP;


/***/ }),

/***/ "./src/_infra/BrowserServiceSessionStorage.ts":
/*!****************************************************!*\
  !*** ./src/_infra/BrowserServiceSessionStorage.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
const EXPLORATION_NUMBER_KEY = 'EXPLORATION_NUMBER_KEY';
class BrowserServiceSessionStorage {
    getExplorationNumber() {
        Logger_1.logger.debug("BrowserServiceSessionStorage.getExplorationNumber");
        const explorationNumberItem = sessionStorage.getItem(EXPLORATION_NUMBER_KEY);
        if (explorationNumberItem) {
            const parsedNumber = parseInt(explorationNumberItem);
            if (isNaN(parsedNumber)) {
                Logger_1.logger.debug("BrowserServiceSessionStorage.getExplorationNumber: NaN");
                return undefined;
            }
            else {
                Logger_1.logger.debug("BrowserServiceSessionStorage.getExplorationNumber: " + parsedNumber);
                return parsedNumber;
            }
        }
        Logger_1.logger.debug("BrowserServiceSessionStorage.getExplorationNumber: undefined");
    }
    saveExplorationNumber(explorationNumber) {
        Logger_1.logger.debug("BrowserServiceSessionStorage.saveExplorationNumber: " + explorationNumber);
        sessionStorage.setItem(EXPLORATION_NUMBER_KEY, explorationNumber.toString());
    }
}
exports["default"] = BrowserServiceSessionStorage;


/***/ }),

/***/ "./src/domain/Action.ts":
/*!******************************!*\
  !*** ./src/domain/Action.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Action {
    constructor(prefix, suffix, ruleList = [], htmlElementList = []) {
        this.prefix = prefix;
        this.suffix = suffix;
        this.ruleList = ruleList;
        this.htmlElementList = htmlElementList;
        this.date = new Date();
    }
    setRuleList(ruleList) {
        this.ruleList = ruleList;
    }
    getConcreteType() {
        return "Action";
    }
    toString() {
        if (this.suffix) {
            return `${this.prefix}$${this.suffix}`;
        }
        else {
            return this.prefix;
        }
    }
    equals(action) {
        return ((this.prefix === action.prefix) && (this.suffix === action.suffix));
    }
    static parseAction(actionText) {
        const parts = actionText.split("$");
        if (parts.length === 1) {
            return new Action(parts[0]);
        }
        else if (parts.length === 2) {
            return new Action(parts[0], parts[1]);
        }
        else {
            throw new Error("Failed to parse action : " + actionText);
        }
    }
}
exports["default"] = Action;


/***/ }),

/***/ "./src/domain/AifexPluginInfo.ts":
/*!***************************************!*\
  !*** ./src/domain/AifexPluginInfo.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class AifexPluginInfo {
    constructor(version, name, description, url) {
        this.version = version;
        this.name = name;
        this.description = description;
        this.url = url;
    }
}
exports["default"] = AifexPluginInfo;


/***/ }),

/***/ "./src/domain/AttributeValueRule.ts":
/*!******************************************!*\
  !*** ./src/domain/AttributeValueRule.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
class AttributeValueRule extends SimpleRule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description, attributeName) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
        this.attributeName = attributeName;
    }
    makeAction(event) {
        const element = this.findActionMappedTarget(event);
        if (element !== undefined) {
            let attributeValue = element.getAttribute(this.attributeName);
            if (attributeValue) {
                return new Action_1.default(this.prefix, attributeValue);
            }
        }
        return new Action_1.default(this.prefix);
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix === undefined) {
            return super.actionToElements(action);
        }
        else {
            let suffix = action.suffix;
            const elements = this.findMatchedElements();
            return elements.filter(domElement => {
                if (domElement instanceof HTMLElement) {
                    return domElement.getAttribute(this.attributeName) === suffix;
                }
                else {
                    return false;
                }
            });
        }
    }
}
exports["default"] = AttributeValueRule;


/***/ }),

/***/ "./src/domain/BrowserScript.ts":
/*!*************************************!*\
  !*** ./src/domain/BrowserScript.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const ClassMutationHandler_1 = __importDefault(__webpack_require__(/*! ./ClassMutationHandler */ "./src/domain/ClassMutationHandler.ts"));
const EventListener_1 = __importDefault(__webpack_require__(/*! ./EventListener */ "./src/domain/EventListener.ts"));
const PageMutationHandler_1 = __importDefault(__webpack_require__(/*! ./PageMutationHandler */ "./src/domain/PageMutationHandler.ts"));
const RuleService_1 = __importDefault(__webpack_require__(/*! ./RuleService */ "./src/domain/RuleService.ts"));
class BrowserScript {
    constructor(serverURL, sessionId, token, aifexService, browserService) {
        this._serverURL = serverURL;
        this._sessionId = sessionId;
        this._token = token;
        this._aifexService = aifexService;
        this._browserService = browserService;
        this._ruleService = new RuleService_1.default();
        this._eventListener = new EventListener_1.default(this._ruleService);
        this._eventListener.addObserver(this.processNewAction.bind(this));
        this._pageMutationHandler = new PageMutationHandler_1.default(this.onMutation.bind(this));
        this._pageMutationHandler.init();
    }
    start() {
        return this._aifexService.getSession(this._serverURL, this._sessionId, undefined)
            .then((sessionResult) => {
            if (sessionResult && sessionResult !== "Unauthorized") {
                this._webSiteId = sessionResult.webSiteId;
                this._aifexService.getWebSite(this._serverURL, this._webSiteId, undefined)
                    .then((webSiteResult) => {
                    if (webSiteResult && webSiteResult !== 'Unauthorized') {
                        const rules = webSiteResult.mappingList.map((ru) => this._ruleService.createRule(ru));
                        this._ruleService.loadRules(rules);
                        if (this._ruleService.getEventsToHandle().includes("css-class-added")) {
                            if (this._classMutationHandler === undefined) {
                                this._classMutationHandler = new ClassMutationHandler_1.default();
                            }
                        }
                        this._ruleService.mapRulesToElements();
                        Logger_1.logger.debug(`Rules loaded : ${rules.length}`);
                        this._eventListener.start();
                    }
                })
                    .then(() => {
                    const currentExplorationNumber = this._browserService.getExplorationNumber();
                    if (currentExplorationNumber !== undefined) {
                        this._explorationNumber = currentExplorationNumber;
                    }
                    else {
                        this._aifexService.createEmptyExploration("BROWSER_SCRIPT", this._serverURL, this._sessionId)
                            .then((explorationNumber) => {
                            this._explorationNumber = explorationNumber;
                            this._browserService.saveExplorationNumber(this._explorationNumber);
                        })
                            .then(() => {
                            this.processNewAction(new Action_1.default("start", undefined));
                        });
                    }
                });
            }
        });
    }
    processNewAction(action) {
        if (this._explorationNumber === undefined) {
            throw new Error("The exploration has not been correctly started");
        }
        this._aifexService.sendAction(this._explorationNumber, action, this._serverURL, this._sessionId);
    }
    onMutation() {
        this._ruleService.mapRulesToElements();
    }
}
exports["default"] = BrowserScript;


/***/ }),

/***/ "./src/domain/CSSContextMapper.ts":
/*!****************************************!*\
  !*** ./src/domain/CSSContextMapper.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ContextMapper_1 = __importDefault(__webpack_require__(/*! ./ContextMapper */ "./src/domain/ContextMapper.ts"));
class CSSContextMapper extends ContextMapper_1.default {
    constructor(context) {
        super(context);
    }
    buildElementToRuleMap() {
        if (this._context) {
            const cssQueryResult = document.querySelector(this._context);
            if (cssQueryResult && cssQueryResult instanceof HTMLElement) {
                return this.buildElementToRuleMapForSelectors(cssQueryResult);
            }
            else {
                return new Map();
            }
        }
        else {
            return new Map();
        }
    }
}
exports["default"] = CSSContextMapper;


/***/ }),

/***/ "./src/domain/CSSSelectorRule.ts":
/*!***************************************!*\
  !*** ./src/domain/CSSSelectorRule.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const Rule_1 = __importDefault(__webpack_require__(/*! ./Rule */ "./src/domain/Rule.ts"));
const css_selector_generator_1 = __importDefault(__webpack_require__(/*! css-selector-generator */ "./node_modules/css-selector-generator/build/index.js"));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class CSSSelectorRule extends Rule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        if (event.target) {
            if (event.target instanceof HTMLElement || event.target instanceof SVGElement) {
                let suffix;
                try {
                    suffix = (0, css_selector_generator_1.default)(event.target, {
                        selectors: [
                            "id",
                            "class",
                            "tag",
                            "attribute"
                        ],
                        blacklist: [
                            /.*data.*/i,
                            /.*aifex.*/i,
                            /.*over.*/i,
                            /.*auto.*/i,
                            /.*value.*/i,
                            /.*checked.*/i,
                            '[placeholder]',
                            /.*href.*/i,
                            /.*src.*/i,
                            /.*onclick.*/i,
                            /.*onload.*/i,
                            /.*onkeyup.*/i,
                            /.*width.*/i,
                            /.*height.*/i,
                            /.*style.*/i,
                            /.*size.*/i,
                            /.*maxlength.*/i
                        ],
                        combineBetweenSelectors: true,
                        maxCandidates: 100
                    });
                }
                catch (e) {
                    Logger_1.logger.error(`exception`, new Error('css exception'));
                }
                return new Action_1.default(this.prefix, suffix);
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix) {
            const elements = [];
            const parentElements = this.findMatchedElements();
            document.querySelectorAll(action.suffix).forEach((element) => {
                if (parentElements.some((parent) => parent.contains(element))) {
                    if (element instanceof HTMLElement || element instanceof SVGElement) {
                        elements.push(element);
                    }
                }
            });
            return elements;
        }
        else {
            return [];
        }
    }
}
exports["default"] = CSSSelectorRule;


/***/ }),

/***/ "./src/domain/CSSSelectorWithValueRule.ts":
/*!************************************************!*\
  !*** ./src/domain/CSSSelectorWithValueRule.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const Rule_1 = __importDefault(__webpack_require__(/*! ./Rule */ "./src/domain/Rule.ts"));
const css_selector_generator_1 = __importDefault(__webpack_require__(/*! css-selector-generator */ "./node_modules/css-selector-generator/build/index.js"));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class CSSSelectorWithValueRule extends Rule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        if (event.target) {
            if (event.target instanceof HTMLElement || event.target instanceof SVGElement) {
                let value = this.getValue(event.target);
                let suffix;
                try {
                    suffix = (0, css_selector_generator_1.default)(event.target, {
                        selectors: [
                            "id",
                            "class",
                            "tag",
                            "attribute"
                        ],
                        blacklist: [
                            /.*data.*/i,
                            /.*aifex.*/i,
                            /.*over.*/i,
                            /.*auto.*/i,
                            /.*value.*/i,
                            /.*checked.*/i,
                            '[placeholder]',
                            /.*href.*/i,
                            /.*src.*/i,
                            /.*onclick.*/i,
                            /.*onload.*/i,
                            /.*onkeyup.*/i,
                            /.*width.*/i,
                            /.*height.*/i,
                            /.*style.*/i,
                            /.*size.*/i,
                            /.*maxlength.*/i
                        ],
                        combineBetweenSelectors: true,
                        maxCandidates: 100
                    });
                }
                catch (e) {
                    Logger_1.logger.error(`exception`, new Error('css exception'));
                }
                if (value !== undefined && value.trim().length > 0) {
                    suffix += `?${value}`;
                }
                return new Action_1.default(this.prefix, suffix);
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix) {
            const elements = [];
            const parentElements = this.findMatchedElements();
            let sharpCharIndex = action.suffix.indexOf('?');
            let cssSelector = sharpCharIndex === -1 ? action.suffix : action.suffix.substring(0, sharpCharIndex);
            document.querySelectorAll(cssSelector).forEach((element) => {
                if (parentElements.some((parent) => parent.contains(element))) {
                    if (element instanceof HTMLElement || element instanceof SVGElement) {
                        elements.push(element);
                    }
                }
            });
            return elements;
        }
        else {
            return [];
        }
    }
    getValue(element) {
        if (element instanceof HTMLInputElement) {
            return element.value;
        }
        const valueAttribute = element.getAttribute('value');
        if (valueAttribute) {
            return valueAttribute;
        }
    }
}
exports["default"] = CSSSelectorWithValueRule;


/***/ }),

/***/ "./src/domain/ClassMutationHandler.ts":
/*!********************************************!*\
  !*** ./src/domain/ClassMutationHandler.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class ClassMutationHandler {
    constructor() {
        this._observer = new MutationObserver((records) => {
            for (const record of records) {
                if (record.type === "attributes") {
                    if (record.attributeName === "class") {
                        if (record.target instanceof HTMLElement) {
                            Logger_1.logger.debug('class mutation');
                            if (record.target.matches(':hover')) {
                                let currentClass = record.target.getAttribute('class');
                                let createEvent = false;
                                if (record.oldValue) {
                                    if (currentClass && currentClass.includes(record.oldValue)) {
                                        createEvent = true;
                                    }
                                }
                                else {
                                    if (currentClass) {
                                        createEvent = true;
                                    }
                                }
                                if (createEvent) {
                                    Logger_1.logger.debug('create event');
                                    let event = new Event('css-class-added', { bubbles: true });
                                    record.target.dispatchEvent(event);
                                }
                            }
                        }
                    }
                }
            }
        });
        const config = { attributes: true, subtree: true, attributeOldValue: true };
        this._observer.observe(document.body, config);
        Logger_1.logger.info('class mutation handler initialized');
    }
}
exports["default"] = ClassMutationHandler;


/***/ }),

/***/ "./src/domain/ContextLessMapper.ts":
/*!*****************************************!*\
  !*** ./src/domain/ContextLessMapper.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ContextMapper_1 = __importDefault(__webpack_require__(/*! ./ContextMapper */ "./src/domain/ContextMapper.ts"));
class ContextLessMapper extends ContextMapper_1.default {
    constructor() {
        super(undefined);
    }
    buildElementToRuleMap() {
        return this.buildElementToRuleMapForSelectors();
    }
}
exports["default"] = ContextLessMapper;


/***/ }),

/***/ "./src/domain/ContextMapper.ts":
/*!*************************************!*\
  !*** ./src/domain/ContextMapper.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class ContextMapper {
    constructor(context) {
        this._context = context;
        this._cssSelector2Rules = new Map();
        this._xpathSelector2Rules = new Map();
    }
    add(rule) {
        if (rule.contextCSS !== this._context && rule.contextURL !== this._context && rule.contextXPath !== this._context) {
            throw new Error('cannot add rule with a different context ');
        }
        if (rule.css) {
            if (!this._cssSelector2Rules.has(rule.css)) {
                this._cssSelector2Rules.set(rule.css, []);
            }
            let rules4Selector = this._cssSelector2Rules.get(rule.css);
            if (rules4Selector) {
                rules4Selector.push(rule);
            }
        }
        if (rule.xpath) {
            if (!this._xpathSelector2Rules.has(rule.xpath)) {
                this._xpathSelector2Rules.set(rule.xpath, []);
            }
            let rules4Selector = this._xpathSelector2Rules.get(rule.xpath);
            if (rules4Selector) {
                rules4Selector.push(rule);
            }
        }
    }
    buildElementToRuleMapForSelectors(context) {
        const elementToRules = new Map();
        for (const [selector, rules] of this._cssSelector2Rules) {
            let querySelector;
            if (context) {
                querySelector = context.querySelectorAll(selector);
            }
            else {
                querySelector = document.querySelectorAll(selector);
            }
            querySelector.forEach(element => {
                let rules4Element = elementToRules.get(element);
                if (!rules4Element) {
                    rules4Element = [];
                    elementToRules.set(element, rules4Element);
                }
                rules4Element.push(...rules);
            });
        }
        for (const [selector, rules] of this._xpathSelector2Rules) {
            let queryXpath;
            let queryXpathResult;
            try {
                if (context) {
                    queryXpath = document.evaluate(selector, context, null, XPathResult.ANY_TYPE, null);
                }
                else {
                    queryXpath = document.evaluate(selector, document, null, XPathResult.ANY_TYPE, null);
                }
            }
            catch (e) {
                Logger_1.logger.error('XPath Error:', new Error("e"));
            }
            if (queryXpath) {
                queryXpathResult = queryXpath.iterateNext();
                while (queryXpathResult) {
                    if (queryXpathResult instanceof HTMLElement || queryXpathResult instanceof SVGElement) {
                        let noContext = !context;
                        let resultInContext = context && context.contains(queryXpathResult);
                        if (noContext || resultInContext) {
                            let rules4Element = elementToRules.get(queryXpathResult);
                            if (!rules4Element) {
                                rules4Element = [];
                                elementToRules.set(queryXpathResult, rules4Element);
                            }
                            rules4Element.push(...rules);
                        }
                    }
                    queryXpathResult = queryXpath.iterateNext();
                }
            }
        }
        return elementToRules;
    }
}
exports["default"] = ContextMapper;


/***/ }),

/***/ "./src/domain/EventListener.ts":
/*!*************************************!*\
  !*** ./src/domain/EventListener.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class EventListener {
    constructor(ruleService) {
        this._ruleService = ruleService;
        this._handledEvents = [];
        this._observers = [];
    }
    start() {
        this._handledEvents = this._ruleService.getEventsToHandle();
        Logger_1.logger.debug(`EventListener: there are ${this._handledEvents.length} events to handle`);
        this._handledEvents.forEach((handledEvent) => {
            document.addEventListener(handledEvent, this.exploratoryListener.bind(this), true);
        });
    }
    addObserver(observerFunction) {
        this._observers.push(observerFunction);
    }
    exploratoryListener(event) {
        let unsafeEvent = event;
        if (unsafeEvent.isTrusted) {
            if (!unsafeEvent.explored) {
                unsafeEvent.explored = true;
                Logger_1.logger.debug(`EventListener: event ${unsafeEvent.type} is being handled`);
                const rule = this._ruleService.getMatchingRule(event);
                if (rule) {
                    const action = rule.makeAction(event);
                    if (action) {
                        Logger_1.logger.info(`action : ${action.toString()}`);
                        this._observers.forEach((observer) => {
                            observer(action);
                        });
                    }
                    else {
                        Logger_1.logger.debug('no action');
                    }
                }
            }
        }
    }
}
exports["default"] = EventListener;


/***/ }),

/***/ "./src/domain/IndexRule.ts":
/*!*********************************!*\
  !*** ./src/domain/IndexRule.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
class IndexRule extends SimpleRule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        const matchingElements = this.findMatchedElements();
        for (let i = 0; i < matchingElements.length; i++) {
            let targetElements = event.composedPath().filter((target) => target instanceof HTMLElement || target instanceof SVGElement);
            if (targetElements.length > 0 && matchingElements[i].contains(targetElements[0])) {
                return new Action_1.default(this.prefix, i.toString());
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix === undefined) {
            return super.actionToElements(action);
        }
        const index = parseInt(action.suffix, 10);
        const elements = this.findMatchedElements();
        if (index !== undefined || null) {
            if (elements.length > index) {
                return [elements[index]];
            }
            else {
                return [];
            }
        }
        else {
            return elements;
        }
    }
}
exports["default"] = IndexRule;


/***/ }),

/***/ "./src/domain/InnerTextRule.ts":
/*!*************************************!*\
  !*** ./src/domain/InnerTextRule.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
class InnerTextRule extends SimpleRule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        const element = this.findActionMappedTarget(event);
        if (element) {
            if (element instanceof HTMLElement) {
                return new Action_1.default(this.prefix, element.innerText.trim());
            }
            else {
                return new Action_1.default(this.prefix, "svg");
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix === undefined) {
            return super.actionToElements(action);
        }
        else {
            let suffix = action.suffix;
            const elements = this.findMatchedElements();
            return elements.filter(domElement => {
                if (domElement instanceof HTMLElement) {
                    return domElement.innerText.trim() === suffix.trim();
                }
                else if (domElement instanceof SVGElement) {
                    return "svg" === suffix.trim();
                }
                else {
                    return false;
                }
            });
        }
    }
}
exports["default"] = InnerTextRule;


/***/ }),

/***/ "./src/domain/PageMutationHandler.ts":
/*!*******************************************!*\
  !*** ./src/domain/PageMutationHandler.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const MUTATION_REFRESH_CHECK = 1000;
const DOM_IDS = ["AIFEX_probabilityPopup", "AIFEX_tab"];
class PageMutationHandler {
    constructor(onPageMutation) {
        this.onPageMutation = onPageMutation;
        this.beRefreshing = false;
        this.mutationHasOccured = false;
        this.willRefresh = false;
    }
    init() {
        this.lastMutation = Date.now();
        this.observer = new MutationObserver((records) => {
            let watchedPageHasMutated = false;
            for (const record of records) {
                if (record.type === "childList") {
                    if (this.isWatchedNodeList(record.addedNodes) && !this.isIncludedInAIFEXElement(record.addedNodes)) {
                        watchedPageHasMutated = true;
                    }
                }
            }
            if (watchedPageHasMutated) {
                if (!this.beRefreshing) {
                    this.beRefreshing = true;
                    this.onPageMutation();
                    setTimeout(() => {
                        this.beRefreshing = false;
                    }, MUTATION_REFRESH_CHECK);
                }
                else {
                    if (!this.willRefresh) {
                        this.willRefresh = true;
                        const TIME_CHECK_MULTIPLIER = 2;
                        setTimeout(() => {
                            this.beRefreshing = true;
                            this.onPageMutation();
                            setTimeout(() => {
                                this.beRefreshing = false;
                                this.willRefresh = false;
                            }, MUTATION_REFRESH_CHECK);
                        }, TIME_CHECK_MULTIPLIER * MUTATION_REFRESH_CHECK);
                    }
                }
            }
        });
        const config = { attributes: false, childList: true, characterData: false, subtree: true };
        this.observer.observe(document.body, config);
    }
    isWatchedNodeList(nodeList) {
        let isWatched = false;
        nodeList.forEach(node => {
            if (node instanceof HTMLElement) {
                if (node.tagName !== "SCRIPT" && node.tagName !== "IFRAME" && node.tagName !== "IMG") {
                    if (!node.style) {
                        isWatched = true;
                    }
                    if (!node.style.display) {
                        isWatched = true;
                    }
                    if (node.style.display !== "none") {
                        isWatched = true;
                    }
                }
            }
        });
        return isWatched;
    }
    isIncludedInAIFEXElement(nodeList) {
        const AIFEXElementList = DOM_IDS.map(id => document.getElementById(id)).filter((element) => element !== null);
        let isIncluded = true;
        nodeList.forEach(node => {
            if (node instanceof HTMLElement) {
                if (!AIFEXElementList.some((aifexNode) => {
                    return aifexNode.contains(node);
                })) {
                    isIncluded = false;
                }
            }
        });
        return isIncluded;
    }
}
exports["default"] = PageMutationHandler;


/***/ }),

/***/ "./src/domain/Rule.ts":
/*!****************************!*\
  !*** ./src/domain/Rule.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const query_selector_shadow_dom_1 = __webpack_require__(/*! query-selector-shadow-dom */ "./node_modules/query-selector-shadow-dom/src/querySelectorDeep.js");
class Rule {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        this.event = event;
        this.code = code;
        this.css = css;
        this.xpath = xpath;
        this.prefix = prefix;
        this.suffix = suffix;
        this.key = key;
        this.contextURL = contextURL;
        this.contextCSS = contextCSS;
        this.contextXPath = contextXPath;
        this.description = description;
    }
    match(event) {
        if (event.type !== this.event) {
            return false;
        }
        if (event instanceof KeyboardEvent) {
            if (this.event === "keyup" || this.event === "keydown" || this.event === "keypress") {
                if (this.code && event.code !== this.code) {
                    return false;
                }
                if (this.key && event.key !== this.key) {
                    return false;
                }
            }
            return true;
        }
        else {
            return true;
        }
    }
    findActionMappedTarget(event) {
        const target = event.composedPath()[0];
        if (target instanceof HTMLElement || target instanceof SVGElement) {
            if (target.hasAttribute("aifex_style")) {
                return target;
            }
            else {
                let closest = target.closest("[aifex_style]");
                if (closest && (closest instanceof HTMLElement || closest instanceof SVGElement)) {
                    return closest;
                }
            }
        }
    }
    findMatchedElements() {
        let context;
        if (this.contextXPath) {
            try {
                const result = document.evaluate(this.contextXPath, document, null, XPathResult.ANY_TYPE, null);
                context = result.iterateNext();
            }
            catch (e) {
                console.error(e);
            }
            if (!context) {
                return [];
            }
        }
        if (this.contextCSS) {
            context = document.querySelector(this.contextCSS);
            if (!context) {
                return [];
            }
        }
        let elements = [];
        if (this.xpath) {
            try {
                let result;
                if (context) {
                    result = document.evaluate(this.xpath, context, null, XPathResult.ANY_TYPE, null);
                }
                else {
                    result = document.evaluate(this.xpath, document, null, XPathResult.ANY_TYPE, null);
                }
                let node = result.iterateNext();
                while (node) {
                    elements.push(node);
                    node = result.iterateNext();
                }
            }
            catch (e) {
                console.error(e);
            }
        }
        if (this.css) {
            if (context) {
                elements = (0, query_selector_shadow_dom_1.querySelectorAllDeep)(this.css, context);
            }
            else {
                elements = (0, query_selector_shadow_dom_1.querySelectorAllDeep)(this.css);
            }
        }
        return elements.filter((element) => element instanceof HTMLElement || element instanceof SVGElement);
    }
}
exports["default"] = Rule;


/***/ }),

/***/ "./src/domain/RuleMapper.ts":
/*!**********************************!*\
  !*** ./src/domain/RuleMapper.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const URLContextMapper_1 = __importDefault(__webpack_require__(/*! ./URLContextMapper */ "./src/domain/URLContextMapper.ts"));
const XPathContextMapper_1 = __importDefault(__webpack_require__(/*! ./XPathContextMapper */ "./src/domain/XPathContextMapper.ts"));
const ContextLessMapper_1 = __importDefault(__webpack_require__(/*! ./ContextLessMapper */ "./src/domain/ContextLessMapper.ts"));
const CSSContextMapper_1 = __importDefault(__webpack_require__(/*! ./CSSContextMapper */ "./src/domain/CSSContextMapper.ts"));
class RuleMapper {
    constructor(rules) {
        this._cssContext2ContextMapper = new Map();
        this._xpathContext2ContextMapper = new Map();
        this._urlContext2ContextMapper = new Map();
        this._contextLessMapper = new ContextLessMapper_1.default();
        this._prefix2Rules = new Map();
        this._eventInRules = [];
        this.rules = rules;
        rules.forEach(rule => {
            let rules4Prefix = this._prefix2Rules.get(rule.prefix);
            if (!rules4Prefix) {
                rules4Prefix = [];
                this._prefix2Rules.set(rule.prefix, rules4Prefix);
            }
            rules4Prefix.push(rule);
            if (!this._eventInRules.includes(rule.event)) {
                this._eventInRules.push(rule.event);
            }
            if (rule.contextCSS) {
                let contextMapper4CssContext = this._cssContext2ContextMapper.get(rule.contextCSS);
                if (!contextMapper4CssContext) {
                    contextMapper4CssContext = new CSSContextMapper_1.default(rule.contextCSS);
                    this._cssContext2ContextMapper.set(rule.contextCSS, contextMapper4CssContext);
                }
                contextMapper4CssContext.add(rule);
            }
            else if (rule.contextXPath) {
                let contextMapper4XpathContext = this._xpathContext2ContextMapper.get(rule.contextXPath);
                if (!contextMapper4XpathContext) {
                    contextMapper4XpathContext = new XPathContextMapper_1.default(rule.contextXPath);
                    this._xpathContext2ContextMapper.set(rule.contextXPath, contextMapper4XpathContext);
                }
                contextMapper4XpathContext.add(rule);
            }
            else if (rule.contextURL) {
                let contexMapper4URLContext = this._urlContext2ContextMapper.get(rule.contextURL);
                if (!contexMapper4URLContext) {
                    contexMapper4URLContext = new URLContextMapper_1.default(rule.contextURL);
                    this._urlContext2ContextMapper.set(rule.contextURL, contexMapper4URLContext);
                }
                contexMapper4URLContext.add(rule);
            }
            else {
                this._contextLessMapper.add(rule);
            }
        });
    }
    getIsLoaded() {
        return this._prefix2Rules.size > 0;
    }
    getRuleListByPrefix(prefix) {
        let rules4prefis = this._prefix2Rules.get(prefix);
        if (rules4prefis) {
            return rules4prefis;
        }
        else {
            return [];
        }
    }
    get eventInRules() {
        return this._eventInRules;
    }
    buildElementToRuleMap() {
        const result = new Map();
        for (const mapper of this._urlContext2ContextMapper.values()) {
            for (const [element, rules] of mapper.buildElementToRuleMap()) {
                let rules4element = result.get(element);
                if (!rules4element) {
                    rules4element = [];
                    result.set(element, rules4element);
                }
                rules4element.push(...rules);
            }
        }
        for (const mapper of this._cssContext2ContextMapper.values()) {
            for (const [element, rules] of mapper.buildElementToRuleMap()) {
                let rules4element = result.get(element);
                if (!rules4element) {
                    rules4element = [];
                    result.set(element, rules4element);
                }
                rules4element.push(...rules);
            }
        }
        for (const mapper of this._xpathContext2ContextMapper.values()) {
            for (const [element, rules] of mapper.buildElementToRuleMap()) {
                let rules4element = result.get(element);
                if (!rules4element) {
                    rules4element = [];
                    result.set(element, rules4element);
                }
                rules4element.push(...rules);
            }
        }
        for (const [element, rules] of this._contextLessMapper.buildElementToRuleMap()) {
            let rules4element = result.get(element);
            if (!rules4element) {
                rules4element = [];
                result.set(element, rules4element);
            }
            rules4element.push(...rules);
        }
        return result;
    }
}
exports["default"] = RuleMapper;


/***/ }),

/***/ "./src/domain/RuleService.ts":
/*!***********************************!*\
  !*** ./src/domain/RuleService.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const RuleMapper_1 = __importDefault(__webpack_require__(/*! ./RuleMapper */ "./src/domain/RuleMapper.ts"));
const IndexRule_1 = __importDefault(__webpack_require__(/*! ./IndexRule */ "./src/domain/IndexRule.ts"));
const InnerTextRule_1 = __importDefault(__webpack_require__(/*! ./InnerTextRule */ "./src/domain/InnerTextRule.ts"));
const ValueRule_1 = __importDefault(__webpack_require__(/*! ./ValueRule */ "./src/domain/ValueRule.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
const CSSSelectorRule_1 = __importDefault(__webpack_require__(/*! ./CSSSelectorRule */ "./src/domain/CSSSelectorRule.ts"));
const AttributeValueRule_1 = __importDefault(__webpack_require__(/*! ./AttributeValueRule */ "./src/domain/AttributeValueRule.ts"));
const CSSSelectorWithValueRule_1 = __importDefault(__webpack_require__(/*! ./CSSSelectorWithValueRule */ "./src/domain/CSSSelectorWithValueRule.ts"));
class RuleService {
    constructor() {
        this.elementRules = new Map();
        this._ruleMapper = new RuleMapper_1.default([]);
    }
    get elementListMatchedByRule() {
        return Array.from(this.elementRules.keys());
    }
    getEventsToHandle() {
        return this._ruleMapper.eventInRules;
    }
    loadRules(rules) {
        this._ruleMapper = new RuleMapper_1.default(rules);
    }
    mapRulesToElements() {
        this.elementRules = this._ruleMapper.buildElementToRuleMap();
    }
    getMatchingRule(event) {
        let elements = event.composedPath().filter((target) => target instanceof HTMLElement || target instanceof SVGElement);
        for (const element of elements) {
            const rules = this.elementRules.get(element);
            if (rules !== undefined) {
                const matchingRule = rules.find((rule) => rule.match(event));
                if (matchingRule) {
                    return matchingRule;
                }
            }
        }
    }
    getRuleListByAction(action) {
        return this._ruleMapper.getRuleListByPrefix(action.prefix);
    }
    getHTMLElementsMatchedByAction(action) {
        const elements = new Set();
        action.ruleList.forEach(rule => {
            const elementListForRule = rule.actionToElements(action);
            elementListForRule.forEach(element => elements.add(element));
        });
        return [...elements.values()];
    }
    createRule(data) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32;
        switch (data.output.suffix) {
            case "innerText":
                return new InnerTextRule_1.default(data.output.prefix, (_a = data.output) === null || _a === void 0 ? void 0 : _a.suffix, data.match.event, (_b = data.match) === null || _b === void 0 ? void 0 : _b.css, (_c = data.match) === null || _c === void 0 ? void 0 : _c.xpath, (_d = data.match) === null || _d === void 0 ? void 0 : _d.code, (_e = data.match) === null || _e === void 0 ? void 0 : _e.key, (_f = data === null || data === void 0 ? void 0 : data.context) === null || _f === void 0 ? void 0 : _f.url, (_g = data === null || data === void 0 ? void 0 : data.context) === null || _g === void 0 ? void 0 : _g.css, (_h = data === null || data === void 0 ? void 0 : data.context) === null || _h === void 0 ? void 0 : _h.xpath, data.description);
            case "index":
                return new IndexRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_j = data.match) === null || _j === void 0 ? void 0 : _j.css, (_k = data.match) === null || _k === void 0 ? void 0 : _k.xpath, (_l = data.match) === null || _l === void 0 ? void 0 : _l.code, (_m = data.match) === null || _m === void 0 ? void 0 : _m.key, (_o = data === null || data === void 0 ? void 0 : data.context) === null || _o === void 0 ? void 0 : _o.url, (_p = data === null || data === void 0 ? void 0 : data.context) === null || _p === void 0 ? void 0 : _p.css, (_q = data === null || data === void 0 ? void 0 : data.context) === null || _q === void 0 ? void 0 : _q.xpath, data.description);
            case "value":
                return new ValueRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_r = data.match) === null || _r === void 0 ? void 0 : _r.css, (_s = data.match) === null || _s === void 0 ? void 0 : _s.xpath, (_t = data.match) === null || _t === void 0 ? void 0 : _t.code, (_u = data.match) === null || _u === void 0 ? void 0 : _u.key, (_v = data === null || data === void 0 ? void 0 : data.context) === null || _v === void 0 ? void 0 : _v.url, (_w = data === null || data === void 0 ? void 0 : data.context) === null || _w === void 0 ? void 0 : _w.css, (_x = data === null || data === void 0 ? void 0 : data.context) === null || _x === void 0 ? void 0 : _x.xpath, data.description);
            case "cssSelector":
                return new CSSSelectorRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_y = data.match) === null || _y === void 0 ? void 0 : _y.css, (_z = data.match) === null || _z === void 0 ? void 0 : _z.xpath, (_0 = data.match) === null || _0 === void 0 ? void 0 : _0.code, (_1 = data.match) === null || _1 === void 0 ? void 0 : _1.key, (_2 = data === null || data === void 0 ? void 0 : data.context) === null || _2 === void 0 ? void 0 : _2.url, (_3 = data === null || data === void 0 ? void 0 : data.context) === null || _3 === void 0 ? void 0 : _3.css, (_4 = data === null || data === void 0 ? void 0 : data.context) === null || _4 === void 0 ? void 0 : _4.xpath, data.description);
            case "cssSelectorWithValue":
                return new CSSSelectorWithValueRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_5 = data.match) === null || _5 === void 0 ? void 0 : _5.css, (_6 = data.match) === null || _6 === void 0 ? void 0 : _6.xpath, (_7 = data.match) === null || _7 === void 0 ? void 0 : _7.code, (_8 = data.match) === null || _8 === void 0 ? void 0 : _8.key, (_9 = data === null || data === void 0 ? void 0 : data.context) === null || _9 === void 0 ? void 0 : _9.url, (_10 = data === null || data === void 0 ? void 0 : data.context) === null || _10 === void 0 ? void 0 : _10.css, (_11 = data === null || data === void 0 ? void 0 : data.context) === null || _11 === void 0 ? void 0 : _11.xpath, data.description);
            case "attributeValue":
                if (data.match.attributeName === undefined) {
                    return new SimpleRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_12 = data.match) === null || _12 === void 0 ? void 0 : _12.css, (_13 = data.match) === null || _13 === void 0 ? void 0 : _13.xpath, (_14 = data.match) === null || _14 === void 0 ? void 0 : _14.code, (_15 = data.match) === null || _15 === void 0 ? void 0 : _15.key, (_16 = data === null || data === void 0 ? void 0 : data.context) === null || _16 === void 0 ? void 0 : _16.url, (_17 = data === null || data === void 0 ? void 0 : data.context) === null || _17 === void 0 ? void 0 : _17.css, (_18 = data === null || data === void 0 ? void 0 : data.context) === null || _18 === void 0 ? void 0 : _18.xpath, data.description);
                }
                else {
                    return new AttributeValueRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_19 = data.match) === null || _19 === void 0 ? void 0 : _19.css, (_20 = data.match) === null || _20 === void 0 ? void 0 : _20.xpath, (_21 = data.match) === null || _21 === void 0 ? void 0 : _21.code, (_22 = data.match) === null || _22 === void 0 ? void 0 : _22.key, (_23 = data === null || data === void 0 ? void 0 : data.context) === null || _23 === void 0 ? void 0 : _23.url, (_24 = data === null || data === void 0 ? void 0 : data.context) === null || _24 === void 0 ? void 0 : _24.css, (_25 = data === null || data === void 0 ? void 0 : data.context) === null || _25 === void 0 ? void 0 : _25.xpath, data.description, data.match.attributeName);
                }
            default:
                return new SimpleRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_26 = data.match) === null || _26 === void 0 ? void 0 : _26.css, (_27 = data.match) === null || _27 === void 0 ? void 0 : _27.xpath, (_28 = data.match) === null || _28 === void 0 ? void 0 : _28.code, (_29 = data.match) === null || _29 === void 0 ? void 0 : _29.key, (_30 = data === null || data === void 0 ? void 0 : data.context) === null || _30 === void 0 ? void 0 : _30.url, (_31 = data === null || data === void 0 ? void 0 : data.context) === null || _31 === void 0 ? void 0 : _31.css, (_32 = data === null || data === void 0 ? void 0 : data.context) === null || _32 === void 0 ? void 0 : _32.xpath, data.description);
        }
    }
}
exports["default"] = RuleService;


/***/ }),

/***/ "./src/domain/Session.ts":
/*!*******************************!*\
  !*** ./src/domain/Session.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Session {
    constructor(id, webSiteId, baseURL, name, description, overlayType, recordingMode) {
        if (id === null || id === undefined) {
            throw new Error('cannot create Session without id');
        }
        if (webSiteId === null || webSiteId === undefined) {
            throw new Error('cannot create Session without webSiteId');
        }
        this.id = id;
        this.webSiteId = webSiteId;
        this.baseURL = baseURL;
        this.name = name;
        this.description = description;
        this.overlayType = overlayType;
        this.recordingMode = recordingMode;
    }
}
exports["default"] = Session;


/***/ }),

/***/ "./src/domain/SimpleRule.ts":
/*!**********************************!*\
  !*** ./src/domain/SimpleRule.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const Rule_1 = __importDefault(__webpack_require__(/*! ./Rule */ "./src/domain/Rule.ts"));
class SimpleRule extends Rule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        return new Action_1.default(this.prefix);
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        const elements = this.findMatchedElements();
        return elements;
    }
}
exports["default"] = SimpleRule;


/***/ }),

/***/ "./src/domain/URLContextMapper.ts":
/*!****************************************!*\
  !*** ./src/domain/URLContextMapper.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ContextMapper_1 = __importDefault(__webpack_require__(/*! ./ContextMapper */ "./src/domain/ContextMapper.ts"));
class URLContextMapper extends ContextMapper_1.default {
    constructor(context) {
        super(context);
    }
    buildElementToRuleMap() {
        if (this._context && document.URL.startsWith(this._context)) {
            return this.buildElementToRuleMapForSelectors();
        }
        else {
            return new Map();
        }
    }
}
exports["default"] = URLContextMapper;


/***/ }),

/***/ "./src/domain/ValueRule.ts":
/*!*********************************!*\
  !*** ./src/domain/ValueRule.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
class ValueRule extends SimpleRule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        let target = event.target;
        if (target) {
            if (target instanceof HTMLInputElement) {
                return new Action_1.default(this.prefix, target.value);
            }
            else if (target instanceof HTMLSelectElement) {
                return new Action_1.default(this.prefix, "svg");
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix === undefined) {
            return super.actionToElements(action);
        }
        const elements = this.findMatchedElements();
        return elements;
    }
}
exports["default"] = ValueRule;


/***/ }),

/***/ "./src/domain/Website.ts":
/*!*******************************!*\
  !*** ./src/domain/Website.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class WebSite {
    constructor(id, name, mappingList) {
        this.id = id;
        this.name = name;
        this.mappingList = mappingList;
    }
}
exports["default"] = WebSite;


/***/ }),

/***/ "./src/domain/XPathContextMapper.ts":
/*!******************************************!*\
  !*** ./src/domain/XPathContextMapper.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ContextMapper_1 = __importDefault(__webpack_require__(/*! ./ContextMapper */ "./src/domain/ContextMapper.ts"));
class XPathContextMapper extends ContextMapper_1.default {
    constructor(context) {
        super(context);
    }
    buildElementToRuleMap() {
        if (this._context) {
            const xpathQueryResult = document.evaluate(this._context, document, null, XPathResult.ANY_TYPE, null);
            const context = xpathQueryResult.iterateNext();
            if (context instanceof HTMLElement || context instanceof SVGElement) {
                return this.buildElementToRuleMapForSelectors();
            }
            else {
                return new Map();
            }
        }
        else {
            return new Map();
        }
    }
}
exports["default"] = XPathContextMapper;


/***/ }),

/***/ "./src/framework/Logger.ts":
/*!*********************************!*\
  !*** ./src/framework/Logger.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logger = void 0;
const typescript_logging_1 = __webpack_require__(/*! typescript-logging */ "./node_modules/typescript-logging/dist/commonjs/typescript-logging.js");
let logLevel;
switch ("development") {
    case 'production':
        logLevel = typescript_logging_1.LogLevel.Error;
        break;
    case 'development':
        logLevel = typescript_logging_1.LogLevel.Debug;
        break;
    case 'github':
        logLevel = typescript_logging_1.LogLevel.Error;
        break;
    default:
        logLevel = typescript_logging_1.LogLevel.Error;
}
typescript_logging_1.CategoryServiceFactory.setDefaultConfiguration(new typescript_logging_1.CategoryConfiguration(logLevel));
exports.logger = new typescript_logging_1.Category("TabScript");


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const BrowserScript_1 = __importDefault(__webpack_require__(/*! ./domain/BrowserScript */ "./src/domain/BrowserScript.ts"));
const Logger_1 = __webpack_require__(/*! ./framework/Logger */ "./src/framework/Logger.ts");
const AifexServiceHTTP_1 = __importDefault(__webpack_require__(/*! ./_infra/AifexServiceHTTP */ "./src/_infra/AifexServiceHTTP.ts"));
const BrowserServiceSessionStorage_1 = __importDefault(__webpack_require__(/*! ./_infra/BrowserServiceSessionStorage */ "./src/_infra/BrowserServiceSessionStorage.ts"));
Logger_1.logger.info("AIFEX script is running.");
const AIFEX_SCRIPT = document.getElementById("AIFEX");
if (AIFEX_SCRIPT) {
    Logger_1.logger.info("AIFEX SCRIPT Element is found.");
    const CONNEXION_URL = AIFEX_SCRIPT.getAttribute("connexion-url");
    if (CONNEXION_URL) {
        Logger_1.logger.info("AIFEX connexion-url Element is found.");
        try {
            const AIFEX_URL = new URL(CONNEXION_URL);
            let sessionId = AIFEX_URL.searchParams.get('sessionId');
            if (sessionId) {
                Logger_1.logger.info("AIFEX sessionId is found.");
                const AIFEX_SERVICE = new AifexServiceHTTP_1.default();
                const BROWSER_SERVICE = new BrowserServiceSessionStorage_1.default();
                const BROWSER_SCRIPT = new BrowserScript_1.default(AIFEX_URL.origin, sessionId, undefined, AIFEX_SERVICE, BROWSER_SERVICE);
                BROWSER_SCRIPT.start();
            }
        }
        catch (e) {
            Logger_1.logger.error("Invalid connexion URL", new Error("Invalid connexion URL"));
        }
    }
}
else {
    Logger_1.logger.error("AIFEX SCRIPT Element is not found.", new Error("AIFEX SCRIPT Element is not found."));
}


/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/control/CategoryServiceControl.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/control/CategoryServiceControl.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CategoryServiceControlImpl = void 0;
var CategoryService_1 = __webpack_require__(/*! ../log/category/CategoryService */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js");
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var DataStructures_1 = __webpack_require__(/*! ../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
/**
 * Implementation class for CategoryServiceControl.
 */
var CategoryServiceControlImpl = /** @class */ (function () {
    function CategoryServiceControlImpl() {
    }
    CategoryServiceControlImpl.prototype.help = function () {
        /* tslint:disable:no-console */
        console.log(CategoryServiceControlImpl._help);
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl.prototype.example = function () {
        /* tslint:disable:no-console */
        console.log(CategoryServiceControlImpl._example);
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl.prototype.showSettings = function (id) {
        if (id === void 0) { id = "all"; }
        var result = new DataStructures_1.StringBuilder();
        var service = CategoryServiceControlImpl._getCategoryService();
        var categories = CategoryServiceControlImpl._getCategories(id);
        categories.forEach(function (category) {
            CategoryServiceControlImpl._processCategory(service, category, result, 0);
        });
        /* tslint:disable:no-console */
        console.log(result.toString());
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl.prototype.change = function (settings) {
        var service = CategoryServiceControlImpl._getCategoryService();
        var categories = CategoryServiceControlImpl._getCategories(settings.category);
        var logLevel = null;
        var formatEnum = null;
        var showCategoryName = null;
        var showTimestamp = null;
        var result = null;
        var addResult = function (value) {
            if (result !== null) {
                result += ", ";
            }
            if (result === null) {
                result = value;
            }
            else {
                result += value;
            }
        };
        addResult("recursive=" + settings.recursive);
        if (typeof settings.logLevel === "string") {
            logLevel = LoggerOptions_1.LogLevel.fromString(settings.logLevel);
            addResult("logLevel=" + settings.logLevel);
        }
        if (typeof settings.logFormat === "string") {
            formatEnum = LoggerOptions_1.DateFormatEnum.fromString(settings.logFormat);
            addResult("logFormat=" + settings.logFormat);
        }
        if (typeof settings.showCategoryName === "boolean") {
            showCategoryName = settings.showCategoryName;
            addResult("showCategoryName=" + settings.showCategoryName);
        }
        if (typeof settings.showTimestamp === "boolean") {
            showTimestamp = settings.showTimestamp;
            addResult("showTimestamp=" + settings.showTimestamp);
        }
        var applyChanges = function (cat) {
            var categorySettings = service.getCategorySettings(cat);
            // Should not happen but make tslint happy
            if (categorySettings !== null) {
                if (logLevel !== null) {
                    categorySettings.logLevel = logLevel;
                }
                if (formatEnum !== null) {
                    categorySettings.logFormat.dateFormat.formatEnum = formatEnum;
                }
                if (showTimestamp !== null) {
                    categorySettings.logFormat.showTimeStamp = showTimestamp;
                }
                if (showCategoryName !== null) {
                    categorySettings.logFormat.showCategoryName = showCategoryName;
                }
            }
        };
        categories.forEach(function (cat) { return CategoryServiceControlImpl._applyToCategory(cat, settings.recursive, applyChanges); });
        /* tslint:disable:no-console */
        console.log("Applied changes: " + result + " to categories '" + settings.category + "'.");
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl.prototype.reset = function (id) {
        if (id === void 0) { id = "all"; }
        var service = CategoryServiceControlImpl._getCategoryService();
        var categories = CategoryServiceControlImpl._getCategories(id);
        var applyChanges = function (cat) {
            var categorySettings = service.getCategorySettings(cat);
            var original = service.getOriginalCategorySettings(cat);
            // Should not happen but make tslint happy
            if (categorySettings !== null && original !== null) {
                categorySettings.logLevel = original.logLevel;
                categorySettings.logFormat.dateFormat.formatEnum = original.logFormat.dateFormat.formatEnum;
                categorySettings.logFormat.showTimeStamp = original.logFormat.showTimeStamp;
                categorySettings.logFormat.showCategoryName = original.logFormat.showCategoryName;
            }
        };
        categories.forEach(function (cat) { return CategoryServiceControlImpl._applyToCategory(cat, true, applyChanges); });
        /* tslint:disable:no-console */
        console.log("Applied reset to category: " + id + ".");
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl._processCategory = function (service, category, result, indent) {
        var settings = service.getCategorySettings(category);
        if (settings !== null) {
            result.append("  " + category.id + ": ");
            if (indent > 0) {
                for (var i = 0; i < indent; i++) {
                    result.append("  ");
                }
            }
            result.append(category.name + " (" + LoggerOptions_1.LogLevel[settings.logLevel].toString() + "@" + LoggerOptions_1.LoggerType[settings.loggerType].toString() + ")\n");
            if (category.children.length > 0) {
                category.children.forEach(function (child) {
                    CategoryServiceControlImpl._processCategory(service, child, result, indent + 1);
                });
            }
        }
    };
    CategoryServiceControlImpl._applyToCategory = function (category, recursive, apply) {
        apply(category);
        if (recursive) {
            category.children.forEach(function (child) {
                CategoryServiceControlImpl._applyToCategory(child, recursive, apply);
            });
        }
    };
    CategoryServiceControlImpl._getCategoryService = function () {
        return CategoryService_1.CategoryServiceImpl.getInstance();
    };
    CategoryServiceControlImpl._getCategories = function (idCategory) {
        var service = CategoryServiceControlImpl._getCategoryService();
        var categories = [];
        if (idCategory === "all") {
            categories = service.getRootCategories();
        }
        else {
            var category = service.getCategoryById(idCategory);
            if (category === null) {
                throw new Error("Failed to find category with id " + idCategory);
            }
            categories.push(category);
        }
        return categories;
    };
    CategoryServiceControlImpl._help = "\n  help(): void\n    ** Shows this help.\n\n  example(): void\n    ** Shows an example on how to use this.\n\n  showSettings(id: number | \"all\" = \"all\"): void\n    ** Shows settings for a specific category, or for all. The id of categories can be found by calling this method without parameter.\n\n  change(settings: CategoryServiceControlSettings): void\n    ** Changes the current settings for one or all categories.\n    **\n       CategoryServiceControlSettings, properties of object:\n         category: number | \"all\"\n           ** Apply to specific category, or \"all\".\n           ** Required\n\n         recursive: boolean\n           ** Apply to child categories (true) or not.\n           ** Required\n\n         logLevel: \"Fatal\" | \"Error\" | \"Warn\" | \"Info\" | \"Debug\" | \"Trace\" | undefined\n           ** Set log level, undefined will not change the setting.\n           ** Optional\n\n         logFormat: \"Default\" | \"YearMonthDayTime\" | \"YearDayMonthWithFullTime\" | \"YearDayMonthTime\" | undefined\n           ** Set the log format, undefined will not change the setting.\n           ** Optional\n\n         showTimestamp: boolean | undefined\n           ** Whether to show timestamp, undefined will not change the setting.\n           ** Optional\n\n         showCategoryName: boolean | undefined\n           ** Whether to show the category name, undefined will not change the setting.\n           ** Optional\n\n   reset(id: number | \"all\"): void\n     ** Resets everything to original values, for one specific or for all categories.\n";
    CategoryServiceControlImpl._example = "\n  Examples:\n    change({category: \"all\", recursive:true, logLevel: \"Info\"})\n      ** Change loglevel to Info for all categories, apply to child categories as well.\n\n    change({category: 1, recursive:false, logLevel: \"Warn\"})\n      ** Change logLevel for category 1, do not recurse.\n\n    change({category: \"all\", recursive:true, logLevel: \"Debug\", logFormat: \"YearDayMonthTime\", showTimestamp:false, showCategoryName:false})\n      ** Change loglevel to Debug for all categories, apply format, do not show timestamp and category names - recursively to child categories.\n\n";
    return CategoryServiceControlImpl;
}());
exports.CategoryServiceControlImpl = CategoryServiceControlImpl;
//# sourceMappingURL=CategoryServiceControl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/control/LogGroupControl.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/control/LogGroupControl.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggerControlImpl = void 0;
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var LFService_1 = __webpack_require__(/*! ../log/standard/LFService */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LFService.js");
var DataStructures_1 = __webpack_require__(/*! ../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var LoggerControlImpl = /** @class */ (function () {
    function LoggerControlImpl() {
    }
    LoggerControlImpl.prototype.help = function () {
        /* tslint:disable:no-console */
        console.log(LoggerControlImpl._help);
        /* tslint:enable:no-console */
    };
    LoggerControlImpl.prototype.listFactories = function () {
        var rtSettingsFactories = LoggerControlImpl._getRuntimeSettingsLoggerFactories();
        var result = new DataStructures_1.StringBuilder();
        result.appendLine("Registered LoggerFactories (index / name)");
        for (var i = 0; i < rtSettingsFactories.length; i++) {
            var rtSettingsFactory = rtSettingsFactories[i];
            result.append("  " + i).append(": " + rtSettingsFactory.getName() + "\n");
        }
        /* tslint:disable:no-console */
        console.log(result.toString());
        /* tslint:enable:no-console */
    };
    LoggerControlImpl.prototype.showSettings = function (id) {
        if (id === void 0) { id = "all"; }
        var result = [];
        if (id === "all") {
            var idx_1 = 0;
            LoggerControlImpl._getRuntimeSettingsLoggerFactories().forEach(function (item) {
                result.push(new DataStructures_1.TuplePair(idx_1++, item));
            });
        }
        else {
            var settings = LoggerControlImpl._getRuntimeSettingsLoggerFactories();
            if (id >= 0 && id < settings.length) {
                result.push(new DataStructures_1.TuplePair(id, settings[id]));
            }
            else {
                throw new Error("Requested number: " + id + " was not found.");
            }
        }
        for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
            var setting = result_1[_i];
            /* tslint:disable:no-console */
            console.log("  LoggerFactory: " + setting.y.getName() + " (id=" + setting.x + ")");
            var logGroupRuntimeSettings = setting.y.getLogGroupRuntimeSettings();
            for (var g = 0; g < logGroupRuntimeSettings.length; g++) {
                var groupSetting = logGroupRuntimeSettings[g];
                console.log("     LogGroup: (id=" + g + ")");
                console.log("       RegExp: " + groupSetting.logGroupRule.regExp.source);
                console.log("       Level: " + LoggerOptions_1.LogLevel[groupSetting.level].toString());
                console.log("       LoggerType: " + LoggerOptions_1.LoggerType[groupSetting.loggerType].toString());
            }
            /* tslint:enable:no-console */
        }
    };
    LoggerControlImpl.prototype.reset = function (idFactory) {
        if (idFactory === void 0) { idFactory = "all"; }
        var loggerFactoriesSettings = LoggerControlImpl._getRuntimeSettingsLoggerFactories();
        var result = [];
        if (idFactory === "all") {
            result = loggerFactoriesSettings;
        }
        else {
            if (idFactory >= 0 && idFactory < loggerFactoriesSettings.length) {
                result.push(loggerFactoriesSettings[idFactory]);
            }
        }
        result.forEach(function (setting) {
            /* tslint:disable:no-console */
            console.log("Reset all settings for factory " + idFactory);
            /* tslint:enable:no-console */
            var control = new LoggerFactoryControlImpl(setting);
            control.reset();
        });
    };
    LoggerControlImpl.prototype.getLoggerFactoryControl = function (idFactory) {
        var loggerFactoriesSettings = LoggerControlImpl._getRuntimeSettingsLoggerFactories();
        if (idFactory >= 0 && idFactory < loggerFactoriesSettings.length) {
            return new LoggerFactoryControlImpl(loggerFactoriesSettings[idFactory]);
        }
        throw new Error("idFactory is invalid (less than 0) or non existing id.");
    };
    LoggerControlImpl._getRuntimeSettingsLoggerFactories = function () {
        return LoggerControlImpl._getSettings().getRuntimeSettingsForLoggerFactories();
    };
    LoggerControlImpl._getSettings = function () {
        return LFService_1.LFService.getRuntimeSettings();
    };
    LoggerControlImpl._help = "\n  help(): void\n    ** Shows this help.\n\n  listFactories(): void\n    ** List all registered LoggerFactories with associated log groups with respective ids (ids can be used to target a factory and/or group).\n\n  showSettings(idFactory: number | \"all\"): void\n    ** Show log group settings for idFactory (use listFactories to find id for a LoggerFactory). If idFactory is \"all\" shows all factories.\n\n  getLoggerFactoryControl(idFactory: number): LoggerFactoryControl\n    ** Return LoggerFactoryControl when found for given idFactory or throws Error if invalid or null, get the id by using listFactories()\n\n  reset(idFactory: number | \"all\"): void\n    ** Resets given factory or all factories back to original values.\n";
    return LoggerControlImpl;
}());
exports.LoggerControlImpl = LoggerControlImpl;
var LoggerFactoryControlImpl = /** @class */ (function () {
    function LoggerFactoryControlImpl(settings) {
        this._settings = settings;
    }
    LoggerFactoryControlImpl.prototype.help = function () {
        /* tslint:disable:no-console */
        console.log(LoggerFactoryControlImpl._help);
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype.example = function () {
        /* tslint:disable:no-console */
        console.log(LoggerFactoryControlImpl._example);
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype.showSettings = function (id) {
        if (id === void 0) { id = "all"; }
        var result = new DataStructures_1.StringBuilder();
        var logGroupRuntimeSettings = this._settings.getLogGroupRuntimeSettings();
        result.appendLine("Registered LogGroups (index / expression)");
        for (var i = 0; i < logGroupRuntimeSettings.length; i++) {
            var logGroupRuntimeSetting = logGroupRuntimeSettings[i];
            result.appendLine("  " + i + ": " + logGroupRuntimeSetting.logGroupRule.regExp.source + ", logLevel=" +
                LoggerOptions_1.LogLevel[logGroupRuntimeSetting.level].toString() + ", showTimestamp=" + logGroupRuntimeSetting.logFormat.showTimeStamp +
                ", showLoggerName=" + logGroupRuntimeSetting.logFormat.showLoggerName +
                ", format=" + LoggerOptions_1.DateFormatEnum[logGroupRuntimeSetting.logFormat.dateFormat.formatEnum].toString());
        }
        /* tslint:disable:no-console */
        console.log(result.toString());
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype.change = function (settings) {
        var logGroupRuntimeSettings = this._getLogGroupRunTimeSettingsFor(settings.group);
        var logLevel = null;
        var formatEnum = null;
        var showLoggerName = null;
        var showTimestamp = null;
        var result = null;
        var addResult = function (value) {
            if (result !== null) {
                result += ", ";
            }
            if (result === null) {
                result = value;
            }
            else {
                result += value;
            }
        };
        if (typeof settings.logLevel === "string") {
            logLevel = LoggerOptions_1.LogLevel.fromString(settings.logLevel);
            addResult("logLevel=" + settings.logLevel);
        }
        if (typeof settings.logFormat === "string") {
            formatEnum = LoggerOptions_1.DateFormatEnum.fromString(settings.logFormat);
            addResult("logFormat=" + settings.logFormat);
        }
        if (typeof settings.showLoggerName === "boolean") {
            showLoggerName = settings.showLoggerName;
            addResult("showLoggerName=" + settings.showLoggerName);
        }
        if (typeof settings.showTimestamp === "boolean") {
            showTimestamp = settings.showTimestamp;
            addResult("showTimestamp=" + settings.showTimestamp);
        }
        logGroupRuntimeSettings.forEach(function (s) {
            if (logLevel !== null) {
                s.level = logLevel;
            }
            if (formatEnum !== null) {
                s.logFormat.dateFormat.formatEnum = formatEnum;
            }
            if (showTimestamp !== null) {
                s.logFormat.showTimeStamp = showTimestamp;
            }
            if (showLoggerName !== null) {
                s.logFormat.showLoggerName = showLoggerName;
            }
        });
        /* tslint:disable:no-console */
        console.log("Applied changes: " + result + " to log groups '" + settings.group + "'.");
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype.reset = function (idGroup) {
        if (idGroup === void 0) { idGroup = "all"; }
        var settings = this._getLogGroupRunTimeSettingsFor(idGroup);
        for (var _i = 0, settings_1 = settings; _i < settings_1.length; _i++) {
            var setting = settings_1[_i];
            setting.level = setting.logGroupRule.level;
            setting.logFormat.showTimeStamp = setting.logGroupRule.logFormat.showTimeStamp;
            setting.logFormat.showLoggerName = setting.logGroupRule.logFormat.showLoggerName;
            setting.logFormat.dateFormat.formatEnum = setting.logGroupRule.logFormat.dateFormat.formatEnum;
        }
        /* tslint:disable:no-console */
        console.log("Reset all settings for group " + idGroup);
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype._getLogGroupRunTimeSettingsFor = function (idGroup) {
        var settings = [];
        if (idGroup === "all") {
            settings = this._settings.getLogGroupRuntimeSettings();
        }
        else {
            this._checkIndex(idGroup);
            settings.push(this._settings.getLogGroupRuntimeSettings()[idGroup]);
        }
        return settings;
    };
    LoggerFactoryControlImpl.prototype._checkIndex = function (index) {
        if (index < 0 || index >= this._settings.getLogGroupRuntimeSettings().length) {
            throw new Error("Invalid index, use listLogGroups to find out a valid one.");
        }
    };
    LoggerFactoryControlImpl._help = "\n  help(): void\n    ** Shows this help.\n\n  example(): void\n    ** Shows an example of usage.\n\n  showSettings(id: number | \"all\"): void\n    ** Prints settings for given group id, \"all\" for all group.\n\n  change(settings: LogGroupControlSettings): void\n    ** Changes the current settings for one or all log groups.\n    **\n       LogGroupControlSettings, properties of object:\n         group: number | \"all\"\n           ** Apply to specific group, or \"all\".\n           ** Required\n\n         logLevel: \"Fatal\" | \"Error\" | \"Warn\" | \"Info\" | \"Debug\" | \"Trace\" | undefined\n           ** Set log level, undefined will not change the setting.\n           ** Optional\n\n         logFormat: \"Default\" | \"YearMonthDayTime\" | \"YearDayMonthWithFullTime\" | \"YearDayMonthTime\" | undefined\n           ** Set the log format, undefined will not change the setting.\n           ** Optional\n\n         showTimestamp: boolean | undefined\n           ** Whether to show timestamp, undefined will not change the setting.\n           ** Optional\n\n         showLoggerName: boolean | undefined\n           ** Whether to show the logger name, undefined will not change the setting.\n           ** Optional\n\n  reset(id: number | \"all\"): void\n    ** Resets everything to original values, for one specific or for all groups.\n\n  help():\n    ** Shows this help.\n";
    LoggerFactoryControlImpl._example = "\n  Examples:\n    change({group: \"all\", logLevel: \"Info\"})\n      ** Change loglevel to Info for all groups.\n\n    change({group: 1, recursive:false, logLevel: \"Warn\"})\n      ** Change logLevel for group 1 to Warn.\n\n    change({group: \"all\", logLevel: \"Debug\", logFormat: \"YearDayMonthTime\", showTimestamp:false, showLoggerName:false})\n      ** Change loglevel to Debug for all groups, apply format, do not show timestamp and logger names.\n";
    return LoggerFactoryControlImpl;
}());
//# sourceMappingURL=LogGroupControl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js":
/*!************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExtensionHelper = void 0;
var CategoryService_1 = __webpack_require__(/*! ../log/category/CategoryService */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js");
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var MessageUtils_1 = __webpack_require__(/*! ../utils/MessageUtils */ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js");
var ExtensionHelper = /** @class */ (function () {
    function ExtensionHelper() {
        // Private constructor
    }
    /**
     * Enables the window event listener to listen to messages (from extensions).
     * Can be registered/enabled only once.
     */
    ExtensionHelper.register = function () {
        if (!ExtensionHelper.registered) {
            var listener = function (evt) {
                var msg = evt.data;
                if (msg !== null) {
                    ExtensionHelper.processMessageFromExtension(msg);
                }
            };
            if (typeof window !== "undefined" && typeof window.removeEventListener !== "undefined" && typeof window.addEventListener !== "undefined") {
                window.removeEventListener("message", listener);
                window.addEventListener("message", listener);
                ExtensionHelper.registered = true;
            }
        }
    };
    ExtensionHelper.processMessageFromExtension = function (msg) {
        if (!ExtensionHelper.registered) {
            return;
        }
        /* tslint:disable:no-console */
        if (msg.from === "tsl-extension") {
            var data = msg.data;
            switch (data.type) {
                case "register":
                    ExtensionHelper.enableExtensionIntegration();
                    break;
                case "request-change-loglevel":
                    var valueRequest = data.value;
                    var catsApplied = ExtensionHelper.applyLogLevel(valueRequest.categoryId, valueRequest.logLevel, valueRequest.recursive);
                    if (catsApplied.length > 0) {
                        // Send changes back
                        ExtensionHelper.sendCategoriesRuntimeUpdateMessage(catsApplied);
                    }
                    break;
                default:
                    console.log("Unknown command to process message from extension, command was: " + data.type);
                    break;
            }
        }
        /* tslint:enable:no-console */
    };
    ExtensionHelper.sendCategoryLogMessage = function (msg) {
        if (!ExtensionHelper.registered) {
            return;
        }
        var categoryIds = msg.categories.map(function (cat) {
            return cat.id;
        });
        var content = {
            type: "log-message",
            value: {
                categories: categoryIds,
                errorAsStack: msg.errorAsStack,
                formattedMessage: MessageUtils_1.MessageFormatUtils.renderDefaultMessage(msg, false),
                logLevel: LoggerOptions_1.LogLevel[msg.level].toString(),
                message: msg.messageAsString,
                resolvedErrorMessage: msg.isResolvedErrorMessage
            }
        };
        var message = {
            data: content,
            from: "tsl-logging",
        };
        ExtensionHelper.sendMessage(message);
    };
    ExtensionHelper.sendCategoriesRuntimeUpdateMessage = function (categories) {
        if (!ExtensionHelper.registered) {
            return;
        }
        var service = CategoryService_1.CategoryServiceImpl.getInstance();
        var catLevels = { categories: Array() };
        categories.forEach(function (cat) {
            var catSettings = service.getCategorySettings(cat);
            if (catSettings != null) {
                catLevels.categories.push({ id: cat.id, logLevel: LoggerOptions_1.LogLevel[catSettings.logLevel].toString() });
            }
        });
        var content = {
            type: "categories-rt-update",
            value: catLevels,
        };
        var message = {
            data: content,
            from: "tsl-logging"
        };
        ExtensionHelper.sendMessage(message);
    };
    ExtensionHelper.sendRootCategoriesToExtension = function () {
        if (!ExtensionHelper.registered) {
            return;
        }
        var categories = CategoryService_1.CategoryServiceImpl.getInstance().getRootCategories().map(function (cat) {
            return ExtensionHelper.getCategoryAsJSON(cat);
        });
        var content = {
            type: "root-categories-tree",
            value: categories
        };
        var message = {
            data: content,
            from: "tsl-logging"
        };
        ExtensionHelper.sendMessage(message);
    };
    /**
     * If extension integration is enabled, will send the root categories over to the extension.
     * Otherwise does nothing.
     */
    ExtensionHelper.getCategoryAsJSON = function (cat) {
        var childCategories = cat.children.map(function (child) {
            return ExtensionHelper.getCategoryAsJSON(child);
        });
        return {
            children: childCategories,
            id: cat.id,
            logLevel: LoggerOptions_1.LogLevel[cat.logLevel].toString(),
            name: cat.name,
            parentId: (cat.parent != null ? cat.parent.id : null),
        };
    };
    ExtensionHelper.applyLogLevel = function (categoryId, logLevel, recursive) {
        var cats = [];
        var category = CategoryService_1.CategoryServiceImpl.getInstance().getCategoryById(categoryId);
        if (category != null) {
            ExtensionHelper._applyLogLevelRecursive(category, LoggerOptions_1.LogLevel.fromString(logLevel), recursive, cats);
        }
        else {
            /* tslint:disable:no-console */
            console.log("Could not change log level, failed to find category with id: " + categoryId);
            /* tslint:enable:no-console */
        }
        return cats;
    };
    ExtensionHelper._applyLogLevelRecursive = function (category, logLevel, recursive, cats) {
        var categorySettings = CategoryService_1.CategoryServiceImpl.getInstance().getCategorySettings(category);
        if (categorySettings != null) {
            categorySettings.logLevel = logLevel;
            cats.push(category);
            if (recursive) {
                category.children.forEach(function (child) {
                    ExtensionHelper._applyLogLevelRecursive(child, logLevel, recursive, cats);
                });
            }
        }
    };
    ExtensionHelper.getAllCategories = function () {
        var cats = [];
        var addCats = function (cat, allCats) {
            allCats.push(cat);
            cat.children.forEach(function (catChild) {
                addCats(catChild, allCats);
            });
        };
        CategoryService_1.CategoryServiceImpl.getInstance().getRootCategories().forEach(function (cat) {
            addCats(cat, cats);
        });
        return cats;
    };
    ExtensionHelper.sendMessage = function (msg) {
        if (!ExtensionHelper.registered) {
            return;
        }
        if (typeof window !== "undefined" && typeof window.postMessage !== "undefined") {
            window.postMessage(msg, "*");
        }
    };
    /**
     *  Extension framework will call this to enable the integration between two,
     *  after this call the framework will respond with postMessage() messages.
     */
    ExtensionHelper.enableExtensionIntegration = function () {
        if (!ExtensionHelper.registered) {
            return;
        }
        var instance = CategoryService_1.CategoryServiceImpl.getInstance();
        instance.enableExtensionIntegration();
        // Send over all categories
        ExtensionHelper.sendRootCategoriesToExtension();
        // Send over the current runtime levels
        var cats = ExtensionHelper.getAllCategories();
        ExtensionHelper.sendCategoriesRuntimeUpdateMessage(cats);
    };
    ExtensionHelper.registered = false;
    return ExtensionHelper;
}());
exports.ExtensionHelper = ExtensionHelper;
//# sourceMappingURL=ExtensionHelper.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionMessageJSON.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/extension/ExtensionMessageJSON.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=ExtensionMessageJSON.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/extension/MessagesFromExtensionJSON.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/extension/MessagesFromExtensionJSON.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=MessagesFromExtensionJSON.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/extension/MessagesToExtensionJSON.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/extension/MessagesToExtensionJSON.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=MessagesToExtensionJSON.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js":
/*!****************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CategoryLogFormat = exports.LogFormat = exports.DateFormat = exports.DateFormatEnum = exports.LoggerType = exports.LogLevel = void 0;
/**
 * Log level for a logger.
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Warn"] = 3] = "Warn";
    LogLevel[LogLevel["Error"] = 4] = "Error";
    LogLevel[LogLevel["Fatal"] = 5] = "Fatal";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/* tslint:disable:no-namespace */
(function (LogLevel) {
    /**
     * Returns LogLevel based on string representation
     * @param val Value
     * @returns {LogLevel}, Error is thrown if invalid.
     */
    function fromString(val) {
        if (val == null) {
            throw new Error("Argument must be set");
        }
        switch (val.toLowerCase()) {
            case "trace":
                return LogLevel.Trace;
            case "debug":
                return LogLevel.Debug;
            case "info":
                return LogLevel.Info;
            case "warn":
                return LogLevel.Warn;
            case "error":
                return LogLevel.Error;
            case "fatal":
                return LogLevel.Fatal;
            default:
                throw new Error("Unsupported value for conversion: " + val);
        }
    }
    LogLevel.fromString = fromString;
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/* tslint:disable:enable-namespace */
/**
 * Where to log to? Pick one of the constants. Custom requires a callback to be present, see LFService.createLoggerFactory(...)
 * where this comes into play.
 */
var LoggerType;
(function (LoggerType) {
    LoggerType[LoggerType["Console"] = 0] = "Console";
    LoggerType[LoggerType["MessageBuffer"] = 1] = "MessageBuffer";
    LoggerType[LoggerType["Custom"] = 2] = "Custom";
})(LoggerType = exports.LoggerType || (exports.LoggerType = {}));
/**
 * Defines several date enums used for formatting a date.
 */
var DateFormatEnum;
(function (DateFormatEnum) {
    /**
     * Displays as: year-month-day hour:minute:second,millis -> 1999-02-12 23:59:59,123
     * Note the date separator can be set separately.
     */
    DateFormatEnum[DateFormatEnum["Default"] = 0] = "Default";
    /**
     * Displays as: year-month-day hour:minute:second -> 1999-02-12 23:59:59
     * Note the date separator can be set separately.
     */
    DateFormatEnum[DateFormatEnum["YearMonthDayTime"] = 1] = "YearMonthDayTime";
    /**
     * Displays as: year-day-month hour:minute:second,millis -> 1999-12-02 23:59:59,123
     * Note the date separator can be set separately.
     */
    DateFormatEnum[DateFormatEnum["YearDayMonthWithFullTime"] = 2] = "YearDayMonthWithFullTime";
    /**
     * Displays as: year-day-month hour:minute:second -> 1999-12-02 23:59:59
     * Note the date separator can be set separately.
     */
    DateFormatEnum[DateFormatEnum["YearDayMonthTime"] = 3] = "YearDayMonthTime";
})(DateFormatEnum = exports.DateFormatEnum || (exports.DateFormatEnum = {}));
/* tslint:disable:no-namespace */
(function (DateFormatEnum) {
    /**
     * Returns LogLevel based on string representation
     * @param val Value
     * @returns {LogLevel}, Error is thrown if invalid.
     */
    function fromString(val) {
        if (val == null) {
            throw new Error("Argument must be set");
        }
        switch (val.toLowerCase()) {
            case "default":
                return DateFormatEnum.Default;
            case "yearmonthdayTime":
                return DateFormatEnum.YearMonthDayTime;
            case "yeardaymonthwithfulltime":
                return DateFormatEnum.YearDayMonthWithFullTime;
            case "yeardaymonthtime":
                return DateFormatEnum.YearDayMonthTime;
            default:
                throw new Error("Unsupported value for conversion: " + val);
        }
    }
    DateFormatEnum.fromString = fromString;
})(DateFormatEnum = exports.DateFormatEnum || (exports.DateFormatEnum = {}));
/* tslint:disable:enable-namespace */
/**
 * DateFormat class, stores data on how to format a date.
 */
var DateFormat = /** @class */ (function () {
    /**
     * Constructor to define the dateformat used for logging, can be called empty as it uses defaults.
     * @param formatEnum DateFormatEnum, use one of the constants from the enum. Defaults to DateFormatEnum.Default
     * @param dateSeparator Separator used between dates, defaults to -
     */
    function DateFormat(formatEnum, dateSeparator) {
        if (formatEnum === void 0) { formatEnum = DateFormatEnum.Default; }
        if (dateSeparator === void 0) { dateSeparator = "-"; }
        this._formatEnum = formatEnum;
        this._dateSeparator = dateSeparator;
    }
    Object.defineProperty(DateFormat.prototype, "formatEnum", {
        get: function () {
            return this._formatEnum;
        },
        set: function (value) {
            this._formatEnum = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DateFormat.prototype, "dateSeparator", {
        get: function () {
            return this._dateSeparator;
        },
        set: function (value) {
            this._dateSeparator = value;
        },
        enumerable: false,
        configurable: true
    });
    DateFormat.prototype.copy = function () {
        return new DateFormat(this._formatEnum, this._dateSeparator);
    };
    return DateFormat;
}());
exports.DateFormat = DateFormat;
/**
 * Information about the log format, what will a log line look like?
 */
var LogFormat = /** @class */ (function () {
    /**
     * Constructor to create a LogFormat. Can be created without parameters where it will use sane defaults.
     * @param dateFormat DateFormat (what needs the date look like in the log line)
     * @param showTimeStamp Show date timestamp at all?
     * @param showLoggerName Show the logger name?
     */
    function LogFormat(dateFormat, showTimeStamp, showLoggerName) {
        if (dateFormat === void 0) { dateFormat = new DateFormat(); }
        if (showTimeStamp === void 0) { showTimeStamp = true; }
        if (showLoggerName === void 0) { showLoggerName = true; }
        this._showTimeStamp = true;
        this._showLoggerName = true;
        this._dateFormat = dateFormat;
        this._showTimeStamp = showTimeStamp;
        this._showLoggerName = showLoggerName;
    }
    Object.defineProperty(LogFormat.prototype, "dateFormat", {
        get: function () {
            return this._dateFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogFormat.prototype, "showTimeStamp", {
        get: function () {
            return this._showTimeStamp;
        },
        set: function (value) {
            this._showTimeStamp = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogFormat.prototype, "showLoggerName", {
        get: function () {
            return this._showLoggerName;
        },
        set: function (value) {
            this._showLoggerName = value;
        },
        enumerable: false,
        configurable: true
    });
    return LogFormat;
}());
exports.LogFormat = LogFormat;
/**
 * Information about the log format, what will a log line look like?
 */
var CategoryLogFormat = /** @class */ (function () {
    /**
     * Create an instance defining the category log format used.
     * @param dateFormat Date format (uses default), for details see DateFormat class.
     * @param showTimeStamp True to show timestamp in the logging, defaults to true.
     * @param showCategoryName True to show category name in the logging, defaults to true.
     */
    function CategoryLogFormat(dateFormat, showTimeStamp, showCategoryName) {
        if (dateFormat === void 0) { dateFormat = new DateFormat(); }
        if (showTimeStamp === void 0) { showTimeStamp = true; }
        if (showCategoryName === void 0) { showCategoryName = true; }
        this._dateFormat = dateFormat;
        this._showTimeStamp = showTimeStamp;
        this._showCategoryName = showCategoryName;
    }
    Object.defineProperty(CategoryLogFormat.prototype, "dateFormat", {
        get: function () {
            return this._dateFormat;
        },
        set: function (value) {
            this._dateFormat = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryLogFormat.prototype, "showTimeStamp", {
        get: function () {
            return this._showTimeStamp;
        },
        set: function (value) {
            this._showTimeStamp = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryLogFormat.prototype, "showCategoryName", {
        get: function () {
            return this._showCategoryName;
        },
        set: function (value) {
            this._showCategoryName = value;
        },
        enumerable: false,
        configurable: true
    });
    CategoryLogFormat.prototype.copy = function () {
        return new CategoryLogFormat(this._dateFormat.copy(), this._showTimeStamp, this._showCategoryName);
    };
    return CategoryLogFormat;
}());
exports.CategoryLogFormat = CategoryLogFormat;
//# sourceMappingURL=LoggerOptions.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractCategoryLogger = void 0;
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var MessageUtils_1 = __webpack_require__(/*! ../../utils/MessageUtils */ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var CategoryLogMessageImpl = /** @class */ (function () {
    function CategoryLogMessageImpl(message, error, categories, date, level, logFormat, ready) {
        this._resolvedErrorMessage = false;
        this._errorAsStack = null;
        this._message = message;
        this._error = error;
        this._categories = categories;
        this._date = date;
        this._level = level;
        this._logFormat = logFormat;
        this._ready = ready;
    }
    Object.defineProperty(CategoryLogMessageImpl.prototype, "message", {
        get: function () {
            return this._message;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "error", {
        get: function () {
            return this._error;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "categories", {
        get: function () {
            return this._categories;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "date", {
        get: function () {
            return this._date;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "level", {
        get: function () {
            return this._level;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "isMessageLogData", {
        get: function () {
            return typeof (this._message) !== "string";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "messageAsString", {
        get: function () {
            if (typeof (this._message) === "string") {
                return this._message;
            }
            return this._message.msg;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "logData", {
        get: function () {
            var result = null;
            if (typeof (this._message) !== "string") {
                result = this.message;
            }
            return result;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "isResolvedErrorMessage", {
        get: function () {
            return this._resolvedErrorMessage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "errorAsStack", {
        get: function () {
            return this._errorAsStack;
        },
        set: function (stack) {
            this._errorAsStack = stack;
        },
        enumerable: false,
        configurable: true
    });
    CategoryLogMessageImpl.prototype.isReady = function () {
        return this._ready;
    };
    CategoryLogMessageImpl.prototype.setReady = function (value) {
        this._ready = value;
    };
    Object.defineProperty(CategoryLogMessageImpl.prototype, "resolvedErrorMessage", {
        get: function () {
            return this._resolvedErrorMessage;
        },
        set: function (value) {
            this._resolvedErrorMessage = value;
        },
        enumerable: false,
        configurable: true
    });
    return CategoryLogMessageImpl;
}());
/**
 * Abstract category logger, use as your base class for new type of loggers (it
 * saves you a lot of work) and override doLog(CategoryLogMessage). The message argument
 * provides full access to anything related to the logging event.
 * If you just want the standard line of logging, call: this.createDefaultLogMessage(msg) on
 * this class which will return you the formatted log message as string (e.g. the
 * default loggers all use this).
 */
var AbstractCategoryLogger = /** @class */ (function () {
    function AbstractCategoryLogger(rootCategory, runtimeSettings) {
        this.allMessages = new DataStructures_1.LinkedList();
        this.rootCategory = rootCategory;
        this.runtimeSettings = runtimeSettings;
    }
    AbstractCategoryLogger.prototype.trace = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this._log.apply(this, __spreadArray([LoggerOptions_1.LogLevel.Trace, msg, null, false], categories, false));
    };
    AbstractCategoryLogger.prototype.debug = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this._log.apply(this, __spreadArray([LoggerOptions_1.LogLevel.Debug, msg, null, false], categories, false));
    };
    AbstractCategoryLogger.prototype.info = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this._log.apply(this, __spreadArray([LoggerOptions_1.LogLevel.Info, msg, null, false], categories, false));
    };
    AbstractCategoryLogger.prototype.warn = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this._log.apply(this, __spreadArray([LoggerOptions_1.LogLevel.Warn, msg, null, false], categories, false));
    };
    AbstractCategoryLogger.prototype.error = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this._log.apply(this, __spreadArray([LoggerOptions_1.LogLevel.Error, msg, error, false], categories, false));
    };
    AbstractCategoryLogger.prototype.fatal = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this._log.apply(this, __spreadArray([LoggerOptions_1.LogLevel.Fatal, msg, error, false], categories, false));
    };
    AbstractCategoryLogger.prototype.resolved = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this._log.apply(this, __spreadArray([LoggerOptions_1.LogLevel.Error, msg, error, true], categories, false));
    };
    AbstractCategoryLogger.prototype.log = function (level, msg, error) {
        var categories = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            categories[_i - 3] = arguments[_i];
        }
        this._log.apply(this, __spreadArray([level, msg, error, false], categories, false));
    };
    AbstractCategoryLogger.prototype.getRootCategory = function () {
        return this.rootCategory;
    };
    AbstractCategoryLogger.prototype.createDefaultLogMessage = function (msg) {
        return MessageUtils_1.MessageFormatUtils.renderDefaultMessage(msg, true);
    };
    /**
     * Return optional message formatter. All LoggerTypes (except custom) will see if
     * they have this, and if so use it to log.
     * @returns {((message:CategoryLogMessage)=>string)|null}
     */
    AbstractCategoryLogger.prototype._getMessageFormatter = function () {
        var categorySettings = this.runtimeSettings.getCategorySettings(this.rootCategory);
        // Should not happen but make ts happy
        if (categorySettings === null) {
            throw new Error("Did not find CategorySettings for rootCategory: " + this.rootCategory.name);
        }
        return categorySettings.formatterLogMessage;
    };
    AbstractCategoryLogger.prototype._log = function (level, msg, error, resolved) {
        if (error === void 0) { error = null; }
        if (resolved === void 0) { resolved = false; }
        var categories = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            categories[_i - 4] = arguments[_i];
        }
        // this._logInternal(level, () => msg, () => error, resolved, ...categories);
        var functionMessage = function () {
            if (typeof msg === "function") {
                return msg();
            }
            return msg;
        };
        var functionError = function () {
            if (typeof error === "function") {
                return error();
            }
            return error;
        };
        this._logInternal.apply(this, __spreadArray([level, functionMessage, functionError, resolved], categories, false));
    };
    AbstractCategoryLogger.prototype._logInternal = function (level, msg, error, resolved) {
        var _this = this;
        var categories = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            categories[_i - 4] = arguments[_i];
        }
        var logCategories = [this.rootCategory];
        // Log root category by default if none present
        if (typeof categories !== "undefined" && categories.length > 0) {
            logCategories = logCategories.concat(categories.filter(function (c) { return c !== _this.rootCategory; }));
        }
        var _loop_1 = function (i) {
            var category = logCategories[i];
            if (category === null) {
                throw new Error("Cannot have a null element within categories, at index=" + i);
            }
            var settings = this_1.runtimeSettings.getCategorySettings(category);
            if (settings === null) {
                throw new Error("Category with path: " + category.getCategoryPath() + " is not registered with this logger, maybe " +
                    "you registered it with a different root logger?");
            }
            if (settings.logLevel <= level) {
                var actualError = error !== null ? error() : null;
                if (actualError === null) {
                    var logMessage = new CategoryLogMessageImpl(msg(), actualError, logCategories, new Date(), level, settings.logFormat, true);
                    logMessage.resolvedErrorMessage = resolved;
                    this_1.allMessages.addTail(logMessage);
                    this_1.processMessages();
                }
                else {
                    var logMessage_1 = new CategoryLogMessageImpl(msg(), actualError, logCategories, new Date(), level, settings.logFormat, false);
                    logMessage_1.resolvedErrorMessage = resolved;
                    this_1.allMessages.addTail(logMessage_1);
                    MessageUtils_1.MessageFormatUtils.renderError(actualError).then(function (stack) {
                        logMessage_1.errorAsStack = stack;
                        logMessage_1.setReady(true);
                        _this.processMessages();
                    }).catch(function () {
                        logMessage_1.errorAsStack = "<UNKNOWN> unable to get stack.";
                        logMessage_1.setReady(true);
                        _this.processMessages();
                    });
                }
                return "break";
            }
        };
        var this_1 = this;
        // Get the runtime levels for given categories. If their level is lower than given level, we log.
        // In addition we pass along which category/categories we log this statement for.
        for (var i = 0; i < logCategories.length; i++) {
            var state_1 = _loop_1(i);
            if (state_1 === "break")
                break;
        }
    };
    AbstractCategoryLogger.prototype.processMessages = function () {
        // Basically we wait until errors are resolved (those messages
        // may not be ready).
        var msgs = this.allMessages;
        if (msgs.getSize() > 0) {
            do {
                var msg = msgs.getHead();
                if (msg != null) {
                    if (!msg.isReady()) {
                        break;
                    }
                    msgs.removeHead();
                    this.doLog(msg);
                }
            } while (msgs.getSize() > 0);
        }
    };
    return AbstractCategoryLogger;
}());
exports.AbstractCategoryLogger = AbstractCategoryLogger;
//# sourceMappingURL=AbstractCategoryLogger.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/Category.js":
/*!********************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/Category.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Category = void 0;
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var CategoryService_1 = __webpack_require__(/*! ./CategoryService */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js");
/**
 * Category for use with categorized logging.
 * At minimum you need one category, which will serve as the root category.
 * You can create child categories (like a tree). You can have multiple root
 * categories.
 */
var Category = /** @class */ (function () {
    function Category(name, parent) {
        if (parent === void 0) { parent = null; }
        this._children = [];
        this._logLevel = LoggerOptions_1.LogLevel.Error;
        if (name.indexOf("#") !== -1) {
            throw new Error("Cannot use # in a name of a Category");
        }
        this._id = Category.nextId();
        this._name = name;
        this._parent = parent;
        if (this._parent !== null) {
            this._parent._children.push(this);
        }
        CategoryService_1.CategoryServiceImpl.getInstance().registerCategory(this);
    }
    Object.defineProperty(Category.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Category.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Category.prototype, "children", {
        get: function () {
            return this._children;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Category.prototype, "logLevel", {
        get: function () {
            return this._logLevel;
        },
        enumerable: false,
        configurable: true
    });
    Category.prototype.trace = function (msg) {
        var _a;
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).trace.apply(_a, __spreadArray([msg], categories, false));
    };
    Category.prototype.debug = function (msg) {
        var _a;
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).debug.apply(_a, __spreadArray([msg], categories, false));
    };
    Category.prototype.info = function (msg) {
        var _a;
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).info.apply(_a, __spreadArray([msg], categories, false));
    };
    Category.prototype.warn = function (msg) {
        var _a;
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).warn.apply(_a, __spreadArray([msg], categories, false));
    };
    Category.prototype.error = function (msg, error) {
        var _a;
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).error.apply(_a, __spreadArray([msg, error], categories, false));
    };
    Category.prototype.fatal = function (msg, error) {
        var _a;
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).fatal.apply(_a, __spreadArray([msg, error], categories, false));
    };
    Category.prototype.resolved = function (msg, error) {
        var _a;
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).resolved.apply(_a, __spreadArray([msg, error], categories, false));
    };
    Category.prototype.log = function (level, msg, error) {
        var _a;
        var categories = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            categories[_i - 3] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).log.apply(_a, __spreadArray([level, msg, error], categories, false));
    };
    Category.prototype.getCategoryPath = function () {
        var result = this.name;
        var cat = this.parent;
        while (cat != null) {
            result = cat.name + "#" + result;
            cat = cat.parent;
        }
        return result;
    };
    Object.defineProperty(Category.prototype, "id", {
        /**
         * Returns the id for this category (this
         * is for internal purposes only).
         * @returns {number} Id
         */
        get: function () {
            return this._id;
        },
        enumerable: false,
        configurable: true
    });
    Category.prototype.loadCategoryLogger = function () {
        if (!this._logger) {
            this._logger = CategoryService_1.CategoryServiceImpl.getInstance().getLogger(this);
        }
        if (typeof this._logger === "undefined" || this._logger === null) {
            throw new Error("Failed to load a logger for category (should not happen): " + this.name);
        }
    };
    Category.nextId = function () {
        return Category.currentId++;
    };
    Category.currentId = 1;
    return Category;
}());
exports.Category = Category;
//# sourceMappingURL=Category.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConfiguration.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConfiguration.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CategoryConfiguration = void 0;
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Default configuration, can be used to initially set a different default configuration
 * on the CategoryServiceFactory. This will be applied to all categories already registered (or
 * registered in the future). Can also be applied to one Category (and childs).
 */
var CategoryConfiguration = /** @class */ (function () {
    /**
     * Create a new instance
     * @param logLevel Log level for all loggers, default is LogLevel.Error
     * @param loggerType Where to log, default is LoggerType.Console
     * @param logFormat What logging format to use, use default instance, for default values see CategoryLogFormat.
     * @param callBackLogger Optional callback, if LoggerType.Custom is used as loggerType. In that case must return a new Logger instance.
     *            It is recommended to extend AbstractCategoryLogger to make your custom logger.
     */
    function CategoryConfiguration(logLevel, loggerType, logFormat, callBackLogger) {
        if (logLevel === void 0) { logLevel = LoggerOptions_1.LogLevel.Error; }
        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }
        if (logFormat === void 0) { logFormat = new LoggerOptions_1.CategoryLogFormat(); }
        if (callBackLogger === void 0) { callBackLogger = null; }
        this._formatterLogMessage = null;
        this._logLevel = logLevel;
        this._loggerType = loggerType;
        this._logFormat = logFormat;
        this._callBackLogger = callBackLogger;
        if (this._loggerType === LoggerOptions_1.LoggerType.Custom && this.callBackLogger === null) {
            throw new Error("If you specify loggerType to be Custom, you must provide the callBackLogger argument");
        }
    }
    Object.defineProperty(CategoryConfiguration.prototype, "logLevel", {
        get: function () {
            return this._logLevel;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryConfiguration.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryConfiguration.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryConfiguration.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryConfiguration.prototype, "formatterLogMessage", {
        /**
         * Get the formatterLogMessage function, see comment on the setter.
         * @returns {((message:CategoryLogMessage)=>string)|null}
         */
        get: function () {
            return this._formatterLogMessage;
        },
        /**
         * Set the default formatterLogMessage function, if set it is applied to all type of loggers except for a custom logger.
         * By default this is null (not set). You can assign a function to allow custom formatting of a log message.
         * Each log message will call this function then and expects your function to format the message and return a string.
         * Will throw an error if you attempt to set a formatterLogMessage if the LoggerType is custom.
         * @param value The formatter function, or null to reset it.
         */
        set: function (value) {
            if (value !== null && this._loggerType === LoggerOptions_1.LoggerType.Custom) {
                throw new Error("You cannot specify a formatter for log messages if your loggerType is Custom");
            }
            this._formatterLogMessage = value;
        },
        enumerable: false,
        configurable: true
    });
    CategoryConfiguration.prototype.copy = function () {
        var config = new CategoryConfiguration(this.logLevel, this.loggerType, this.logFormat.copy(), this.callBackLogger);
        config.formatterLogMessage = this.formatterLogMessage;
        return config;
    };
    return CategoryConfiguration;
}());
exports.CategoryConfiguration = CategoryConfiguration;
//# sourceMappingURL=CategoryConfiguration.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConsoleLoggerImpl.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConsoleLoggerImpl.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CategoryConsoleLoggerImpl = void 0;
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var AbstractCategoryLogger_1 = __webpack_require__(/*! ./AbstractCategoryLogger */ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js");
/**
 * Simple logger, that logs to the console. If the console is unavailable will throw an exception.
 */
var CategoryConsoleLoggerImpl = /** @class */ (function (_super) {
    __extends(CategoryConsoleLoggerImpl, _super);
    function CategoryConsoleLoggerImpl(rootCategory, runtimeSettings) {
        return _super.call(this, rootCategory, runtimeSettings) || this;
    }
    CategoryConsoleLoggerImpl.prototype.doLog = function (msg) {
        if (console !== undefined) {
            var messageFormatter = this._getMessageFormatter();
            var fullMsg = void 0;
            if (messageFormatter === null) {
                fullMsg = this.createDefaultLogMessage(msg);
            }
            else {
                fullMsg = messageFormatter(msg);
            }
            var logged = false;
            /* tslint:disable:no-console */
            switch (msg.level) {
                case LoggerOptions_1.LogLevel.Trace:
                    // Don't try trace we don't want stacks
                    break;
                case LoggerOptions_1.LogLevel.Debug:
                    // Don't try, too much differences of consoles.
                    break;
                case LoggerOptions_1.LogLevel.Info:
                    if (console.info) {
                        console.info(fullMsg);
                        logged = true;
                    }
                    break;
                case LoggerOptions_1.LogLevel.Warn:
                    if (console.warn) {
                        console.warn(fullMsg);
                        logged = true;
                    }
                    break;
                case LoggerOptions_1.LogLevel.Error:
                case LoggerOptions_1.LogLevel.Fatal:
                    if (console.error) {
                        console.error(fullMsg);
                        logged = true;
                    }
                    break;
                default:
                    throw new Error("Unsupported level: " + msg.level);
            }
            if (!logged) {
                console.log(fullMsg);
            }
            /* tslint:enable:no-console */
        }
        else {
            throw new Error("Console is not defined, cannot log msg: " + msg.messageAsString);
        }
    };
    return CategoryConsoleLoggerImpl;
}(AbstractCategoryLogger_1.AbstractCategoryLogger));
exports.CategoryConsoleLoggerImpl = CategoryConsoleLoggerImpl;
//# sourceMappingURL=CategoryConsoleLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryDelegateLoggerImpl.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryDelegateLoggerImpl.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CategoryDelegateLoggerImpl = void 0;
/**
 * Delegate logger, delegates logging to given logger (constructor).
 */
var CategoryDelegateLoggerImpl = /** @class */ (function () {
    function CategoryDelegateLoggerImpl(delegate) {
        this._delegate = delegate;
    }
    Object.defineProperty(CategoryDelegateLoggerImpl.prototype, "delegate", {
        get: function () {
            return this._delegate;
        },
        set: function (value) {
            this._delegate = value;
        },
        enumerable: false,
        configurable: true
    });
    CategoryDelegateLoggerImpl.prototype.trace = function (msg) {
        var _a;
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        (_a = this._delegate).trace.apply(_a, __spreadArray([msg], categories, false));
    };
    CategoryDelegateLoggerImpl.prototype.debug = function (msg) {
        var _a;
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        (_a = this._delegate).debug.apply(_a, __spreadArray([msg], categories, false));
    };
    CategoryDelegateLoggerImpl.prototype.info = function (msg) {
        var _a;
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        (_a = this._delegate).info.apply(_a, __spreadArray([msg], categories, false));
    };
    CategoryDelegateLoggerImpl.prototype.warn = function (msg) {
        var _a;
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        (_a = this._delegate).warn.apply(_a, __spreadArray([msg], categories, false));
    };
    CategoryDelegateLoggerImpl.prototype.error = function (msg, error) {
        var _a;
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        (_a = this._delegate).error.apply(_a, __spreadArray([msg, error], categories, false));
    };
    CategoryDelegateLoggerImpl.prototype.fatal = function (msg, error) {
        var _a;
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        (_a = this._delegate).fatal.apply(_a, __spreadArray([msg, error], categories, false));
    };
    CategoryDelegateLoggerImpl.prototype.resolved = function (msg, error) {
        var _a;
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        (_a = this._delegate).resolved.apply(_a, __spreadArray([msg, error], categories, false));
    };
    CategoryDelegateLoggerImpl.prototype.log = function (level, msg, error) {
        var _a;
        var categories = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            categories[_i - 3] = arguments[_i];
        }
        (_a = this._delegate).log.apply(_a, __spreadArray([level, msg, error], categories, false));
    };
    return CategoryDelegateLoggerImpl;
}());
exports.CategoryDelegateLoggerImpl = CategoryDelegateLoggerImpl;
//# sourceMappingURL=CategoryDelegateLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryExtensionLoggerImpl.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryExtensionLoggerImpl.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CategoryExtensionLoggerImpl = void 0;
var ExtensionHelper_1 = __webpack_require__(/*! ../../extension/ExtensionHelper */ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js");
var AbstractCategoryLogger_1 = __webpack_require__(/*! ./AbstractCategoryLogger */ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js");
/**
 * This class should not be used directly, it is used for communication with the extension only.
 */
var CategoryExtensionLoggerImpl = /** @class */ (function (_super) {
    __extends(CategoryExtensionLoggerImpl, _super);
    function CategoryExtensionLoggerImpl(rootCategory, runtimeSettings) {
        return _super.call(this, rootCategory, runtimeSettings) || this;
    }
    CategoryExtensionLoggerImpl.prototype.doLog = function (msg) {
        if (typeof window !== "undefined") {
            ExtensionHelper_1.ExtensionHelper.sendCategoryLogMessage(msg);
        }
        else {
            /* tslint:disable:no-console */
            console.log("window is not available, you must be running in a browser for this. Dropped message.");
            /* tslint:enable:no-console */
        }
    };
    return CategoryExtensionLoggerImpl;
}(AbstractCategoryLogger_1.AbstractCategoryLogger));
exports.CategoryExtensionLoggerImpl = CategoryExtensionLoggerImpl;
//# sourceMappingURL=CategoryExtensionLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryMessageBufferImpl.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryMessageBufferImpl.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CategoryMessageBufferLoggerImpl = void 0;
var AbstractCategoryLogger_1 = __webpack_require__(/*! ./AbstractCategoryLogger */ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js");
/**
 * Logger which buffers all messages, use with care due to possible high memory footprint.
 * Can be convenient in some cases. Call toString() for full output, or cast to this class
 * and call getMessages() to do something with it yourself.
 */
var CategoryMessageBufferLoggerImpl = /** @class */ (function (_super) {
    __extends(CategoryMessageBufferLoggerImpl, _super);
    function CategoryMessageBufferLoggerImpl() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.messages = [];
        return _this;
    }
    CategoryMessageBufferLoggerImpl.prototype.getMessages = function () {
        return this.messages;
    };
    CategoryMessageBufferLoggerImpl.prototype.toString = function () {
        return this.messages.map(function (msg) {
            return msg;
        }).join("\n");
    };
    CategoryMessageBufferLoggerImpl.prototype.doLog = function (msg) {
        var messageFormatter = this._getMessageFormatter();
        var fullMsg;
        if (messageFormatter === null) {
            fullMsg = this.createDefaultLogMessage(msg);
        }
        else {
            fullMsg = messageFormatter(msg);
        }
        this.messages.push(fullMsg);
    };
    return CategoryMessageBufferLoggerImpl;
}(AbstractCategoryLogger_1.AbstractCategoryLogger));
exports.CategoryMessageBufferLoggerImpl = CategoryMessageBufferLoggerImpl;
//# sourceMappingURL=CategoryMessageBufferImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryRuntimeSettings.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryRuntimeSettings.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CategoryRuntimeSettings = void 0;
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * RuntimeSettings for a category, at runtime these are associated to a category.
 */
var CategoryRuntimeSettings = /** @class */ (function () {
    function CategoryRuntimeSettings(category, logLevel, loggerType, logFormat, callBackLogger, formatterLogMessage) {
        if (logLevel === void 0) { logLevel = LoggerOptions_1.LogLevel.Error; }
        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }
        if (logFormat === void 0) { logFormat = new LoggerOptions_1.CategoryLogFormat(); }
        if (callBackLogger === void 0) { callBackLogger = null; }
        if (formatterLogMessage === void 0) { formatterLogMessage = null; }
        this._formatterLogMessage = null;
        this._category = category;
        this._logLevel = logLevel;
        this._loggerType = loggerType;
        this._logFormat = logFormat;
        this._callBackLogger = callBackLogger;
        this._formatterLogMessage = formatterLogMessage;
    }
    Object.defineProperty(CategoryRuntimeSettings.prototype, "category", {
        get: function () {
            return this._category;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "logLevel", {
        get: function () {
            return this._logLevel;
        },
        set: function (value) {
            this._logLevel = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        set: function (value) {
            this._loggerType = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        set: function (value) {
            this._logFormat = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        set: function (value) {
            this._callBackLogger = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "formatterLogMessage", {
        get: function () {
            return this._formatterLogMessage;
        },
        set: function (value) {
            this._formatterLogMessage = value;
        },
        enumerable: false,
        configurable: true
    });
    return CategoryRuntimeSettings;
}());
exports.CategoryRuntimeSettings = CategoryRuntimeSettings;
//# sourceMappingURL=CategoryRuntimeSettings.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CategoryServiceImpl = void 0;
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var CategoryConsoleLoggerImpl_1 = __webpack_require__(/*! ./CategoryConsoleLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConsoleLoggerImpl.js");
var CategoryDelegateLoggerImpl_1 = __webpack_require__(/*! ./CategoryDelegateLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryDelegateLoggerImpl.js");
var CategoryExtensionLoggerImpl_1 = __webpack_require__(/*! ./CategoryExtensionLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryExtensionLoggerImpl.js");
var CategoryMessageBufferImpl_1 = __webpack_require__(/*! ./CategoryMessageBufferImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryMessageBufferImpl.js");
var ExtensionHelper_1 = __webpack_require__(/*! ../../extension/ExtensionHelper */ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js");
var CategoryRuntimeSettings_1 = __webpack_require__(/*! ./CategoryRuntimeSettings */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryRuntimeSettings.js");
var CategoryConfiguration_1 = __webpack_require__(/*! ./CategoryConfiguration */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConfiguration.js");
/**
 * The service (only available as singleton) for all category related stuff as
 * retrieving, registering a logger. You should normally NOT use this,
 * instead use CategoryServiceFactory which is meant for end users.
 */
var CategoryServiceImpl = /** @class */ (function () {
    function CategoryServiceImpl() {
        this._defaultConfig = new CategoryConfiguration_1.CategoryConfiguration();
        this._mapState = new DataStructures_1.SimpleMap();
        // Private constructor
        ExtensionHelper_1.ExtensionHelper.register();
    }
    CategoryServiceImpl.getInstance = function () {
        // Load on-demand, to assure webpack ordering of module usage doesn't screw things over
        // for us when we accidentally change the order.
        if (CategoryServiceImpl._INSTANCE === null) {
            CategoryServiceImpl._INSTANCE = new CategoryServiceImpl();
        }
        return CategoryServiceImpl._INSTANCE;
    };
    CategoryServiceImpl.prototype.getLogger = function (category) {
        return this.createOrGetCategoryState(category).logger;
    };
    /**
     * Clears everything, including a default configuration you may have set.
     * After this you need to re-register your categories etc.
     */
    CategoryServiceImpl.prototype.clear = function () {
        this._mapState.clear();
        this.setDefaultConfiguration(new CategoryConfiguration_1.CategoryConfiguration());
    };
    CategoryServiceImpl.prototype.getCategorySettings = function (category) {
        return this.createOrGetCategoryState(category).currentRuntimeSettings;
    };
    CategoryServiceImpl.prototype.getOriginalCategorySettings = function (category) {
        return this.createOrGetCategoryState(category).originalRuntimeSettings;
    };
    /**
     * Set the default configuration. New root loggers created get this
     * applied. If you want to reset all current loggers to have this
     * applied as well, pass in reset=true (the default is false). All
     * categories will be reset then as well.
     * @param config New config
     * @param reset Defaults to true. Set to true to reset all loggers and current runtimesettings.
     */
    CategoryServiceImpl.prototype.setDefaultConfiguration = function (config, reset) {
        if (reset === void 0) { reset = true; }
        this._defaultConfig = config;
        if (reset) {
            this._mapState.forEachValue(function (state) {
                state.updateSettings(config);
            });
        }
    };
    /**
     * Set new configuration settings for a category (and possibly its child categories)
     * @param config Config
     * @param category Category
     * @param applyChildren True to apply to child categories, defaults to false.
     */
    CategoryServiceImpl.prototype.setConfigurationCategory = function (config, category, applyChildren) {
        var _this = this;
        if (applyChildren === void 0) { applyChildren = false; }
        this.createOrGetCategoryState(category).updateSettings(config);
        // Apply the settings to children recursive if requested
        if (applyChildren) {
            category.children.forEach(function (child) {
                // False flag, a child cannot reset a rootlogger
                _this.setConfigurationCategory(config, child, applyChildren);
            });
        }
    };
    CategoryServiceImpl.prototype.registerCategory = function (category) {
        if (category === null || typeof category === "undefined") {
            throw new Error("Category CANNOT be null/undefined");
        }
        if (this._mapState.exists(CategoryServiceImpl.getCategoryKey(category))) {
            throw new Error("Cannot add this root category with name: " + category.name + ", it already exists (same name in hierarchy).");
        }
        this.createOrGetCategoryState(category);
    };
    /**
     * Used to enable integration with chrome extension. Do not use manually, the
     * extension and the logger framework deal with this.
     */
    CategoryServiceImpl.prototype.enableExtensionIntegration = function () {
        var _this = this;
        this._mapState.forEachValue(function (state) { return state.enableForExtension(_this); });
    };
    /**
     * Return all root categories currently registered.
     */
    CategoryServiceImpl.prototype.getRootCategories = function () {
        return this._mapState.values().filter(function (state) { return state.category.parent == null; }).map(function (state) { return state.category; });
    };
    /**
     * Return Category by id
     * @param id The id of the category to find
     * @returns {Category} or null if not found
     */
    CategoryServiceImpl.prototype.getCategoryById = function (id) {
        var result = this._mapState.values().filter(function (state) { return state.category.id === id; }).map(function (state) { return state.category; });
        if (result.length === 1) {
            return result[0];
        }
        return null;
    };
    CategoryServiceImpl.prototype.createOrGetCategoryState = function (category) {
        var key = CategoryServiceImpl.getCategoryKey(category);
        var state = this._mapState.get(key);
        if (typeof state !== "undefined") {
            return state;
        }
        var newState = this.createState(category);
        this._mapState.put(key, newState);
        return newState;
    };
    CategoryServiceImpl.prototype.createState = function (category) {
        var _this = this;
        return new CategoryState(category, function () { return _this._defaultConfig; }, function (config, cat) { return _this.createLogger(config, cat); });
    };
    CategoryServiceImpl.prototype.createLogger = function (config, category) {
        // Default is always a console logger
        switch (config.loggerType) {
            case LoggerOptions_1.LoggerType.Console:
                return new CategoryConsoleLoggerImpl_1.CategoryConsoleLoggerImpl(category, this);
            case LoggerOptions_1.LoggerType.MessageBuffer:
                return new CategoryMessageBufferImpl_1.CategoryMessageBufferLoggerImpl(category, this);
            case LoggerOptions_1.LoggerType.Custom:
                if (config.callBackLogger === null) {
                    throw new Error("Cannot create custom logger, custom callback is null");
                }
                else {
                    return config.callBackLogger(category, this);
                }
            default:
                throw new Error("Cannot create a Logger for LoggerType: " + config.loggerType);
        }
    };
    CategoryServiceImpl.getCategoryKey = function (category) {
        return category.getCategoryPath();
    };
    // Singleton category service, used by CategoryServiceFactory as well as Categories.
    // Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.
    CategoryServiceImpl._INSTANCE = null;
    return CategoryServiceImpl;
}());
exports.CategoryServiceImpl = CategoryServiceImpl;
var CategoryState = /** @class */ (function () {
    function CategoryState(category, defaultConfig, createLogger) {
        this._category = category;
        this._lazyState = new LazyState(category, defaultConfig, createLogger);
    }
    Object.defineProperty(CategoryState.prototype, "category", {
        get: function () {
            return this._category;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryState.prototype, "logger", {
        get: function () {
            return this._lazyState.getLogger();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryState.prototype, "originalRuntimeSettings", {
        get: function () {
            return this._lazyState.getOriginalRuntimeSettings();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryState.prototype, "currentRuntimeSettings", {
        get: function () {
            return this._lazyState.getCurrentRuntimeSettings();
        },
        enumerable: false,
        configurable: true
    });
    CategoryState.prototype.enableForExtension = function (runtimeSettings) {
        this._lazyState.enableForExtension(runtimeSettings);
    };
    CategoryState.prototype.updateSettings = function (config) {
        this._lazyState.updateSettings(config);
    };
    return CategoryState;
}());
var LazyState = /** @class */ (function () {
    function LazyState(category, defaultConfig, createLogger) {
        this._category = category;
        this._defaultConfig = defaultConfig;
        this._createLogger = createLogger;
    }
    LazyState.prototype.isLoaded = function () {
        return (typeof this._logger !== "undefined");
    };
    LazyState.prototype.getLogger = function () {
        this.loadLoggerOnDemand();
        return this._delegateLogger;
    };
    LazyState.prototype.getOriginalRuntimeSettings = function () {
        this.loadLoggerOnDemand();
        return this._originalRuntimeSettings;
    };
    LazyState.prototype.getCurrentRuntimeSettings = function () {
        this.loadLoggerOnDemand();
        return this._currentRuntimeSettings;
    };
    LazyState.prototype.enableForExtension = function (runtimeSettings) {
        this.loadLoggerOnDemand();
        if (!(this._wrappedLogger instanceof CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl)) {
            /* tslint:disable no-console */
            console.log("Reconfiguring logger for extension for category: " + this._category.name);
            /* tslint:enable no-console */
            this._wrappedLogger = new CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl(this._category, runtimeSettings);
            this._delegateLogger.delegate = this._wrappedLogger;
        }
    };
    LazyState.prototype.updateSettings = function (config) {
        if (this.isLoaded()) {
            this._currentRuntimeSettings.logLevel = config.logLevel;
            this._currentRuntimeSettings.loggerType = config.loggerType;
            this._currentRuntimeSettings.logFormat = config.logFormat;
            this._currentRuntimeSettings.callBackLogger = config.callBackLogger;
            this._currentRuntimeSettings.formatterLogMessage = config.formatterLogMessage;
            // Replace the real logger, it may have changed.
            this._logger = this._createLogger(config, this._category);
            if (!(this._wrappedLogger instanceof CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl)) {
                this._wrappedLogger = this._logger;
            }
            this._delegateLogger.delegate = this._wrappedLogger;
        }
        else {
            // Set this config, it may be for the category specific, the default is therefore not good enough.
            this._defaultConfig = function () { return config; };
        }
    };
    LazyState.prototype.loadLoggerOnDemand = function () {
        if (!this.isLoaded()) {
            this._logger = this._createLogger(this._defaultConfig(), this._category);
            this._wrappedLogger = this._logger;
            this._delegateLogger = new CategoryDelegateLoggerImpl_1.CategoryDelegateLoggerImpl(this._wrappedLogger);
            this._originalRuntimeSettings = this.initNewSettings();
            this._currentRuntimeSettings = this.initNewSettings();
        }
    };
    LazyState.prototype.initNewSettings = function () {
        var defSettings = this._defaultConfig().copy();
        return new CategoryRuntimeSettings_1.CategoryRuntimeSettings(this._category, defSettings.logLevel, defSettings.loggerType, defSettings.logFormat, defSettings.callBackLogger, defSettings.formatterLogMessage);
    };
    return LazyState;
}());
//# sourceMappingURL=CategoryService.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryServiceFactory.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryServiceFactory.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CategoryServiceFactory = void 0;
var CategoryService_1 = __webpack_require__(/*! ./CategoryService */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js");
/**
 * Categorized service for logging, where logging is bound to categories which
 * can log horizontally through specific application logic (services, group(s) of components etc).
 * For the standard way of logging like most frameworks do these days, use LFService instead.
 * If you want fine grained control to divide sections of your application in
 * logical units to enable/disable logging for, this is the service you want to use instead.
 * Also for this type a browser plugin will be available.
 */
var CategoryServiceFactory = /** @class */ (function () {
    function CategoryServiceFactory() {
        // Private constructor.
    }
    /**
     * Return a CategoryLogger for given ROOT category (thus has no parent).
     * You can only retrieve loggers for their root, when logging
     * you specify to log for what (child)categories.
     * @param root Category root (has no parent)
     * @returns {CategoryLogger}
     */
    CategoryServiceFactory.getLogger = function (root) {
        return CategoryService_1.CategoryServiceImpl.getInstance().getLogger(root);
    };
    /**
     * Clears everything, any registered (root)categories and loggers
     * are discarded. Resets to default configuration.
     */
    CategoryServiceFactory.clear = function () {
        return CategoryService_1.CategoryServiceImpl.getInstance().clear();
    };
    /**
     * Set the default configuration. New root loggers created get this
     * applied. If you want to reset all current loggers to have this
     * applied as well, pass in reset=true (the default is false). All
     * categories runtimesettings will be reset then as well.
     * @param config The new default configuration
     * @param reset If true, will reset *all* runtimesettings for all loggers/categories to these. Default is true.
     */
    CategoryServiceFactory.setDefaultConfiguration = function (config, reset) {
        if (reset === void 0) { reset = true; }
        CategoryService_1.CategoryServiceImpl.getInstance().setDefaultConfiguration(config, reset);
    };
    /**
     * Set new configuration settings for a category (and possibly its child categories)
     * @param config Config
     * @param category Category
     * @param applyChildren True to apply to child categories, defaults to false.
     */
    CategoryServiceFactory.setConfigurationCategory = function (config, category, applyChildren) {
        if (applyChildren === void 0) { applyChildren = false; }
        CategoryService_1.CategoryServiceImpl.getInstance().setConfigurationCategory(config, category, applyChildren);
    };
    return CategoryServiceFactory;
}());
exports.CategoryServiceFactory = CategoryServiceFactory;
//# sourceMappingURL=CategoryServiceFactory.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractLogger = void 0;
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var MessageUtils_1 = __webpack_require__(/*! ../../utils/MessageUtils */ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js");
var LogMessageInternalImpl = /** @class */ (function () {
    function LogMessageInternalImpl(loggerName, message, errorAsStack, error, logGroupRule, date, level, ready) {
        this._errorAsStack = null;
        this._error = null;
        this._loggerName = loggerName;
        this._message = message;
        this._errorAsStack = errorAsStack;
        this._error = error;
        this._logGroupRule = logGroupRule;
        this._date = date;
        this._level = level;
        this._ready = ready;
    }
    Object.defineProperty(LogMessageInternalImpl.prototype, "loggerName", {
        get: function () {
            return this._loggerName;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "message", {
        get: function () {
            return this._message;
        },
        set: function (value) {
            this._message = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "errorAsStack", {
        get: function () {
            return this._errorAsStack;
        },
        set: function (value) {
            this._errorAsStack = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "error", {
        get: function () {
            return this._error;
        },
        set: function (value) {
            this._error = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "logGroupRule", {
        get: function () {
            return this._logGroupRule;
        },
        set: function (value) {
            this._logGroupRule = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "date", {
        get: function () {
            return this._date;
        },
        set: function (value) {
            this._date = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "level", {
        get: function () {
            return this._level;
        },
        set: function (value) {
            this._level = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "isMessageLogData", {
        get: function () {
            return typeof (this._message) !== "string";
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "ready", {
        get: function () {
            return this._ready;
        },
        set: function (value) {
            this._ready = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "messageAsString", {
        get: function () {
            if (typeof (this._message) === "string") {
                return this._message;
            }
            return this._message.msg;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "logData", {
        get: function () {
            var result = null;
            if (typeof (this._message) !== "string") {
                result = this.message;
            }
            return result;
        },
        enumerable: false,
        configurable: true
    });
    return LogMessageInternalImpl;
}());
/**
 * Abstract base logger, extend to easily implement a custom logger that
 * logs wherever you want. You only need to implement doLog(msg: LogMessage) and
 * log that somewhere (it will contain format and everything else).
 */
var AbstractLogger = /** @class */ (function () {
    function AbstractLogger(name, logGroupRuntimeSettings) {
        this._allMessages = new DataStructures_1.LinkedList();
        this._open = true;
        this._name = name;
        this._logGroupRuntimeSettings = logGroupRuntimeSettings;
    }
    Object.defineProperty(AbstractLogger.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    AbstractLogger.prototype.trace = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Trace, msg, error);
    };
    AbstractLogger.prototype.debug = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Debug, msg, error);
    };
    AbstractLogger.prototype.info = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Info, msg, error);
    };
    AbstractLogger.prototype.warn = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Warn, msg, error);
    };
    AbstractLogger.prototype.error = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Error, msg, error);
    };
    AbstractLogger.prototype.fatal = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Fatal, msg, error);
    };
    AbstractLogger.prototype.isTraceEnabled = function () {
        return this._logGroupRuntimeSettings.level === LoggerOptions_1.LogLevel.Trace;
    };
    AbstractLogger.prototype.isDebugEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Debug;
    };
    AbstractLogger.prototype.isInfoEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Info;
    };
    AbstractLogger.prototype.isWarnEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Warn;
    };
    AbstractLogger.prototype.isErrorEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Error;
    };
    AbstractLogger.prototype.isFatalEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Fatal;
    };
    AbstractLogger.prototype.getLogLevel = function () {
        return this._logGroupRuntimeSettings.level;
    };
    AbstractLogger.prototype.isOpen = function () {
        return this._open;
    };
    AbstractLogger.prototype.close = function () {
        this._open = false;
        this._allMessages.clear();
    };
    AbstractLogger.prototype.createDefaultLogMessage = function (msg) {
        return MessageUtils_1.MessageFormatUtils.renderDefaultLog4jMessage(msg, true);
    };
    /**
     * Return optional message formatter. All LoggerTypes (except custom) will see if
     * they have this, and if so use it to log.
     * @returns {((message:LogMessage)=>string)|null}
     */
    AbstractLogger.prototype._getMessageFormatter = function () {
        return this._logGroupRuntimeSettings.formatterLogMessage;
    };
    AbstractLogger.prototype._log = function (level, msg, error) {
        if (error === void 0) { error = null; }
        if (this._open && this._logGroupRuntimeSettings.level <= level) {
            var functionMessage = function () {
                if (typeof msg === "function") {
                    return msg();
                }
                return msg;
            };
            var functionError = function () {
                if (typeof error === "function") {
                    return error();
                }
                return error;
            };
            this._allMessages.addTail(this.createMessage(level, functionMessage, functionError, new Date()));
            this.processMessages();
        }
    };
    AbstractLogger.prototype.createMessage = function (level, msg, error, date) {
        var _this = this;
        var errorResult = error();
        if (errorResult !== null) {
            var message_1 = new LogMessageInternalImpl(this._name, msg(), null, errorResult, this._logGroupRuntimeSettings.logGroupRule, date, level, false);
            MessageUtils_1.MessageFormatUtils.renderError(errorResult).then(function (stack) {
                message_1.errorAsStack = stack;
                message_1.ready = true;
                _this.processMessages();
            }).catch(function () {
                message_1.errorAsStack = "<UNKNOWN> unable to get stack.";
                message_1.ready = true;
                _this.processMessages();
            });
            return message_1;
        }
        return new LogMessageInternalImpl(this._name, msg(), null, errorResult, this._logGroupRuntimeSettings.logGroupRule, date, level, true);
    };
    AbstractLogger.prototype.processMessages = function () {
        // Basically we wait until errors are resolved (those messages
        // may not be ready).
        var msgs = this._allMessages;
        if (msgs.getSize() > 0) {
            do {
                var msg = msgs.getHead();
                if (msg != null) {
                    if (!msg.ready) {
                        break;
                    }
                    msgs.removeHead();
                    // This can never be null normally, but strict null checking ...
                    if (msg.message !== null) {
                        this.doLog(msg);
                    }
                }
            } while (msgs.getSize() > 0);
        }
    };
    return AbstractLogger;
}());
exports.AbstractLogger = AbstractLogger;
//# sourceMappingURL=AbstractLogger.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/ConsoleLoggerImpl.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/ConsoleLoggerImpl.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleLoggerImpl = void 0;
var AbstractLogger_1 = __webpack_require__(/*! ./AbstractLogger */ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Simple logger, that logs to the console. If the console is unavailable will throw exception.
 */
var ConsoleLoggerImpl = /** @class */ (function (_super) {
    __extends(ConsoleLoggerImpl, _super);
    function ConsoleLoggerImpl(name, logGroupRuntimeSettings) {
        return _super.call(this, name, logGroupRuntimeSettings) || this;
    }
    ConsoleLoggerImpl.prototype.doLog = function (message) {
        if (console !== undefined) {
            var logged = false;
            var logLevel = message.level;
            var messageFormatter = this._getMessageFormatter();
            var msg = void 0;
            if (messageFormatter === null) {
                msg = this.createDefaultLogMessage(message);
            }
            else {
                msg = messageFormatter(message);
            }
            /* tslint:disable:no-console */
            switch (logLevel) {
                case LoggerOptions_1.LogLevel.Trace:
                    // Do not try trace we don't want a stack
                    break;
                case LoggerOptions_1.LogLevel.Debug:
                    // Don't try, too much differences of consoles.
                    break;
                case LoggerOptions_1.LogLevel.Info:
                    if (console.info) {
                        console.info(msg);
                        logged = true;
                    }
                    break;
                case LoggerOptions_1.LogLevel.Warn:
                    if (console.warn) {
                        console.warn(msg);
                        logged = true;
                    }
                    break;
                case LoggerOptions_1.LogLevel.Error:
                case LoggerOptions_1.LogLevel.Fatal:
                    if (console.error) {
                        console.error(msg);
                        logged = true;
                    }
                    break;
                default:
                    throw new Error("Log level not supported: " + logLevel);
            }
            if (!logged) {
                console.log(msg);
            }
            /* tslint:enable:no-console */
        }
        else {
            throw new Error("Console is not defined, cannot log msg: " + message.message);
        }
    };
    return ConsoleLoggerImpl;
}(AbstractLogger_1.AbstractLogger));
exports.ConsoleLoggerImpl = ConsoleLoggerImpl;
//# sourceMappingURL=ConsoleLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LFService.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LFService.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LFService = void 0;
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var LoggerFactoryImpl_1 = __webpack_require__(/*! ./LoggerFactoryImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryImpl.js");
var ExtensionHelper_1 = __webpack_require__(/*! ../../extension/ExtensionHelper */ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js");
var LogGroupRule_1 = __webpack_require__(/*! ./LogGroupRule */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRule.js");
var LoggerFactoryOptions_1 = __webpack_require__(/*! ./LoggerFactoryOptions */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryOptions.js");
var LFServiceImpl = /** @class */ (function () {
    function LFServiceImpl() {
        // Private constructor.
        this._nameCounter = 1;
        this._mapFactories = new DataStructures_1.SimpleMap();
        ExtensionHelper_1.ExtensionHelper.register();
    }
    LFServiceImpl.getInstance = function () {
        // Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.
        if (LFServiceImpl._INSTANCE === null) {
            LFServiceImpl._INSTANCE = new LFServiceImpl();
        }
        return LFServiceImpl._INSTANCE;
    };
    /**
     * Create a new LoggerFactory with given options (if any). If no options
     * are specified, the LoggerFactory, will accept any named logger and will
     * log on info level by default for, to the console.
     * @param options Options, optional.
     * @returns {LoggerFactory}
     */
    LFServiceImpl.prototype.createLoggerFactory = function (options) {
        if (options === void 0) { options = null; }
        var name = "LoggerFactory" + this._nameCounter++;
        return this.createNamedLoggerFactory(name, options);
    };
    /**
     * Create a new LoggerFactory using given name (used for console api/extension).
     * @param name Name Pick something short but distinguishable.
     * @param options Options, optional
     * @return {LoggerFactory}
     */
    LFServiceImpl.prototype.createNamedLoggerFactory = function (name, options) {
        if (options === void 0) { options = null; }
        if (this._mapFactories.exists(name)) {
            throw new Error("LoggerFactory with name " + name + " already exists.");
        }
        var factory;
        if (options !== null) {
            factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(name, options);
        }
        else {
            factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(name, LFServiceImpl.createDefaultOptions());
        }
        this._mapFactories.put(name, factory);
        return factory;
    };
    /**
     * Closes all Loggers for LoggerFactories that were created.
     * After this call, all previously fetched Loggers (from their
     * factories) are unusable. The factories remain as they were.
     */
    LFServiceImpl.prototype.closeLoggers = function () {
        this._mapFactories.values().forEach(function (factory) {
            factory.closeLoggers();
        });
        this._mapFactories.clear();
        this._nameCounter = 1;
    };
    LFServiceImpl.prototype.getRuntimeSettingsForLoggerFactories = function () {
        var result = [];
        this._mapFactories.forEachValue(function (factory) { return result.push(factory); });
        return result;
    };
    LFServiceImpl.prototype.getLogGroupSettings = function (nameLoggerFactory, idLogGroupRule) {
        var factory = this._mapFactories.get(nameLoggerFactory);
        if (typeof factory === "undefined") {
            return null;
        }
        return factory.getLogGroupRuntimeSettingsByIndex(idLogGroupRule);
    };
    LFServiceImpl.prototype.getLoggerFactoryRuntimeSettingsByName = function (nameLoggerFactory) {
        var result = this._mapFactories.get(nameLoggerFactory);
        if (typeof result === "undefined") {
            return null;
        }
        return result;
    };
    LFServiceImpl.createDefaultOptions = function () {
        return new LoggerFactoryOptions_1.LoggerFactoryOptions().addLogGroupRule(new LogGroupRule_1.LogGroupRule(new RegExp(".+"), LoggerOptions_1.LogLevel.Info));
    };
    // Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.
    LFServiceImpl._INSTANCE = null;
    return LFServiceImpl;
}());
/**
 * Create and configure your LoggerFactory from here.
 */
var LFService = /** @class */ (function () {
    function LFService() {
    }
    /**
     * Create a new LoggerFactory with given options (if any). If no options
     * are specified, the LoggerFactory, will accept any named logger and will
     * log on info level by default for, to the console.
     * @param options Options, optional.
     * @returns {LoggerFactory}
     */
    LFService.createLoggerFactory = function (options) {
        if (options === void 0) { options = null; }
        return LFService.INSTANCE_SERVICE.createLoggerFactory(options);
    };
    /**
     * Create a new LoggerFactory using given name (used for console api/extension).
     * @param name Name Pick something short but distinguishable. The word "DEFAULT" is reserved and cannot be taken, it is used
     * for the default LoggerFactory.
     * @param options Options, optional
     * @return {LoggerFactory}
     */
    LFService.createNamedLoggerFactory = function (name, options) {
        if (options === void 0) { options = null; }
        if (name === LFService.DEFAULT_LOGGER_FACTORY_NAME) {
            throw new Error("LoggerFactory name: " + LFService.DEFAULT_LOGGER_FACTORY_NAME + " is reserved and cannot be used.");
        }
        return LFService.INSTANCE_SERVICE.createNamedLoggerFactory(name, options);
    };
    /**
     * Closes all Loggers for LoggerFactories that were created.
     * After this call, all previously fetched Loggers (from their
     * factories) are unusable. The factories remain as they were.
     */
    LFService.closeLoggers = function () {
        return LFService.INSTANCE_SERVICE.closeLoggers();
    };
    /**
     * Return LFServiceRuntimeSettings to retrieve information loggerfactories
     * and their runtime settings.
     * @returns {LFServiceRuntimeSettings}
     */
    LFService.getRuntimeSettings = function () {
        return LFService.INSTANCE_SERVICE;
    };
    Object.defineProperty(LFService, "DEFAULT", {
        /**
         * This property returns the default LoggerFactory (if not yet initialized it is initialized).
         * This LoggerFactory can be used to share among multiple
         * applications/libraries - that way you can enable/change logging over everything from
         * your own application when required.
         * It is recommended to be used by library developers to make logging easily available for the
         * consumers of their libraries.
         * It is highly recommended to use Loggers from the LoggerFactory with unique grouping/names to prevent
         * clashes of Loggers between multiple projects.
         * @returns {LoggerFactory} Returns the default LoggerFactory
         */
        get: function () {
            return LFService.getDefault();
        },
        enumerable: false,
        configurable: true
    });
    LFService.getDefault = function () {
        if (LFService.DEFAULT_LOGGER_FACTORY === null) {
            LFService.DEFAULT_LOGGER_FACTORY = LFService.DEFAULT_LOGGER_FACTORY = LFService.INSTANCE_SERVICE.createNamedLoggerFactory(LFService.DEFAULT_LOGGER_FACTORY_NAME, new LoggerFactoryOptions_1.LoggerFactoryOptions().addLogGroupRule(new LogGroupRule_1.LogGroupRule(new RegExp(".+"), LoggerOptions_1.LogLevel.Error)));
        }
        return LFService.DEFAULT_LOGGER_FACTORY;
    };
    LFService.DEFAULT_LOGGER_FACTORY_NAME = "DEFAULT";
    LFService.INSTANCE_SERVICE = LFServiceImpl.getInstance();
    LFService.DEFAULT_LOGGER_FACTORY = null;
    return LFService;
}());
exports.LFService = LFService;
//# sourceMappingURL=LFService.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRule.js":
/*!************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRule.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogGroupRule = void 0;
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Defines a LogGroupRule, this allows you to either have everything configured the same way
 * or for example loggers that start with name model. It allows you to group loggers together
 * to have a certain loglevel and other settings. You can configure this when creating the
 * LoggerFactory (which accepts multiple LogGroupRules).
 */
var LogGroupRule = /** @class */ (function () {
    /**
     * Create a LogGroupRule. Basically you define what logger name(s) match for this group, what level should be used what logger type (where to log)
     * and what format to write in. If the loggerType is custom, then the callBackLogger must be supplied as callback function to return a custom logger.
     * @param regExp Regular expression, what matches for your logger names for this group
     * @param level LogLevel
     * @param logFormat LogFormat
     * @param loggerType Type of logger, if Custom, make sure to implement callBackLogger and pass in, this will be called so you can return your own logger.
     * @param callBackLogger Callback function to return a new clean custom logger (yours!)
     */
    function LogGroupRule(regExp, level, logFormat, loggerType, callBackLogger) {
        if (logFormat === void 0) { logFormat = new LoggerOptions_1.LogFormat(); }
        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }
        if (callBackLogger === void 0) { callBackLogger = null; }
        this._formatterLogMessage = null;
        this._regExp = regExp;
        this._level = level;
        this._logFormat = logFormat;
        this._loggerType = loggerType;
        this._callBackLogger = callBackLogger;
    }
    Object.defineProperty(LogGroupRule.prototype, "regExp", {
        get: function () {
            return this._regExp;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "level", {
        get: function () {
            return this._level;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "formatterLogMessage", {
        /**
         * Get the formatterLogMessage function, see comment on the setter.
         * @returns {((message:LogMessage)=>string)|null}
         */
        get: function () {
            return this._formatterLogMessage;
        },
        /**
         * Set the default formatterLogMessage function, if set it is applied to all type of loggers except for a custom logger.
         * By default this is null (not set). You can assign a function to allow custom formatting of a log message.
         * Each log message will call this function then and expects your function to format the message and return a string.
         * Will throw an error if you attempt to set a formatterLogMessage if the LoggerType is custom.
         * @param value The formatter function, or null to reset it.
         */
        set: function (value) {
            if (value !== null && this._loggerType === LoggerOptions_1.LoggerType.Custom) {
                throw new Error("You cannot specify a formatter for log messages if your loggerType is Custom");
            }
            this._formatterLogMessage = value;
        },
        enumerable: false,
        configurable: true
    });
    return LogGroupRule;
}());
exports.LogGroupRule = LogGroupRule;
//# sourceMappingURL=LogGroupRule.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRuntimeSettings.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRuntimeSettings.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogGroupRuntimeSettings = void 0;
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Represents the runtime settings for a LogGroup (LogGroupRule).
 */
var LogGroupRuntimeSettings = /** @class */ (function () {
    function LogGroupRuntimeSettings(logGroupRule) {
        this._formatterLogMessage = null;
        this._logGroupRule = logGroupRule;
        this._level = logGroupRule.level;
        this._loggerType = logGroupRule.loggerType;
        this._logFormat = new LoggerOptions_1.LogFormat(new LoggerOptions_1.DateFormat(logGroupRule.logFormat.dateFormat.formatEnum, logGroupRule.logFormat.dateFormat.dateSeparator), logGroupRule.logFormat.showTimeStamp, logGroupRule.logFormat.showLoggerName);
        this._callBackLogger = logGroupRule.callBackLogger;
        this._formatterLogMessage = logGroupRule.formatterLogMessage;
    }
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "logGroupRule", {
        /**
         * Returns original LogGroupRule (so not runtime settings!)
         * @return {LogGroupRule}
         */
        get: function () {
            return this._logGroupRule;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "level", {
        get: function () {
            return this._level;
        },
        set: function (value) {
            this._level = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        set: function (value) {
            this._loggerType = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        set: function (value) {
            this._logFormat = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        set: function (value) {
            this._callBackLogger = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "formatterLogMessage", {
        get: function () {
            return this._formatterLogMessage;
        },
        set: function (value) {
            this._formatterLogMessage = value;
        },
        enumerable: false,
        configurable: true
    });
    return LogGroupRuntimeSettings;
}());
exports.LogGroupRuntimeSettings = LogGroupRuntimeSettings;
//# sourceMappingURL=LogGroupRuntimeSettings.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryImpl.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryImpl.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggerFactoryImpl = void 0;
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var ConsoleLoggerImpl_1 = __webpack_require__(/*! ./ConsoleLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/ConsoleLoggerImpl.js");
var MessageBufferLoggerImpl_1 = __webpack_require__(/*! ./MessageBufferLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/MessageBufferLoggerImpl.js");
var AbstractLogger_1 = __webpack_require__(/*! ./AbstractLogger */ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js");
var LogGroupRuntimeSettings_1 = __webpack_require__(/*! ./LogGroupRuntimeSettings */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRuntimeSettings.js");
var LoggerFactoryImpl = /** @class */ (function () {
    function LoggerFactoryImpl(name, options) {
        this._loggers = new DataStructures_1.SimpleMap();
        this._logGroupRuntimeSettingsIndexed = [];
        this._loggerToLogGroupSettings = new DataStructures_1.SimpleMap();
        this._name = name;
        this.configure(options);
    }
    LoggerFactoryImpl.prototype.configure = function (options) {
        this._options = options;
        // Close any current open loggers.
        this.closeLoggers();
        this._loggerToLogGroupSettings.clear();
        this._logGroupRuntimeSettingsIndexed = [];
        var logGroupRules = this._options.logGroupRules;
        /* tslint:disable:prefer-for-of */
        for (var i = 0; i < logGroupRules.length; i++) {
            this._logGroupRuntimeSettingsIndexed.push(new LogGroupRuntimeSettings_1.LogGroupRuntimeSettings(logGroupRules[i]));
        }
        /* tslint:enable:prefer-for-of */
    };
    LoggerFactoryImpl.prototype.getLogger = function (named) {
        if (!this._options.enabled) {
            throw new Error("LoggerFactory is not enabled, please check your options passed in");
        }
        var logger = this._loggers.get(named);
        if (typeof logger !== "undefined") {
            return logger;
        }
        // Initialize logger with appropriate level
        logger = this.loadLogger(named);
        this._loggers.put(named, logger);
        return logger;
    };
    LoggerFactoryImpl.prototype.isEnabled = function () {
        return this._options.enabled;
    };
    LoggerFactoryImpl.prototype.closeLoggers = function () {
        this._loggers.forEachValue(function (logger) {
            // We can only close if AbstractLogger is used (our loggers, but user loggers may not extend it, even though unlikely).
            if (logger instanceof AbstractLogger_1.AbstractLogger) {
                logger.close();
            }
        });
        this._loggers.clear();
    };
    LoggerFactoryImpl.prototype.getName = function () {
        return this._name;
    };
    LoggerFactoryImpl.prototype.getLogGroupRuntimeSettingsByIndex = function (idx) {
        if (idx >= 0 && idx < this._logGroupRuntimeSettingsIndexed.length) {
            return this._logGroupRuntimeSettingsIndexed[idx];
        }
        return null;
    };
    LoggerFactoryImpl.prototype.getLogGroupRuntimeSettingsByLoggerName = function (nameLogger) {
        var result = this._loggerToLogGroupSettings.get(nameLogger);
        if (typeof result === "undefined") {
            return null;
        }
        return result;
    };
    LoggerFactoryImpl.prototype.getLogGroupRuntimeSettings = function () {
        return this._logGroupRuntimeSettingsIndexed.slice(0);
    };
    LoggerFactoryImpl.prototype.loadLogger = function (named) {
        var logGroupRules = this._options.logGroupRules;
        for (var i = 0; i < logGroupRules.length; i++) {
            var logGroupRule = logGroupRules[i];
            if (logGroupRule.regExp.test(named)) {
                var logGroupRuntimeSettings = this._logGroupRuntimeSettingsIndexed[i];
                var logger = void 0;
                switch (logGroupRule.loggerType) {
                    case LoggerOptions_1.LoggerType.Console:
                        logger = new ConsoleLoggerImpl_1.ConsoleLoggerImpl(named, logGroupRuntimeSettings);
                        break;
                    case LoggerOptions_1.LoggerType.MessageBuffer:
                        logger = new MessageBufferLoggerImpl_1.MessageBufferLoggerImpl(named, logGroupRuntimeSettings);
                        break;
                    case LoggerOptions_1.LoggerType.Custom:
                        if (logGroupRule.callBackLogger != null) {
                            logger = logGroupRule.callBackLogger(named, logGroupRuntimeSettings);
                        }
                        else {
                            throw new Error("Cannot create a custom logger, custom callback is null");
                        }
                        break;
                    default:
                        throw new Error("Cannot create a Logger for LoggerType: " + logGroupRule.loggerType);
                }
                // For a new logger map it by its name
                this._loggerToLogGroupSettings.put(named, logGroupRuntimeSettings);
                return logger;
            }
        }
        throw new Error("Failed to find a match to create a Logger for: " + named);
    };
    return LoggerFactoryImpl;
}());
exports.LoggerFactoryImpl = LoggerFactoryImpl;
//# sourceMappingURL=LoggerFactoryImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryOptions.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryOptions.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggerFactoryOptions = void 0;
/**
 * Options object you can use to configure the LoggerFactory you create at LFService.
 */
var LoggerFactoryOptions = /** @class */ (function () {
    function LoggerFactoryOptions() {
        this._logGroupRules = [];
        this._enabled = true;
    }
    /**
     * Add LogGroupRule, see {LogGroupRule) for details
     * @param rule Rule to add
     * @returns {LoggerFactoryOptions} returns itself
     */
    LoggerFactoryOptions.prototype.addLogGroupRule = function (rule) {
        this._logGroupRules.push(rule);
        return this;
    };
    /**
     * Enable or disable logging completely for the LoggerFactory.
     * @param enabled True for enabled (default)
     * @returns {LoggerFactoryOptions} returns itself
     */
    LoggerFactoryOptions.prototype.setEnabled = function (enabled) {
        this._enabled = enabled;
        return this;
    };
    Object.defineProperty(LoggerFactoryOptions.prototype, "logGroupRules", {
        get: function () {
            return this._logGroupRules;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LoggerFactoryOptions.prototype, "enabled", {
        get: function () {
            return this._enabled;
        },
        enumerable: false,
        configurable: true
    });
    return LoggerFactoryOptions;
}());
exports.LoggerFactoryOptions = LoggerFactoryOptions;
//# sourceMappingURL=LoggerFactoryOptions.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/MessageBufferLoggerImpl.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/MessageBufferLoggerImpl.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageBufferLoggerImpl = void 0;
var AbstractLogger_1 = __webpack_require__(/*! ./AbstractLogger */ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js");
/**
 * Logger which buffers all messages, use with care due to possible high memory footprint.
 * Can be convenient in some cases. Call toString() for full output, or cast to this class
 * and call getMessages() to do something with it yourself.
 */
var MessageBufferLoggerImpl = /** @class */ (function (_super) {
    __extends(MessageBufferLoggerImpl, _super);
    function MessageBufferLoggerImpl(name, logGroupRuntimeSettings) {
        var _this = _super.call(this, name, logGroupRuntimeSettings) || this;
        _this.messages = [];
        return _this;
    }
    MessageBufferLoggerImpl.prototype.close = function () {
        this.messages = [];
        _super.prototype.close.call(this);
    };
    MessageBufferLoggerImpl.prototype.getMessages = function () {
        return this.messages;
    };
    MessageBufferLoggerImpl.prototype.toString = function () {
        return this.messages.map(function (msg) {
            return msg;
        }).join("\n");
    };
    MessageBufferLoggerImpl.prototype.doLog = function (message) {
        var messageFormatter = this._getMessageFormatter();
        var fullMsg;
        if (messageFormatter === null) {
            fullMsg = this.createDefaultLogMessage(message);
        }
        else {
            fullMsg = messageFormatter(message);
        }
        this.messages.push(fullMsg);
    };
    return MessageBufferLoggerImpl;
}(AbstractLogger_1.AbstractLogger));
exports.MessageBufferLoggerImpl = MessageBufferLoggerImpl;
//# sourceMappingURL=MessageBufferLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/typescript-logging.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/typescript-logging.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCategoryControl = exports.getLogControl = exports.help = exports.MessageFormatUtils = exports.LinkedList = exports.SimpleMap = exports.LogLevel = exports.LoggerType = exports.LogFormat = exports.DateFormatEnum = exports.DateFormat = exports.CategoryLogFormat = exports.MessageBufferLoggerImpl = exports.ConsoleLoggerImpl = exports.AbstractLogger = exports.LFService = exports.LogGroupRule = exports.LoggerFactoryOptions = exports.CategoryServiceFactory = exports.CategoryMessageBufferLoggerImpl = exports.CategoryConfiguration = exports.CategoryRuntimeSettings = exports.Category = exports.CategoryDelegateLoggerImpl = exports.CategoryConsoleLoggerImpl = exports.AbstractCategoryLogger = exports.ExtensionHelper = void 0;
var LogGroupControl_1 = __webpack_require__(/*! ./control/LogGroupControl */ "./node_modules/typescript-logging/dist/commonjs/control/LogGroupControl.js");
var CategoryServiceControl_1 = __webpack_require__(/*! ./control/CategoryServiceControl */ "./node_modules/typescript-logging/dist/commonjs/control/CategoryServiceControl.js");
// Public stuff we export for extension
__exportStar(__webpack_require__(/*! ./extension/MessagesToExtensionJSON */ "./node_modules/typescript-logging/dist/commonjs/extension/MessagesToExtensionJSON.js"), exports);
__exportStar(__webpack_require__(/*! ./extension/MessagesFromExtensionJSON */ "./node_modules/typescript-logging/dist/commonjs/extension/MessagesFromExtensionJSON.js"), exports);
__exportStar(__webpack_require__(/*! ./extension/ExtensionMessageJSON */ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionMessageJSON.js"), exports);
var ExtensionHelper_1 = __webpack_require__(/*! ./extension/ExtensionHelper */ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js");
Object.defineProperty(exports, "ExtensionHelper", ({ enumerable: true, get: function () { return ExtensionHelper_1.ExtensionHelper; } }));
// Category related
var AbstractCategoryLogger_1 = __webpack_require__(/*! ./log/category/AbstractCategoryLogger */ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js");
Object.defineProperty(exports, "AbstractCategoryLogger", ({ enumerable: true, get: function () { return AbstractCategoryLogger_1.AbstractCategoryLogger; } }));
var CategoryConsoleLoggerImpl_1 = __webpack_require__(/*! ./log/category/CategoryConsoleLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConsoleLoggerImpl.js");
Object.defineProperty(exports, "CategoryConsoleLoggerImpl", ({ enumerable: true, get: function () { return CategoryConsoleLoggerImpl_1.CategoryConsoleLoggerImpl; } }));
var CategoryDelegateLoggerImpl_1 = __webpack_require__(/*! ./log/category/CategoryDelegateLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryDelegateLoggerImpl.js");
Object.defineProperty(exports, "CategoryDelegateLoggerImpl", ({ enumerable: true, get: function () { return CategoryDelegateLoggerImpl_1.CategoryDelegateLoggerImpl; } }));
var Category_1 = __webpack_require__(/*! ./log/category/Category */ "./node_modules/typescript-logging/dist/commonjs/log/category/Category.js");
Object.defineProperty(exports, "Category", ({ enumerable: true, get: function () { return Category_1.Category; } }));
var CategoryRuntimeSettings_1 = __webpack_require__(/*! ./log/category/CategoryRuntimeSettings */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryRuntimeSettings.js");
Object.defineProperty(exports, "CategoryRuntimeSettings", ({ enumerable: true, get: function () { return CategoryRuntimeSettings_1.CategoryRuntimeSettings; } }));
var CategoryConfiguration_1 = __webpack_require__(/*! ./log/category/CategoryConfiguration */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConfiguration.js");
Object.defineProperty(exports, "CategoryConfiguration", ({ enumerable: true, get: function () { return CategoryConfiguration_1.CategoryConfiguration; } }));
var CategoryMessageBufferImpl_1 = __webpack_require__(/*! ./log/category/CategoryMessageBufferImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryMessageBufferImpl.js");
Object.defineProperty(exports, "CategoryMessageBufferLoggerImpl", ({ enumerable: true, get: function () { return CategoryMessageBufferImpl_1.CategoryMessageBufferLoggerImpl; } }));
var CategoryServiceFactory_1 = __webpack_require__(/*! ./log/category/CategoryServiceFactory */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryServiceFactory.js");
Object.defineProperty(exports, "CategoryServiceFactory", ({ enumerable: true, get: function () { return CategoryServiceFactory_1.CategoryServiceFactory; } }));
var LoggerFactoryOptions_1 = __webpack_require__(/*! ./log/standard/LoggerFactoryOptions */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryOptions.js");
Object.defineProperty(exports, "LoggerFactoryOptions", ({ enumerable: true, get: function () { return LoggerFactoryOptions_1.LoggerFactoryOptions; } }));
var LogGroupRule_1 = __webpack_require__(/*! ./log/standard/LogGroupRule */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRule.js");
Object.defineProperty(exports, "LogGroupRule", ({ enumerable: true, get: function () { return LogGroupRule_1.LogGroupRule; } }));
var LFService_1 = __webpack_require__(/*! ./log/standard/LFService */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LFService.js");
Object.defineProperty(exports, "LFService", ({ enumerable: true, get: function () { return LFService_1.LFService; } }));
var AbstractLogger_1 = __webpack_require__(/*! ./log/standard/AbstractLogger */ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js");
Object.defineProperty(exports, "AbstractLogger", ({ enumerable: true, get: function () { return AbstractLogger_1.AbstractLogger; } }));
var ConsoleLoggerImpl_1 = __webpack_require__(/*! ./log/standard/ConsoleLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/ConsoleLoggerImpl.js");
Object.defineProperty(exports, "ConsoleLoggerImpl", ({ enumerable: true, get: function () { return ConsoleLoggerImpl_1.ConsoleLoggerImpl; } }));
var MessageBufferLoggerImpl_1 = __webpack_require__(/*! ./log/standard/MessageBufferLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/MessageBufferLoggerImpl.js");
Object.defineProperty(exports, "MessageBufferLoggerImpl", ({ enumerable: true, get: function () { return MessageBufferLoggerImpl_1.MessageBufferLoggerImpl; } }));
var LoggerOptions_1 = __webpack_require__(/*! ./log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
Object.defineProperty(exports, "CategoryLogFormat", ({ enumerable: true, get: function () { return LoggerOptions_1.CategoryLogFormat; } }));
Object.defineProperty(exports, "DateFormat", ({ enumerable: true, get: function () { return LoggerOptions_1.DateFormat; } }));
Object.defineProperty(exports, "DateFormatEnum", ({ enumerable: true, get: function () { return LoggerOptions_1.DateFormatEnum; } }));
Object.defineProperty(exports, "LogFormat", ({ enumerable: true, get: function () { return LoggerOptions_1.LogFormat; } }));
Object.defineProperty(exports, "LoggerType", ({ enumerable: true, get: function () { return LoggerOptions_1.LoggerType; } }));
Object.defineProperty(exports, "LogLevel", ({ enumerable: true, get: function () { return LoggerOptions_1.LogLevel; } }));
// Utilities
var DataStructures_1 = __webpack_require__(/*! ./utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
Object.defineProperty(exports, "SimpleMap", ({ enumerable: true, get: function () { return DataStructures_1.SimpleMap; } }));
Object.defineProperty(exports, "LinkedList", ({ enumerable: true, get: function () { return DataStructures_1.LinkedList; } }));
__exportStar(__webpack_require__(/*! ./utils/JSONHelper */ "./node_modules/typescript-logging/dist/commonjs/utils/JSONHelper.js"), exports);
var MessageUtils_1 = __webpack_require__(/*! ./utils/MessageUtils */ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js");
Object.defineProperty(exports, "MessageFormatUtils", ({ enumerable: true, get: function () { return MessageUtils_1.MessageFormatUtils; } }));
/*
 Functions to export on TSL libarary var.
*/
// Export help function
function help() {
    /* tslint:disable:no-console */
    console.log("help()\n   ** Shows this help\n\n getLogControl(): LoggerControl\n   ** Returns LoggerControl Object, use to dynamically change loglevels for log4j logging.\n   ** Call .help() on LoggerControl object for available options.\n\n getCategoryControl(): CategoryServiceControl\n   ** Returns CategoryServiceControl Object, use to dynamically change loglevels for category logging.\n   ** Call .help() on CategoryServiceControl object for available options.\n");
    /* tslint:enable:no-console */
}
exports.help = help;
// Export LogControl function (log4j)
function getLogControl() {
    return new LogGroupControl_1.LoggerControlImpl();
}
exports.getLogControl = getLogControl;
// Export CategoryControl function
function getCategoryControl() {
    return new CategoryServiceControl_1.CategoryServiceControlImpl();
}
exports.getCategoryControl = getCategoryControl;
//# sourceMappingURL=typescript-logging.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringBuilder = exports.TuplePair = exports.SimpleMap = exports.LinkedList = void 0;
var LinkedNode = /** @class */ (function () {
    function LinkedNode(value) {
        this._previous = null;
        this._next = null;
        this._value = value;
    }
    Object.defineProperty(LinkedNode.prototype, "previous", {
        get: function () {
            return this._previous;
        },
        set: function (value) {
            this._previous = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinkedNode.prototype, "next", {
        get: function () {
            return this._next;
        },
        set: function (value) {
            this._next = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LinkedNode.prototype, "value", {
        get: function () {
            return this._value;
        },
        enumerable: false,
        configurable: true
    });
    return LinkedNode;
}());
/**
 * Double linkedlist implementation.
 */
var LinkedList = /** @class */ (function () {
    function LinkedList() {
        this.head = null;
        this.size = 0;
    }
    LinkedList.prototype.addHead = function (value) {
        if (!this.createHeadIfNeeded(value)) {
            if (this.head != null) {
                var nextNode = this.head.next;
                var newHeadNode = new LinkedNode(value);
                if (nextNode != null) {
                    nextNode.previous = newHeadNode;
                    newHeadNode.next = nextNode;
                }
                this.head = newHeadNode;
            }
            else {
                throw new Error("This should never happen, list implementation broken");
            }
        }
        this.size++;
    };
    LinkedList.prototype.addTail = function (value) {
        if (!this.createHeadIfNeeded(value)) {
            var oldTailNode = this.getTailNode();
            if (oldTailNode != null) {
                var newTailNode = new LinkedNode(value);
                oldTailNode.next = newTailNode;
                newTailNode.previous = oldTailNode;
            }
            else {
                throw new Error("List implementation broken");
            }
        }
        this.size++;
    };
    LinkedList.prototype.clear = function () {
        this.head = null;
        this.size = 0;
    };
    LinkedList.prototype.getHead = function () {
        if (this.head != null) {
            return this.head.value;
        }
        return null;
    };
    LinkedList.prototype.removeHead = function () {
        if (this.head != null) {
            var oldHead = this.head;
            var value = oldHead.value;
            this.head = oldHead.next;
            this.size--;
            return value;
        }
        return null;
    };
    LinkedList.prototype.getTail = function () {
        var node = this.getTailNode();
        if (node != null) {
            return node.value;
        }
        return null;
    };
    LinkedList.prototype.removeTail = function () {
        var node = this.getTailNode();
        if (node != null) {
            if (node === this.head) {
                this.head = null;
            }
            else {
                var previousNode = node.previous;
                if (previousNode != null) {
                    previousNode.next = null;
                }
                else {
                    throw new Error("List implementation is broken");
                }
            }
            this.size--;
            return node.value;
        }
        return null;
    };
    LinkedList.prototype.getSize = function () {
        return this.size;
    };
    LinkedList.prototype.filter = function (f) {
        var recurse = function (fn, node, values) {
            if (fn(node.value)) {
                values.push(node.value);
            }
            var nextNode = node.next;
            if (nextNode != null) {
                recurse(fn, nextNode, values);
            }
        };
        var result = [];
        var currentNode = this.head;
        if (currentNode != null) {
            recurse(f, currentNode, result);
        }
        return result;
    };
    LinkedList.prototype.createHeadIfNeeded = function (value) {
        if (this.head == null) {
            this.head = new LinkedNode(value);
            return true;
        }
        return false;
    };
    LinkedList.prototype.getTailNode = function () {
        if (this.head == null) {
            return null;
        }
        var node = this.head;
        while (node.next != null) {
            node = node.next;
        }
        return node;
    };
    return LinkedList;
}());
exports.LinkedList = LinkedList;
/**
 * Map implementation keyed by string (always).
 */
var SimpleMap = /** @class */ (function () {
    function SimpleMap() {
        this.array = {};
    }
    SimpleMap.prototype.put = function (key, value) {
        this.array[key] = value;
    };
    SimpleMap.prototype.get = function (key) {
        return this.array[key];
    };
    SimpleMap.prototype.exists = function (key) {
        var value = this.array[key];
        return (typeof value !== "undefined");
    };
    SimpleMap.prototype.remove = function (key) {
        var value = this.array[key];
        if (typeof value !== "undefined") {
            delete this.array[key];
        }
        return value;
    };
    SimpleMap.prototype.keys = function () {
        var keys = [];
        for (var key in this.array) {
            // To prevent random stuff to appear
            if (this.array.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys;
    };
    SimpleMap.prototype.values = function () {
        var values = [];
        for (var key in this.array) {
            // To prevent random stuff to appear
            if (this.array.hasOwnProperty(key)) {
                values.push(this.get(key));
            }
        }
        return values;
    };
    SimpleMap.prototype.size = function () {
        return this.keys().length;
    };
    SimpleMap.prototype.isEmpty = function () {
        return this.size() === 0;
    };
    SimpleMap.prototype.clear = function () {
        this.array = {};
    };
    SimpleMap.prototype.forEach = function (cbFunction) {
        var count = 0;
        for (var key in this.array) {
            // To prevent random stuff to appear
            if (this.array.hasOwnProperty(key)) {
                var value = this.array[key];
                cbFunction(key, value, count);
                count++;
            }
        }
    };
    SimpleMap.prototype.forEachValue = function (cbFunction) {
        var count = 0;
        for (var key in this.array) {
            // To prevent random stuff to appear
            if (this.array.hasOwnProperty(key)) {
                var value = this.array[key];
                cbFunction(value, count);
                count++;
            }
        }
    };
    return SimpleMap;
}());
exports.SimpleMap = SimpleMap;
/**
 * Tuple to hold two values.
 */
var TuplePair = /** @class */ (function () {
    function TuplePair(x, y) {
        this._x = x;
        this._y = y;
    }
    Object.defineProperty(TuplePair.prototype, "x", {
        get: function () {
            return this._x;
        },
        set: function (value) {
            this._x = value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TuplePair.prototype, "y", {
        get: function () {
            return this._y;
        },
        set: function (value) {
            this._y = value;
        },
        enumerable: false,
        configurable: true
    });
    return TuplePair;
}());
exports.TuplePair = TuplePair;
/**
 * Utility class to build up a string.
 */
var StringBuilder = /** @class */ (function () {
    function StringBuilder() {
        this.data = [];
    }
    StringBuilder.prototype.append = function (line) {
        if (line === undefined || line == null) {
            throw new Error("String must be set, cannot append null or undefined");
        }
        this.data.push(line);
        return this;
    };
    StringBuilder.prototype.appendLine = function (line) {
        this.data.push(line + "\n");
        return this;
    };
    StringBuilder.prototype.isEmpty = function () {
        return this.data.length === 0;
    };
    StringBuilder.prototype.clear = function () {
        this.data = [];
    };
    StringBuilder.prototype.toString = function (separator) {
        if (separator === void 0) { separator = ""; }
        return this.data.join(separator);
    };
    return StringBuilder;
}());
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=DataStructures.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/utils/JSONHelper.js":
/*!***************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/utils/JSONHelper.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JSONHelper = exports.JSONArray = exports.JSONObject = void 0;
/**
 * Module containing bunch of JSON related stuff.
 */
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var DataStructures_1 = __webpack_require__(/*! ./DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var JSONTypeImpl = /** @class */ (function () {
    function JSONTypeImpl(value) {
        this._value = value;
    }
    JSONTypeImpl.prototype.getValue = function () {
        return this._value;
    };
    return JSONTypeImpl;
}());
var JSONBooleanType = /** @class */ (function (_super) {
    __extends(JSONBooleanType, _super);
    function JSONBooleanType(value) {
        return _super.call(this, value) || this;
    }
    return JSONBooleanType;
}(JSONTypeImpl));
var JSONNumberType = /** @class */ (function (_super) {
    __extends(JSONNumberType, _super);
    function JSONNumberType(value) {
        return _super.call(this, value) || this;
    }
    return JSONNumberType;
}(JSONTypeImpl));
var JSONStringType = /** @class */ (function (_super) {
    __extends(JSONStringType, _super);
    function JSONStringType(value) {
        return _super.call(this, value) || this;
    }
    JSONStringType.prototype.toString = function () {
        var value = this.getValue();
        if (value != null) {
            return JSON.stringify(value.toString());
        }
        return "null";
    };
    return JSONStringType;
}(JSONTypeImpl));
var JSONObjectType = /** @class */ (function (_super) {
    __extends(JSONObjectType, _super);
    function JSONObjectType(value) {
        return _super.call(this, value) || this;
    }
    return JSONObjectType;
}(JSONTypeImpl));
var JSONArrayType = /** @class */ (function (_super) {
    __extends(JSONArrayType, _super);
    function JSONArrayType(value) {
        return _super.call(this, value) || this;
    }
    JSONArrayType.prototype.toString = function () {
        var value = this.getValue();
        if (value != null) {
            return value.toString();
        }
        return "null";
    };
    return JSONArrayType;
}(JSONTypeImpl));
var JSONNullType = /** @class */ (function (_super) {
    __extends(JSONNullType, _super);
    function JSONNullType() {
        return _super.call(this, null) || this;
    }
    JSONNullType.prototype.toString = function () {
        return "null";
    };
    return JSONNullType;
}(JSONTypeImpl));
var JSONTypeConverter = /** @class */ (function () {
    function JSONTypeConverter() {
    }
    JSONTypeConverter.toJSONType = function (value) {
        if (value === null) {
            return new JSONNullType();
        }
        if (typeof value === "string") {
            return new JSONStringType(value);
        }
        if (typeof value === "number") {
            return new JSONNumberType(value);
        }
        if (typeof value === "boolean") {
            return new JSONBooleanType(value);
        }
        if (value instanceof JSONObject) {
            return new JSONObjectType(value);
        }
        throw new Error("Type not supported for value: " + value);
    };
    return JSONTypeConverter;
}());
var JSONObject = /** @class */ (function () {
    function JSONObject() {
        this.values = new DataStructures_1.SimpleMap();
    }
    JSONObject.prototype.addBoolean = function (name, value) {
        this.checkName(name);
        JSONObject.checkValue(value);
        this.values.put(name, new JSONBooleanType(value));
        return this;
    };
    JSONObject.prototype.addNumber = function (name, value) {
        this.checkName(name);
        JSONObject.checkValue(value);
        this.values.put(name, new JSONNumberType(value));
        return this;
    };
    JSONObject.prototype.addString = function (name, value) {
        this.checkName(name);
        JSONObject.checkValue(value);
        this.values.put(name, new JSONStringType(value));
        return this;
    };
    JSONObject.prototype.addNull = function (name) {
        this.checkName(name);
        this.values.put(name, new JSONNullType());
        return this;
    };
    JSONObject.prototype.addArray = function (name, array) {
        this.checkName(name);
        JSONObject.checkValue(array);
        if (array == null) {
            throw new Error("Cannot add array as null");
        }
        this.values.put(name, new JSONArrayType(array));
        return this;
    };
    JSONObject.prototype.addObject = function (name, object) {
        this.checkName(name);
        JSONObject.checkValue(object);
        if (object == null) {
            throw new Error("Cannot add object as null");
        }
        this.values.put(name, new JSONObjectType(object));
        return this;
    };
    JSONObject.prototype.toString = function (pretty) {
        var _this = this;
        if (pretty === void 0) { pretty = false; }
        var comma = false;
        var buffer = new DataStructures_1.StringBuilder();
        buffer.append("{");
        this.values.keys().forEach(function (key) {
            var value = _this.values.get(key);
            if (value != null) {
                if (comma) {
                    buffer.append(",");
                }
                buffer.append('"').append(key).append('":').append(value.toString());
                comma = true;
            }
        });
        buffer.append("}");
        return buffer.toString();
    };
    JSONObject.prototype.checkName = function (name) {
        if (name == null || name === undefined) {
            throw new Error("Name is null or undefined");
        }
        if (this.values.exists(name)) {
            throw new Error("Name " + name + " is already present for this object");
        }
    };
    JSONObject.checkValue = function (value) {
        if (value === undefined) {
            throw new Error("Value is undefined");
        }
    };
    return JSONObject;
}());
exports.JSONObject = JSONObject;
var JSONArray = /** @class */ (function () {
    function JSONArray() {
        this.objects = [];
    }
    JSONArray.prototype.add = function (object) {
        if (object === undefined) {
            throw new Error("Object is not allowed to be undefined");
        }
        this.objects.push(JSONTypeConverter.toJSONType(object));
        return this;
    };
    JSONArray.prototype.toString = function (pretty) {
        if (pretty === void 0) { pretty = false; }
        var buffer = new DataStructures_1.StringBuilder();
        buffer.append("[");
        this.objects.forEach(function (value, index) {
            if (index > 0) {
                buffer.append(",");
            }
            buffer.append(value.toString());
        });
        buffer.append("]");
        return buffer.toString();
    };
    return JSONArray;
}());
exports.JSONArray = JSONArray;
/**
 * Utility class that helps us convert things to and from json (not for normal usage).
 */
var JSONHelper = /** @class */ (function () {
    function JSONHelper() {
    }
    JSONHelper.categoryToJSON = function (cat, recursive) {
        /*
         {
         "categories":
         [
         { id=1,
         name: "x",
         parent: null,
         logLevel: "Error"
         },
         { id=2,
         name: "y",
         parent: 1,
         logLevel: "Error"
         }
         ]
         }
         */
        var arr = new JSONArray();
        JSONHelper._categoryToJSON(cat, arr, recursive);
        var object = new JSONObject();
        object.addArray("categories", arr);
        return object;
    };
    JSONHelper._categoryToJSON = function (cat, arr, recursive) {
        var object = new JSONObject();
        object.addNumber("id", cat.id);
        object.addString("name", cat.name);
        object.addString("logLevel", LoggerOptions_1.LogLevel[cat.logLevel].toString());
        if (cat.parent != null) {
            object.addNumber("parent", cat.parent.id);
        }
        else {
            object.addNull("parent");
        }
        arr.add(object);
        if (recursive) {
            cat.children.forEach(function (child) {
                JSONHelper._categoryToJSON(child, arr, recursive);
            });
        }
    };
    return JSONHelper;
}());
exports.JSONHelper = JSONHelper;
//# sourceMappingURL=JSONHelper.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageFormatUtils = void 0;
var ST = __webpack_require__(/*! stacktrace-js */ "./node_modules/stacktrace-js/stacktrace.js");
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Some utilities to format messages.
 */
var MessageFormatUtils = /** @class */ (function () {
    function MessageFormatUtils() {
    }
    /**
     * Render given date in given DateFormat and return as String.
     * @param date Date
     * @param dateFormat Format
     * @returns {string} Formatted date
     */
    MessageFormatUtils.renderDate = function (date, dateFormat) {
        var lpad = function (value, chars, padWith) {
            var howMany = chars - value.length;
            if (howMany > 0) {
                var res = "";
                for (var i = 0; i < howMany; i++) {
                    res += padWith;
                }
                res += value;
                return res;
            }
            return value;
        };
        var fullYear = function (d) {
            return lpad(d.getFullYear().toString(), 4, "0");
        };
        var month = function (d) {
            return lpad((d.getMonth() + 1).toString(), 2, "0");
        };
        var day = function (d) {
            return lpad(d.getDate().toString(), 2, "0");
        };
        var hours = function (d) {
            return lpad(d.getHours().toString(), 2, "0");
        };
        var minutes = function (d) {
            return lpad(d.getMinutes().toString(), 2, "0");
        };
        var seconds = function (d) {
            return lpad(d.getSeconds().toString(), 2, "0");
        };
        var millis = function (d) {
            return lpad(d.getMilliseconds().toString(), 3, "0");
        };
        var dateSeparator = dateFormat.dateSeparator;
        var ds = "";
        switch (dateFormat.formatEnum) {
            case LoggerOptions_1.DateFormatEnum.Default:
                // yyyy-mm-dd hh:mm:ss,m
                ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + " " +
                    hours(date) + ":" + minutes(date) + ":" + seconds(date) + "," + millis(date);
                break;
            case LoggerOptions_1.DateFormatEnum.YearMonthDayTime:
                ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + " " +
                    hours(date) + ":" + minutes(date) + ":" + seconds(date);
                break;
            case LoggerOptions_1.DateFormatEnum.YearDayMonthWithFullTime:
                ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + " " +
                    hours(date) + ":" + minutes(date) + ":" + seconds(date) + "," + millis(date);
                break;
            case LoggerOptions_1.DateFormatEnum.YearDayMonthTime:
                ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + " " +
                    hours(date) + ":" + minutes(date) + ":" + seconds(date);
                break;
            default:
                throw new Error("Unsupported date format enum: " + dateFormat.formatEnum);
        }
        return ds;
    };
    /**
     * Renders given category log message in default format.
     * @param msg Message to format
     * @param addStack If true adds the stack to the output, otherwise skips it
     * @returns {string} Formatted message
     */
    MessageFormatUtils.renderDefaultMessage = function (msg, addStack) {
        var result = "";
        var logFormat = msg.logFormat;
        if (logFormat.showTimeStamp) {
            result += MessageFormatUtils.renderDate(msg.date, logFormat.dateFormat) + " ";
        }
        result += LoggerOptions_1.LogLevel[msg.level].toUpperCase();
        if (msg.isResolvedErrorMessage) {
            result += " (resolved)";
        }
        result += " ";
        if (logFormat.showCategoryName) {
            result += "[";
            msg.categories.forEach(function (value, idx) {
                if (idx > 0) {
                    result += ", ";
                }
                result += value.name;
            });
            result += "]";
        }
        // Get the normal string message first
        var actualStringMsg = "";
        var dataString = "";
        var messageOrLogData = msg.message;
        if (typeof messageOrLogData === "string") {
            actualStringMsg = messageOrLogData;
        }
        else {
            var logData = messageOrLogData;
            actualStringMsg = logData.msg;
            // We do have data?
            if (logData.data) {
                dataString = " [data]: " + (logData.ds ? logData.ds(logData.data) : JSON.stringify(logData.data));
            }
        }
        result += " " + actualStringMsg + "" + dataString;
        if (addStack && msg.errorAsStack !== null) {
            result += "\n" + msg.errorAsStack;
        }
        return result;
    };
    /**
     * Renders given log4j log message in default format.
     * @param msg Message to format
     * @param addStack If true adds the stack to the output, otherwise skips it
     * @returns {string} Formatted message
     */
    MessageFormatUtils.renderDefaultLog4jMessage = function (msg, addStack) {
        var format = msg.logGroupRule.logFormat;
        var result = "";
        if (format.showTimeStamp) {
            result += MessageFormatUtils.renderDate(msg.date, format.dateFormat) + " ";
        }
        result += LoggerOptions_1.LogLevel[msg.level].toUpperCase() + " ";
        if (format.showLoggerName) {
            result += "[" + msg.loggerName + "]";
        }
        // Get the normal string message first
        var actualStringMsg = "";
        var dataString = "";
        if (typeof msg.message === "string") {
            actualStringMsg = msg.message;
        }
        else {
            var logData = msg.message;
            actualStringMsg = logData.msg;
            // We do have data?
            if (logData.data) {
                dataString = " [data]: " + (logData.ds ? logData.ds(logData.data) : JSON.stringify(logData.data));
            }
        }
        result += " " + actualStringMsg + "" + dataString;
        if (addStack && msg.errorAsStack !== null) {
            result += "\n" + msg.errorAsStack;
        }
        return result;
    };
    /**
     * Render error as stack
     * @param error Return error as Promise
     * @returns {Promise<string>|Promise} Promise for stack
     */
    MessageFormatUtils.renderError = function (error) {
        var result = error.name + ": " + error.message + "\n@";
        return new Promise(function (resolve) {
            // This one has a promise too
            ST.fromError(error, { offline: true }).then(function (frames) {
                var stackStr = (frames.map(function (frame) {
                    return frame.toString();
                })).join("\n  ");
                result += "\n" + stackStr;
                // This resolves our returned promise
                resolve(result);
            }).catch(function () {
                result = "Unexpected error object was passed in. ";
                try {
                    result += "Could not resolve it, stringified object: " + JSON.stringify(error);
                }
                catch (e) {
                    // Cannot stringify can only tell something was wrong.
                    result += "Could not resolve it or stringify it.";
                }
                resolve(result);
            });
        });
    };
    return MessageFormatUtils;
}());
exports.MessageFormatUtils = MessageFormatUtils;
//# sourceMappingURL=MessageUtils.js.map

/***/ }),

/***/ "./node_modules/css-selector-generator/build/index.js":
/*!************************************************************!*\
  !*** ./node_modules/css-selector-generator/build/index.js ***!
  \************************************************************/
/***/ ((module) => {

!function(t,e){ true?module.exports=e():0}(self,(()=>(()=>{var t={426:(t,e,n)=>{var r=n(529);function o(t,e,n){Array.isArray(t)?t.push(e):t[n]=e}t.exports=function(t){var e,n,i,c=[];if(Array.isArray(t))n=[],e=t.length-1;else{if("object"!=typeof t||null===t)throw new TypeError("Expecting an Array or an Object, but `"+(null===t?"null":typeof t)+"` provided.");n={},i=Object.keys(t),e=i.length-1}return function n(u,a){var l,s,f,d;for(s=i?i[a]:a,Array.isArray(t[s])||(void 0===t[s]?t[s]=[]:t[s]=[t[s]]),l=0;l<t[s].length;l++)o((d=u,f=Array.isArray(d)?[].concat(d):r(d)),t[s][l],s),a>=e?c.push(f):n(f,a+1)}(n,0),c}},529:t=>{t.exports=function(){for(var t={},n=0;n<arguments.length;n++){var r=arguments[n];for(var o in r)e.call(r,o)&&(t[o]=r[o])}return t};var e=Object.prototype.hasOwnProperty}},e={};function n(r){var o=e[r];if(void 0!==o)return o.exports;var i=e[r]={exports:{}};return t[r](i,i.exports,n),i.exports}n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var r={};return(()=>{"use strict";n.r(r),n.d(r,{default:()=>K,getCssSelector:()=>J});var t,e,o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol?"symbol":typeof t};function i(t){return null!=t&&"object"===(void 0===t?"undefined":o(t))&&1===t.nodeType&&"object"===o(t.style)&&"object"===o(t.ownerDocument)}function c(t="unknown problem",...e){console.warn(`CssSelectorGenerator: ${t}`,...e)}!function(t){t.NONE="none",t.DESCENDANT="descendant",t.CHILD="child"}(t||(t={})),function(t){t.id="id",t.class="class",t.tag="tag",t.attribute="attribute",t.nthchild="nthchild",t.nthoftype="nthoftype"}(e||(e={}));const u={selectors:[e.id,e.class,e.tag,e.attribute],includeTag:!1,whitelist:[],blacklist:[],combineWithinSelector:!0,combineBetweenSelectors:!0,root:null,maxCombinations:Number.POSITIVE_INFINITY,maxCandidates:Number.POSITIVE_INFINITY};function a(t){return t instanceof RegExp}function l(t){return["string","function"].includes(typeof t)||a(t)}function s(t){return Array.isArray(t)?t.filter(l):[]}function f(t){const e=[Node.DOCUMENT_NODE,Node.DOCUMENT_FRAGMENT_NODE,Node.ELEMENT_NODE];return function(t){return t instanceof Node}(t)&&e.includes(t.nodeType)}function d(t,e){if(f(t))return t.contains(e)||c("element root mismatch","Provided root does not contain the element. This will most likely result in producing a fallback selector using element's real root node. If you plan to use the selector using provided root (e.g. `root.querySelector`), it will nto work as intended."),t;const n=e.getRootNode({composed:!1});return f(n)?(n!==document&&c("shadow root inferred","You did not provide a root and the element is a child of Shadow DOM. This will produce a selector using ShadowRoot as a root. If you plan to use the selector using document as a root (e.g. `document.querySelector`), it will not work as intended."),n):e.ownerDocument.querySelector(":root")}function p(t){return"number"==typeof t?t:Number.POSITIVE_INFINITY}function m(t=[]){const[e=[],...n]=t;return 0===n.length?e:n.reduce(((t,e)=>t.filter((t=>e.includes(t)))),e)}function h(t){return[].concat(...t)}function y(t){const e=t.map((t=>{if(a(t))return e=>t.test(e);if("function"==typeof t)return e=>{const n=t(e);return"boolean"!=typeof n?(c("pattern matcher function invalid","Provided pattern matching function does not return boolean. It's result will be ignored.",t),!1):n};if("string"==typeof t){const e=new RegExp("^"+t.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".+")+"$");return t=>e.test(t)}return c("pattern matcher invalid","Pattern matching only accepts strings, regular expressions and/or functions. This item is invalid and will be ignored.",t),()=>!1}));return t=>e.some((e=>e(t)))}function g(t,e,n){const r=Array.from(d(n,t[0]).querySelectorAll(e));return r.length===t.length&&t.every((t=>r.includes(t)))}function b(t,e){e=null!=e?e:function(t){return t.ownerDocument.querySelector(":root")}(t);const n=[];let r=t;for(;i(r)&&r!==e;)n.push(r),r=r.parentElement;return n}function N(t,e){return m(t.map((t=>b(t,e))))}const v={[t.NONE]:{type:t.NONE,value:""},[t.DESCENDANT]:{type:t.DESCENDANT,value:" > "},[t.CHILD]:{type:t.CHILD,value:" "}},S=new RegExp(["^$","\\s"].join("|")),E=new RegExp(["^$"].join("|")),w=[e.nthoftype,e.tag,e.id,e.class,e.attribute,e.nthchild];var x=n(426);const A=y(["class","id","ng-*"]);function C({nodeName:t}){return`[${t}]`}function O({nodeName:t,nodeValue:e}){return`[${t}='${F(e)}']`}function T(t){const e=Array.from(t.attributes).filter((e=>function({nodeName:t},e){const n=e.tagName.toLowerCase();return!(["input","option"].includes(n)&&"value"===t||A(t))}(e,t)));return[...e.map(C),...e.map(O)]}function I(t){return(t.getAttribute("class")||"").trim().split(/\s+/).filter((t=>!E.test(t))).map((t=>`.${F(t)}`))}function j(t){const e=t.getAttribute("id")||"",n=`#${F(e)}`,r=t.getRootNode({composed:!1});return!S.test(e)&&g([t],n,r)?[n]:[]}function D(t){const e=t.parentNode;if(e){const n=Array.from(e.childNodes).filter(i).indexOf(t);if(n>-1)return[`:nth-child(${n+1})`]}return[]}function $(t){return[F(t.tagName.toLowerCase())]}function P(t){const e=[...new Set(h(t.map($)))];return 0===e.length||e.length>1?[]:[e[0]]}function R(t){const e=P([t])[0],n=t.parentElement;if(n){const r=Array.from(n.children).filter((t=>t.tagName.toLowerCase()===e)),o=r.indexOf(t);if(o>-1)return[`${e}:nth-of-type(${o+1})`]}return[]}function k(t=[],{maxResults:e=Number.POSITIVE_INFINITY}={}){const n=[];let r=0,o=L(1);for(;o.length<=t.length&&r<e;)r+=1,n.push(o.map((e=>t[e]))),o=_(o,t.length-1);return n}function _(t=[],e=0){const n=t.length;if(0===n)return[];const r=[...t];r[n-1]+=1;for(let t=n-1;t>=0;t--)if(r[t]>e){if(0===t)return L(n+1);r[t-1]++,r[t]=r[t-1]+1}return r[n-1]>e?L(n+1):r}function L(t=1){return Array.from(Array(t).keys())}const M=":".charCodeAt(0).toString(16).toUpperCase(),q=/[ !"#$%&'()\[\]{|}<>*+,./;=?@^`~\\]/;function F(t=""){var e,n;return null!==(n=null===(e=null===CSS||void 0===CSS?void 0:CSS.escape)||void 0===e?void 0:e.call(CSS,t))&&void 0!==n?n:function(t=""){return t.split("").map((t=>":"===t?`\\${M} `:q.test(t)?`\\${t}`:escape(t).replace(/%/g,"\\"))).join("")}(t)}const V={tag:P,id:function(t){return 0===t.length||t.length>1?[]:j(t[0])},class:function(t){return m(t.map(I))},attribute:function(t){return m(t.map(T))},nthchild:function(t){return m(t.map(D))},nthoftype:function(t){return m(t.map(R))}},Y={tag:$,id:j,class:I,attribute:T,nthchild:D,nthoftype:R};function B(t){return t.includes(e.tag)||t.includes(e.nthoftype)?[...t]:[...t,e.tag]}function G(t={}){const n=[...w];return t[e.tag]&&t[e.nthoftype]&&n.splice(n.indexOf(e.tag),1),n.map((e=>{return(r=t)[n=e]?r[n].join(""):"";var n,r})).join("")}function W(t,e,n="",r){const o=function(t,e){return""===e?t:function(t,e){return[...t.map((t=>e+" "+t)),...t.map((t=>e+" > "+t))]}(t,e)}(function(t,e,n){const r=function(t,e){const{blacklist:n,whitelist:r,combineWithinSelector:o,maxCombinations:i}=e,c=y(n),u=y(r);return function(t){const{selectors:e,includeTag:n}=t,r=[].concat(e);return n&&!r.includes("tag")&&r.push("tag"),r}(e).reduce(((e,n)=>{const r=function(t,e){var n;return(null!==(n=V[e])&&void 0!==n?n:()=>[])(t)}(t,n),a=function(t=[],e,n){return t.filter((t=>n(t)||!e(t)))}(r,c,u),l=function(t=[],e){return t.sort(((t,n)=>{const r=e(t),o=e(n);return r&&!o?-1:!r&&o?1:0}))}(a,u);return e[n]=o?k(l,{maxResults:i}):l.map((t=>[t])),e}),{})}(t,n),o=function(t,e){return function(t){const{selectors:e,combineBetweenSelectors:n,includeTag:r,maxCandidates:o}=t,i=n?k(e,{maxResults:o}):e.map((t=>[t]));return r?i.map(B):i}(e).map((e=>function(t,e){const n={};return t.forEach((t=>{const r=e[t];r.length>0&&(n[t]=r)})),x(n).map(G)}(e,t))).filter((t=>t.length>0))}(r,n),i=h(o);return[...new Set(i)]}(t,r.root,r),n);for(const e of o)if(g(t,e,r.root))return e;return null}function H(t){return{value:t,include:!1}}function U({selectors:t,operator:n}){let r=[...w];t[e.tag]&&t[e.nthoftype]&&(r=r.filter((t=>t!==e.tag)));let o="";return r.forEach((e=>{(t[e]||[]).forEach((({value:t,include:e})=>{e&&(o+=t)}))})),n.value+o}function z(n){return[":root",...b(n).reverse().map((n=>{const r=function(e,n,r=t.NONE){const o={};return n.forEach((t=>{Reflect.set(o,t,function(t,e){return Y[e](t)}(e,t).map(H))})),{element:e,operator:v[r],selectors:o}}(n,[e.nthchild],t.DESCENDANT);return r.selectors.nthchild.forEach((t=>{t.include=!0})),r})).map(U)].join("")}function J(t,n={}){const r=function(t){const e=(Array.isArray(t)?t:[t]).filter(i);return[...new Set(e)]}(t),o=function(t,n={}){const r=Object.assign(Object.assign({},u),n);return{selectors:(o=r.selectors,Array.isArray(o)?o.filter((t=>{return n=e,r=t,Object.values(n).includes(r);var n,r})):[]),whitelist:s(r.whitelist),blacklist:s(r.blacklist),root:d(r.root,t),combineWithinSelector:!!r.combineWithinSelector,combineBetweenSelectors:!!r.combineBetweenSelectors,includeTag:!!r.includeTag,maxCombinations:p(r.maxCombinations),maxCandidates:p(r.maxCandidates)};var o}(r[0],n);let c="",a=o.root;function l(){return function(t,e,n="",r){if(0===t.length)return null;const o=[t.length>1?t:[],...N(t,e).map((t=>[t]))];for(const t of o){const e=W(t,0,n,r);if(e)return{foundElements:t,selector:e}}return null}(r,a,c,o)}let f=l();for(;f;){const{foundElements:t,selector:e}=f;if(g(r,e,o.root))return e;a=t[0],c=e,f=l()}return r.length>1?r.map((t=>J(t,o))).join(", "):function(t){return t.map(z).join(", ")}(r)}const K=J})(),r})()));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQUlGRVhTY3JpcHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRCxRQUFRLGlDQUE2QixDQUFDLGdGQUFZLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUM3RCxNQUFNLEtBQUssRUFJTjtBQUNMLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2TkQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcktBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDZEQUFpQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVCxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVEQUF1RCxZQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdDQUF3QztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG9CQUFvQjtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0Msc0JBQXNCLCtDQUErQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7Ozs7Ozs7Ozs7QUN6akNoQyxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQWM7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLHFEQUFRO0FBQzNCLGVBQWUsK0ZBQStCO0FBQzlDLGtCQUFrQix3R0FBcUM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOzs7Ozs7Ozs7OztBQ25aMUIsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QiwrSEFBb0Q7QUFDN0UsV0FBVyxtQkFBTyxDQUFDLHFEQUFROztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxXQUFXO0FBQ1g7O0FBRUEsa0JBQWtCOzs7Ozs7Ozs7OztBQ3RabEIsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVosa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCO0FBQ3RCOzs7Ozs7Ozs7OztBQzVRYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsdUJBQXVCLG1CQUFPLENBQUMsd0dBQWtCO0FBQ2pELHNCQUFzQixtQkFBTyxDQUFDLDhGQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCOzs7Ozs7Ozs7OztBQ2xGYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsdUJBQXVCLG1CQUFPLENBQUMsMkdBQTRCO0FBQzNELHNCQUFzQixtQkFBTyxDQUFDLDhGQUFrQjtBQUNoRCwwQkFBMEIsbUJBQU8sQ0FBQyw4R0FBcUI7QUFDdkQsd0JBQXdCLG1CQUFPLENBQUMscUhBQWlDO0FBQ2pFLHFCQUFxQixtQkFBTyxDQUFDLG9HQUFnQjtBQUM3Qyw2QkFBNkIsbUJBQU8sQ0FBQyxvSEFBd0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDhCQUE4QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUJBQWlCO0FBQ2pCOzs7Ozs7Ozs7OztBQzNLYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsc0JBQXNCLG1CQUFPLENBQUMsOEZBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Qsb0JBQW9CO0FBQ3BCOzs7Ozs7Ozs7OztBQzdGYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0I7QUFDL0Isc0JBQXNCLG1CQUFPLENBQUMsOEZBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRCwrQkFBK0I7QUFDL0I7Ozs7Ozs7Ozs7O0FDakZhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6Qix1QkFBdUIsbUJBQU8sQ0FBQywyR0FBNEI7QUFDM0Qsc0JBQXNCLG1CQUFPLENBQUMsOEZBQWtCO0FBQ2hELDBCQUEwQixtQkFBTyxDQUFDLDhHQUFxQjtBQUN2RCxnQ0FBZ0MsbUJBQU8sQ0FBQywwSEFBMkI7QUFDbkUsdUJBQXVCLG1CQUFPLENBQUMsd0dBQWtCO0FBQ2pELGdDQUFnQyxtQkFBTyxDQUFDLDBIQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCOzs7Ozs7Ozs7OztBQzdHYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCO0FBQzVCOzs7Ozs7Ozs7OztBQzlDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0I7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsd0dBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELCtCQUErQjtBQUMvQjs7Ozs7Ozs7Ozs7QUN6RGE7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQyxnQkFBZ0I7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLHFCQUFxQixHQUFHLFlBQVksR0FBRywwQkFBMEIsR0FBRyxrQkFBa0IsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxpQkFBaUIsR0FBRyxzQkFBc0IsR0FBRyxrQkFBa0IsR0FBRyx5QkFBeUIsR0FBRywrQkFBK0IsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxvQkFBb0IsR0FBRyw0QkFBNEIsR0FBRyw4QkFBOEIsR0FBRyx1Q0FBdUMsR0FBRyw2QkFBNkIsR0FBRywrQkFBK0IsR0FBRyxnQkFBZ0IsR0FBRyxrQ0FBa0MsR0FBRyxpQ0FBaUMsR0FBRyw4QkFBOEIsR0FBRyx1QkFBdUI7QUFDbHRCLHdCQUF3QixtQkFBTyxDQUFDLDZHQUEyQjtBQUMzRCwrQkFBK0IsbUJBQU8sQ0FBQywySEFBa0M7QUFDekU7QUFDQSxhQUFhLG1CQUFPLENBQUMsaUlBQXFDO0FBQzFELGFBQWEsbUJBQU8sQ0FBQyxxSUFBdUM7QUFDNUQsYUFBYSxtQkFBTyxDQUFDLDJIQUFrQztBQUN2RCx3QkFBd0IsbUJBQU8sQ0FBQyxpSEFBNkI7QUFDN0QsbURBQWtELEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDO0FBQ3ZJO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMscUlBQXVDO0FBQzlFLDBEQUF5RCxFQUFFLHFDQUFxQywyREFBMkQsRUFBQztBQUM1SixrQ0FBa0MsbUJBQU8sQ0FBQywySUFBMEM7QUFDcEYsNkRBQTRELEVBQUUscUNBQXFDLGlFQUFpRSxFQUFDO0FBQ3JLLG1DQUFtQyxtQkFBTyxDQUFDLDZJQUEyQztBQUN0Riw4REFBNkQsRUFBRSxxQ0FBcUMsbUVBQW1FLEVBQUM7QUFDeEssaUJBQWlCLG1CQUFPLENBQUMseUdBQXlCO0FBQ2xELDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCxnQ0FBZ0MsbUJBQU8sQ0FBQyx1SUFBd0M7QUFDaEYsMkRBQTBELEVBQUUscUNBQXFDLDZEQUE2RCxFQUFDO0FBQy9KLDhCQUE4QixtQkFBTyxDQUFDLG1JQUFzQztBQUM1RSx5REFBd0QsRUFBRSxxQ0FBcUMseURBQXlELEVBQUM7QUFDekosa0NBQWtDLG1CQUFPLENBQUMsMklBQTBDO0FBQ3BGLG1FQUFrRSxFQUFFLHFDQUFxQyx1RUFBdUUsRUFBQztBQUNqTCwrQkFBK0IsbUJBQU8sQ0FBQyxxSUFBdUM7QUFDOUUsMERBQXlELEVBQUUscUNBQXFDLDJEQUEyRCxFQUFDO0FBQzVKLDZCQUE2QixtQkFBTyxDQUFDLGlJQUFxQztBQUMxRSx3REFBdUQsRUFBRSxxQ0FBcUMsdURBQXVELEVBQUM7QUFDdEoscUJBQXFCLG1CQUFPLENBQUMsaUhBQTZCO0FBQzFELGdEQUErQyxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUM5SCxrQkFBa0IsbUJBQU8sQ0FBQywyR0FBMEI7QUFDcEQsNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3JILHVCQUF1QixtQkFBTyxDQUFDLHFIQUErQjtBQUM5RCxrREFBaUQsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDcEksMEJBQTBCLG1CQUFPLENBQUMsMkhBQWtDO0FBQ3BFLHFEQUFvRCxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUM3SSxnQ0FBZ0MsbUJBQU8sQ0FBQyx1SUFBd0M7QUFDaEYsMkRBQTBELEVBQUUscUNBQXFDLDZEQUE2RCxFQUFDO0FBQy9KLHNCQUFzQixtQkFBTyxDQUFDLGlHQUFxQjtBQUNuRCxxREFBb0QsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDekksOENBQTZDLEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQzNILGtEQUFpRCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUNuSSw2Q0FBNEMsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDekgsOENBQTZDLEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQzNILDRDQUEyQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUN2SDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLHVHQUF3QjtBQUN2RCw2Q0FBNEMsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDMUgsOENBQTZDLEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQzVILGFBQWEsbUJBQU8sQ0FBQywrRkFBb0I7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsbUdBQXNCO0FBQ25ELHNEQUFxRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7Ozs7Ozs7Ozs7O0FDcEZhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGtCQUFrQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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UTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCwwQkFBMEI7QUFDMUI7Ozs7Ozs7Ozs7QUNoTUEsZUFBZSxLQUFpRCxvQkFBb0IsQ0FBdUksQ0FBQyxpQkFBaUIsT0FBTyxjQUFjLGFBQWEsa0JBQWtCLGtDQUFrQyxzQkFBc0IsZUFBZSxzQ0FBc0MsS0FBSyx1SUFBdUksSUFBSSwrQkFBK0IsdUJBQXVCLFlBQVksNEVBQTRFLGNBQWMsb0ZBQW9GLFNBQVMsU0FBUyxxQkFBcUIsWUFBWSxLQUFLLG1CQUFtQixLQUFLLG1CQUFtQix3Q0FBd0MsVUFBVSx1Q0FBdUMsTUFBTSxjQUFjLFdBQVcsK0JBQStCLFlBQVksWUFBWSxxQ0FBcUMsWUFBWSwrREFBK0QsdUJBQXVCLEVBQUUsOERBQThELDRGQUE0RixlQUFlLHdDQUF3QyxTQUFTLEdBQUcsU0FBUyxZQUFZLGFBQWEsY0FBYyxtQ0FBbUMsRUFBRSxrRkFBa0YsZ0JBQWdCLGFBQWEsK0VBQStFLGNBQWMsK0hBQStILHFDQUFxQyxzQ0FBc0MsRUFBRSxRQUFRLGFBQWEsd0RBQXdELFNBQVMsZUFBZSw0R0FBNEcsU0FBUyxHQUFHLFNBQVMsa09BQWtPLGNBQWMsMkJBQTJCLGNBQWMscURBQXFELGNBQWMsdUNBQXVDLGNBQWMsMkVBQTJFLG1CQUFtQix5QkFBeUIsNEJBQTRCLGdCQUFnQixzVEFBc1QsdUJBQXVCLFlBQVksRUFBRSx1VkFBdVYsY0FBYyxvREFBb0QsaUJBQWlCLG1CQUFtQix3RUFBd0UsY0FBYyxzQkFBc0IsY0FBYyxtQkFBbUIsNEJBQTRCLG1DQUFtQyxhQUFhLHFLQUFxSyx1QkFBdUIsd0NBQXdDLCtDQUErQyxvQkFBb0Isc0tBQXNLLEdBQUcsNEJBQTRCLGtCQUFrQixrREFBa0Qsd0RBQXdELGdCQUFnQix3QkFBd0IsOENBQThDLElBQUksV0FBVyxRQUFRLEtBQUssWUFBWSw2QkFBNkIsU0FBUyxnQkFBZ0IsNkJBQTZCLFNBQVMsVUFBVSxxQkFBcUIsaUJBQWlCLDhCQUE4QixZQUFZLHdCQUF3QiwrSEFBK0gsYUFBYSxpQ0FBaUMsWUFBWSxXQUFXLEVBQUUsVUFBVSxFQUFFLEdBQUcsWUFBWSx1QkFBdUIsRUFBRSxVQUFVLEVBQUUsSUFBSSxLQUFLLElBQUksY0FBYyxzREFBc0QsV0FBVyxJQUFJLGdDQUFnQywyREFBMkQsUUFBUSxnQ0FBZ0MsY0FBYyw0RkFBNEYsS0FBSyxJQUFJLGNBQWMsdUNBQXVDLEtBQUssbUJBQW1CLFlBQVksRUFBRSxvQ0FBb0MsY0FBYyxxQkFBcUIsTUFBTSxzREFBc0QsNkJBQTZCLElBQUksSUFBSSxTQUFTLGNBQWMsbUNBQW1DLGNBQWMsa0NBQWtDLDBDQUEwQyxjQUFjLG9DQUFvQyxNQUFNLHVGQUF1RixrQkFBa0IsRUFBRSxlQUFlLElBQUksSUFBSSxTQUFTLGlCQUFpQixzQ0FBc0MsR0FBRyxFQUFFLFdBQVcsZUFBZSxLQUFLLHdCQUF3QixpREFBaUQsU0FBUyxxQkFBcUIsaUJBQWlCLGtCQUFrQixlQUFlLFVBQVUsY0FBYyxLQUFLLGVBQWUsdUJBQXVCLHVCQUF1Qix5QkFBeUIsZ0JBQWdCLG1DQUFtQyx3RUFBd0UsRUFBRSxRQUFRLFdBQVcsaUJBQWlCLFFBQVEsc0lBQXNJLHdDQUF3QyxHQUFHLGlCQUFpQixFQUFFLDBDQUEwQyxJQUFJLFNBQVMscUJBQXFCLDJDQUEyQyxtQkFBbUIsbUJBQW1CLHVCQUF1QixtQkFBbUIsc0JBQXNCLG1CQUFtQix1QkFBdUIsb0JBQW9CLElBQUksdURBQXVELGNBQWMsc0VBQXNFLGVBQWUsRUFBRSxlQUFlLHlFQUF5RSxrQ0FBa0MsUUFBUSxZQUFZLHVCQUF1QixzQkFBc0IsNkJBQTZCLHdEQUF3RCxNQUFNLGlCQUFpQixzQkFBc0IsTUFBTSxrRUFBa0UsaUJBQWlCLG1CQUFtQixNQUFNLHlCQUF5QixrQkFBa0IsOENBQThDLG9CQUFvQixzQkFBc0IsTUFBTSxnREFBZ0QsMkJBQTJCLGtDQUFrQywyQkFBMkIsdUJBQXVCLG9CQUFvQiwwQkFBMEIsR0FBRyxNQUFNLG1CQUFtQixhQUFhLG9CQUFvQixJQUFJLEVBQUUsc0JBQXNCLG1CQUFtQixNQUFNLG1FQUFtRSxZQUFZLGFBQWEsa0JBQWtCLG9CQUFvQiwwQkFBMEIsV0FBVyxzQkFBc0IsYUFBYSxxQkFBcUIsZUFBZSxnQ0FBZ0MsYUFBYSxzQkFBc0IsZ0JBQWdCLDJDQUEyQyxZQUFZLGNBQWMsT0FBTyxvQkFBb0IsWUFBWSx1QkFBdUIsRUFBRSxhQUFhLHVEQUF1RCxTQUFTLHNCQUFzQixzQkFBc0Isa0JBQWtCLElBQUksVUFBVSxHQUFHLGFBQWEsY0FBYywwQ0FBMEMsK0JBQStCLFdBQVcsc0JBQXNCLDhCQUE4QixlQUFlLGNBQWMsSUFBSSxxQ0FBcUMsOEJBQThCLHlDQUF5QyxhQUFhLEtBQUssb0JBQW9CLGlCQUFpQixFQUFFLG9CQUFvQiwyQ0FBMkMsc0JBQXNCLHFCQUFxQixFQUFFLHNDQUFzQyxPQUFPLE9BQU8sd0RBQXdELDRDQUE0QyxRQUFRLCtRQUErUSxNQUFNLFNBQVMsa0JBQWtCLGFBQWEsNEJBQTRCLDRCQUE0QixrREFBa0Qsa0JBQWtCLG1CQUFtQixZQUFZLDRCQUE0QixZQUFZLFVBQVUsVUFBVSxLQUFLLEVBQUUsRUFBRSxNQUFNLDJCQUEyQixHQUFHLDBCQUEwQixpQkFBaUIsNERBQTRELDJCQUEyQixJQUFJLFVBQVUsTUFBTTs7Ozs7O1VDQTVwVDtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7VUVOQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lcnJvci1zdGFjay1wYXJzZXIvZXJyb3Itc3RhY2stcGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeS1zZWxlY3Rvci1zaGFkb3ctZG9tL3NyYy9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5LXNlbGVjdG9yLXNoYWRvdy1kb20vc3JjL3F1ZXJ5U2VsZWN0b3JEZWVwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9hcnJheS1zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC12bHEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2Jhc2U2NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvbWFwcGluZy1saXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9xdWljay1zb3J0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvc291cmNlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RhY2stZ2VuZXJhdG9yL25vZGVfbW9kdWxlcy9zdGFja2ZyYW1lL3N0YWNrZnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0YWNrLWdlbmVyYXRvci9zdGFjay1nZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0YWNrZnJhbWUvc3RhY2tmcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RhY2t0cmFjZS1ncHMvc3RhY2t0cmFjZS1ncHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0YWNrdHJhY2UtanMvc3RhY2t0cmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvX2luZnJhL0FpZmV4U2VydmljZUhUVFAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL19pbmZyYS9Ccm93c2VyU2VydmljZVNlc3Npb25TdG9yYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vQWN0aW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vQWlmZXhQbHVnaW5JbmZvLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vQXR0cmlidXRlVmFsdWVSdWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vQnJvd3NlclNjcmlwdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL0NTU0NvbnRleHRNYXBwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9DU1NTZWxlY3RvclJ1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9DU1NTZWxlY3RvcldpdGhWYWx1ZVJ1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9DbGFzc011dGF0aW9uSGFuZGxlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL0NvbnRleHRMZXNzTWFwcGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vQ29udGV4dE1hcHBlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL0V2ZW50TGlzdGVuZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9JbmRleFJ1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9Jbm5lclRleHRSdWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vUGFnZU11dGF0aW9uSGFuZGxlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL1J1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9SdWxlTWFwcGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vUnVsZVNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9TZXNzaW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vU2ltcGxlUnVsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL1VSTENvbnRleHRNYXBwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9WYWx1ZVJ1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9XZWJzaXRlLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vWFBhdGhDb250ZXh0TWFwcGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvTG9nZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvY29udHJvbC9DYXRlZ29yeVNlcnZpY2VDb250cm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9jb250cm9sL0xvZ0dyb3VwQ29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvZXh0ZW5zaW9uL0V4dGVuc2lvbkhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvZXh0ZW5zaW9uL0V4dGVuc2lvbk1lc3NhZ2VKU09OLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9leHRlbnNpb24vTWVzc2FnZXNGcm9tRXh0ZW5zaW9uSlNPTi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvZXh0ZW5zaW9uL01lc3NhZ2VzVG9FeHRlbnNpb25KU09OLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvTG9nZ2VyT3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0Fic3RyYWN0Q2F0ZWdvcnlMb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9jYXRlZ29yeS9DYXRlZ29yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5Q29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5Q29uc29sZUxvZ2dlckltcGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9jYXRlZ29yeS9DYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5TWVzc2FnZUJ1ZmZlckltcGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9jYXRlZ29yeS9DYXRlZ29yeVJ1bnRpbWVTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5U2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5U2VydmljZUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9zdGFuZGFyZC9BYnN0cmFjdExvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL3N0YW5kYXJkL0NvbnNvbGVMb2dnZXJJbXBsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvc3RhbmRhcmQvTEZTZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvc3RhbmRhcmQvTG9nR3JvdXBSdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvc3RhbmRhcmQvTG9nR3JvdXBSdW50aW1lU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9zdGFuZGFyZC9Mb2dnZXJGYWN0b3J5SW1wbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL3N0YW5kYXJkL0xvZ2dlckZhY3RvcnlPcHRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvc3RhbmRhcmQvTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL3R5cGVzY3JpcHQtbG9nZ2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvdXRpbHMvRGF0YVN0cnVjdHVyZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL3V0aWxzL0pTT05IZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL3V0aWxzL01lc3NhZ2VVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLXNlbGVjdG9yLWdlbmVyYXRvci9idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly8vd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly8vd2VicGFjay9zdGFydHVwIiwid2VicGFjazovLy93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnZXJyb3Itc3RhY2stcGFyc2VyJywgWydzdGFja2ZyYW1lJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdzdGFja2ZyYW1lJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuRXJyb3JTdGFja1BhcnNlciA9IGZhY3Rvcnkocm9vdC5TdGFja0ZyYW1lKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIoU3RhY2tGcmFtZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFAgPSAvKF58QClcXFMrXFw6XFxkKy87XG4gICAgdmFyIENIUk9NRV9JRV9TVEFDS19SRUdFWFAgPSAvXlxccyphdCAuKihcXFMrXFw6XFxkK3xcXChuYXRpdmVcXCkpL207XG4gICAgdmFyIFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFAgPSAvXihldmFsQCk/KFxcW25hdGl2ZSBjb2RlXFxdKT8kLztcblxuICAgIGZ1bmN0aW9uIF9tYXAoYXJyYXksIGZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlLm1hcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChmbiwgdGhpc0FyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gbmV3IEFycmF5KGFycmF5Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2ldID0gZm4uY2FsbCh0aGlzQXJnLCBhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZpbHRlcihhcnJheSwgZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZuLCB0aGlzQXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4uY2FsbCh0aGlzQXJnLCBhcnJheVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5kZXhPZihhcnJheSwgdGFyZ2V0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycmF5W2ldID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGFuIEVycm9yIG9iamVjdCwgZXh0cmFjdCB0aGUgbW9zdCBpbmZvcm1hdGlvbiBmcm9tIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7QXJyYXl9IG9mIFN0YWNrRnJhbWVzXG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2UoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3Iuc3RhY2t0cmFjZSAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGVycm9yWydvcGVyYSNzb3VyY2Vsb2MnXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhY2sgJiYgZXJyb3Iuc3RhY2subWF0Y2goQ0hST01FX0lFX1NUQUNLX1JFR0VYUCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVY4T3JJRShlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGRk9yU2FmYXJpKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgZ2l2ZW4gRXJyb3Igb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gU2VwYXJhdGUgbGluZSBhbmQgY29sdW1uIG51bWJlcnMgZnJvbSBhIHN0cmluZyBvZiB0aGUgZm9ybTogKFVSSTpMaW5lOkNvbHVtbilcbiAgICAgICAgZXh0cmFjdExvY2F0aW9uOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRleHRyYWN0TG9jYXRpb24odXJsTGlrZSkge1xuICAgICAgICAgICAgLy8gRmFpbC1mYXN0IGJ1dCByZXR1cm4gbG9jYXRpb25zIGxpa2UgXCIobmF0aXZlKVwiXG4gICAgICAgICAgICBpZiAodXJsTGlrZS5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt1cmxMaWtlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlZ0V4cCA9IC8oLis/KSg/OlxcOihcXGQrKSk/KD86XFw6KFxcZCspKT8kLztcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHJlZ0V4cC5leGVjKHVybExpa2UucmVwbGFjZSgvW1xcKFxcKV0vZywgJycpKTtcbiAgICAgICAgICAgIHJldHVybiBbcGFydHNbMV0sIHBhcnRzWzJdIHx8IHVuZGVmaW5lZCwgcGFydHNbM10gfHwgdW5kZWZpbmVkXTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZVY4T3JJRTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VWOE9ySUUoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IF9maWx0ZXIoZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gX21hcChmaWx0ZXJlZCwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyhldmFsICcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgYXdheSBldmFsIGluZm9ybWF0aW9uIHVudGlsIHdlIGltcGxlbWVudCBzdGFja3RyYWNlLmpzL3N0YWNrZnJhbWUjOFxuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9ldmFsIGNvZGUvZywgJ2V2YWwnKS5yZXBsYWNlKC8oXFwoZXZhbCBhdCBbXlxcKCldKil8KFxcKVxcLC4qJCkvZywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gbGluZS5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXChldmFsIGNvZGUvZywgJygnKS5zcGxpdCgvXFxzKy8pLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24odG9rZW5zLnBvcCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdG9rZW5zLmpvaW4oJyAnKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gX2luZGV4T2YoWydldmFsJywgJzxhbm9ueW1vdXM+J10sIGxvY2F0aW9uUGFydHNbMF0pID4gLTEgPyB1bmRlZmluZWQgOiBsb2NhdGlvblBhcnRzWzBdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKGZ1bmN0aW9uTmFtZSwgdW5kZWZpbmVkLCBmaWxlTmFtZSwgbG9jYXRpb25QYXJ0c1sxXSwgbG9jYXRpb25QYXJ0c1syXSwgbGluZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZUZGT3JTYWZhcmk6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlRkZPclNhZmFyaShlcnJvcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gX2ZpbHRlcihlcnJvci5zdGFjay5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWxpbmUubWF0Y2goU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIF9tYXAoZmlsdGVyZWQsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignID4gZXZhbCcpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIGxpbmUgKFxcZCspKD86ID4gZXZhbCBsaW5lIFxcZCspKiA+IGV2YWxcXDpcXGQrXFw6XFxkKy9nLCAnOiQxJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignQCcpID09PSAtMSAmJiBsaW5lLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIGV2YWwgZnJhbWVzIG9ubHkgaGF2ZSBmdW5jdGlvbiBuYW1lcyBhbmQgbm90aGluZyBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZShsaW5lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gbGluZS5zcGxpdCgnQCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0b2tlbnMuam9pbignQCcpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmE6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmEoZSkge1xuICAgICAgICAgICAgaWYgKCFlLnN0YWNrdHJhY2UgfHwgKGUubWVzc2FnZS5pbmRleE9mKCdcXG4nKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlLnNwbGl0KCdcXG4nKS5sZW5ndGggPiBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhOShlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWUuc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhMTAoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZU9wZXJhOTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTkoZSkge1xuICAgICAgICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspL2k7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBlLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMiwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTdGFja0ZyYW1lKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtYXRjaFsyXSwgbWF0Y2hbMV0sIHVuZGVmaW5lZCwgbGluZXNbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VPcGVyYTEwOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhMTAoZSkge1xuICAgICAgICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspKD86OiBJbiBmdW5jdGlvbiAoXFxTKykpPyQvaTtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IGUuc3RhY2t0cmFjZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgU3RhY2tGcmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFszXSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lc1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPcGVyYSAxMC42NSsgRXJyb3Iuc3RhY2sgdmVyeSBzaW1pbGFyIHRvIEZGL1NhZmFyaVxuICAgICAgICBwYXJzZU9wZXJhMTE6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmExMShlcnJvcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gX2ZpbHRlcihlcnJvci5zdGFjay5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFsaW5lLm1hdGNoKEZJUkVGT1hfU0FGQVJJX1NUQUNLX1JFR0VYUCkgJiYgIWxpbmUubWF0Y2goL15FcnJvciBjcmVhdGVkIGF0Lyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIF9tYXAoZmlsdGVyZWQsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gbGluZS5zcGxpdCgnQCcpO1xuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24odG9rZW5zLnBvcCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25DYWxsID0gKHRva2Vucy5zaGlmdCgpIHx8ICcnKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb25DYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPGFub255bW91cyBmdW5jdGlvbig6IChcXHcrKSk/Pi8sICckMicpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwoW15cXCldKlxcKS9nLCAnJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciBhcmdzUmF3O1xuICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGwubWF0Y2goL1xcKChbXlxcKV0qKVxcKS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NSYXcgPSBmdW5jdGlvbkNhbGwucmVwbGFjZSgvXlteXFwoXStcXCgoW15cXCldKilcXCkkLywgJyQxJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gKGFyZ3NSYXcgPT09IHVuZGVmaW5lZCB8fCBhcmdzUmF3ID09PSAnW2FyZ3VtZW50cyBub3QgYXZhaWxhYmxlXScpID9cbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDogYXJnc1Jhdy5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZShcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvblBhcnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICBsaW5lKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKTtcblxuIiwiLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cblxuXG4vLyBub3JtYWxpemUtc2VsZWN0b3ItcmV2LTAyLmpzXG4vKlxuICBhdXRob3I6IGt5bGUgc2ltcHNvbiAoQGdldGlmeSlcbiAgb3JpZ2luYWwgc291cmNlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9nZXRpZnkvOTY3OTM4MFxuXG4gIG1vZGlmaWVkIGZvciB0ZXN0cyBieSBkYXZpZCBrYXllIChAZGZrYXllKVxuICAyMSBtYXJjaCAyMDE0XG5cbiAgcmV2LTAyIGluY29ycG9yYXRlIGt5bGUncyBjaGFuZ2VzIDMvMi80MjAxNFxuKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdG9yKHNlbCkge1xuICAvLyBzYXZlIHVubWF0Y2hlZCB0ZXh0LCBpZiBhbnlcbiAgZnVuY3Rpb24gc2F2ZVVubWF0Y2hlZCgpIHtcbiAgICBpZiAodW5tYXRjaGVkKSB7XG4gICAgICAvLyB3aGl0ZXNwYWNlIG5lZWRlZCBhZnRlciBjb21iaW5hdG9yP1xuICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAwICYmIC9eW34rPl0kLy50ZXN0KHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKFwiIFwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2F2ZSB1bm1hdGNoZWQgdGV4dFxuICAgICAgdG9rZW5zLnB1c2godW5tYXRjaGVkKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdG9rZW5zID0gW10sXG4gICAgbWF0Y2gsXG4gICAgdW5tYXRjaGVkLFxuICAgIHJlZ2V4LFxuICAgIHN0YXRlID0gWzBdLFxuICAgIG5leHRfbWF0Y2hfaWR4ID0gMCxcbiAgICBwcmV2X21hdGNoX2lkeCxcbiAgICBub3RfZXNjYXBlZF9wYXR0ZXJuID0gLyg/OlteXFxcXF18KD86XnxbXlxcXFxdKSg/OlxcXFxcXFxcKSspJC8sXG4gICAgd2hpdGVzcGFjZV9wYXR0ZXJuID0gL15cXHMrJC8sXG4gICAgc3RhdGVfcGF0dGVybnMgPSBbXG4gICAgICAvXFxzK3xcXC9cXCp8W1wiJz5+K1soXS9nLCAvLyBnZW5lcmFsXG4gICAgICAvXFxzK3xcXC9cXCp8W1wiJ1tcXF0oKV0vZywgLy8gWy4uXSBzZXRcbiAgICAgIC9cXHMrfFxcL1xcKnxbXCInW1xcXSgpXS9nLCAvLyAoLi4pIHNldFxuICAgICAgbnVsbCwgLy8gc3RyaW5nIGxpdGVyYWwgKHBsYWNlaG9sZGVyKVxuICAgICAgL1xcKlxcLy9nLCAvLyBjb21tZW50XG4gICAgXTtcbiAgc2VsID0gc2VsLnRyaW0oKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdW5tYXRjaGVkID0gXCJcIjtcblxuICAgIHJlZ2V4ID0gc3RhdGVfcGF0dGVybnNbc3RhdGVbc3RhdGUubGVuZ3RoIC0gMV1dO1xuXG4gICAgcmVnZXgubGFzdEluZGV4ID0gbmV4dF9tYXRjaF9pZHg7XG4gICAgbWF0Y2ggPSByZWdleC5leGVjKHNlbCk7XG5cbiAgICAvLyBtYXRjaGVkIHRleHQgdG8gcHJvY2Vzcz9cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHByZXZfbWF0Y2hfaWR4ID0gbmV4dF9tYXRjaF9pZHg7XG4gICAgICBuZXh0X21hdGNoX2lkeCA9IHJlZ2V4Lmxhc3RJbmRleDtcblxuICAgICAgLy8gY29sbGVjdCB0aGUgcHJldmlvdXMgc3RyaW5nIGNodW5rIG5vdCBtYXRjaGVkIGJlZm9yZSB0aGlzIHRva2VuXG4gICAgICBpZiAocHJldl9tYXRjaF9pZHggPCBuZXh0X21hdGNoX2lkeCAtIG1hdGNoWzBdLmxlbmd0aCkge1xuICAgICAgICB1bm1hdGNoZWQgPSBzZWwuc3Vic3RyaW5nKFxuICAgICAgICAgIHByZXZfbWF0Y2hfaWR4LFxuICAgICAgICAgIG5leHRfbWF0Y2hfaWR4IC0gbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdlbmVyYWwsIFsgXSBwYWlyLCAoICkgcGFpcj9cbiAgICAgIGlmIChzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXSA8IDMpIHtcbiAgICAgICAgc2F2ZVVubWF0Y2hlZCgpO1xuXG4gICAgICAgIC8vIHN0YXJ0aW5nIGEgWyBdIHBhaXI/XG4gICAgICAgIGlmIChtYXRjaFswXSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICBzdGF0ZS5wdXNoKDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0YXJ0aW5nIGEgKCApIHBhaXI/XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09PSBcIihcIikge1xuICAgICAgICAgIHN0YXRlLnB1c2goMik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RhcnRpbmcgYSBzdHJpbmcgbGl0ZXJhbD9cbiAgICAgICAgZWxzZSBpZiAoL15bXCInXSQvLnRlc3QobWF0Y2hbMF0pKSB7XG4gICAgICAgICAgc3RhdGUucHVzaCgzKTtcbiAgICAgICAgICBzdGF0ZV9wYXR0ZXJuc1szXSA9IG5ldyBSZWdFeHAobWF0Y2hbMF0sIFwiZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGFydGluZyBhIGNvbW1lbnQ/XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09PSBcIi8qXCIpIHtcbiAgICAgICAgICBzdGF0ZS5wdXNoKDQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuZGluZyBhIFsgXSBvciAoICkgcGFpcj9cbiAgICAgICAgZWxzZSBpZiAoL15bXFxdKV0kLy50ZXN0KG1hdGNoWzBdKSAmJiBzdGF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3RhdGUucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxpbmcgd2hpdGVzcGFjZSBvciBhIGNvbWJpbmF0b3I/XG4gICAgICAgIGVsc2UgaWYgKC9eKD86XFxzK3xbfis+XSkkLy50ZXN0KG1hdGNoWzBdKSkge1xuICAgICAgICAgIC8vIG5lZWQgdG8gaW5zZXJ0IHdoaXRlc3BhY2UgYmVmb3JlP1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRva2Vucy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAhd2hpdGVzcGFjZV9wYXR0ZXJuLnRlc3QodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSkgJiZcbiAgICAgICAgICAgIHN0YXRlW3N0YXRlLmxlbmd0aCAtIDFdID09PSAwXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBhZGQgbm9ybWFsaXplZCB3aGl0ZXNwYWNlXG4gICAgICAgICAgICB0b2tlbnMucHVzaChcIiBcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZSBhdHRyaWJ1dGUgc2VsZWN0b3IgQ1NTIEw0XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgc3RhdGVbc3RhdGUubGVuZ3RoIC0gMV0gPT09IDEgJiZcbiAgICAgICAgICAgIHRva2Vucy5sZW5ndGggPT09IDUgJiZcbiAgICAgICAgICAgIHRva2Vuc1syXS5jaGFyQXQodG9rZW5zWzJdLmxlbmd0aCAtIDEpID09PSBcIj1cIlxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdG9rZW5zWzRdID0gXCIgXCIgKyB0b2tlbnNbNF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gd2hpdGVzcGFjZSB0b2tlbiB3ZSBjYW4gc2tpcD9cbiAgICAgICAgICBpZiAod2hpdGVzcGFjZV9wYXR0ZXJuLnRlc3QobWF0Y2hbMF0pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzYXZlIG1hdGNoZWQgdGV4dFxuICAgICAgICB0b2tlbnMucHVzaChtYXRjaFswXSk7XG4gICAgICB9XG4gICAgICAvLyBvdGhlcndpc2UsIHN0cmluZyBsaXRlcmFsIG9yIGNvbW1lbnRcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBzYXZlIHVubWF0Y2hlZCB0ZXh0XG4gICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0gKz0gdW5tYXRjaGVkO1xuXG4gICAgICAgIC8vIHVuZXNjYXBlZCB0ZXJtaW5hdG9yIHRvIHN0cmluZyBsaXRlcmFsIG9yIGNvbW1lbnQ/XG4gICAgICAgIGlmIChub3RfZXNjYXBlZF9wYXR0ZXJuLnRlc3QodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAvLyBjb21tZW50IHRlcm1pbmF0b3I/XG4gICAgICAgICAgaWYgKHN0YXRlW3N0YXRlLmxlbmd0aCAtIDFdID09PSA0KSB7XG4gICAgICAgICAgICAvLyBvayB0byBkcm9wIGNvbW1lbnQ/XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHRva2Vucy5sZW5ndGggPCAyIHx8XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2VfcGF0dGVybi50ZXN0KHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMl0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCB0dXJuIGNvbW1lbnQgaW50byB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSA9IFwiIFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoYW5kbGVkIGFscmVhZHlcbiAgICAgICAgICAgIG1hdGNoWzBdID0gXCJcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGF0ZS5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGVuZCBtYXRjaGVkIHRleHQgdG8gZXhpc3RpbmcgdG9rZW5cbiAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSArPSBtYXRjaFswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlLCBlbmQgb2YgcHJvY2Vzc2luZyAobm8gbW9yZSBtYXRjaGVzKVxuICAgIGVsc2Uge1xuICAgICAgdW5tYXRjaGVkID0gc2VsLnN1YnN0cihuZXh0X21hdGNoX2lkeCk7XG4gICAgICBzYXZlVW5tYXRjaGVkKCk7XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b2tlbnMuam9pbihcIlwiKS50cmltKCk7XG59XG4iLCIvKipcbiAqIEBhdXRob3IgR2VvcmdlZ3JpZmZAIChHZW9yZ2UgR3JpZmZpdGhzKVxuICogTGljZW5zZSBBcGFjaGUtMi4wXG4gKi9cblxuaW1wb3J0IHsgbm9ybWFsaXplU2VsZWN0b3IgfSBmcm9tICcuL25vcm1hbGl6ZSc7XG5cbi8qKlxuKiBGaW5kcyBmaXJzdCBtYXRjaGluZyBlbGVtZW50cyBvbiB0aGUgcGFnZSB0aGF0IG1heSBiZSBpbiBhIHNoYWRvdyByb290IHVzaW5nIGEgY29tcGxleCBzZWxlY3RvciBvZiBuLWRlcHRoXG4qXG4qIERvbid0IGhhdmUgdG8gc3BlY2lmeSBhbGwgc2hhZG93IHJvb3RzIHRvIGJ1dHRvbiwgdHJlZSBpcyB0cmF2ZXJlZCB0byBmaW5kIHRoZSBjb3JyZWN0IGVsZW1lbnRcbipcbiogRXhhbXBsZSBxdWVyeVNlbGVjdG9yQWxsRGVlcCgnZG93bmxvYWRzLWl0ZW06bnRoLWNoaWxkKDQpICNyZW1vdmUnKTtcbipcbiogRXhhbXBsZSBzaG91bGQgd29yayBvbiBjaHJvbWU6Ly9kb3dubG9hZHMgb3V0cHV0dGluZyB0aGUgcmVtb3ZlIGJ1dHRvbiBpbnNpZGUgb2YgYSBkb3dubG9hZCBjYXJkIGNvbXBvbmVudFxuKlxuKiBFeGFtcGxlIGZpbmQgZmlyc3QgYWN0aXZlIGRvd25sb2FkIGxpbmsgZWxlbWVudCBxdWVyeVNlbGVjdG9yRGVlcCgnI2Rvd25sb2Fkcy1saXN0IC5pcy1hY3RpdmUgYVtocmVmXj1cImh0dHBzOi8vXCJdJyk7XG4qXG4qIEFub3RoZXIgZXhhbXBsZSBxdWVyeVNlbGVjdG9yQWxsRGVlcCgnI2Rvd25sb2Fkcy1saXN0IGRpdiN0aXRsZS1hcmVhICsgYScpO1xuZS5nLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsRGVlcChzZWxlY3Rvciwgcm9vdCA9IGRvY3VtZW50LCBhbGxFbGVtZW50cyA9IG51bGwpIHtcbiAgICByZXR1cm4gX3F1ZXJ5U2VsZWN0b3JEZWVwKHNlbGVjdG9yLCB0cnVlLCByb290LCBhbGxFbGVtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yRGVlcChzZWxlY3Rvciwgcm9vdCA9IGRvY3VtZW50LCBhbGxFbGVtZW50cyA9IG51bGwpIHtcbiAgICByZXR1cm4gX3F1ZXJ5U2VsZWN0b3JEZWVwKHNlbGVjdG9yLCBmYWxzZSwgcm9vdCwgYWxsRWxlbWVudHMpO1xufVxuXG5mdW5jdGlvbiBfcXVlcnlTZWxlY3RvckRlZXAoc2VsZWN0b3IsIGZpbmRNYW55LCByb290LCBhbGxFbGVtZW50cyA9IG51bGwpIHtcbiAgICBzZWxlY3RvciA9IG5vcm1hbGl6ZVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBsZXQgbGlnaHRFbGVtZW50ID0gcm9vdC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcblxuICAgIGlmIChkb2N1bWVudC5oZWFkLmNyZWF0ZVNoYWRvd1Jvb3QgfHwgZG9jdW1lbnQuaGVhZC5hdHRhY2hTaGFkb3cpIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBkbyBhbnkgc3BlY2lhbCBpZiBzZWxlY3RvciBtYXRjaGVzIHNvbWV0aGluZyBzcGVjaWZpYyBpbiBsaWdodC1kb21cbiAgICAgICAgaWYgKCFmaW5kTWFueSAmJiBsaWdodEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBsaWdodEVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzcGxpdCBvbiBjb21tYXMgYmVjYXVzZSB0aG9zZSBhcmUgYSBsb2dpY2FsIGRpdmlkZSBpbiB0aGUgb3BlcmF0aW9uXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbnNUb01ha2UgPSBzcGxpdEJ5Q2hhcmFjdGVyVW5sZXNzUXVvdGVkKHNlbGVjdG9yLCAnLCcpO1xuXG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25zVG9NYWtlLnJlZHVjZSgoYWNjLCBtaW5pbWFsU2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBmaW5kaW5nIG1hbnkganVzdCByZWR1Y2UgdGhlIGZpcnN0IG1hdGNoXG4gICAgICAgICAgICBpZiAoIWZpbmRNYW55ICYmIGFjYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkbyBiZXN0IHRvIHN1cHBvcnQgY29tcGxleCBzZWxlY3RvcnMgYW5kIHNwbGl0IHRoZSBxdWVyeVxuICAgICAgICAgICAgY29uc3Qgc3BsaXRTZWxlY3RvciA9IHNwbGl0QnlDaGFyYWN0ZXJVbmxlc3NRdW90ZWQobWluaW1hbFNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHdoaXRlIHNwYWNlIGF0IHN0YXJ0IG9mIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzKy9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xccyooWz4rfl0rKVxccyovZywgJyQxJyksICcgJylcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBlbnRyeSB3aGl0ZSBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZW50cnkpID0+ICEhZW50cnkpXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgXCJhID4gYlwiIHRvIFtcImFcIiwgXCJiXCJdXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGVudHJ5KSA9PiBzcGxpdEJ5Q2hhcmFjdGVyVW5sZXNzUXVvdGVkKGVudHJ5LCAnPicpKTtcblxuICAgICAgICAgICAgY29uc3QgcG9zc2libGVFbGVtZW50c0luZGV4ID0gc3BsaXRTZWxlY3Rvci5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29uc3QgbGFzdFNwbGl0UGFydCA9IHNwbGl0U2VsZWN0b3JbcG9zc2libGVFbGVtZW50c0luZGV4XVtzcGxpdFNlbGVjdG9yW3Bvc3NpYmxlRWxlbWVudHNJbmRleF0ubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZUVsZW1lbnRzID0gY29sbGVjdEFsbEVsZW1lbnRzRGVlcChsYXN0U3BsaXRQYXJ0LCByb290LCBhbGxFbGVtZW50cyk7XG4gICAgICAgICAgICBjb25zdCBmaW5kRWxlbWVudHMgPSBmaW5kTWF0Y2hpbmdFbGVtZW50KHNwbGl0U2VsZWN0b3IsIHBvc3NpYmxlRWxlbWVudHNJbmRleCwgcm9vdCk7XG4gICAgICAgICAgICBpZiAoZmluZE1hbnkpIHtcbiAgICAgICAgICAgICAgICBhY2MgPSBhY2MuY29uY2F0KHBvc3NpYmxlRWxlbWVudHMuZmlsdGVyKGZpbmRFbGVtZW50cykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjYyA9IHBvc3NpYmxlRWxlbWVudHMuZmluZChmaW5kRWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZmluZE1hbnkgPyBbXSA6IG51bGwpO1xuXG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWZpbmRNYW55KSB7XG4gICAgICAgICAgICByZXR1cm4gbGlnaHRFbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJvb3QucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gZmluZE1hdGNoaW5nRWxlbWVudChzcGxpdFNlbGVjdG9yLCBwb3NzaWJsZUVsZW1lbnRzSW5kZXgsIHJvb3QpIHtcbiAgICByZXR1cm4gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gcG9zc2libGVFbGVtZW50c0luZGV4O1xuICAgICAgICBsZXQgcGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgbGV0IGZvdW5kRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAocGFyZW50ICYmICFpc0RvY3VtZW50Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgICAgICBsZXQgZm91bmRNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoc3BsaXRTZWxlY3Rvcltwb3NpdGlvbl0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZm91bmRNYXRjaCA9IHBhcmVudC5tYXRjaGVzKHNwbGl0U2VsZWN0b3JbcG9zaXRpb25dKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0b3IgaXMgaW4gdGhlIGZvcm1hdCBcImEgPiBiXCJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgYSBmZXcgcGFyZW50cyBtYXRjaCBpbiBvcmRlclxuICAgICAgICAgICAgICAgIGNvbnN0IHJldmVyc2VkUGFydHMgPSAoW10pLmNvbmNhdChzcGxpdFNlbGVjdG9yW3Bvc2l0aW9uXSkucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIGxldCBuZXdQYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHJldmVyc2VkUGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdQYXJlbnQgfHwgIW5ld1BhcmVudC5tYXRjaGVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZE1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdQYXJlbnQgPSBmaW5kUGFyZW50T3JIb3N0KG5ld1BhcmVudCwgcm9vdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZm91bmRNYXRjaCAmJiBwb3NpdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZvdW5kRWxlbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmRNYXRjaCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBmaW5kUGFyZW50T3JIb3N0KHBhcmVudCwgcm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kRWxlbWVudDtcbiAgICB9O1xuXG59XG5cbmZ1bmN0aW9uIHNwbGl0QnlDaGFyYWN0ZXJVbmxlc3NRdW90ZWQoc2VsZWN0b3IsIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBzZWxlY3Rvci5tYXRjaCgvXFxcXD8ufF4kL2cpLnJlZHVjZSgocCwgYykgPT4ge1xuICAgICAgICBpZiAoYyA9PT0gJ1wiJyAmJiAhcC5zUXVvdGUpIHtcbiAgICAgICAgICAgIHAucXVvdGUgXj0gMTtcbiAgICAgICAgICAgIHAuYVtwLmEubGVuZ3RoIC0gMV0gKz0gYztcbiAgICAgICAgfSBlbHNlIGlmIChjID09PSAnXFwnJyAmJiAhcC5xdW90ZSkge1xuICAgICAgICAgICAgcC5zUXVvdGUgXj0gMTtcbiAgICAgICAgICAgIHAuYVtwLmEubGVuZ3RoIC0gMV0gKz0gYztcblxuICAgICAgICB9IGVsc2UgaWYgKCFwLnF1b3RlICYmICFwLnNRdW90ZSAmJiBjID09PSBjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHAuYS5wdXNoKCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAuYVtwLmEubGVuZ3RoIC0gMV0gKz0gYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9LCB7IGE6IFsnJ10gfSkuYTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIG5vZGUgaXMgYSBkb2N1bWVudCBub2RlIG9yIG5vdC5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHJldHVybnMge25vZGUgaXMgRG9jdW1lbnQgfCBEb2N1bWVudEZyYWdtZW50fVxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREU7XG59XG5cbmZ1bmN0aW9uIGZpbmRQYXJlbnRPckhvc3QoZWxlbWVudCwgcm9vdCkge1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuaG9zdCAmJiBwYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMSkgPyBwYXJlbnROb2RlLmhvc3QgOiBwYXJlbnROb2RlID09PSByb290ID8gbnVsbCA6IHBhcmVudE5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgYWxsIGVsZW1lbnRzIG9uIHRoZSBwYWdlLCBpbmNsdXNpdmUgb2YgdGhvc2Ugd2l0aGluIHNoYWRvdyByb290cy5cbiAqIEBwYXJhbSB7c3RyaW5nPX0gc2VsZWN0b3IgU2ltcGxlIHNlbGVjdG9yIHRvIGZpbHRlciB0aGUgZWxlbWVudHMgYnkuIGUuZy4gJ2EnLCAnZGl2Lm1haW4nXG4gKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn0gTGlzdCBvZiBhbmNob3IgaHJlZnMuXG4gKiBAYXV0aG9yIGViaWRlbEAgKEVyaWMgQmlkZWxtYW4pXG4gKiBMaWNlbnNlIEFwYWNoZS0yLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RBbGxFbGVtZW50c0RlZXAoc2VsZWN0b3IgPSBudWxsLCByb290LCBjYWNoZWRFbGVtZW50cyA9IG51bGwpIHtcbiAgICBsZXQgYWxsRWxlbWVudHMgPSBbXTtcblxuICAgIGlmIChjYWNoZWRFbGVtZW50cykge1xuICAgICAgICBhbGxFbGVtZW50cyA9IGNhY2hlZEVsZW1lbnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZpbmRBbGxFbGVtZW50cyA9IGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWwgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBhbGxFbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBzaGFkb3cgcm9vdCwgZGlnIGRlZXBlci5cbiAgICAgICAgICAgICAgICBpZiAoZWwuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICBmaW5kQWxsRWxlbWVudHMoZWwuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYocm9vdC5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICBmaW5kQWxsRWxlbWVudHMocm9vdC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluZEFsbEVsZW1lbnRzKHJvb3QucXVlcnlTZWxlY3RvckFsbCgnKicpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0b3IgPyBhbGxFbGVtZW50cy5maWx0ZXIoZWwgPT4gZWwubWF0Y2hlcyhzZWxlY3RvcikpIDogYWxsRWxlbWVudHM7XHR9XG5cbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggaXMgYSBjb21iaW5hdGlvbiBvZiBhbiBhcnJheSBhbmQgYSBzZXQuIEFkZGluZyBhIG5ld1xuICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gKiBlbGVtZW50IGlzIE8oMSkuIFJlbW92aW5nIGVsZW1lbnRzIGZyb20gdGhlIHNldCBpcyBub3Qgc3VwcG9ydGVkLiBPbmx5XG4gKiBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQgZm9yIG1lbWJlcnNoaXAuXG4gKi9cbmZ1bmN0aW9uIEFycmF5U2V0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG4vKipcbiAqIFN0YXRpYyBtZXRob2QgZm9yIGNyZWF0aW5nIEFycmF5U2V0IGluc3RhbmNlcyBmcm9tIGFuIGV4aXN0aW5nIGFycmF5LlxuICovXG5BcnJheVNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF9mcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzZXQgPSBuZXcgQXJyYXlTZXQoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHNldC5hZGQoYUFycmF5W2ldLCBhQWxsb3dEdXBsaWNhdGVzKTtcbiAgfVxuICByZXR1cm4gc2V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICogYWRkZWQsIHRoYW4gdGhvc2UgZG8gbm90IGNvdW50IHRvd2FyZHMgdGhlIHNpemUuXG4gKlxuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gQXJyYXlTZXRfc2l6ZSgpIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgdmFyIGlzRHVwbGljYXRlID0gaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgfVxuICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgdGhpcy5fc2V0W3NTdHJdID0gaWR4O1xuICB9XG59O1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHJldHVybiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBhcnJheT9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICBpZiAoaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKSkge1xuICAgIHJldHVybiB0aGlzLl9zZXRbc1N0cl07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAqXG4gKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICogaW5kaWNhdGVkIGJ5IGluZGV4T2YpLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIGFycmF5IHVzZWRcbiAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG59O1xuXG5leHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4vLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbi8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4vLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4vLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbi8vXG4vLyAgIENvbnRpbnVhdGlvblxuLy8gICB8ICAgIFNpZ25cbi8vICAgfCAgICB8XG4vLyAgIFYgICAgVlxuLy8gICAxMDEwMTFcblxudmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbi8vIGJpbmFyeTogMDExMTExXG52YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4vKipcbiAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gKi9cbmZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICByZXR1cm4gYVZhbHVlIDwgMFxuICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gKi9cbmZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgID8gLXNoaWZ0ZWRcbiAgICA6IHNoaWZ0ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gIHZhciBkaWdpdDtcblxuICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICBkbyB7XG4gICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgIH1cbiAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSAwO1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICBkbyB7XG4gICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICB9XG5cbiAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgaWYgKGRpZ2l0ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgIH1cblxuICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gIGFPdXRQYXJhbS5yZXN0ID0gYUluZGV4O1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGludFRvQ2hhck1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJy5zcGxpdCgnJyk7XG5cbi8qKlxuICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIGlmICgwIDw9IG51bWJlciAmJiBudW1iZXIgPCBpbnRUb0NoYXJNYXAubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGludFRvQ2hhck1hcFtudW1iZXJdO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNdXN0IGJlIGJldHdlZW4gMCBhbmQgNjM6IFwiICsgbnVtYmVyKTtcbn07XG5cbi8qKlxuICogRGVjb2RlIGEgc2luZ2xlIGJhc2UgNjQgY2hhcmFjdGVyIGNvZGUgZGlnaXQgdG8gYW4gaW50ZWdlci4gUmV0dXJucyAtMSBvblxuICogZmFpbHVyZS5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgdmFyIGJpZ0EgPSA2NTsgICAgIC8vICdBJ1xuICB2YXIgYmlnWiA9IDkwOyAgICAgLy8gJ1onXG5cbiAgdmFyIGxpdHRsZUEgPSA5NzsgIC8vICdhJ1xuICB2YXIgbGl0dGxlWiA9IDEyMjsgLy8gJ3onXG5cbiAgdmFyIHplcm8gPSA0ODsgICAgIC8vICcwJ1xuICB2YXIgbmluZSA9IDU3OyAgICAgLy8gJzknXG5cbiAgdmFyIHBsdXMgPSA0MzsgICAgIC8vICcrJ1xuICB2YXIgc2xhc2ggPSA0NzsgICAgLy8gJy8nXG5cbiAgdmFyIGxpdHRsZU9mZnNldCA9IDI2O1xuICB2YXIgbnVtYmVyT2Zmc2V0ID0gNTI7XG5cbiAgLy8gMCAtIDI1OiBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlxuICBpZiAoYmlnQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBiaWdaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGJpZ0EpO1xuICB9XG5cbiAgLy8gMjYgLSA1MTogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcbiAgaWYgKGxpdHRsZUEgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbGl0dGxlWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBsaXR0bGVBICsgbGl0dGxlT2Zmc2V0KTtcbiAgfVxuXG4gIC8vIDUyIC0gNjE6IDAxMjM0NTY3ODlcbiAgaWYgKHplcm8gPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbmluZSkge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSB6ZXJvICsgbnVtYmVyT2Zmc2V0KTtcbiAgfVxuXG4gIC8vIDYyOiArXG4gIGlmIChjaGFyQ29kZSA9PSBwbHVzKSB7XG4gICAgcmV0dXJuIDYyO1xuICB9XG5cbiAgLy8gNjM6IC9cbiAgaWYgKGNoYXJDb2RlID09IHNsYXNoKSB7XG4gICAgcmV0dXJuIDYzO1xuICB9XG5cbiAgLy8gSW52YWxpZCBiYXNlNjQgZGlnaXQuXG4gIHJldHVybiAtMTtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL1xuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC0taW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDE0IE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIG1hcHBpbmdCIGlzIGFmdGVyIG1hcHBpbmdBIHdpdGggcmVzcGVjdCB0byBnZW5lcmF0ZWRcbiAqIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAvLyBPcHRpbWl6ZWQgZm9yIG1vc3QgY29tbW9uIGNhc2VcbiAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGxpbmVCID0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGNvbHVtbkEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW47XG4gIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICByZXR1cm4gbGluZUIgPiBsaW5lQSB8fCBsaW5lQiA9PSBsaW5lQSAmJiBjb2x1bW5CID49IGNvbHVtbkEgfHxcbiAgICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSA8PSAwO1xufVxuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgdG8gcHJvdmlkZSBhIHNvcnRlZCB2aWV3IG9mIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIGFcbiAqIHBlcmZvcm1hbmNlIGNvbnNjaW91cyBtYW5uZXIuIEl0IHRyYWRlcyBhIG5lZ2xpYmFibGUgb3ZlcmhlYWQgaW4gZ2VuZXJhbFxuICogY2FzZSBmb3IgYSBsYXJnZSBzcGVlZHVwIGluIGNhc2Ugb2YgbWFwcGluZ3MgYmVpbmcgYWRkZWQgaW4gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmdMaXN0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAvLyBTZXJ2ZXMgYXMgaW5maW11bVxuICB0aGlzLl9sYXN0ID0ge2dlbmVyYXRlZExpbmU6IC0xLCBnZW5lcmF0ZWRDb2x1bW46IDB9O1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAqIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgdGFrZXMuXG4gKlxuICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnVuc29ydGVkRm9yRWFjaCA9XG4gIGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2ZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZykge1xuICAgIHRoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZyk7XG4gIH07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzb3VyY2UgbWFwcGluZy5cbiAqXG4gKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF9hZGQoYU1hcHBpbmcpIHtcbiAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIodGhpcy5fbGFzdCwgYU1hcHBpbmcpKSB7XG4gICAgdGhpcy5fbGFzdCA9IGFNYXBwaW5nO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAqIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqXG4gKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAqIHBlcmZvcm1hbmNlLiBUaGUgcmV0dXJuIHZhbHVlIG11c3QgTk9UIGJlIG11dGF0ZWQsIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICogYW4gaW1tdXRhYmxlIGJvcnJvdy4gSWYgeW91IHdhbnQgdG8gdGFrZSBvd25lcnNoaXAsIHlvdSBtdXN0IG1ha2UgeW91ciBvd25cbiAqIGNvcHkuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfdG9BcnJheSgpIHtcbiAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICB0aGlzLl9hcnJheS5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQpO1xuICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5O1xufTtcblxuZXhwb3J0cy5NYXBwaW5nTGlzdCA9IE1hcHBpbmdMaXN0O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vLyBJdCB0dXJucyBvdXQgdGhhdCBzb21lIChtb3N0PykgSmF2YVNjcmlwdCBlbmdpbmVzIGRvbid0IHNlbGYtaG9zdFxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YC4gVGhpcyBtYWtlcyBzZW5zZSBiZWNhdXNlIEMrKyB3aWxsIGxpa2VseSByZW1haW5cbi8vIGZhc3RlciB0aGFuIEpTIHdoZW4gZG9pbmcgcmF3IENQVS1pbnRlbnNpdmUgc29ydGluZy4gSG93ZXZlciwgd2hlbiB1c2luZyBhXG4vLyBjdXN0b20gY29tcGFyYXRvciBmdW5jdGlvbiwgY2FsbGluZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZSBWTSdzIEMrKyBhbmRcbi8vIEpJVCdkIEpTIGlzIHJhdGhlciBzbG93ICphbmQqIGxvc2VzIEpJVCB0eXBlIGluZm9ybWF0aW9uLCByZXN1bHRpbmcgaW5cbi8vIHdvcnNlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgY29tcGFyYXRvciBmdW5jdGlvbiB0aGFuIHdvdWxkIGJlIG9wdGltYWwuIEluXG4vLyBmYWN0LCB3aGVuIHNvcnRpbmcgd2l0aCBhIGNvbXBhcmF0b3IsIHRoZXNlIGNvc3RzIG91dHdlaWdoIHRoZSBiZW5lZml0cyBvZlxuLy8gc29ydGluZyBpbiBDKysuIEJ5IHVzaW5nIG91ciBvd24gSlMtaW1wbGVtZW50ZWQgUXVpY2sgU29ydCAoYmVsb3cpLCB3ZSBnZXRcbi8vIGEgfjM1MDBtcyBtZWFuIHNwZWVkLXVwIGluIGBiZW5jaC9iZW5jaC5odG1sYC5cblxuLyoqXG4gKiBTd2FwIHRoZSBlbGVtZW50cyBpbmRleGVkIGJ5IGB4YCBhbmQgYHlgIGluIHRoZSBhcnJheSBgYXJ5YC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBUaGUgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgaXRlbS5cbiAqL1xuZnVuY3Rpb24gc3dhcChhcnksIHgsIHkpIHtcbiAgdmFyIHRlbXAgPSBhcnlbeF07XG4gIGFyeVt4XSA9IGFyeVt5XTtcbiAgYXJ5W3ldID0gdGVtcDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBgbG93IC4uIGhpZ2hgIGluY2x1c2l2ZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbG93XG4gKiAgICAgICAgVGhlIGxvd2VyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gKiAgICAgICAgVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShsb3csIGhpZ2gpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobG93ICsgKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpKTtcbn1cblxuLyoqXG4gKiBUaGUgUXVpY2sgU29ydCBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gcFxuICogICAgICAgIFN0YXJ0IGluZGV4IG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAqICAgICAgICBFbmQgaW5kZXggb2YgdGhlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcikge1xuICAvLyBJZiBvdXIgbG93ZXIgYm91bmQgaXMgbGVzcyB0aGFuIG91ciB1cHBlciBib3VuZCwgd2UgKDEpIHBhcnRpdGlvbiB0aGVcbiAgLy8gYXJyYXkgaW50byB0d28gcGllY2VzIGFuZCAoMikgcmVjdXJzZSBvbiBlYWNoIGhhbGYuIElmIGl0IGlzIG5vdCwgdGhpcyBpc1xuICAvLyB0aGUgZW1wdHkgYXJyYXkgYW5kIG91ciBiYXNlIGNhc2UuXG5cbiAgaWYgKHAgPCByKSB7XG4gICAgLy8gKDEpIFBhcnRpdGlvbmluZy5cbiAgICAvL1xuICAgIC8vIFRoZSBwYXJ0aXRpb25pbmcgY2hvb3NlcyBhIHBpdm90IGJldHdlZW4gYHBgIGFuZCBgcmAgYW5kIG1vdmVzIGFsbFxuICAgIC8vIGVsZW1lbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QgdG8gdGhlIGJlZm9yZSBpdCwgYW5kXG4gICAgLy8gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gaXQgYWZ0ZXIgaXQuIFRoZSBlZmZlY3QgaXMgdGhhdFxuICAgIC8vIG9uY2UgcGFydGl0aW9uIGlzIGRvbmUsIHRoZSBwaXZvdCBpcyBpbiB0aGUgZXhhY3QgcGxhY2UgaXQgd2lsbCBiZSB3aGVuXG4gICAgLy8gdGhlIGFycmF5IGlzIHB1dCBpbiBzb3J0ZWQgb3JkZXIsIGFuZCBpdCB3aWxsIG5vdCBuZWVkIHRvIGJlIG1vdmVkXG4gICAgLy8gYWdhaW4uIFRoaXMgcnVucyBpbiBPKG4pIHRpbWUuXG5cbiAgICAvLyBBbHdheXMgY2hvb3NlIGEgcmFuZG9tIHBpdm90IHNvIHRoYXQgYW4gaW5wdXQgYXJyYXkgd2hpY2ggaXMgcmV2ZXJzZVxuICAgIC8vIHNvcnRlZCBkb2VzIG5vdCBjYXVzZSBPKG5eMikgcnVubmluZyB0aW1lLlxuICAgIHZhciBwaXZvdEluZGV4ID0gcmFuZG9tSW50SW5SYW5nZShwLCByKTtcbiAgICB2YXIgaSA9IHAgLSAxO1xuXG4gICAgc3dhcChhcnksIHBpdm90SW5kZXgsIHIpO1xuICAgIHZhciBwaXZvdCA9IGFyeVtyXTtcblxuICAgIC8vIEltbWVkaWF0ZWx5IGFmdGVyIGBqYCBpcyBpbmNyZW1lbnRlZCBpbiB0aGlzIGxvb3AsIHRoZSBmb2xsb3dpbmcgaG9sZFxuICAgIC8vIHRydWU6XG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W3AgLi4gaV1gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QuXG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W2krMSAuLiBqLTFdYCBpcyBncmVhdGVyIHRoYW4gdGhlIHBpdm90LlxuICAgIGZvciAodmFyIGogPSBwOyBqIDwgcjsgaisrKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnlbal0sIHBpdm90KSA8PSAwKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgdmFyIHEgPSBpICsgMTtcblxuICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcSArIDEsIHIpO1xuICB9XG59XG5cbi8qKlxuICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqL1xuZXhwb3J0cy5xdWlja1NvcnQgPSBmdW5jdGlvbiAoYXJ5LCBjb21wYXJhdG9yKSB7XG4gIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgMCwgYXJ5Lmxlbmd0aCAtIDEpO1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgcXVpY2tTb3J0ID0gcmVxdWlyZSgnLi9xdWljay1zb3J0JykucXVpY2tTb3J0O1xuXG5mdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApXG4gICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApO1xufVxuXG5Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCkge1xuICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApO1xufVxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbi8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4vLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4vLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbi8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbi8vXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuLy9cbi8vICAgICB7XG4vLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4vLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuLy8gICAgICAgICAgICAgY29kZS5cbi8vICAgICB9XG4vL1xuLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuLy8gYG51bGxgLlxuLy9cbi8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4vL1xuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19vcmlnaW5hbE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX29yaWdpbmFsTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBhU3RyLmNoYXJBdChpbmRleCk7XG4gICAgcmV0dXJuIGMgPT09IFwiO1wiIHx8IGMgPT09IFwiLFwiO1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgX3BhcnNlTWFwcGluZ3NcIik7XG4gIH07XG5cblNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUiA9IDI7XG5cblNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICpcbiAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gKiBAcGFyYW0gT2JqZWN0IGFDb250ZXh0XG4gKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAqIEBwYXJhbSBhT3JkZXJcbiAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICogICAgICAgIGl0ZXJhdGUgb3ZlciB0aGUgbWFwcGluZ3Mgc29ydGVkIGJ5IHRoZSBnZW5lcmF0ZWQgZmlsZSdzIGxpbmUvY29sdW1uXG4gKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5lYWNoTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgIHZhciBjb250ZXh0ID0gYUNvbnRleHQgfHwgbnVsbDtcbiAgICB2YXIgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgdmFyIG1hcHBpbmdzO1xuICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuc291cmNlUm9vdDtcbiAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lID09PSBudWxsID8gbnVsbCA6IHRoaXMuX25hbWVzLmF0KG1hcHBpbmcubmFtZSlcbiAgICAgIH07XG4gICAgfSwgdGhpcykuZm9yRWFjaChhQ2FsbGJhY2ssIGNvbnRleHQpO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHByb3ZpZGVkLiBJZiBubyBjb2x1bW4gaXMgcHJvdmlkZWQsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0XG4gKiBjbG9zZXN0IGxpbmUgdGhhdCBoYXMgYW55IG1hcHBpbmdzLiBPdGhlcndpc2UsIHJldHVybnMgYWxsIG1hcHBpbmdzXG4gKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBsaW5lIGFuZCBlaXRoZXIgdGhlIGNvbHVtbiB3ZSBhcmUgc2VhcmNoaW5nIGZvclxuICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuXG4gKlxuICogVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgdmFyIGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yXG4gICAgLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgb3JpZ2luYWxMaW5lOiBsaW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJywgMClcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBuZWVkbGUuc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIG5lZWRsZS5zb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKG5lZWRsZS5zb3VyY2UpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIG5lZWRsZS5zb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobmVlZGxlLnNvdXJjZSk7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSBbXTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKGFBcmdzLmNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIGZvdW5kLiBTaW5jZVxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGZvdW5kLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gb3JpZ2luYWxMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgLy8gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBsaW5lICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID09IG9yaWdpbmFsQ29sdW1uKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5ncztcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gKiBxdWVyeSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGZpbGUgcG9zaXRpb25zIGJ5IGdpdmluZyBpdCBhIGZpbGVcbiAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICpcbiAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICpcbiAqICAgICB7XG4gKiAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gKiAgICAgfVxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICovXG5mdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHNvdXJjZXMgPSBzb3VyY2VzXG4gICAgLm1hcChTdHJpbmcpXG4gICAgLy8gU29tZSBzb3VyY2UgbWFwcyBwcm9kdWNlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBsaWtlIFwiLi9mb28uanNcIiBpbnN0ZWFkIG9mXG4gICAgLy8gXCJmb28uanNcIi4gIE5vcm1hbGl6ZSB0aGVzZSBmaXJzdCBzbyB0aGF0IGZ1dHVyZSBjb21wYXJpc29ucyB3aWxsIHN1Y2NlZWQuXG4gICAgLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuICAgIC5tYXAodXRpbC5ub3JtYWxpemUpXG4gICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IGFic29sdXRlIHNvdXJjZXMgYXJlIGludGVybmFsbHkgc3RvcmVkIHJlbGF0aXZlIHRvXG4gICAgLy8gdGhlIHNvdXJjZSByb290LCBpZiB0aGUgc291cmNlIHJvb3QgaXMgYWJzb2x1dGUuIE5vdCBkb2luZyB0aGlzIHdvdWxkXG4gICAgLy8gYmUgcGFydGljdWxhcmx5IHByb2JsZW1hdGljIHdoZW4gdGhlIHNvdXJjZSByb290IGlzIGEgcHJlZml4IG9mIHRoZVxuICAgIC8vIHNvdXJjZSAodmFsaWQsIGJ1dCB3aHk/PykuIFNlZSBnaXRodWIgaXNzdWUgIzE5OSBhbmQgYnVnemlsLmxhLzExODg5ODIuXG4gICAgLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlUm9vdCAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlUm9vdCkgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZSlcbiAgICAgICAgPyB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZSlcbiAgICAgICAgOiBzb3VyY2U7XG4gICAgfSk7XG5cbiAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAvLyBzb21ldGltZXMgZ2VuZXJhdGVzIHNvdXJjZSBtYXBzIHdpdGggZHVwbGljYXRlcyBpbiB0aGVtLiBTZWUgR2l0aHViIGlzc3VlXG4gIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMubWFwKFN0cmluZyksIHRydWUpO1xuICB0aGlzLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuXG4gIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgdGhpcy5fbWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgdGhpcy5maWxlID0gZmlsZTtcbn1cblxuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG5cbiAgICAvLyBCZWNhdXNlIHdlIGFyZSBtb2RpZnlpbmcgdGhlIGVudHJpZXMgKGJ5IGNvbnZlcnRpbmcgc3RyaW5nIHNvdXJjZXMgYW5kXG4gICAgLy8gbmFtZXMgdG8gaW5kaWNlcyBpbnRvIHRoZSBzb3VyY2VzIGFuZCBuYW1lcyBBcnJheVNldHMpLCB3ZSBoYXZlIHRvIG1ha2VcbiAgICAvLyBhIGNvcHkgb2YgdGhlIGVudHJ5IG9yIGVsc2UgYmFkIHRoaW5ncyBoYXBwZW4uIFNoYXJlZCBtdXRhYmxlIHN0YXRlXG4gICAgLy8gc3RyaWtlcyBhZ2FpbiEgU2VlIGdpdGh1YiBpc3N1ZSAjMTkxLlxuXG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gYVNvdXJjZU1hcC5fbWFwcGluZ3MudG9BcnJheSgpLnNsaWNlKCk7XG4gICAgdmFyIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncyA9IHNtYy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIGRlc3RPcmlnaW5hbE1hcHBpbmdzID0gc21jLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3JjTWFwcGluZyA9IGdlbmVyYXRlZE1hcHBpbmdzW2ldO1xuICAgICAgdmFyIGRlc3RNYXBwaW5nID0gbmV3IE1hcHBpbmc7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRMaW5lO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChzcmNNYXBwaW5nLnNvdXJjZSkge1xuICAgICAgICBkZXN0TWFwcGluZy5zb3VyY2UgPSBzb3VyY2VzLmluZGV4T2Yoc3JjTWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbExpbmUgPSBzcmNNYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBzcmNNYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChzcmNNYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICBkZXN0TWFwcGluZy5uYW1lID0gbmFtZXMuaW5kZXhPZihzcmNNYXBwaW5nLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdE9yaWdpbmFsTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgICB9XG5cbiAgICAgIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICB9XG5cbiAgICBxdWlja1NvcnQoc21jLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICByZXR1cm4gc21jO1xuICB9O1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCA/IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHMpIDogcztcbiAgICB9LCB0aGlzKTtcbiAgfVxufSk7XG5cbi8qKlxuICogUHJvdmlkZSB0aGUgSklUIHdpdGggYSBuaWNlIHNoYXBlIC8gaGlkZGVuIGNsYXNzLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nKCkge1xuICB0aGlzLmdlbmVyYXRlZExpbmUgPSAwO1xuICB0aGlzLmdlbmVyYXRlZENvbHVtbiA9IDA7XG4gIHRoaXMuc291cmNlID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbExpbmUgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdGhpcy5uYW1lID0gbnVsbDtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHZhciBnZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNhY2hlZFNlZ21lbnRzID0ge307XG4gICAgdmFyIHRlbXAgPSB7fTtcbiAgICB2YXIgb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBtYXBwaW5nLCBzdHIsIHNlZ21lbnQsIGVuZCwgdmFsdWU7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICc7Jykge1xuICAgICAgICBnZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJywnKSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbWFwcGluZyA9IG5ldyBNYXBwaW5nKCk7XG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IGdlbmVyYXRlZExpbmU7XG5cbiAgICAgICAgLy8gQmVjYXVzZSBlYWNoIG9mZnNldCBpcyBlbmNvZGVkIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBvbmUsXG4gICAgICAgIC8vIG1hbnkgc2VnbWVudHMgb2Z0ZW4gaGF2ZSB0aGUgc2FtZSBlbmNvZGluZy4gV2UgY2FuIGV4cGxvaXQgdGhpc1xuICAgICAgICAvLyBmYWN0IGJ5IGNhY2hpbmcgdGhlIHBhcnNlZCB2YXJpYWJsZSBsZW5ndGggZmllbGRzIG9mIGVhY2ggc2VnbWVudCxcbiAgICAgICAgLy8gYWxsb3dpbmcgdXMgdG8gYXZvaWQgYSBzZWNvbmQgcGFyc2UgaWYgd2UgZW5jb3VudGVyIHRoZSBzYW1lXG4gICAgICAgIC8vIHNlZ21lbnQgYWdhaW4uXG4gICAgICAgIGZvciAoZW5kID0gaW5kZXg7IGVuZCA8IGxlbmd0aDsgZW5kKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBlbmQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gYVN0ci5zbGljZShpbmRleCwgZW5kKTtcblxuICAgICAgICBzZWdtZW50ID0gY2FjaGVkU2VnbWVudHNbc3RyXTtcbiAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICBpbmRleCArPSBzdHIubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZ21lbnQgPSBbXTtcbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmQpIHtcbiAgICAgICAgICAgIGJhc2U2NFZMUS5kZWNvZGUoYVN0ciwgaW5kZXgsIHRlbXApO1xuICAgICAgICAgICAgdmFsdWUgPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgaW5kZXggPSB0ZW1wLnJlc3Q7XG4gICAgICAgICAgICBzZWdtZW50LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSwgYnV0IG5vIGxpbmUgYW5kIGNvbHVtbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBhIHNvdXJjZSBhbmQgbGluZSwgYnV0IG5vIGNvbHVtbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhY2hlZFNlZ21lbnRzW3N0cl0gPSBzZWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGVkIGNvbHVtbi5cbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiArIHNlZ21lbnRbMF07XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIC8vIE9yaWdpbmFsIHNvdXJjZS5cbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHByZXZpb3VzU291cmNlICsgc2VnbWVudFsxXTtcbiAgICAgICAgICBwcmV2aW91c1NvdXJjZSArPSBzZWdtZW50WzFdO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgbGluZS5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IHByZXZpb3VzT3JpZ2luYWxMaW5lICsgc2VnbWVudFsyXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgIC8vIExpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZFxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lICs9IDE7XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBjb2x1bW4uXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gKyBzZWdtZW50WzNdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IHByZXZpb3VzTmFtZSArIHNlZ21lbnRbNF07XG4gICAgICAgICAgICBwcmV2aW91c05hbWUgKz0gc2VnbWVudFs0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG9yaWdpbmFsTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydChnZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gZ2VuZXJhdGVkTWFwcGluZ3M7XG5cbiAgICBxdWlja1NvcnQob3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBvcmlnaW5hbE1hcHBpbmdzO1xuICB9O1xuXG4vKipcbiAqIEZpbmQgdGhlIG1hcHBpbmcgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGh5cG90aGV0aWNhbCBcIm5lZWRsZVwiIG1hcHBpbmcgdGhhdFxuICogd2UgYXJlIHNlYXJjaGluZyBmb3IgaW4gdGhlIGdpdmVuIFwiaGF5c3RhY2tcIiBvZiBtYXBwaW5ncy5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZmluZE1hcHBpbmcoYU5lZWRsZSwgYU1hcHBpbmdzLCBhTGluZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb2x1bW5OYW1lLCBhQ29tcGFyYXRvciwgYUJpYXMpIHtcbiAgICAvLyBUbyByZXR1cm4gdGhlIHBvc2l0aW9uIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCB3ZSBtdXN0IGZpcnN0IGZpbmQgdGhlXG4gICAgLy8gbWFwcGluZyBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCB0aGVuIHJldHVybiB0aGUgb3Bwb3NpdGUgcG9zaXRpb24gaXRcbiAgICAvLyBwb2ludHMgdG8uIEJlY2F1c2UgdGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHdlIGNhbiB1c2UgYmluYXJ5IHNlYXJjaCB0b1xuICAgIC8vIGZpbmQgdGhlIGJlc3QgbWFwcGluZy5cblxuICAgIGlmIChhTmVlZGxlW2FMaW5lTmFtZV0gPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUxpbmVOYW1lXSk7XG4gICAgfVxuICAgIGlmIChhTmVlZGxlW2FDb2x1bW5OYW1lXSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUNvbHVtbk5hbWVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmluYXJ5U2VhcmNoLnNlYXJjaChhTmVlZGxlLCBhTWFwcGluZ3MsIGFDb21wYXJhdG9yLCBhQmlhcyk7XG4gIH07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbGFzdCBjb2x1bW4gZm9yIGVhY2ggZ2VuZXJhdGVkIG1hcHBpbmcuIFRoZSBsYXN0IGNvbHVtbiBpc1xuICogaW5jbHVzaXZlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnMgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9jb21wdXRlQ29sdW1uU3BhbnMoKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIC8vIE1hcHBpbmdzIGRvIG5vdCBjb250YWluIGEgZmllbGQgZm9yIHRoZSBsYXN0IGdlbmVyYXRlZCBjb2x1bW50LiBXZVxuICAgICAgLy8gY2FuIGNvbWUgdXAgd2l0aCBhbiBvcHRpbWlzdGljIGVzdGltYXRlLCBob3dldmVyLCBieSBhc3N1bWluZyB0aGF0XG4gICAgICAvLyBtYXBwaW5ncyBhcmUgY29udGlndW91cyAoaS5lLiBnaXZlbiB0d28gY29uc2VjdXRpdmUgbWFwcGluZ3MsIHRoZVxuICAgICAgLy8gZmlyc3QgbWFwcGluZyBlbmRzIHdoZXJlIHRoZSBzZWNvbmQgb25lIHN0YXJ0cykuXG4gICAgICBpZiAoaW5kZXggKyAxIDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoKSB7XG4gICAgICAgIHZhciBuZXh0TWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4ICsgMV07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IG5leHRNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbiAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IEluZmluaXR5O1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgIFwiZ2VuZXJhdGVkTGluZVwiLFxuICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpO1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIG5hbWU6IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgYVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBhU291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc291cmNlcy5oYXMoYVNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihhU291cmNlKV07XG4gICAgfVxuXG4gICAgdmFyIHVybDtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSBhU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgIH1cblxuICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyBhU291cmNlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoXCIvXCIgKyBhU291cmNlKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBuZWVkbGUuc291cmNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gKiBpbnB1dC5cbiAqXG4gKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgYSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yIGFscmVhZHlcbiAqIHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMgZm9yIGluZGV4ZWQgc291cmNlIG1hcHMsIHRoZXlcbiAqIGhhdmUgdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqICAgLSBzZWN0aW9uczogQSBsaXN0IG9mIHNlY3Rpb24gZGVmaW5pdGlvbnMuXG4gKlxuICogRWFjaCB2YWx1ZSB1bmRlciB0aGUgXCJzZWN0aW9uc1wiIGZpZWxkIGhhcyB0d28gZmllbGRzOlxuICogICAtIG9mZnNldDogVGhlIG9mZnNldCBpbnRvIHRoZSBvcmlnaW5hbCBzcGVjaWZpZWQgYXQgd2hpY2ggdGhpcyBzZWN0aW9uXG4gKiAgICAgICBiZWdpbnMgdG8gYXBwbHksIGRlZmluZWQgYXMgYW4gb2JqZWN0IHdpdGggYSBcImxpbmVcIiBhbmQgXCJjb2x1bW5cIlxuICogICAgICAgZmllbGQuXG4gKiAgIC0gbWFwOiBBIHNvdXJjZSBtYXAgZGVmaW5pdGlvbi4gVGhpcyBzb3VyY2UgbWFwIGNvdWxkIGFsc28gYmUgaW5kZXhlZCxcbiAqICAgICAgIGJ1dCBkb2Vzbid0IGhhdmUgdG8gYmUuXG4gKlxuICogSW5zdGVhZCBvZiB0aGUgXCJtYXBcIiBmaWVsZCwgaXQncyBhbHNvIHBvc3NpYmxlIHRvIGhhdmUgYSBcInVybFwiIGZpZWxkXG4gKiBzcGVjaWZ5aW5nIGEgVVJMIHRvIHJldHJpZXZlIGEgc291cmNlIG1hcCBmcm9tLCBidXQgdGhhdCdzIGN1cnJlbnRseVxuICogdW5zdXBwb3J0ZWQuXG4gKlxuICogSGVyZSdzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdLCBidXRcbiAqIG1vZGlmaWVkIHRvIG9taXQgYSBzZWN0aW9uIHdoaWNoIHVzZXMgdGhlIFwidXJsXCIgZmllbGQuXG4gKlxuICogIHtcbiAqICAgIHZlcnNpb24gOiAzLFxuICogICAgZmlsZTogXCJhcHAuanNcIixcbiAqICAgIHNlY3Rpb25zOiBbe1xuICogICAgICBvZmZzZXQ6IHtsaW5lOjEwMCwgY29sdW1uOjEwfSxcbiAqICAgICAgbWFwOiB7XG4gKiAgICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICAgZmlsZTogXCJzZWN0aW9uLmpzXCIsXG4gKiAgICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgIG1hcHBpbmdzOiBcIkFBQUEsRTs7QUJDREU7XCJcbiAqICAgICAgfVxuICogICAgfV0sXG4gKiAgfVxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzZWN0aW9ucyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NlY3Rpb25zJyk7XG5cbiAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gIHZhciBsYXN0T2Zmc2V0ID0ge1xuICAgIGxpbmU6IC0xLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB0aGlzLl9zZWN0aW9ucyA9IHNlY3Rpb25zLm1hcChmdW5jdGlvbiAocykge1xuICAgIGlmIChzLnVybCkge1xuICAgICAgLy8gVGhlIHVybCBmaWVsZCB3aWxsIHJlcXVpcmUgc3VwcG9ydCBmb3IgYXN5bmNocm9uaWNpdHkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMTZcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3VwcG9ydCBmb3IgdXJsIGZpZWxkIGluIHNlY3Rpb25zIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IHV0aWwuZ2V0QXJnKHMsICdvZmZzZXQnKTtcbiAgICB2YXIgb2Zmc2V0TGluZSA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2xpbmUnKTtcbiAgICB2YXIgb2Zmc2V0Q29sdW1uID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnY29sdW1uJyk7XG5cbiAgICBpZiAob2Zmc2V0TGluZSA8IGxhc3RPZmZzZXQubGluZSB8fFxuICAgICAgICAob2Zmc2V0TGluZSA9PT0gbGFzdE9mZnNldC5saW5lICYmIG9mZnNldENvbHVtbiA8IGxhc3RPZmZzZXQuY29sdW1uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWN0aW9uIG9mZnNldHMgbXVzdCBiZSBvcmRlcmVkIGFuZCBub24tb3ZlcmxhcHBpbmcuJyk7XG4gICAgfVxuICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2VuZXJhdGVkT2Zmc2V0OiB7XG4gICAgICAgIC8vIFRoZSBvZmZzZXQgZmllbGRzIGFyZSAwLWJhc2VkLCBidXQgd2UgdXNlIDEtYmFzZWQgaW5kaWNlcyB3aGVuXG4gICAgICAgIC8vIGVuY29kaW5nL2RlY29kaW5nIGZyb20gVkxRLlxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBvZmZzZXRDb2x1bW4gKyAxXG4gICAgICB9LFxuICAgICAgY29uc3VtZXI6IG5ldyBTb3VyY2VNYXBDb25zdW1lcih1dGlsLmdldEFyZyhzLCAnbWFwJykpXG4gICAgfVxuICB9KTtcbn1cblxuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbiAgfVxufSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICB2YXIgc2VjdGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoLnNlYXJjaChuZWVkbGUsIHRoaXMuX3NlY3Rpb25zLFxuICAgICAgZnVuY3Rpb24obmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgIHZhciBjbXAgPSBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgfSk7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICA6IDApLFxuICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpO1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgdHJ1ZSk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZXMuaW5kZXhPZih1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gZ2VuZXJhdGVkUG9zaXRpb24ubGluZVxuICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgIDogMClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICB2YXIgc2VjdGlvbk1hcHBpbmdzID0gc2VjdGlvbi5jb25zdW1lci5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlY3Rpb25NYXBwaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tqXTtcblxuICAgICAgICB2YXIgc291cmNlID0gc2VjdGlvbi5jb25zdW1lci5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICAgIHZhciBuYW1lID0gc2VjdGlvbi5jb25zdW1lci5fbmFtZXMuYXQobWFwcGluZy5uYW1lKTtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcblxuICAgICAgICAvLyBUaGUgbWFwcGluZ3MgY29taW5nIGZyb20gdGhlIGNvbnN1bWVyIGZvciB0aGUgc2VjdGlvbiBoYXZlXG4gICAgICAgIC8vIGdlbmVyYXRlZCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzZWN0aW9uLCBzbyB3ZVxuICAgICAgICAvLyBuZWVkIHRvIG9mZnNldCB0aGVtIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgY29uY2F0ZW5hdGVkXG4gICAgICAgIC8vIGdlbmVyYXRlZCBmaWxlLlxuICAgICAgICB2YXIgYWRqdXN0ZWRNYXBwaW5nID0ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG1hcHBpbmcuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICA6IDApLFxuICAgICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYWRqdXN0ZWRNYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQodGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICBxdWlja1NvcnQodGhpcy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICB9O1xuXG5leHBvcnRzLkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciA9IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcjtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICBpZiAoIWFBcmdzKSB7XG4gICAgYUFyZ3MgPSB7fTtcbiAgfVxuICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gIHRoaXMuX3NvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG59XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICBpZiAoIXRoaXMuX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IFN0cmluZyhzb3VyY2UpO1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgIGlmICghdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgIH1cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgIH1cbiAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IHNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgIT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gKlxuICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gKiAgICAgIHRva2VuLlxuICpcbiAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgIC8vIENhc2UgMS5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsICYmICdsaW5lJyBpbiBhT3JpZ2luYWwgJiYgJ2NvbHVtbicgaW4gYU9yaWdpbmFsXG4gICAgICAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFTb3VyY2UpIHtcbiAgICAgIC8vIENhc2VzIDIgYW5kIDMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGdlbmVyYXRlZDogYUdlbmVyYXRlZCxcbiAgICAgICAgc291cmNlOiBhU291cmNlLFxuICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICBuYW1lOiBhTmFtZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXJpYWxpemVNYXBwaW5ncygpIHtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBuZXh0O1xuICAgIHZhciBtYXBwaW5nO1xuICAgIHZhciBuYW1lSWR4O1xuICAgIHZhciBzb3VyY2VJZHg7XG5cbiAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICBuZXh0ID0gJydcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbmV4dCArPSAnOyc7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQgKz0gJywnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VJZHggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4IC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHNvdXJjZUlkeDtcblxuICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5hbWVJZHggPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHggLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgIHByZXZpb3VzTmFtZSA9IG5hbWVJZHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKGFTb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fc291cmNlc0NvbnRlbnRzLCBrZXkpXG4gICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgOiBudWxsO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEV4dGVybmFsaXplIHRoZSBzb3VyY2UgbWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvSlNPTiA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b0pTT04oKSB7XG4gICAgdmFyIG1hcCA9IHtcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgICBzb3VyY2VzOiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICBtYXBwaW5nczogdGhpcy5fc2VyaWFsaXplTWFwcGluZ3MoKVxuICAgIH07XG4gICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgbWFwLmZpbGUgPSB0aGlzLl9maWxlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBtYXAuc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIG1hcC5zb3VyY2VzQ29udGVudCA9IHRoaXMuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQobWFwLnNvdXJjZXMsIG1hcC5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuXG4vKipcbiAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxudmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG52YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbi8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2Zcbi8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4vLyB2ZXJzaW9ucyFcbnZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4vKipcbiAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gKlxuICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICovXG5Tb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSByZW1vdmVkIGZyb20gdGhpcyBhcnJheSwgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lQ29udGVudHMgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpO1xuICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgdmFyIG5ld0xpbmUgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpIHx8IFwiXCI7XG4gICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcbiAgICB9O1xuXG4gICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgfVxuICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICBpZiAocmVtYWluaW5nTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICB9XG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuam9pbihcIlwiKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZTtcblxuICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGFDaHVuaykge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgdmFyIGNodW5rO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICB2YXIgbmV3Q2hpbGRyZW47XG4gIHZhciBpO1xuICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgfVxuICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gKlxuICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gIH07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHN0ciArPSBjaHVuaztcbiAgfSk7XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAqIG1hcC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICBjb2RlOiBcIlwiLFxuICAgIGxpbmU6IDEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG59O1xuXG5leHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgfVxufVxuZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbnZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Ll0qKSg/OjooXFxkKykpPyhcXFMqKSQvO1xudmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG5mdW5jdGlvbiB1cmxQYXJzZShhVXJsKSB7XG4gIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2NoZW1lOiBtYXRjaFsxXSxcbiAgICBhdXRoOiBtYXRjaFsyXSxcbiAgICBob3N0OiBtYXRjaFszXSxcbiAgICBwb3J0OiBtYXRjaFs0XSxcbiAgICBwYXRoOiBtYXRjaFs1XVxuICB9O1xufVxuZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG5mdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gIHZhciB1cmwgPSAnJztcbiAgaWYgKGFQYXJzZWRVcmwuc2NoZW1lKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuc2NoZW1lICsgJzonO1xuICB9XG4gIHVybCArPSAnLy8nO1xuICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuYXV0aCArICdAJztcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmV4cG9ydHMudXJsR2VuZXJhdGUgPSB1cmxHZW5lcmF0ZTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAqXG4gKiAtIFJlcGxhY2VzIGNvbnNlY3V0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gKlxuICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gKlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCkge1xuICB2YXIgcGF0aCA9IGFQYXRoO1xuICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICBpZiAodXJsKSB7XG4gICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cbiAgICBwYXRoID0gdXJsLnBhdGg7XG4gIH1cbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCk7XG5cbiAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pO1xuICBmb3IgKHZhciBwYXJ0LCB1cCA9IDAsIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYmxhbmsgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIFRyeWluZyB0byBnb1xuICAgICAgICAvLyBhYm92ZSB0aGUgcm9vdCBpcyBhIG5vLW9wLiBUaGVyZWZvcmUgd2UgY2FuIHJlbW92ZSBhbGwgJy4uJyBwYXJ0c1xuICAgICAgICAvLyBkaXJlY3RseSBhZnRlciB0aGUgcm9vdC5cbiAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCB1cCk7XG4gICAgICAgIHVwID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgdXAtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF0aCA9IHBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICBwYXRoID0gaXNBYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgfVxuXG4gIGlmICh1cmwpIHtcbiAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICpcbiAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAqICAgZmlyc3QuXG4gKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICogICBpcyByZXR1cm5lZC5cbiAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBqb2luKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG4gIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgIGFQYXRoID0gXCIuXCI7XG4gIH1cbiAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICB2YXIgYVJvb3RVcmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gIH1cblxuICAvLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVBhdGhVcmwuc2NoZW1lID0gYVJvb3RVcmwuc2NoZW1lO1xuICAgIH1cbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICB9XG5cbiAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgcmV0dXJuIGFQYXRoO1xuICB9XG5cbiAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgIGFSb290VXJsLmhvc3QgPSBhUGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG5cbiAgdmFyIGpvaW5lZCA9IGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgPyBhUGF0aFxuICAgIDogbm9ybWFsaXplKGFSb290LnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgYVBhdGgpO1xuXG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuICByZXR1cm4gam9pbmVkO1xufVxuZXhwb3J0cy5qb2luID0gam9pbjtcblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24gKGFQYXRoKSB7XG4gIHJldHVybiBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJyB8fCAhIWFQYXRoLm1hdGNoKHVybFJlZ2V4cCk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG5cbiAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gIC8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGF0aCB0byBiZSBhYm92ZSB0aGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBzaW1wbHlcbiAgLy8gY2hlY2tpbmcgd2hldGhlciB0aGUgcm9vdCBpcyBhIHByZWZpeCBvZiB0aGUgcGF0aCB3b24ndCB3b3JrLiBJbnN0ZWFkLCB3ZVxuICAvLyBuZWVkIHRvIHJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIHJvb3Qgb25lIGJ5IG9uZSwgdW50aWwgZWl0aGVyIHdlIGZpbmRcbiAgLy8gYSBwcmVmaXggdGhhdCBmaXRzLCBvciB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgdG8gcmVtb3ZlLlxuICB2YXIgbGV2ZWwgPSAwO1xuICB3aGlsZSAoYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgIT09IDApIHtcbiAgICB2YXIgaW5kZXggPSBhUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBvbmx5IHBhcnQgb2YgdGhlIHJvb3QgdGhhdCBpcyBsZWZ0IGlzIHRoZSBzY2hlbWUgKGkuZS4gaHR0cDovLyxcbiAgICAvLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4gICAgLy8gaGF2ZSBleGhhdXN0ZWQgYWxsIGNvbXBvbmVudHMsIHNvIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSB0byB0aGUgcm9vdC5cbiAgICBhUm9vdCA9IGFSb290LnNsaWNlKDAsIGluZGV4KTtcbiAgICBpZiAoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICArK2xldmVsO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIFwiLi4vXCIgZm9yIGVhY2ggY29tcG9uZW50IHdlIHJlbW92ZWQgZnJvbSB0aGUgcm9vdC5cbiAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbihcIi4uL1wiKSArIGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKTtcbn1cbmV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxudmFyIHN1cHBvcnRzTnVsbFByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAhKCdfX3Byb3RvX18nIGluIG9iaik7XG59KCkpO1xuXG5mdW5jdGlvbiBpZGVudGl0eSAocykge1xuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gKiBoYXZlIHRvIHByZWZpeCBhbGwgdGhlIHN0cmluZ3MgaW4gb3VyIHNldCB3aXRoIGFuIGFyYml0cmFyeSBjaGFyYWN0ZXIuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzMwXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbmZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy50b1NldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiB0b1NldFN0cmluZztcblxuZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuIGFTdHIuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMuZnJvbVNldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiBmcm9tU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBpc1Byb3RvU3RyaW5nKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCA5IC8qIFwiX19wcm90b19fXCIubGVuZ3RoICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHMuY2hhckNvZGVBdChsZW5ndGggLSAxKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDIpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMykgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA0KSAhPT0gMTE2IC8qICd0JyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDUpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNikgIT09IDExNCAvKiAncicgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA3KSAhPT0gMTEyIC8qICdwJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDgpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOSkgIT09IDk1ICAvKiAnXycgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTA7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHMuY2hhckNvZGVBdChpKSAhPT0gMzYgLyogJyQnICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbmZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgaWYgKGFTdHIxID09PSBhU3RyMikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFTdHIxID4gYVN0cjIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggaW5mbGF0ZWQgc291cmNlIGFuZCBuYW1lIHN0cmluZ3Mgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG4iLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdzdGFja2ZyYW1lJywgW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuU3RhY2tGcmFtZSA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBmdW5jdGlvbiBfaXNOdW1iZXIobikge1xuICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZ2V0dGVyKHApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbcF07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGJvb2xlYW5Qcm9wcyA9IFsnaXNDb25zdHJ1Y3RvcicsICdpc0V2YWwnLCAnaXNOYXRpdmUnLCAnaXNUb3BsZXZlbCddO1xuICAgIHZhciBudW1lcmljUHJvcHMgPSBbJ2NvbHVtbk51bWJlcicsICdsaW5lTnVtYmVyJ107XG4gICAgdmFyIHN0cmluZ1Byb3BzID0gWydmaWxlTmFtZScsICdmdW5jdGlvbk5hbWUnLCAnc291cmNlJ107XG4gICAgdmFyIGFycmF5UHJvcHMgPSBbJ2FyZ3MnXTtcbiAgICB2YXIgb2JqZWN0UHJvcHMgPSBbJ2V2YWxPcmlnaW4nXTtcblxuICAgIHZhciBwcm9wcyA9IGJvb2xlYW5Qcm9wcy5jb25jYXQobnVtZXJpY1Byb3BzLCBzdHJpbmdQcm9wcywgYXJyYXlQcm9wcywgb2JqZWN0UHJvcHMpO1xuXG4gICAgZnVuY3Rpb24gU3RhY2tGcmFtZShvYmopIHtcbiAgICAgICAgaWYgKCFvYmopIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9ialtwcm9wc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNbJ3NldCcgKyBfY2FwaXRhbGl6ZShwcm9wc1tpXSldKG9ialtwcm9wc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGdldEFyZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0QXJnczogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3MgbXVzdCBiZSBhbiBBcnJheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcmdzID0gdjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRFdmFsT3JpZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2YWxPcmlnaW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldEV2YWxPcmlnaW46IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGlmICh2IGluc3RhbmNlb2YgU3RhY2tGcmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZhbE9yaWdpbiA9IHY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2YWxPcmlnaW4gPSBuZXcgU3RhY2tGcmFtZSh2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXZhbCBPcmlnaW4gbXVzdCBiZSBhbiBPYmplY3Qgb3IgU3RhY2tGcmFtZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IHRoaXMuZ2V0RmlsZU5hbWUoKSB8fCAnJztcbiAgICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gdGhpcy5nZXRMaW5lTnVtYmVyKCkgfHwgJyc7XG4gICAgICAgICAgICB2YXIgY29sdW1uTnVtYmVyID0gdGhpcy5nZXRDb2x1bW5OdW1iZXIoKSB8fCAnJztcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0aGlzLmdldEZ1bmN0aW9uTmFtZSgpIHx8ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0SXNFdmFsKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdbZXZhbF0gKCcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXIgKyAnKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAnW2V2YWxdOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgKyAnICgnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyICsgJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTdGFja0ZyYW1lLmZyb21TdHJpbmcgPSBmdW5jdGlvbiBTdGFja0ZyYW1lJCRmcm9tU3RyaW5nKHN0cikge1xuICAgICAgICB2YXIgYXJnc1N0YXJ0SW5kZXggPSBzdHIuaW5kZXhPZignKCcpO1xuICAgICAgICB2YXIgYXJnc0VuZEluZGV4ID0gc3RyLmxhc3RJbmRleE9mKCcpJyk7XG5cbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHN0ci5zdWJzdHJpbmcoMCwgYXJnc1N0YXJ0SW5kZXgpO1xuICAgICAgICB2YXIgYXJncyA9IHN0ci5zdWJzdHJpbmcoYXJnc1N0YXJ0SW5kZXggKyAxLCBhcmdzRW5kSW5kZXgpLnNwbGl0KCcsJyk7XG4gICAgICAgIHZhciBsb2NhdGlvblN0cmluZyA9IHN0ci5zdWJzdHJpbmcoYXJnc0VuZEluZGV4ICsgMSk7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uU3RyaW5nLmluZGV4T2YoJ0AnKSA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gL0AoLis/KSg/OjooXFxkKykpPyg/OjooXFxkKykpPyQvLmV4ZWMobG9jYXRpb25TdHJpbmcsICcnKTtcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSBwYXJ0c1syXTtcbiAgICAgICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBwYXJ0c1szXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3MgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGVOYW1lLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlciB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb2x1bW5OdW1iZXI6IGNvbHVtbk51bWJlciB8fCB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9vbGVhblByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUoYm9vbGVhblByb3BzW2ldKV0gPSBfZ2V0dGVyKGJvb2xlYW5Qcm9wc1tpXSk7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUoYm9vbGVhblByb3BzW2ldKV0gPSAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3BdID0gQm9vbGVhbih2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKGJvb2xlYW5Qcm9wc1tpXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1lcmljUHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXSA9IF9nZXR0ZXIobnVtZXJpY1Byb3BzW2pdKTtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXSA9IChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIGlmICghX2lzTnVtYmVyKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocCArICcgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW3BdID0gTnVtYmVyKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkobnVtZXJpY1Byb3BzW2pdKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IHN0cmluZ1Byb3BzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUoc3RyaW5nUHJvcHNba10pXSA9IF9nZXR0ZXIoc3RyaW5nUHJvcHNba10pO1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV0gPSAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3BdID0gU3RyaW5nKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoc3RyaW5nUHJvcHNba10pO1xuICAgIH1cblxuICAgIHJldHVybiBTdGFja0ZyYW1lO1xufSkpO1xuIiwiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ3N0YWNrLWdlbmVyYXRvcicsIFsnc3RhY2tmcmFtZSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnc3RhY2tmcmFtZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LlN0YWNrR2VuZXJhdG9yID0gZmFjdG9yeShyb290LlN0YWNrRnJhbWUpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKFN0YWNrRnJhbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYWNrdHJhY2U6IGZ1bmN0aW9uIFN0YWNrR2VuZXJhdG9yJCRiYWNrdHJhY2Uob3B0cykge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgICAgICB2YXIgbWF4U3RhY2tTaXplID0gMTA7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdHMubWF4U3RhY2tTaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG1heFN0YWNrU2l6ZSA9IG9wdHMubWF4U3RhY2tTaXplO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VyciA9IGFyZ3VtZW50cy5jYWxsZWU7XG4gICAgICAgICAgICB3aGlsZSAoY3VyciAmJiBzdGFjay5sZW5ndGggPCBtYXhTdGFja1NpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBWOCBvcHRpbWl6YXRpb25zXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoY3VyclsnYXJndW1lbnRzJ10ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gY3VyclsnYXJndW1lbnRzJ11baV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvZnVuY3Rpb24oPzpcXHMrKFtcXHckXSspKStcXHMqXFwoLy50ZXN0KGN1cnIudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChuZXcgU3RhY2tGcmFtZSh7ZnVuY3Rpb25OYW1lOiBSZWdFeHAuJDEgfHwgdW5kZWZpbmVkLCBhcmdzOiBhcmdzfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3IFN0YWNrRnJhbWUoe2FyZ3M6IGFyZ3N9KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnIuY2FsbGVyO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9XG4gICAgfTtcbn0pKTtcbiIsIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdzdGFja2ZyYW1lJywgW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuU3RhY2tGcmFtZSA9IGZhY3RvcnkoKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gX2lzTnVtYmVyKG4pIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTdGFja0ZyYW1lKGZ1bmN0aW9uTmFtZSwgYXJncywgZmlsZU5hbWUsIGxpbmVOdW1iZXIsIGNvbHVtbk51bWJlciwgc291cmNlKSB7XG4gICAgICAgIGlmIChmdW5jdGlvbk5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk5hbWUoZnVuY3Rpb25OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFyZ3MoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbGVOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RmlsZU5hbWUoZmlsZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lTnVtYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TGluZU51bWJlcihsaW5lTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sdW1uTnVtYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sdW1uTnVtYmVyKGNvbHVtbk51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNvdXJjZShzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGdldEZ1bmN0aW9uTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25OYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXRGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLmZ1bmN0aW9uTmFtZSA9IFN0cmluZyh2KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBcmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmdzO1xuICAgICAgICB9LFxuICAgICAgICBzZXRBcmdzOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2KSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3MgbXVzdCBiZSBhbiBBcnJheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcmdzID0gdjtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBOT1RFOiBQcm9wZXJ0eSBuYW1lIG1heSBiZSBtaXNsZWFkaW5nIGFzIGl0IGluY2x1ZGVzIHRoZSBwYXRoLFxuICAgICAgICAvLyBidXQgaXQgc29tZXdoYXQgbWlycm9ycyBWOCdzIEphdmFTY3JpcHRTdGFja1RyYWNlQXBpXG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3Avdjgvd2lraS9KYXZhU2NyaXB0U3RhY2tUcmFjZUFwaSBhbmQgR2Vja28nc1xuICAgICAgICAvLyBodHRwOi8vbXhyLm1vemlsbGEub3JnL21vemlsbGEtY2VudHJhbC9zb3VyY2UveHBjb20vYmFzZS9uc0lFeGNlcHRpb24uaWRsIzE0XG4gICAgICAgIGdldEZpbGVOYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlTmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RmlsZU5hbWU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVOYW1lID0gU3RyaW5nKHYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldExpbmVOdW1iZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVOdW1iZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldExpbmVOdW1iZXI6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAoIV9pc051bWJlcih2KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgTnVtYmVyIG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGluZU51bWJlciA9IE51bWJlcih2KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb2x1bW5OdW1iZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbk51bWJlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q29sdW1uTnVtYmVyOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKCFfaXNOdW1iZXIodikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gTnVtYmVyIG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29sdW1uTnVtYmVyID0gTnVtYmVyKHYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNvdXJjZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlO1xuICAgICAgICB9LFxuICAgICAgICBzZXRTb3VyY2U6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZSA9IFN0cmluZyh2KTtcbiAgICAgICAgfSxcblxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5nZXRGdW5jdGlvbk5hbWUoKSB8fCAne2Fub255bW91c30nO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSAnKCcgKyAodGhpcy5nZXRBcmdzKCkgfHwgW10pLmpvaW4oJywnKSArICcpJztcbiAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IHRoaXMuZ2V0RmlsZU5hbWUoKSA/ICgnQCcgKyB0aGlzLmdldEZpbGVOYW1lKCkpIDogJyc7XG4gICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IF9pc051bWJlcih0aGlzLmdldExpbmVOdW1iZXIoKSkgPyAoJzonICsgdGhpcy5nZXRMaW5lTnVtYmVyKCkpIDogJyc7XG4gICAgICAgICAgICB2YXIgY29sdW1uTnVtYmVyID0gX2lzTnVtYmVyKHRoaXMuZ2V0Q29sdW1uTnVtYmVyKCkpID8gKCc6JyArIHRoaXMuZ2V0Q29sdW1uTnVtYmVyKCkpIDogJyc7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25OYW1lICsgYXJncyArIGZpbGVOYW1lICsgbGluZU51bWJlciArIGNvbHVtbk51bWJlcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gU3RhY2tGcmFtZTtcbn0pKTtcbiIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ3N0YWNrdHJhY2UtZ3BzJywgWydzb3VyY2UtbWFwJywgJ3N0YWNrZnJhbWUnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtY29uc3VtZXInKSwgcmVxdWlyZSgnc3RhY2tmcmFtZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LlN0YWNrVHJhY2VHUFMgPSBmYWN0b3J5KHJvb3QuU291cmNlTWFwIHx8IHJvb3Quc291cmNlTWFwLCByb290LlN0YWNrRnJhbWUpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24oU291cmNlTWFwLCBTdGFja0ZyYW1lKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogTWFrZSBhIFgtRG9tYWluIHJlcXVlc3QgdG8gdXJsIGFuZCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gd2l0aCByZXNwb25zZSB0ZXh0IGlmIGZ1bGZpbGxlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF94ZHIodXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcS5vcGVuKCdnZXQnLCB1cmwpO1xuICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gb25yZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA+PSAyMDAgJiYgcmVxLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0hUVFAgc3RhdHVzOiAnICsgcmVxLnN0YXR1cyArICcgcmV0cmlldmluZyAnICsgdXJsKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVxLnNlbmQoKTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgQmFzZTY0LWVuY29kZWQgc3RyaW5nIGludG8gaXRzIG9yaWdpbmFsIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIFVzZWQgZm9yIGlubGluZSBzb3VyY2VtYXBzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGI2NHN0ciBCYXNlLTY0IGVuY29kZWQgc3RyaW5nXG4gICAgICogQHJldHVybnMge1N0cmluZ30gb3JpZ2luYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGJhc2U2NC1lbmNvZGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfYXRvYihiNjRzdHIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hdG9iKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LmF0b2IoYjY0c3RyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3VwcGx5IGEgcG9seWZpbGwgZm9yIHdpbmRvdy5hdG9iIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9wYXJzZUpzb24oc3RyaW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcgJiYgSlNPTi5wYXJzZSkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3VwcGx5IGEgcG9seWZpbGwgZm9yIEpTT04ucGFyc2UgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZpbmRGdW5jdGlvbk5hbWUoc291cmNlLCBsaW5lTnVtYmVyLyosIGNvbHVtbk51bWJlciovKSB7XG4gICAgICAgIC8vIGZ1bmN0aW9uIHtuYW1lfSh7YXJnc30pIG1bMV09bmFtZSBtWzJdPWFyZ3NcbiAgICAgICAgdmFyIHJlRnVuY3Rpb25EZWNsYXJhdGlvbiA9IC9mdW5jdGlvblxccysoW14oXSo/KVxccypcXCgoW14pXSopXFwpLztcbiAgICAgICAgLy8ge25hbWV9ID0gZnVuY3Rpb24gKHthcmdzfSkgVE9ETyBhcmdzIGNhcHR1cmVcbiAgICAgICAgdmFyIHJlRnVuY3Rpb25FeHByZXNzaW9uID0gL1snXCJdPyhbJF9BLVphLXpdWyRfQS1aYS16MC05XSopWydcIl0/XFxzKls6PV1cXHMqZnVuY3Rpb25cXGIvO1xuICAgICAgICAvLyB7bmFtZX0gPSBldmFsKClcbiAgICAgICAgdmFyIHJlRnVuY3Rpb25FdmFsdWF0aW9uID0gL1snXCJdPyhbJF9BLVphLXpdWyRfQS1aYS16MC05XSopWydcIl0/XFxzKls6PV1cXHMqKD86ZXZhbHxuZXcgRnVuY3Rpb24pXFxiLztcbiAgICAgICAgdmFyIGxpbmVzID0gc291cmNlLnNwbGl0KCdcXG4nKTtcblxuICAgICAgICAvLyBXYWxrIGJhY2t3YXJkcyBpbiB0aGUgc291cmNlIGxpbmVzIHVudGlsIHdlIGZpbmQgdGhlIGxpbmUgd2hpY2ggbWF0Y2hlcyBvbmUgb2YgdGhlIHBhdHRlcm5zIGFib3ZlXG4gICAgICAgIHZhciBjb2RlID0gJyc7XG4gICAgICAgIHZhciBtYXhMaW5lcyA9IE1hdGgubWluKGxpbmVOdW1iZXIsIDIwKTtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4TGluZXM7ICsraSkge1xuICAgICAgICAgICAgLy8gbGluZU5vIGlzIDEtYmFzZWQsIHNvdXJjZVtdIGlzIDAtYmFzZWRcbiAgICAgICAgICAgIHZhciBsaW5lID0gbGluZXNbbGluZU51bWJlciAtIGkgLSAxXTtcbiAgICAgICAgICAgIHZhciBjb21tZW50UG9zID0gbGluZS5pbmRleE9mKCcvLycpO1xuICAgICAgICAgICAgaWYgKGNvbW1lbnRQb3MgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBjb21tZW50UG9zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gbGluZSArIGNvZGU7XG4gICAgICAgICAgICAgICAgbSA9IHJlRnVuY3Rpb25FeHByZXNzaW9uLmV4ZWMoY29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG0gJiYgbVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbSA9IHJlRnVuY3Rpb25EZWNsYXJhdGlvbi5leGVjKGNvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1bMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0gPSByZUZ1bmN0aW9uRXZhbHVhdGlvbi5leGVjKGNvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1bMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2Vuc3VyZVN1cHBvcnRlZEVudmlyb25tZW50KCkge1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY29uc3VtZSBzb3VyY2UgbWFwcyBpbiBvbGRlciBicm93c2VycycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2Vuc3VyZVN0YWNrRnJhbWVJc0xlZ2l0KHN0YWNrZnJhbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFja2ZyYW1lICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR2l2ZW4gU3RhY2tGcmFtZSBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0YWNrZnJhbWUuZmlsZU5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHaXZlbiBmaWxlIG5hbWUgaXMgbm90IGEgU3RyaW5nJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0YWNrZnJhbWUubGluZU51bWJlciAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIHN0YWNrZnJhbWUubGluZU51bWJlciAlIDEgIT09IDAgfHxcbiAgICAgICAgICAgIHN0YWNrZnJhbWUubGluZU51bWJlciA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dpdmVuIGxpbmUgbnVtYmVyIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0YWNrZnJhbWUuY29sdW1uTnVtYmVyICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgc3RhY2tmcmFtZS5jb2x1bW5OdW1iZXIgJSAxICE9PSAwIHx8XG4gICAgICAgICAgICBzdGFja2ZyYW1lLmNvbHVtbk51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dpdmVuIGNvbHVtbiBudW1iZXIgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZpbmRTb3VyY2VNYXBwaW5nVVJMKHNvdXJjZSkge1xuICAgICAgICB2YXIgbSA9IC9cXC9cXC9bI0BdID9zb3VyY2VNYXBwaW5nVVJMPShbXlxccydcIl0rKVxccyokLy5leGVjKHNvdXJjZSk7XG4gICAgICAgIGlmIChtICYmIG1bMV0pIHtcbiAgICAgICAgICAgIHJldHVybiBtWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VNYXBwaW5nVVJMIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2V4dHJhY3RMb2NhdGlvbkluZm9Gcm9tU291cmNlTWFwKHN0YWNrZnJhbWUsIHJhd1NvdXJjZU1hcCwgc291cmNlQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIG1hcENvbnN1bWVyID0gbmV3IFNvdXJjZU1hcC5Tb3VyY2VNYXBDb25zdW1lcihyYXdTb3VyY2VNYXApO1xuXG4gICAgICAgICAgICB2YXIgbG9jID0gbWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICAgICAgbGluZTogc3RhY2tmcmFtZS5saW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogc3RhY2tmcmFtZS5jb2x1bW5OdW1iZXJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobG9jLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXBwZWRTb3VyY2UgPSBtYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGxvYy5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlQ2FjaGVbbG9jLnNvdXJjZV0gPSBtYXBwZWRTb3VyY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgICAgICAgICAgIG5ldyBTdGFja0ZyYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLm5hbWUgfHwgc3RhY2tmcmFtZS5mdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja2ZyYW1lLmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2Muc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MuY29sdW1uKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgb3JpZ2luYWwgc291cmNlIGZvciBnaXZlbiBzdGFja2ZyYW1lIGFuZCBzb3VyY2UgbWFwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqICAgICAgb3B0cy5zb3VyY2VDYWNoZSA9IHt1cmw6IFwiU291cmNlIFN0cmluZ1wifSA9PiBwcmVsb2FkIHNvdXJjZSBjYWNoZVxuICAgICAqICAgICAgb3B0cy5vZmZsaW5lID0gVHJ1ZSB0byBwcmV2ZW50IG5ldHdvcmsgcmVxdWVzdHMuXG4gICAgICogICAgICAgICAgICAgIEJlc3QgZWZmb3J0IHdpdGhvdXQgc291cmNlcyBvciBzb3VyY2UgbWFwcy5cbiAgICAgKiAgICAgIG9wdHMuYWpheCA9IFByb21pc2UgcmV0dXJuaW5nIGZ1bmN0aW9uIHRvIG1ha2UgWC1Eb21haW4gcmVxdWVzdHNcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gU3RhY2tUcmFjZUdQUyhvcHRzKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdGFja1RyYWNlR1BTKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja1RyYWNlR1BTKG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuc291cmNlQ2FjaGUgPSBvcHRzLnNvdXJjZUNhY2hlIHx8IHt9O1xuXG4gICAgICAgIHRoaXMuYWpheCA9IG9wdHMuYWpheCB8fCBfeGRyO1xuXG4gICAgICAgIHRoaXMuX2F0b2IgPSBvcHRzLmF0b2IgfHwgX2F0b2I7XG5cbiAgICAgICAgdGhpcy5fZ2V0ID0gZnVuY3Rpb24gX2dldChsb2NhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBpc0RhdGFVcmwgPSBsb2NhdGlvbi5zdWJzdHIoMCwgNSkgPT09ICdkYXRhOic7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlQ2FjaGVbbG9jYXRpb25dKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5zb3VyY2VDYWNoZVtsb2NhdGlvbl0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5vZmZsaW5lICYmICFpc0RhdGFVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ2Fubm90IG1ha2UgbmV0d29yayByZXF1ZXN0cyBpbiBvZmZsaW5lIG1vZGUnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGF0YVVybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YSBVUkxzIGNhbiBoYXZlIHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZWUgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjM5N1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1cHBvcnRlZEVuY29kaW5nUmVnZXhwID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uOyhbXFx3PTpcIi1dKzspKmJhc2U2NCwvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbG9jYXRpb24ubWF0Y2goc3VwcG9ydGVkRW5jb2RpbmdSZWdleHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZU1hcFN0YXJ0ID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmNvZGVkU291cmNlID0gbG9jYXRpb24uc3Vic3RyKHNvdXJjZU1hcFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fYXRvYihlbmNvZGVkU291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZUNhY2hlW2xvY2F0aW9uXSA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBlbmNvZGluZyBvZiB0aGUgaW5saW5lIHNvdXJjZW1hcCBpcyBub3Qgc3VwcG9ydGVkJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhoclByb21pc2UgPSB0aGlzLmFqYXgobG9jYXRpb24sIHttZXRob2Q6ICdnZXQnfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgUHJvbWlzZSB0byBwcmV2ZW50IGR1cGxpY2F0ZSBpbi1mbGlnaHQgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlQ2FjaGVbbG9jYXRpb25dID0geGhyUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoclByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBTdGFja0ZyYW1lLCBlbmhhbmNlIGZ1bmN0aW9uIG5hbWUgYW5kIHVzZSBzb3VyY2UgbWFwcyBmb3IgYVxuICAgICAgICAgKiBiZXR0ZXIgU3RhY2tGcmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdGFja0ZyYW1lfSBzdGFja2ZyYW1lIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyB3aXRoIHdpdGggc291cmNlLW1hcHBlZCBTdGFja0ZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBpbnBvaW50ID0gZnVuY3Rpb24gU3RhY2tUcmFjZUdQUyQkcGlucG9pbnQoc3RhY2tmcmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TWFwcGVkTG9jYXRpb24oc3RhY2tmcmFtZSkudGhlbihmdW5jdGlvbihtYXBwZWRTdGFja0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVNYXBwZWRTdGFja0ZyYW1lKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtYXBwZWRTdGFja0ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZEZ1bmN0aW9uTmFtZShtYXBwZWRTdGFja0ZyYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSwgcmVzb2x2ZU1hcHBlZFN0YWNrRnJhbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBbJ2NhdGNoJ10ocmVzb2x2ZU1hcHBlZFN0YWNrRnJhbWUpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgU3RhY2tGcmFtZSwgZ3Vlc3MgZnVuY3Rpb24gbmFtZSBmcm9tIGxvY2F0aW9uIGluZm9ybWF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0YWNrRnJhbWV9IHN0YWNrZnJhbWVcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgd2l0aCBlbmhhbmNlZCBTdGFja0ZyYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maW5kRnVuY3Rpb25OYW1lID0gZnVuY3Rpb24gU3RhY2tUcmFjZUdQUyQkZmluZEZ1bmN0aW9uTmFtZShzdGFja2ZyYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgX2Vuc3VyZVN0YWNrRnJhbWVJc0xlZ2l0KHN0YWNrZnJhbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldChzdGFja2ZyYW1lLmZpbGVOYW1lKS50aGVuKGZ1bmN0aW9uIGdldFNvdXJjZUNhbGxiYWNrKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHN0YWNrZnJhbWUubGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHN0YWNrZnJhbWUuY29sdW1uTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3Vlc3NlZEZ1bmN0aW9uTmFtZSA9IF9maW5kRnVuY3Rpb25OYW1lKHNvdXJjZSwgbGluZU51bWJlciwgY29sdW1uTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSByZXBsYWNlIGZ1bmN0aW9uTmFtZSBpZiB3ZSBmb3VuZCBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGd1ZXNzZWRGdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IFN0YWNrRnJhbWUoZ3Vlc3NlZEZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja2ZyYW1lLmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tmcmFtZS5maWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcikpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGFja2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHJlamVjdClbJ2NhdGNoJ10ocmVqZWN0KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgU3RhY2tGcmFtZSwgc2VlayBzb3VyY2UtbWFwcGVkIGxvY2F0aW9uIGFuZCByZXR1cm4gbmV3IGVuaGFuY2VkIFN0YWNrRnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RhY2tGcmFtZX0gc3RhY2tmcmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyB3aXRoIGVuaGFuY2VkIFN0YWNrRnJhbWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldE1hcHBlZExvY2F0aW9uID0gZnVuY3Rpb24gU3RhY2tUcmFjZUdQUyQkZ2V0TWFwcGVkTG9jYXRpb24oc3RhY2tmcmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIF9lbnN1cmVTdXBwb3J0ZWRFbnZpcm9ubWVudCgpO1xuICAgICAgICAgICAgICAgIF9lbnN1cmVTdGFja0ZyYW1lSXNMZWdpdChzdGFja2ZyYW1lKTtcblxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VDYWNoZSA9IHRoaXMuc291cmNlQ2FjaGU7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gc3RhY2tmcmFtZS5maWxlTmFtZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXQoZmlsZU5hbWUpLnRoZW4oZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VNYXBwaW5nVVJMID0gX2ZpbmRTb3VyY2VNYXBwaW5nVVJMKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0RhdGFVcmwgPSBzb3VyY2VNYXBwaW5nVVJMLnN1YnN0cigwLCA1KSA9PT0gJ2RhdGE6JztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2UgPSBmaWxlTmFtZS5zdWJzdHJpbmcoMCwgZmlsZU5hbWUubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VNYXBwaW5nVVJMWzBdICE9PSAnLycgJiYgIWlzRGF0YVVybCAmJiAhKC9eaHR0cHM/OlxcL1xcL3xeXFwvXFwvL2kpLnRlc3Qoc291cmNlTWFwcGluZ1VSTCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU1hcHBpbmdVUkwgPSBiYXNlICsgc291cmNlTWFwcGluZ1VSTDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldChzb3VyY2VNYXBwaW5nVVJMKS50aGVuKGZ1bmN0aW9uKHNvdXJjZU1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwID0gX3BhcnNlSnNvbihzb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VNYXAuc291cmNlUm9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXAuc291cmNlUm9vdCA9IGJhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9leHRyYWN0TG9jYXRpb25JbmZvRnJvbVNvdXJjZU1hcChzdGFja2ZyYW1lLCBzb3VyY2VNYXAsIHNvdXJjZUNhY2hlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpWydjYXRjaCddKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3RhY2tmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVqZWN0KVsnY2F0Y2gnXShyZWplY3QpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgcmVqZWN0KVsnY2F0Y2gnXShyZWplY3QpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfTtcbiAgICB9O1xufSkpO1xuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3RhY2t0cmFjZScsIFsnZXJyb3Itc3RhY2stcGFyc2VyJywgJ3N0YWNrLWdlbmVyYXRvcicsICdzdGFja3RyYWNlLWdwcyddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnZXJyb3Itc3RhY2stcGFyc2VyJyksIHJlcXVpcmUoJ3N0YWNrLWdlbmVyYXRvcicpLCByZXF1aXJlKCdzdGFja3RyYWNlLWdwcycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LlN0YWNrVHJhY2UgPSBmYWN0b3J5KHJvb3QuRXJyb3JTdGFja1BhcnNlciwgcm9vdC5TdGFja0dlbmVyYXRvciwgcm9vdC5TdGFja1RyYWNlR1BTKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIFN0YWNrVHJhY2UoRXJyb3JTdGFja1BhcnNlciwgU3RhY2tHZW5lcmF0b3IsIFN0YWNrVHJhY2VHUFMpIHtcbiAgICB2YXIgX29wdGlvbnMgPSB7XG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24oc3RhY2tmcmFtZSkge1xuICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBzdGFja2ZyYW1lcyBmb3IgdGhpcyBsaWJyYXJ5IGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHJldHVybiAoc3RhY2tmcmFtZS5mdW5jdGlvbk5hbWUgfHwgJycpLmluZGV4T2YoJ1N0YWNrVHJhY2UkJCcpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIChzdGFja2ZyYW1lLmZ1bmN0aW9uTmFtZSB8fCAnJykuaW5kZXhPZignRXJyb3JTdGFja1BhcnNlciQkJykgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgKHN0YWNrZnJhbWUuZnVuY3Rpb25OYW1lIHx8ICcnKS5pbmRleE9mKCdTdGFja1RyYWNlR1BTJCQnKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAoc3RhY2tmcmFtZS5mdW5jdGlvbk5hbWUgfHwgJycpLmluZGV4T2YoJ1N0YWNrR2VuZXJhdG9yJCQnKSA9PT0gLTE7XG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZUNhY2hlOiB7fVxuICAgIH07XG5cbiAgICB2YXIgX2dlbmVyYXRlRXJyb3IgPSBmdW5jdGlvbiBTdGFja1RyYWNlJCRHZW5lcmF0ZUVycm9yKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRXJyb3IgbXVzdCBiZSB0aHJvd24gdG8gZ2V0IHN0YWNrIGluIElFXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1lcmdlIDIgZ2l2ZW4gT2JqZWN0cy4gSWYgYSBjb25mbGljdCBvY2N1cnMgdGhlIHNlY29uZCBvYmplY3Qgd2lucy5cbiAgICAgKiBEb2VzIG5vdCBkbyBkZWVwIG1lcmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmaXJzdCBiYXNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZWNvbmQgb3ZlcnJpZGVzXG4gICAgICogQHJldHVybnMge09iamVjdH0gbWVyZ2VkIGZpcnN0IGFuZCBzZWNvbmRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9tZXJnZShmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB7fTtcblxuICAgICAgICBbZmlyc3QsIHNlY29uZF0uZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaXNTaGFwZWRMaWtlUGFyc2FibGVFcnJvcihlcnIpIHtcbiAgICAgICAgcmV0dXJuIGVyci5zdGFjayB8fCBlcnJbJ29wZXJhI3NvdXJjZWxvYyddO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9maWx0ZXJlZChzdGFja2ZyYW1lcywgZmlsdGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tmcmFtZXMuZmlsdGVyKGZpbHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrZnJhbWVzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBiYWNrdHJhY2UgZnJvbSBpbnZvY2F0aW9uIHBvaW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IG9mIFN0YWNrRnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gU3RhY2tUcmFjZSQkZ2V0KG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBfZ2VuZXJhdGVFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuIF9pc1NoYXBlZExpa2VQYXJzYWJsZUVycm9yKGVycikgPyB0aGlzLmZyb21FcnJvcihlcnIsIG9wdHMpIDogdGhpcy5nZW5lcmF0ZUFydGlmaWNpYWxseShvcHRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgYmFja3RyYWNlIGZyb20gaW52b2NhdGlvbiBwb2ludC5cbiAgICAgICAgICogSU1QT1JUQU5UOiBEb2VzIG5vdCBoYW5kbGUgc291cmNlIG1hcHMgb3IgZ3Vlc3MgZnVuY3Rpb24gbmFtZXMhXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gb2YgU3RhY2tGcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3luYzogZnVuY3Rpb24gU3RhY2tUcmFjZSQkZ2V0U3luYyhvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gX21lcmdlKF9vcHRpb25zLCBvcHRzKTtcbiAgICAgICAgICAgIHZhciBlcnIgPSBfZ2VuZXJhdGVFcnJvcigpO1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gX2lzU2hhcGVkTGlrZVBhcnNhYmxlRXJyb3IoZXJyKSA/IEVycm9yU3RhY2tQYXJzZXIucGFyc2UoZXJyKSA6IFN0YWNrR2VuZXJhdG9yLmJhY2t0cmFjZShvcHRzKTtcbiAgICAgICAgICAgIHJldHVybiBfZmlsdGVyZWQoc3RhY2ssIG9wdHMuZmlsdGVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYW4gZXJyb3Igb2JqZWN0LCBwYXJzZSBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3Igb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBmb3IgQXJyYXlbU3RhY2tGcmFtZX1cbiAgICAgICAgICovXG4gICAgICAgIGZyb21FcnJvcjogZnVuY3Rpb24gU3RhY2tUcmFjZSQkZnJvbUVycm9yKGVycm9yLCBvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gX21lcmdlKF9vcHRpb25zLCBvcHRzKTtcbiAgICAgICAgICAgIHZhciBncHMgPSBuZXcgU3RhY2tUcmFjZUdQUyhvcHRzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrZnJhbWVzID0gX2ZpbHRlcmVkKEVycm9yU3RhY2tQYXJzZXIucGFyc2UoZXJyb3IpLCBvcHRzLmZpbHRlcik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShQcm9taXNlLmFsbChzdGFja2ZyYW1lcy5tYXAoZnVuY3Rpb24oc2YpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVPcmlnaW5hbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZ3BzLnBpbnBvaW50KHNmKS50aGVuKHJlc29sdmUsIHJlc29sdmVPcmlnaW5hbClbJ2NhdGNoJ10ocmVzb2x2ZU9yaWdpbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSBTdGFja0dlbmVyYXRvciB0byBnZW5lcmF0ZSBhIGJhY2t0cmFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IG9mIEFycmF5W1N0YWNrRnJhbWVdXG4gICAgICAgICAqL1xuICAgICAgICBnZW5lcmF0ZUFydGlmaWNpYWxseTogZnVuY3Rpb24gU3RhY2tUcmFjZSQkZ2VuZXJhdGVBcnRpZmljaWFsbHkob3B0cykge1xuICAgICAgICAgICAgb3B0cyA9IF9tZXJnZShfb3B0aW9ucywgb3B0cyk7XG4gICAgICAgICAgICB2YXIgc3RhY2tGcmFtZXMgPSBTdGFja0dlbmVyYXRvci5iYWNrdHJhY2Uob3B0cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc3RhY2tGcmFtZXMgPSBzdGFja0ZyYW1lcy5maWx0ZXIob3B0cy5maWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzdGFja0ZyYW1lcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgZnVuY3Rpb24sIHdyYXAgaXQgc3VjaCB0aGF0IGludm9jYXRpb25zIHRyaWdnZXIgYSBjYWxsYmFjayB0aGF0XG4gICAgICAgICAqIGlzIGNhbGxlZCB3aXRoIGEgc3RhY2sgdHJhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRvIGJlIGluc3RydW1lbnRlZFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdpdGggYSBzdGFjayB0cmFjZSBvbiBpbnZvY2F0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVycmJhY2sgb3B0aW9uYWwgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIGVycm9yIGlmIHVuYWJsZSB0byBnZXQgc3RhY2sgdHJhY2UuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIG9wdGlvbmFsIGNvbnRleHQgb2JqZWN0IChlLmcuIHdpbmRvdylcbiAgICAgICAgICovXG4gICAgICAgIGluc3RydW1lbnQ6IGZ1bmN0aW9uIFN0YWNrVHJhY2UkJGluc3RydW1lbnQoZm4sIGNhbGxiYWNrLCBlcnJiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaW5zdHJ1bWVudCBub24tZnVuY3Rpb24gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmbi5fX3N0YWNrdHJhY2VPcmlnaW5hbEZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBpbnN0cnVtZW50ZWQsIHJldHVybiBnaXZlbiBGdW5jdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluc3RydW1lbnRlZCA9IGZ1bmN0aW9uIFN0YWNrVHJhY2UkJGluc3RydW1lbnRlZCgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldCgpLnRoZW4oY2FsbGJhY2ssIGVycmJhY2spWydjYXRjaCddKGVycmJhY2spO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZyB8fCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1NoYXBlZExpa2VQYXJzYWJsZUVycm9yKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyb21FcnJvcihlKS50aGVuKGNhbGxiYWNrLCBlcnJiYWNrKVsnY2F0Y2gnXShlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIGluc3RydW1lbnRlZC5fX3N0YWNrdHJhY2VPcmlnaW5hbEZuID0gZm47XG5cbiAgICAgICAgICAgIHJldHVybiBpbnN0cnVtZW50ZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgZnVuY3Rpb24gdGhhdCBoYXMgYmVlbiBpbnN0cnVtZW50ZWQsXG4gICAgICAgICAqIHJldmVydCB0aGUgZnVuY3Rpb24gdG8gaXQncyBvcmlnaW5hbCAobm9uLWluc3RydW1lbnRlZCkgc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIHRvIGRlLWluc3RydW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGRlaW5zdHJ1bWVudDogZnVuY3Rpb24gU3RhY2tUcmFjZSQkZGVpbnN0cnVtZW50KGZuKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZGUtaW5zdHJ1bWVudCBub24tZnVuY3Rpb24gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmbi5fX3N0YWNrdHJhY2VPcmlnaW5hbEZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLl9fc3RhY2t0cmFjZU9yaWdpbmFsRm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIG5vdCBpbnN0cnVtZW50ZWQsIHJldHVybiBvcmlnaW5hbFxuICAgICAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYW4gZXJyb3IgbWVzc2FnZSBhbmQgQXJyYXkgb2YgU3RhY2tGcmFtZXMsIHNlcmlhbGl6ZSBhbmQgUE9TVCB0byBnaXZlbiBVUkwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHN0YWNrZnJhbWVzXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGVycm9yTXNnXG4gICAgICAgICAqL1xuICAgICAgICByZXBvcnQ6IGZ1bmN0aW9uIFN0YWNrVHJhY2UkJHJlcG9ydChzdGFja2ZyYW1lcywgdXJsLCBlcnJvck1zZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gb25yZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID49IDIwMCAmJiByZXEuc3RhdHVzIDwgNDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignUE9TVCB0byAnICsgdXJsICsgJyBmYWlsZWQgd2l0aCBzdGF0dXM6ICcgKyByZXEuc3RhdHVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcS5vcGVuKCdwb3N0JywgdXJsKTtcbiAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcblxuICAgICAgICAgICAgICAgIHZhciByZXBvcnRQYXlsb2FkID0ge3N0YWNrOiBzdGFja2ZyYW1lc307XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTXNnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0UGF5bG9hZC5tZXNzYWdlID0gZXJyb3JNc2c7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVxLnNlbmQoSlNPTi5zdHJpbmdpZnkocmVwb3J0UGF5bG9hZCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSkpO1xuIiwiaW1wb3J0IEFjdGlvbiBmcm9tIFwiLi4vZG9tYWluL0FjdGlvblwiO1xuaW1wb3J0IEFpZmV4U2VydmljZSBmcm9tIFwiLi4vZG9tYWluL0FpZmV4U2VydmljZVwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuLi9kb21haW4vVG9rZW5cIjtcbmltcG9ydCBXZWJTaXRlIGZyb20gXCIuLi9kb21haW4vV2Vic2l0ZVwiO1xuaW1wb3J0IFNlc3Npb24gZnJvbSBcIi4uL2RvbWFpbi9TZXNzaW9uXCI7XG5pbXBvcnQgQWlmZXhQbHVnaW5JbmZvIGZyb20gXCIuLi9kb21haW4vQWlmZXhQbHVnaW5JbmZvXCI7XG5jb25zdCBPS19TVEFUVVMgPSAyMDA7XG5jb25zdCBJTlZBTElEX1BBUkFNRVRFUlNfU1RBVFVTID0gNDAwO1xuY29uc3QgRk9SQklEREVOX1NUQVRVUyA9IDQwMztcbmNvbnN0IE5PVF9GT1VORF9TVEFUVVMgPSA0MDQ7XG5jb25zdCBJTlRFUk5BTF9TRVJWRVJfRVJST1JfU1RBVFVTID0gNTAwO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWlmZXhTZXJ2aWNlSFRUUCBpbXBsZW1lbnRzIEFpZmV4U2VydmljZSB7XG5cblx0cGluZyhzZXJ2ZXJVUkw6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuXHRcdHJldHVybiBmZXRjaChgJHtzZXJ2ZXJVUkx9L2FwaS9waW5nYCwge1xuXHRcdFx0bWV0aG9kOiBcIkdFVFwiLFxuXHRcdFx0aGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuXHRcdH0pXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcblx0XHRcdFx0aWYgKHJlc3BvbnNlLm9rKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ29rJyk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdlcnJvcicpO1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0fVxuXG5cdGdldFBsdWdpbkluZm8oc2VydmVyVVJMOiBzdHJpbmcpOiBQcm9taXNlPEFpZmV4UGx1Z2luSW5mbz4ge1xuXHRcdGNvbnN0IG9wdGlvbiA9IHtcblx0XHRcdG1ldGhvZDogXCJHRVRcIixcblx0XHRcdGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcblx0XHR9O1xuXHRcdHJldHVybiBmZXRjaChgJHtzZXJ2ZXJVUkx9L2FwaS9wbHVnaW4taW5mb2AsIG9wdGlvbilcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblx0XHRcdFx0aWYgKCFyZXNwb25zZS5vaykge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKGRldGFpbHMgPT4ge1xuXHRcdFx0XHRkZXRhaWxzLnVybCA9IGAke3NlcnZlclVSTH0vZG93bmxvYWRgXG5cdFx0XHRcdHJldHVybiBuZXcgQWlmZXhQbHVnaW5JbmZvKGRldGFpbHMudmVyc2lvbiwgZGV0YWlscy5uYW1lLCBkZXRhaWxzLmRlc2NyaXB0aW9uLCBkZXRhaWxzLnVybCk7XG5cdFx0XHR9KVxuXHR9XG5cblx0Z2V0U2Vzc2lvbihzZXJ2ZXJVUkw6IHN0cmluZywgc2Vzc2lvbklkOiBzdHJpbmcsIHRva2VuOiBUb2tlbiB8IHVuZGVmaW5lZCk6IFByb21pc2U8U2Vzc2lvbiB8IHVuZGVmaW5lZCB8IFwiVW5hdXRob3JpemVkXCI+IHtcblx0XHRjb25zdCBTRVNTSU9OX1VSTCA9IHNlcnZlclVSTCArICcvYXBpL3Nlc3Npb25zLycgKyBzZXNzaW9uSWQ7XG5cdFx0cmV0dXJuIGZldGNoKFNFU1NJT05fVVJMLCB7XG5cdFx0XHRtZXRob2Q6ICdHRVQnLFxuXHRcdFx0aGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCBcIkF1dGhvcml6YXRpb25cIjogYEJlYXJlciAke3Rva2VuPy50b2tlbn1gIH0sXG5cdFx0fSlcblx0XHRcdC50aGVuKChyZXNwb25zZSkgPT4ge1xuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBPS19TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2Vcblx0XHRcdFx0XHRcdC5qc29uKClcblx0XHRcdFx0XHRcdC50aGVuKChzZXNzaW9uOiB7XG5cdFx0XHRcdFx0XHRcdGlkOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHRcdHdlYlNpdGU6IHsgaWQ6IHN0cmluZyB9LFxuXHRcdFx0XHRcdFx0XHRiYXNlVVJMOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHRcdG5hbWU6IHN0cmluZyxcblx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRpb246IHN0cmluZyxcblx0XHRcdFx0XHRcdFx0b3ZlcmxheVR5cGU6IFwicmFpbmJvd1wiIHwgXCJibHVlc2t5XCIgfCBcInNoYWRvd1wiLFxuXHRcdFx0XHRcdFx0XHRyZWNvcmRpbmdNb2RlOiBcImJ5ZXhwbG9yYXRpb25cIiB8IFwiYnlpbnRlcmFjdGlvblwiXG5cblx0XHRcdFx0XHRcdH0pID0+IHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBTZXNzaW9uKHNlc3Npb24uaWQsIHNlc3Npb24ud2ViU2l0ZS5pZCwgc2Vzc2lvbi5iYXNlVVJMLCBzZXNzaW9uLm5hbWUsIHNlc3Npb24uZGVzY3JpcHRpb24sIHNlc3Npb24ub3ZlcmxheVR5cGUsIHNlc3Npb24ucmVjb3JkaW5nTW9kZSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBJTlZBTElEX1BBUkFNRVRFUlNfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBOT1RfRk9VTkRfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBGT1JCSURERU5fU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFwiVW5hdXRob3JpemVkXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gSU5URVJOQUxfU0VSVkVSX0VSUk9SX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChgc2VydmVyIGVycm9yYCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdH1cblxuXHRnZXRXZWJTaXRlKHNlcnZlclVSTDogc3RyaW5nLCB3ZWJTaXRlSWQ6IHN0cmluZywgdG9rZW46IFRva2VuIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxXZWJTaXRlIHwgdW5kZWZpbmVkIHwgXCJVbmF1dGhvcml6ZWRcIj4ge1xuXHRcdHJldHVybiBmZXRjaChgJHtzZXJ2ZXJVUkx9L2FwaS93ZWJzaXRlcy8ke3dlYlNpdGVJZH1gLCB7XG5cdFx0XHRtZXRob2Q6ICdHRVQnLFxuXHRcdFx0aGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLCBcIkF1dGhvcml6YXRpb25cIjogYEJlYXJlciAke3Rva2VuPy50b2tlbn1gIH0sXG5cdFx0fSlcblx0XHRcdC50aGVuKChyZXNwb25zZSkgPT4ge1xuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBPS19TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2Vcblx0XHRcdFx0XHRcdC5qc29uKClcblx0XHRcdFx0XHRcdC50aGVuKHdlYnNpdGVEYXRhID0+IHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBXZWJTaXRlKHdlYnNpdGVEYXRhLmlkLCB3ZWJzaXRlRGF0YS5uYW1lLCB3ZWJzaXRlRGF0YS5tYXBwaW5nTGlzdCk7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IElOVkFMSURfUEFSQU1FVEVSU19TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoYHNlc3Npb25JZCBpcyBtYWxmb3JtZWRgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBOT1RfRk9VTkRfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IElOVEVSTkFMX1NFUlZFUl9FUlJPUl9TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoYHNlcnZlciBlcnJvcmApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXG5cdH1cblxuXHRjcmVhdGVFbXB0eUV4cGxvcmF0aW9uKHRlc3Rlck5hbWU6IHN0cmluZywgc2VydmVyVVJMOiBzdHJpbmcsIHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcblx0XHRjb25zdCBib2R5ID0ge1xuXHRcdFx0dGVzdGVyTmFtZSxcblx0XHRcdGludGVyYWN0aW9uTGlzdDogW10sXG5cdFx0fTtcblx0XHRjb25zdCBvcHRpb24gPSB7XG5cdFx0XHRtZXRob2Q6IFwiUE9TVFwiLFxuXHRcdFx0Ym9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG5cdFx0XHRoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG5cdFx0fTtcblx0XHRyZXR1cm4gZmV0Y2goXG5cdFx0XHRgJHtzZXJ2ZXJVUkx9L2FwaS9zZXNzaW9ucy8ke3Nlc3Npb25JZH0vZXhwbG9yYXRpb25zYCxcblx0XHRcdG9wdGlvblxuXHRcdClcblx0XHRcdC50aGVuKChyZXNwb25zZSkgPT4ge1xuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBPS19TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2UuanNvbigpLnRoZW4oZGF0YSA9PiB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YS5leHBsb3JhdGlvbk51bWJlclxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gTk9UX0ZPVU5EX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYG5vIHNlc3Npb24gbm90IGZvdW5kIGZvciBJZGApKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBJTlZBTElEX1BBUkFNRVRFUlNfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgc2Vzc2lvbklkIGFuZC9vciBleHBsb3JhdGlvbiBpcyBtYWxmb3JtZWRgKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gSU5URVJOQUxfU0VSVkVSX0VSUk9SX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYHNlcnZlciBlcnJvcmApKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblxuXHR9XG5cblx0c2VuZEFjdGlvbihleHBsb3JhdGlvbk51bWJlcjogbnVtYmVyLCBhY3Rpb246IEFjdGlvbiwgc2VydmVyVVJMOiBzdHJpbmcsIHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cblx0XHRjb25zdCBib2R5ID0ge1xuXHRcdFx0aW50ZXJhY3Rpb25MaXN0OiBbe1xuXHRcdFx0XHRjb25jcmV0ZVR5cGU6IGFjdGlvbi5nZXRDb25jcmV0ZVR5cGUoKSxcblx0XHRcdFx0a2luZDogYWN0aW9uLnByZWZpeCxcblx0XHRcdFx0dmFsdWU6IGFjdGlvbi5zdWZmaXgsXG5cdFx0XHRcdGRhdGU6IGFjdGlvbi5kYXRlXG5cdFx0XHR9XVxuXHRcdH1cblx0XHRjb25zdCBvcHRpb24gPSB7XG5cdFx0XHRtZXRob2Q6IFwiUE9TVFwiLFxuXHRcdFx0Ym9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG5cdFx0XHRoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG5cdFx0fTtcblx0XHRyZXR1cm4gZmV0Y2goXG5cdFx0XHRgJHtzZXJ2ZXJVUkx9L2FwaS9zZXNzaW9ucy8ke3Nlc3Npb25JZH0vZXhwbG9yYXRpb25zLyR7ZXhwbG9yYXRpb25OdW1iZXJ9L2ludGVyYWN0aW9uc2AsXG5cdFx0XHRvcHRpb24pXG5cdFx0XHQudGhlbigocmVzcG9uc2UpID0+IHtcblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gT0tfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IE5PVF9GT1VORF9TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBzZXNzaW9uSWQgbm90IGZvdW5kYCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IElOVkFMSURfUEFSQU1FVEVSU19TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBzZXNzaW9uSWQgYW5kL29yIGV4cGxvcmF0aW9uIGlzIG1hbGZvcm1lZGApKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBJTlRFUk5BTF9TRVJWRVJfRVJST1JfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgc2VydmVyIGVycm9yYCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KS5jYXRjaChlcnJvciA9PiB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJTZXJ2aWNlIEZhaWxlZCB0byBwdXNoIG5ldyBhY3Rpb25cIik7XG5cdFx0XHR9KVxuXG5cdH1cbn1cbiIsImltcG9ydCBCcm93c2VyU2VydmljZSBmcm9tIFwiLi4vZG9tYWluL0Jyb3dzZXJTZXJ2aWNlXCI7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwiLi4vZnJhbWV3b3JrL0xvZ2dlclwiO1xuXG5jb25zdCBFWFBMT1JBVElPTl9OVU1CRVJfS0VZID0gJ0VYUExPUkFUSU9OX05VTUJFUl9LRVknO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZSBpbXBsZW1lbnRzIEJyb3dzZXJTZXJ2aWNlIHtcblx0Z2V0RXhwbG9yYXRpb25OdW1iZXIoKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZS5nZXRFeHBsb3JhdGlvbk51bWJlclwiKTtcbiAgICAgICAgY29uc3QgZXhwbG9yYXRpb25OdW1iZXJJdGVtID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShFWFBMT1JBVElPTl9OVU1CRVJfS0VZKTtcbiAgICAgICAgaWYgKGV4cGxvcmF0aW9uTnVtYmVySXRlbSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkTnVtYmVyID0gcGFyc2VJbnQoZXhwbG9yYXRpb25OdW1iZXJJdGVtKTtcbiAgICAgICAgICAgIGlmIChpc05hTihwYXJzZWROdW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZS5nZXRFeHBsb3JhdGlvbk51bWJlcjogTmFOXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkJyb3dzZXJTZXJ2aWNlU2Vzc2lvblN0b3JhZ2UuZ2V0RXhwbG9yYXRpb25OdW1iZXI6IFwiICsgcGFyc2VkTnVtYmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkTnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkJyb3dzZXJTZXJ2aWNlU2Vzc2lvblN0b3JhZ2UuZ2V0RXhwbG9yYXRpb25OdW1iZXI6IHVuZGVmaW5lZFwiKTtcbiAgICB9XG5cblx0c2F2ZUV4cGxvcmF0aW9uTnVtYmVyKGV4cGxvcmF0aW9uTnVtYmVyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZS5zYXZlRXhwbG9yYXRpb25OdW1iZXI6IFwiICsgZXhwbG9yYXRpb25OdW1iZXIpO1xuICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKEVYUExPUkFUSU9OX05VTUJFUl9LRVksIGV4cGxvcmF0aW9uTnVtYmVyLnRvU3RyaW5nKCkpO1xuICAgIH1cbn0iLCJpbXBvcnQgUnVsZSBmcm9tIFwiLi9SdWxlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjdGlvbiB7XG5cbiAgICBwdWJsaWMgcHJlZml4OiBzdHJpbmc7XG4gICAgcHVibGljIHN1ZmZpeDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHB1YmxpYyBydWxlTGlzdDogUnVsZVtdO1xuICAgIHB1YmxpYyBodG1sRWxlbWVudExpc3Q6IChIVE1MRWxlbWVudHxTVkdFbGVtZW50KVtdO1xuICAgIHB1YmxpYyBkYXRlOiBEYXRlO1xuXG4gICAgY29uc3RydWN0b3IocHJlZml4OiBzdHJpbmcsIHN1ZmZpeD86IHN0cmluZywgcnVsZUxpc3Q6IFJ1bGVbXSA9IFtdLCBodG1sRWxlbWVudExpc3Q6IEhUTUxFbGVtZW50W109IFtdKSB7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdGhpcy5ydWxlTGlzdCA9IHJ1bGVMaXN0O1xuICAgICAgICB0aGlzLmh0bWxFbGVtZW50TGlzdCA9IGh0bWxFbGVtZW50TGlzdDtcbiAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0UnVsZUxpc3QocnVsZUxpc3Q6IFJ1bGVbXSk6IHZvaWQge1xuICAgICAgICB0aGlzLnJ1bGVMaXN0ID0gcnVsZUxpc3Q7XG4gICAgfVxuXG4gICAgcHVibGljIGdldENvbmNyZXRlVHlwZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gXCJBY3Rpb25cIjtcbiAgICB9XG5cbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRoaXMuc3VmZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5wcmVmaXh9JCR7dGhpcy5zdWZmaXh9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZWZpeDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBlcXVhbHMoYWN0aW9uOiBBY3Rpb24pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5wcmVmaXggPT09IGFjdGlvbi5wcmVmaXgpICYmICh0aGlzLnN1ZmZpeCA9PT0gYWN0aW9uLnN1ZmZpeCkpXG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlQWN0aW9uKGFjdGlvblRleHQ6IHN0cmluZyk6IEFjdGlvbiB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gYWN0aW9uVGV4dC5zcGxpdChcIiRcIik7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uKHBhcnRzWzBdKVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tbWFnaWMtbnVtYmVyc1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24ocGFydHNbMF0sIHBhcnRzWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBhY3Rpb24gOiBcIiArIGFjdGlvblRleHQpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn0iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBBaWZleFBsdWdpbkluZm8ge1xuICAgIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcbiAgICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICByZWFkb25seSB1cmw6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHZlcnNpb246IHN0cmluZywgbmFtZTogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nLCB1cmw6IHN0cmluZykge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgIH1cbn0iLCJpbXBvcnQgQWN0aW9uIGZyb20gJy4vQWN0aW9uJztcbmltcG9ydCBTaW1wbGVSdWxlIGZyb20gJy4vU2ltcGxlUnVsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF0dHJpYnV0ZVZhbHVlUnVsZSBleHRlbmRzIFNpbXBsZVJ1bGUge1xuXG4gICAgcHVibGljIGF0dHJpYnV0ZU5hbWU6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHByZWZpeDogc3RyaW5nLCBcbiAgICAgICAgc3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQsIFxuICAgICAgICBldmVudDogc3RyaW5nLCBjc3M6IHN0cmluZyB8IHVuZGVmaW5lZCwgXG4gICAgICAgIHhwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCwgXG4gICAgICAgIGtleTogc3RyaW5nIHwgdW5kZWZpbmVkLCBcbiAgICAgICAgY29udGV4dFVSTDogc3RyaW5nIHwgdW5kZWZpbmVkLCBcbiAgICAgICAgY29udGV4dENTUzogc3RyaW5nIHwgdW5kZWZpbmVkLCBcbiAgICAgICAgY29udGV4dFhQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIFxuICAgICAgICBkZXNjcmlwdGlvbjogc3RyaW5nLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBzdHJpbmcsXG4gICAgICAgICkge1xuICAgICAgICBzdXBlcihwcmVmaXgsIHN1ZmZpeCwgZXZlbnQsIGNzcywgeHBhdGgsIGNvZGUsIGtleSwgY29udGV4dFVSTCwgY29udGV4dENTUywgY29udGV4dFhQYXRoLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWVcbiAgICB9XG5cbiAgICBtYWtlQWN0aW9uKGV2ZW50IDogRXZlbnQpOiBBY3Rpb24gfCB1bmRlZmluZWQge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5maW5kQWN0aW9uTWFwcGVkVGFyZ2V0KGV2ZW50KTtcblxuICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgYXR0cmlidXRlVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0aGlzLmF0dHJpYnV0ZU5hbWUpXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGlvbih0aGlzLnByZWZpeCwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWN0aW9uKHRoaXMucHJlZml4KTtcbiAgICB9XG5cblxuICAgIGFjdGlvblRvRWxlbWVudHMoYWN0aW9uOiBBY3Rpb24pOiAoSFRNTEVsZW1lbnR8IFNWR0VsZW1lbnQpW10ge1xuICAgICAgICBpZiAoYWN0aW9uLnByZWZpeCAhPT0gdGhpcy5wcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uLnN1ZmZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuYWN0aW9uVG9FbGVtZW50cyhhY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IGFjdGlvbi5zdWZmaXg7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZmluZE1hdGNoZWRFbGVtZW50cygpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcihkb21FbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb21FbGVtZW50LmdldEF0dHJpYnV0ZSh0aGlzLmF0dHJpYnV0ZU5hbWUpID09PSBzdWZmaXg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIi4uL2ZyYW1ld29yay9Mb2dnZXJcIjtcbmltcG9ydCBBY3Rpb24gZnJvbSBcIi4vQWN0aW9uXCI7XG5pbXBvcnQgQWlmZXhTZXJ2aWNlIGZyb20gXCIuL0FpZmV4U2VydmljZVwiO1xuaW1wb3J0IEJyb3dzZXJTZXJ2aWNlIGZyb20gXCIuL0Jyb3dzZXJTZXJ2aWNlXCI7XG5pbXBvcnQgQ2xhc3NNdXRhdGlvbkhhbmRsZXIgZnJvbSBcIi4vQ2xhc3NNdXRhdGlvbkhhbmRsZXJcIjtcbmltcG9ydCBFdmVudExpc3RlbmVyIGZyb20gXCIuL0V2ZW50TGlzdGVuZXJcIjtcbmltcG9ydCBQYWdlTXV0YXRpb25IYW5kbGVyIGZyb20gXCIuL1BhZ2VNdXRhdGlvbkhhbmRsZXJcIjtcbmltcG9ydCBSdWxlU2VydmljZSBmcm9tIFwiLi9SdWxlU2VydmljZVwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuL1Rva2VuXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJvd3NlclNjcmlwdCB7XG5cbiAgICBwcml2YXRlIF9zZXJ2ZXJVUkw6IHN0cmluZztcblx0cHJpdmF0ZSBfc2Vzc2lvbklkOiBzdHJpbmc7XG5cdHByaXZhdGUgX3dlYlNpdGVJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXHRwcml2YXRlIF90b2tlbjogVG9rZW4gfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfcnVsZVNlcnZpY2UgOiBSdWxlU2VydmljZTtcbiAgICBwcml2YXRlIF9ldmVudExpc3RlbmVyIDogRXZlbnRMaXN0ZW5lcjtcbiAgICBwcml2YXRlIF9haWZleFNlcnZpY2UgOiBBaWZleFNlcnZpY2U7XG4gICAgcHJpdmF0ZSBfYnJvd3NlclNlcnZpY2UgOiBCcm93c2VyU2VydmljZTtcbiAgICBwcml2YXRlIF9wYWdlTXV0YXRpb25IYW5kbGVyIDogUGFnZU11dGF0aW9uSGFuZGxlcjtcbiAgICBwcml2YXRlIF9jbGFzc011dGF0aW9uSGFuZGxlciA6IENsYXNzTXV0YXRpb25IYW5kbGVyIHwgdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgX2V4cGxvcmF0aW9uTnVtYmVyOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgICBcbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXJVUkw6IHN0cmluZywgc2Vzc2lvbklkOiBzdHJpbmcsIHRva2VuOiBUb2tlbiB8IHVuZGVmaW5lZCwgYWlmZXhTZXJ2aWNlOiBBaWZleFNlcnZpY2UsIGJyb3dzZXJTZXJ2aWNlOiBCcm93c2VyU2VydmljZSkge1xuICAgICAgICB0aGlzLl9zZXJ2ZXJVUkwgPSBzZXJ2ZXJVUkw7XG4gICAgICAgIHRoaXMuX3Nlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICAgICAgdGhpcy5fdG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5fYWlmZXhTZXJ2aWNlID0gYWlmZXhTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9icm93c2VyU2VydmljZSA9IGJyb3dzZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9ydWxlU2VydmljZSA9IG5ldyBSdWxlU2VydmljZSgpO1xuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVyID0gbmV3IEV2ZW50TGlzdGVuZXIodGhpcy5fcnVsZVNlcnZpY2UpO1xuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVyLmFkZE9ic2VydmVyKHRoaXMucHJvY2Vzc05ld0FjdGlvbi5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLl9wYWdlTXV0YXRpb25IYW5kbGVyID0gbmV3IFBhZ2VNdXRhdGlvbkhhbmRsZXIodGhpcy5vbk11dGF0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9wYWdlTXV0YXRpb25IYW5kbGVyLmluaXQoKTtcbiAgICB9XG5cbiAgICBzdGFydCgpIDogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9haWZleFNlcnZpY2UuZ2V0U2Vzc2lvbih0aGlzLl9zZXJ2ZXJVUkwsIHRoaXMuX3Nlc3Npb25JZCwgdW5kZWZpbmVkKVxuICAgICAgICAgICAgLnRoZW4oKHNlc3Npb25SZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvblJlc3VsdCAmJiBzZXNzaW9uUmVzdWx0ICE9PSBcIlVuYXV0aG9yaXplZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dlYlNpdGVJZCA9IHNlc3Npb25SZXN1bHQud2ViU2l0ZUlkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9haWZleFNlcnZpY2UuZ2V0V2ViU2l0ZSh0aGlzLl9zZXJ2ZXJVUkwsIHRoaXMuX3dlYlNpdGVJZCwgdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHdlYlNpdGVSZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2ViU2l0ZVJlc3VsdCAmJiB3ZWJTaXRlUmVzdWx0ICE9PSAnVW5hdXRob3JpemVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBydWxlcyA9IHdlYlNpdGVSZXN1bHQubWFwcGluZ0xpc3QubWFwKChydSA6IGFueSkgPT4gdGhpcy5fcnVsZVNlcnZpY2UuY3JlYXRlUnVsZShydSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ydWxlU2VydmljZS5sb2FkUnVsZXMocnVsZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ydWxlU2VydmljZS5nZXRFdmVudHNUb0hhbmRsZSgpLmluY2x1ZGVzKFwiY3NzLWNsYXNzLWFkZGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2xhc3NNdXRhdGlvbkhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsYXNzTXV0YXRpb25IYW5kbGVyID0gbmV3IENsYXNzTXV0YXRpb25IYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3J1bGVTZXJ2aWNlLm1hcFJ1bGVzVG9FbGVtZW50cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFJ1bGVzIGxvYWRlZCA6ICR7cnVsZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RXhwbG9yYXRpb25OdW1iZXIgPSB0aGlzLl9icm93c2VyU2VydmljZS5nZXRFeHBsb3JhdGlvbk51bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RXhwbG9yYXRpb25OdW1iZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBsb3JhdGlvbk51bWJlciA9IGN1cnJlbnRFeHBsb3JhdGlvbk51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9haWZleFNlcnZpY2UuY3JlYXRlRW1wdHlFeHBsb3JhdGlvbihcIkJST1dTRVJfU0NSSVBUXCIsIHRoaXMuX3NlcnZlclVSTCwgdGhpcy5fc2Vzc2lvbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoZXhwbG9yYXRpb25OdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cGxvcmF0aW9uTnVtYmVyID0gZXhwbG9yYXRpb25OdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9icm93c2VyU2VydmljZS5zYXZlRXhwbG9yYXRpb25OdW1iZXIodGhpcy5fZXhwbG9yYXRpb25OdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NOZXdBY3Rpb24obmV3IEFjdGlvbihcInN0YXJ0XCIsIHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwcm9jZXNzTmV3QWN0aW9uKGFjdGlvbjogQWN0aW9uKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9leHBsb3JhdGlvbk51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZXhwbG9yYXRpb24gaGFzIG5vdCBiZWVuIGNvcnJlY3RseSBzdGFydGVkXCIpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWlmZXhTZXJ2aWNlLnNlbmRBY3Rpb24odGhpcy5fZXhwbG9yYXRpb25OdW1iZXIsIGFjdGlvbiwgdGhpcy5fc2VydmVyVVJMLCB0aGlzLl9zZXNzaW9uSWQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25NdXRhdGlvbigpIDp2b2lke1xuICAgICAgICB0aGlzLl9ydWxlU2VydmljZS5tYXBSdWxlc1RvRWxlbWVudHMoKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgQ29udGV4dE1hcHBlciBmcm9tIFwiLi9Db250ZXh0TWFwcGVyXCI7XG5pbXBvcnQgUnVsZSBmcm9tIFwiLi9SdWxlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENTU0NvbnRleHRNYXBwZXIgZXh0ZW5kcyBDb250ZXh0TWFwcGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQgOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgfVxuXG4gICAgYnVpbGRFbGVtZW50VG9SdWxlTWFwKCkgOiBNYXA8SFRNTEVsZW1lbnR8U1ZHRWxlbWVudCwgUnVsZVtdPiB7XG4gICAgICAgIGlmICh0aGlzLl9jb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBjc3NRdWVyeVJlc3VsdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5fY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoY3NzUXVlcnlSZXN1bHQgJiYgY3NzUXVlcnlSZXN1bHQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkRWxlbWVudFRvUnVsZU1hcEZvclNlbGVjdG9ycyhjc3NRdWVyeVJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxufSIsImltcG9ydCBBY3Rpb24gZnJvbSAnLi9BY3Rpb24nO1xuaW1wb3J0IFJ1bGUgZnJvbSAnLi9SdWxlJztcbmltcG9ydCBnZXRDc3NTZWxlY3RvciBmcm9tICdjc3Mtc2VsZWN0b3ItZ2VuZXJhdG9yJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tIFwiLi4vZnJhbWV3b3JrL0xvZ2dlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDU1NTZWxlY3RvclJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXg6IHN0cmluZywgc3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQsIGV2ZW50OiBzdHJpbmcsIGNzczogc3RyaW5nIHwgdW5kZWZpbmVkLCB4cGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgICAgICBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGtleTogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0VVJMOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRDU1M6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dFhQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIocHJlZml4LCBzdWZmaXgsIGV2ZW50LCBjc3MsIHhwYXRoLCBjb2RlLCBrZXksIGNvbnRleHRVUkwsIGNvbnRleHRDU1MsIGNvbnRleHRYUGF0aCwgZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIG1ha2VBY3Rpb24oZXZlbnQgOiBFdmVudCk6IEFjdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7IFxuICAgICAgICAgICAgICAgIGxldCBzdWZmaXg7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gZ2V0Q3NzU2VsZWN0b3IoZXZlbnQudGFyZ2V0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0YWdcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBibGFja2xpc3Q6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipkYXRhLiovaSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qYWlmZXguKi9pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipvdmVyLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLiphdXRvLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLip2YWx1ZS4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qY2hlY2tlZC4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1twbGFjZWhvbGRlcl0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKmhyZWYuKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKnNyYy4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qb25jbGljay4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qb25sb2FkLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipvbmtleXVwLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLip3aWR0aC4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qaGVpZ2h0LiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipzdHlsZS4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qc2l6ZS4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qbWF4bGVuZ3RoLiovaVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbWJpbmVCZXR3ZWVuU2VsZWN0b3JzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4Q2FuZGlkYXRlczogMTAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBleGNlcHRpb25gLG5ldyBFcnJvcignY3NzIGV4Y2VwdGlvbicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24odGhpcy5wcmVmaXgsIHN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3Rpb25Ub0VsZW1lbnRzKGFjdGlvbjogQWN0aW9uKTogKEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpW10ge1xuICAgICAgICBpZiAoYWN0aW9uLnByZWZpeCAhPT0gdGhpcy5wcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24uc3VmZml4KSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA6IChIVE1MRWxlbWVudHxTVkdFbGVtZW50KVtdID0gW107XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50cyA9IHRoaXMuZmluZE1hdGNoZWRFbGVtZW50cygpO1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChhY3Rpb24uc3VmZml4KS5mb3JFYWNoKCAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRFbGVtZW50cy5zb21lKChwYXJlbnQpID0+IHBhcmVudC5jb250YWlucyhlbGVtZW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBlbGVtZW50IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IEFjdGlvbiBmcm9tICcuL0FjdGlvbic7XG5pbXBvcnQgUnVsZSBmcm9tICcuL1J1bGUnO1xuaW1wb3J0IGdldENzc1NlbGVjdG9yIGZyb20gJ2Nzcy1zZWxlY3Rvci1nZW5lcmF0b3InO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gXCIuLi9mcmFtZXdvcmsvTG9nZ2VyXCI7XG5pbXBvcnQgeyBDc3NTZWxlY3RvclR5cGUgfSBmcm9tICdjc3Mtc2VsZWN0b3ItZ2VuZXJhdG9yL3R5cGVzL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1NTU2VsZWN0b3JXaXRoVmFsdWVSdWxlIGV4dGVuZHMgUnVsZSB7XG4gICAgY29uc3RydWN0b3IocHJlZml4OiBzdHJpbmcsIHN1ZmZpeDogc3RyaW5nIHwgdW5kZWZpbmVkLCBldmVudDogc3RyaW5nLCBjc3M6IHN0cmluZyB8IHVuZGVmaW5lZCwgeHBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICAgICAgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBrZXk6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dFVSTDogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0Q1NTOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRYUGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkLCBkZXNjcmlwdGlvbjogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKHByZWZpeCwgc3VmZml4LCBldmVudCwgY3NzLCB4cGF0aCwgY29kZSwga2V5LCBjb250ZXh0VVJMLCBjb250ZXh0Q1NTLCBjb250ZXh0WFBhdGgsIGRlc2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICBtYWtlQWN0aW9uKGV2ZW50IDogRXZlbnQpOiBBY3Rpb24gfCB1bmRlZmluZWQge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkgeyBcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdldFZhbHVlKGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSBnZXRDc3NTZWxlY3RvcihldmVudC50YXJnZXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRhZ1wiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImF0dHJpYnV0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsYWNrbGlzdDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKmRhdGEuKi9pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLiphaWZleC4qL2ksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKm92ZXIuKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKmF1dG8uKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKnZhbHVlLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipjaGVja2VkLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnW3BsYWNlaG9sZGVyXScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qaHJlZi4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qc3JjLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipvbmNsaWNrLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipvbmxvYWQuKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKm9ua2V5dXAuKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKndpZHRoLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipoZWlnaHQuKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKnN0eWxlLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipzaXplLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLiptYXhsZW5ndGguKi9pXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZUJldHdlZW5TZWxlY3RvcnM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhDYW5kaWRhdGVzOiAxMDBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYGV4Y2VwdGlvbmAsbmV3IEVycm9yKCdjc3MgZXhjZXB0aW9uJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdWZmaXggKz0gYD8ke3ZhbHVlfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uKHRoaXMucHJlZml4LCBzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWN0aW9uVG9FbGVtZW50cyhhY3Rpb246IEFjdGlvbik6IChIVE1MRWxlbWVudHxTVkdFbGVtZW50KVtdIHtcbiAgICAgICAgaWYgKGFjdGlvbi5wcmVmaXggIT09IHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uLnN1ZmZpeCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgOiAoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudClbXSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudHMgPSB0aGlzLmZpbmRNYXRjaGVkRWxlbWVudHMoKTtcbiAgICAgICAgICAgIGxldCBzaGFycENoYXJJbmRleCA9IGFjdGlvbi5zdWZmaXguaW5kZXhPZignPycpO1xuICAgICAgICAgICAgbGV0IGNzc1NlbGVjdG9yID0gc2hhcnBDaGFySW5kZXggPT09IC0xID8gYWN0aW9uLnN1ZmZpeCA6IGFjdGlvbi5zdWZmaXguc3Vic3RyaW5nKDAsIHNoYXJwQ2hhckluZGV4KTtcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoY3NzU2VsZWN0b3IpLmZvckVhY2goIChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEVsZW1lbnRzLnNvbWUoKHBhcmVudCkgPT4gcGFyZW50LmNvbnRhaW5zKGVsZW1lbnQpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IGVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRWYWx1ZShlbGVtZW50OiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnZhbHVlO1xuICAgICAgICB9IFxuXG4gICAgICAgIGNvbnN0IHZhbHVlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIGlmICh2YWx1ZUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlQXR0cmlidXRlO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIi4uL2ZyYW1ld29yay9Mb2dnZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2xhc3NNdXRhdGlvbkhhbmRsZXIge1xuXG4gICAgcHJpdmF0ZSBfb2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXI7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigocmVjb3JkcykgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSBcImNsYXNzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2NsYXNzIG11dGF0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC50YXJnZXQubWF0Y2hlcygnOmhvdmVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDbGFzcyA9IHJlY29yZC50YXJnZXQuZ2V0QXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3JlYXRlRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5vbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDbGFzcyAmJiBjdXJyZW50Q2xhc3MuaW5jbHVkZXMocmVjb3JkLm9sZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFdmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNyZWF0ZUV2ZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdjcmVhdGUgZXZlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudCA9IG5ldyBFdmVudCgnY3NzLWNsYXNzLWFkZGVkJyx7YnViYmxlczp0cnVlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHsgYXR0cmlidXRlczogdHJ1ZSwgc3VidHJlZTogdHJ1ZSwgYXR0cmlidXRlT2xkVmFsdWU6IHRydWV9O1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmJvZHksIGNvbmZpZyk7XG4gICAgICAgIGxvZ2dlci5pbmZvKCdjbGFzcyBtdXRhdGlvbiBoYW5kbGVyIGluaXRpYWxpemVkJyk7XG4gICAgfVxuXG59IiwiaW1wb3J0IENvbnRleHRNYXBwZXIgZnJvbSBcIi4vQ29udGV4dE1hcHBlclwiO1xuaW1wb3J0IFJ1bGUgZnJvbSBcIi4vUnVsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZXh0TGVzc01hcHBlciBleHRlbmRzIENvbnRleHRNYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcih1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIGJ1aWxkRWxlbWVudFRvUnVsZU1hcCgpIDogTWFwPEhUTUxFbGVtZW50fFNWR0VsZW1lbnQsIFJ1bGVbXT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZEVsZW1lbnRUb1J1bGVNYXBGb3JTZWxlY3RvcnMoKTtcbiAgICB9XG59IiwiaW1wb3J0IFJ1bGUgZnJvbSBcIi4vUnVsZVwiO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gXCIuLi9mcmFtZXdvcmsvTG9nZ2VyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIENvbnRleHRNYXBwZXIge1xuICAgIHByb3RlY3RlZCBfY29udGV4dCA6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBwcm90ZWN0ZWQgX2Nzc1NlbGVjdG9yMlJ1bGVzIDogTWFwPHN0cmluZywgUnVsZVtdPjtcbiAgICBwcm90ZWN0ZWQgX3hwYXRoU2VsZWN0b3IyUnVsZXMgOiBNYXA8c3RyaW5nLCBSdWxlW10+O1xuXG4gICAgY29uc3RydWN0b3IoY29udGV4dCA6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fY3NzU2VsZWN0b3IyUnVsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3hwYXRoU2VsZWN0b3IyUnVsZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgYWRkKHJ1bGUgOiBSdWxlKTogdm9pZCB7XG4gICAgICAgIGlmIChydWxlLmNvbnRleHRDU1MgIT09IHRoaXMuX2NvbnRleHQgJiYgcnVsZS5jb250ZXh0VVJMICE9PSB0aGlzLl9jb250ZXh0ICYmIHJ1bGUuY29udGV4dFhQYXRoICE9PSB0aGlzLl9jb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBhZGQgcnVsZSB3aXRoIGEgZGlmZmVyZW50IGNvbnRleHQgJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bGUuY3NzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Nzc1NlbGVjdG9yMlJ1bGVzLmhhcyhydWxlLmNzcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jc3NTZWxlY3RvcjJSdWxlcy5zZXQocnVsZS5jc3MsIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBydWxlczRTZWxlY3RvciA9IHRoaXMuX2Nzc1NlbGVjdG9yMlJ1bGVzLmdldChydWxlLmNzcyk7XG4gICAgICAgICAgICBpZiAocnVsZXM0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBydWxlczRTZWxlY3Rvci5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChydWxlLnhwYXRoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3hwYXRoU2VsZWN0b3IyUnVsZXMuaGFzKHJ1bGUueHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feHBhdGhTZWxlY3RvcjJSdWxlcy5zZXQocnVsZS54cGF0aCwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJ1bGVzNFNlbGVjdG9yID0gdGhpcy5feHBhdGhTZWxlY3RvcjJSdWxlcy5nZXQocnVsZS54cGF0aCk7XG4gICAgICAgICAgICBpZiAocnVsZXM0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBydWxlczRTZWxlY3Rvci5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWJzdHJhY3QgYnVpbGRFbGVtZW50VG9SdWxlTWFwKCkgOiBNYXA8SFRNTEVsZW1lbnR8U1ZHRWxlbWVudCwgUnVsZVtdPjtcblxuICAgIHByb3RlY3RlZCBidWlsZEVsZW1lbnRUb1J1bGVNYXBGb3JTZWxlY3RvcnMoY29udGV4dD8gOiBIVE1MRWxlbWVudHxTVkdFbGVtZW50KSA6IE1hcDxIVE1MRWxlbWVudHxTVkdFbGVtZW50LCBSdWxlW10+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudFRvUnVsZXMgOiBNYXA8SFRNTEVsZW1lbnR8U1ZHRWxlbWVudCwgUnVsZVtdPiA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIHJ1bGVzXSBvZiB0aGlzLl9jc3NTZWxlY3RvcjJSdWxlcykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5U2VsZWN0b3IgOiBOb2RlTGlzdE9mPEhUTUxFbGVtZW50fFNWR0VsZW1lbnQ+O1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVNlbGVjdG9yID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnlTZWxlY3RvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVlcnlTZWxlY3Rvci5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBydWxlczRFbGVtZW50ID0gZWxlbWVudFRvUnVsZXMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICghcnVsZXM0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBydWxlczRFbGVtZW50ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRUb1J1bGVzLnNldChlbGVtZW50LCBydWxlczRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVsZXM0RWxlbWVudC5wdXNoKC4uLnJ1bGVzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIHJ1bGVzXSBvZiB0aGlzLl94cGF0aFNlbGVjdG9yMlJ1bGVzKSB7XG4gICAgICAgICAgICBsZXQgcXVlcnlYcGF0aDtcbiAgICAgICAgICAgIGxldCBxdWVyeVhwYXRoUmVzdWx0O1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5WHBhdGggPSBkb2N1bWVudC5ldmFsdWF0ZShzZWxlY3RvciwgY29udGV4dCwgbnVsbCwgWFBhdGhSZXN1bHQuQU5ZX1RZUEUsIG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5WHBhdGggPSBkb2N1bWVudC5ldmFsdWF0ZShzZWxlY3RvciwgZG9jdW1lbnQsIG51bGwsIFhQYXRoUmVzdWx0LkFOWV9UWVBFLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdYUGF0aCBFcnJvcjonLG5ldyBFcnJvcihcImVcIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocXVlcnlYcGF0aCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5WHBhdGhSZXN1bHQgPSBxdWVyeVhwYXRoLml0ZXJhdGVOZXh0KCk7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocXVlcnlYcGF0aFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlYcGF0aFJlc3VsdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHF1ZXJ5WHBhdGhSZXN1bHQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9Db250ZXh0ID0gISBjb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdEluQ29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5jb250YWlucyhxdWVyeVhwYXRoUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub0NvbnRleHQgfHwgcmVzdWx0SW5Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bGVzNEVsZW1lbnQgPSBlbGVtZW50VG9SdWxlcy5nZXQocXVlcnlYcGF0aFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlczRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzNEVsZW1lbnQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFRvUnVsZXMuc2V0KHF1ZXJ5WHBhdGhSZXN1bHQsIHJ1bGVzNEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlczRFbGVtZW50LnB1c2goLi4ucnVsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5WHBhdGhSZXN1bHQgPSBxdWVyeVhwYXRoLml0ZXJhdGVOZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50VG9SdWxlcztcbiAgICB9XG59IiwiaW1wb3J0IFJ1bGVTZXJ2aWNlIGZyb20gXCIuL1J1bGVTZXJ2aWNlXCI7XG5pbXBvcnQgQWN0aW9uIGZyb20gXCIuL0FjdGlvblwiO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIi4uL2ZyYW1ld29yay9Mb2dnZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRMaXN0ZW5lciB7XG4gICAgcHJpdmF0ZSBfcnVsZVNlcnZpY2U6IFJ1bGVTZXJ2aWNlO1xuICAgIHByaXZhdGUgX2hhbmRsZWRFdmVudHM6IHN0cmluZ1tdO1xuICAgIHByaXZhdGUgX29ic2VydmVyczogKChhY3Rpb246IEFjdGlvbikgPT4gdm9pZClbXTtcblxuICAgIGNvbnN0cnVjdG9yKHJ1bGVTZXJ2aWNlOiBSdWxlU2VydmljZSkge1xuICAgICAgICB0aGlzLl9ydWxlU2VydmljZSA9IHJ1bGVTZXJ2aWNlXG4gICAgICAgIHRoaXMuX2hhbmRsZWRFdmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzID0gW107XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZWRFdmVudHMgPSB0aGlzLl9ydWxlU2VydmljZS5nZXRFdmVudHNUb0hhbmRsZSgpO1xuICAgICAgICBsb2dnZXIuZGVidWcoYEV2ZW50TGlzdGVuZXI6IHRoZXJlIGFyZSAke3RoaXMuX2hhbmRsZWRFdmVudHMubGVuZ3RofSBldmVudHMgdG8gaGFuZGxlYCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZWRFdmVudHMuZm9yRWFjaCgoaGFuZGxlZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGhhbmRsZWRFdmVudCwgdGhpcy5leHBsb3JhdG9yeUxpc3RlbmVyLmJpbmQodGhpcyksIHRydWUpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZE9ic2VydmVyKG9ic2VydmVyRnVuY3Rpb24gOiAoYWN0aW9uOiBBY3Rpb24pID0+IHZvaWQpIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXJGdW5jdGlvbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHBsb3JhdG9yeUxpc3RlbmVyKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgICAgICBsZXQgdW5zYWZlRXZlbnQ6IGFueSA9IGV2ZW50O1xuICAgICAgICBpZiAodW5zYWZlRXZlbnQuaXNUcnVzdGVkKSB7XG4gICAgICAgICAgICBpZiAoIXVuc2FmZUV2ZW50LmV4cGxvcmVkKSB7XG4gICAgICAgICAgICAgICAgdW5zYWZlRXZlbnQuZXhwbG9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgRXZlbnRMaXN0ZW5lcjogZXZlbnQgJHt1bnNhZmVFdmVudC50eXBlfSBpcyBiZWluZyBoYW5kbGVkYCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVsZSA9IHRoaXMuX3J1bGVTZXJ2aWNlLmdldE1hdGNoaW5nUnVsZShldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aW9uID0gcnVsZS5tYWtlQWN0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYGFjdGlvbiA6ICR7YWN0aW9uLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcihhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ25vIGFjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgQWN0aW9uIGZyb20gJy4vQWN0aW9uJztcbmltcG9ydCBTaW1wbGVSdWxlIGZyb20gJy4vU2ltcGxlUnVsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZGV4UnVsZSBleHRlbmRzIFNpbXBsZVJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeDogc3RyaW5nLCBzdWZmaXg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IHN0cmluZywgY3NzOiBzdHJpbmcgfCB1bmRlZmluZWQsIHhwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCwga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRVUkw6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dENTUzogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0WFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgICAgICBzdXBlcihwcmVmaXgsIHN1ZmZpeCwgZXZlbnQsIGNzcywgeHBhdGgsIGNvZGUsIGtleSwgY29udGV4dFVSTCwgY29udGV4dENTUywgY29udGV4dFhQYXRoLCBkZXNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgbWFrZUFjdGlvbihldmVudCA6IEV2ZW50KTogQWN0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdFbGVtZW50cyA9IHRoaXMuZmluZE1hdGNoZWRFbGVtZW50cygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoaW5nRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRFbGVtZW50cyA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpLmZpbHRlcigodGFyZ2V0KTp0YXJnZXQgaXMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50ID0+IHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHRhcmdldEVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgbWF0Y2hpbmdFbGVtZW50c1tpXS5jb250YWlucyh0YXJnZXRFbGVtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGlvbih0aGlzLnByZWZpeCwgaS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFjdGlvblRvRWxlbWVudHMoYWN0aW9uOiBBY3Rpb24pOiAoSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50KVtdIHtcbiAgICAgICAgaWYgKGFjdGlvbi5wcmVmaXggIT09IHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYoYWN0aW9uLnN1ZmZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuYWN0aW9uVG9FbGVtZW50cyhhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoYWN0aW9uLnN1ZmZpeCwgMTApO1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZmluZE1hdGNoZWRFbGVtZW50cygpO1xuICAgICAgICAvLyBIYXBwZW5zIGlmIGEgcHJldmlvdXMgcnVsZXMgd2FzIG5vdCB1c2luZyB0aGUgaW5kZXggc3VmZml4XG4gICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkIHx8wqBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2VsZW1lbnRzW2luZGV4XV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBBY3Rpb24gZnJvbSAnLi9BY3Rpb24nO1xuaW1wb3J0IFNpbXBsZVJ1bGUgZnJvbSAnLi9TaW1wbGVSdWxlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5uZXJUZXh0UnVsZSBleHRlbmRzIFNpbXBsZVJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeDogc3RyaW5nLCBzdWZmaXg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IHN0cmluZywgY3NzOiBzdHJpbmcgfCB1bmRlZmluZWQsIHhwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCwga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRVUkw6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dENTUzogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0WFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgICAgICBzdXBlcihwcmVmaXgsIHN1ZmZpeCwgZXZlbnQsIGNzcywgeHBhdGgsIGNvZGUsIGtleSwgY29udGV4dFVSTCwgY29udGV4dENTUywgY29udGV4dFhQYXRoLCBkZXNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgbWFrZUFjdGlvbihldmVudDogYW55KTogQWN0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZmluZEFjdGlvbk1hcHBlZFRhcmdldChldmVudCk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24odGhpcy5wcmVmaXgsIGVsZW1lbnQuaW5uZXJUZXh0LnRyaW0oKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uKHRoaXMucHJlZml4LCBcInN2Z1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFjdGlvblRvRWxlbWVudHMoYWN0aW9uOiBBY3Rpb24pOiAoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudClbXSB7XG4gICAgICAgIGlmIChhY3Rpb24ucHJlZml4ICE9PSB0aGlzLnByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb24uc3VmZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5hY3Rpb25Ub0VsZW1lbnRzKGFjdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3VmZml4ID0gYWN0aW9uLnN1ZmZpeDtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5maW5kTWF0Y2hlZEVsZW1lbnRzKCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHMuZmlsdGVyKGRvbUVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkb21FbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQuaW5uZXJUZXh0LnRyaW0oKSA9PT0gc3VmZml4LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRvbUVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN2Z1wiID09PSBzdWZmaXgudHJpbSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJjb25zdCBNVVRBVElPTl9SRUZSRVNIX0NIRUNLID0gMTAwMDtcbmNvbnN0IERPTV9JRFMgPSBbXCJBSUZFWF9wcm9iYWJpbGl0eVBvcHVwXCIsIFwiQUlGRVhfdGFiXCJdO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gXCIuLi9mcmFtZXdvcmsvTG9nZ2VyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhZ2VNdXRhdGlvbkhhbmRsZXIge1xuXG4gICAgbGFzdE11dGF0aW9uOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgb2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXIgfCB1bmRlZmluZWQ7XG4gICAgbXV0YXRpb25IYXNPY2N1cmVkOiBib29sZWFuO1xuICAgIGJlUmVmcmVzaGluZyA6IGJvb2xlYW47XG4gICAgd2lsbFJlZnJlc2ggOiBib29sZWFuO1xuXG4gICAgb25QYWdlTXV0YXRpb246ICgpID0+IHZvaWQ7XG5cbiAgICBjb25zdHJ1Y3RvcihvblBhZ2VNdXRhdGlvbjogKCkgPT4gdm9pZCkge1xuICAgICAgICB0aGlzLm9uUGFnZU11dGF0aW9uID0gb25QYWdlTXV0YXRpb25cbiAgICAgICAgdGhpcy5iZVJlZnJlc2hpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbkhhc09jY3VyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy53aWxsUmVmcmVzaCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubGFzdE11dGF0aW9uID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChyZWNvcmRzKSA9PiB7XG4gICAgICAgICAgICBsZXQgd2F0Y2hlZFBhZ2VIYXNNdXRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImNoaWxkTGlzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzV2F0Y2hlZE5vZGVMaXN0KHJlY29yZC5hZGRlZE5vZGVzKSAmJiAhIHRoaXMuaXNJbmNsdWRlZEluQUlGRVhFbGVtZW50KHJlY29yZC5hZGRlZE5vZGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2hlZFBhZ2VIYXNNdXRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3YXRjaGVkUGFnZUhhc011dGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoISB0aGlzLmJlUmVmcmVzaGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJlUmVmcmVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25QYWdlTXV0YXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJlUmVmcmVzaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9LCBNVVRBVElPTl9SRUZSRVNIX0NIRUNLKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2lsbFJlZnJlc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2lsbFJlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgVElNRV9DSEVDS19NVUxUSVBMSUVSID0gMjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZVJlZnJlc2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25QYWdlTXV0YXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZVJlZnJlc2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53aWxsUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIE1VVEFUSU9OX1JFRlJFU0hfQ0hFQ0spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgVElNRV9DSEVDS19NVUxUSVBMSUVSICogTVVUQVRJT05fUkVGUkVTSF9DSEVDSyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHsgYXR0cmlidXRlczogZmFsc2UsIGNoaWxkTGlzdDogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogZmFsc2UsIHN1YnRyZWU6IHRydWV9O1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuYm9keSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzV2F0Y2hlZE5vZGVMaXN0KG5vZGVMaXN0IDogTm9kZUxpc3QpIDogYm9vbGVhbiB7XG4gICAgICAgIGxldCBpc1dhdGNoZWQgOiBib29sZWFuID0gZmFsc2U7XG4gICAgICAgIG5vZGVMaXN0LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudGFnTmFtZSAhPT0gXCJTQ1JJUFRcIiAmJiBub2RlLnRhZ05hbWUgIT09IFwiSUZSQU1FXCIgJiYgbm9kZS50YWdOYW1lICE9PSBcIklNR1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5zdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNXYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuc3R5bGUuZGlzcGxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNXYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zdHlsZS5kaXNwbGF5ICE9PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNXYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGlzV2F0Y2hlZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzSW5jbHVkZWRJbkFJRkVYRWxlbWVudChub2RlTGlzdCA6IE5vZGVMaXN0KSA6IGJvb2xlYW4ge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHZhcmlhYmxlLW5hbWVcbiAgICAgICAgY29uc3QgQUlGRVhFbGVtZW50TGlzdCA9IERPTV9JRFMubWFwKGlkID0+IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSkuZmlsdGVyKChlbGVtZW50KTogZWxlbWVudCBpcyBIVE1MRWxlbWVudCA9PiBlbGVtZW50ICE9PSBudWxsKTtcbiAgICAgICAgbGV0IGlzSW5jbHVkZWQgOiBib29sZWFuID0gdHJ1ZTtcbiAgICAgICAgbm9kZUxpc3QuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFJRkVYRWxlbWVudExpc3Quc29tZSgoYWlmZXhOb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhaWZleE5vZGUuY29udGFpbnMobm9kZSk7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNJbmNsdWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGlzSW5jbHVkZWQ7XG4gICAgfVxufSIsImltcG9ydCB7IHF1ZXJ5U2VsZWN0b3JBbGxEZWVwIH0gZnJvbSAncXVlcnktc2VsZWN0b3Itc2hhZG93LWRvbSc7XG5pbXBvcnQgQWN0aW9uIGZyb20gXCIuL0FjdGlvblwiO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBSdWxlIHtcblxuICAgIGV2ZW50OiBzdHJpbmc7XG4gICAgY3NzOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgeHBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBwcmVmaXg6IHN0cmluZztcbiAgICBzdWZmaXg6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBrZXk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgY29udGV4dFVSTDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGNvbnRleHRDU1M6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBjb250ZXh0WFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHJlZml4OiBzdHJpbmcsIHN1ZmZpeDogc3RyaW5nIHwgdW5kZWZpbmVkLCBldmVudDogc3RyaW5nLCBjc3M6IHN0cmluZyB8IHVuZGVmaW5lZCwgeHBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICAgICAgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBrZXk6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dFVSTDogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0Q1NTOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRYUGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkLCBkZXNjcmlwdGlvbjogc3RyaW5nKSB7XG5cbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmNzcyA9IGNzcztcbiAgICAgICAgdGhpcy54cGF0aCA9IHhwYXRoO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLmNvbnRleHRVUkwgPSBjb250ZXh0VVJMO1xuICAgICAgICB0aGlzLmNvbnRleHRDU1MgPSBjb250ZXh0Q1NTO1xuICAgICAgICB0aGlzLmNvbnRleHRYUGF0aCA9IGNvbnRleHRYUGF0aDtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIG1hdGNoKGV2ZW50IDogRXZlbnQpIDogYm9vbGVhbiB7XG4gICAgICAgIGlmIChldmVudC50eXBlICE9PSB0aGlzLmV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudCA9PT0gXCJrZXl1cFwiIHx8IHRoaXMuZXZlbnQgPT09IFwia2V5ZG93blwiIHx8IHRoaXMuZXZlbnQgPT09IFwia2V5cHJlc3NcIikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvZGUgJiYgZXZlbnQuY29kZSAhPT0gdGhpcy5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZXkgJiYgZXZlbnQua2V5ICE9PSB0aGlzLmtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuXG4gICAgYWJzdHJhY3QgbWFrZUFjdGlvbihldmVudCA6IEV2ZW50KTogQWN0aW9uIHwgdW5kZWZpbmVkO1xuXG4gICAgYWJzdHJhY3QgYWN0aW9uVG9FbGVtZW50cyhhY3Rpb246IEFjdGlvbik6IChIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQpW10gO1xuXG4gICAgZmluZEFjdGlvbk1hcHBlZFRhcmdldChldmVudDogRXZlbnQpOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQgfCB1bmRlZmluZWQge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlKFwiYWlmZXhfc3R5bGVcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xvc2VzdCA9IHRhcmdldC5jbG9zZXN0KFwiW2FpZmV4X3N0eWxlXVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdCAmJiAoY2xvc2VzdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IGNsb3Nlc3QgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaW5kTWF0Y2hlZEVsZW1lbnRzKCkgOiAoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudClbXXtcbiAgICAgICAgbGV0IGNvbnRleHQ7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dFhQYXRoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRvY3VtZW50LmV2YWx1YXRlKHRoaXMuY29udGV4dFhQYXRoLCBkb2N1bWVudCwgbnVsbCwgWFBhdGhSZXN1bHQuQU5ZX1RZUEUsIG51bGwpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSByZXN1bHQuaXRlcmF0ZU5leHQoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRDU1MpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuY29udGV4dENTUyk7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMueHBhdGgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkb2N1bWVudC5ldmFsdWF0ZSh0aGlzLnhwYXRoLCBjb250ZXh0LCBudWxsLCBYUGF0aFJlc3VsdC5BTllfVFlQRSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZG9jdW1lbnQuZXZhbHVhdGUodGhpcy54cGF0aCwgZG9jdW1lbnQsIG51bGwsIFhQYXRoUmVzdWx0LkFOWV9UWVBFLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSByZXN1bHQuaXRlcmF0ZU5leHQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gcmVzdWx0Lml0ZXJhdGVOZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIGlmICh0aGlzLmNzcykge1xuICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cyA9IHF1ZXJ5U2VsZWN0b3JBbGxEZWVwKHRoaXMuY3NzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSBxdWVyeVNlbGVjdG9yQWxsRGVlcCh0aGlzLmNzcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudHMuZmlsdGVyKChlbGVtZW50IDogTm9kZSk6IGVsZW1lbnQgaXMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50ID0+IGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBlbGVtZW50IGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XG4gICAgfVxuXG59IiwiaW1wb3J0IENvbnRleHRNYXBwZXIgZnJvbSBcIi4vQ29udGV4dE1hcHBlclwiO1xuaW1wb3J0IFJ1bGUgZnJvbSBcIi4vUnVsZVwiO1xuaW1wb3J0IFVSTENvbnRleHRNYXBwZXIgZnJvbSBcIi4vVVJMQ29udGV4dE1hcHBlclwiO1xuaW1wb3J0IFhQYXRoQ29udGV4dE1hcHBlciBmcm9tIFwiLi9YUGF0aENvbnRleHRNYXBwZXJcIjtcbmltcG9ydCBDb250ZXh0TGVzc01hcHBlciBmcm9tIFwiLi9Db250ZXh0TGVzc01hcHBlclwiO1xuaW1wb3J0IENTU0NvbnRleHRNYXBwZXIgZnJvbSBcIi4vQ1NTQ29udGV4dE1hcHBlclwiO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gXCIuLi9mcmFtZXdvcmsvTG9nZ2VyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bGVNYXBwZXIge1xuICAgIHByaXZhdGUgX2Nzc0NvbnRleHQyQ29udGV4dE1hcHBlciA6IE1hcDxzdHJpbmcsIENvbnRleHRNYXBwZXI+O1xuICAgIHByaXZhdGUgX3hwYXRoQ29udGV4dDJDb250ZXh0TWFwcGVyIDogTWFwPHN0cmluZywgQ29udGV4dE1hcHBlcj47XG4gICAgcHJpdmF0ZSBfdXJsQ29udGV4dDJDb250ZXh0TWFwcGVyIDogTWFwPHN0cmluZywgQ29udGV4dE1hcHBlcj47XG4gICAgcHJpdmF0ZSBfY29udGV4dExlc3NNYXBwZXIgOiBDb250ZXh0TGVzc01hcHBlcjtcbiAgICBwcml2YXRlIF9wcmVmaXgyUnVsZXMgOiBNYXA8c3RyaW5nLCBSdWxlW10+O1xuICAgIHByaXZhdGUgX2V2ZW50SW5SdWxlcyA6IHN0cmluZ1tdO1xuICAgIHB1YmxpYyBydWxlczogUnVsZVtdO1xuXG4gICAgY29uc3RydWN0b3IocnVsZXMgOiBSdWxlW10pIHtcbiAgICAgICAgdGhpcy5fY3NzQ29udGV4dDJDb250ZXh0TWFwcGVyID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl94cGF0aENvbnRleHQyQ29udGV4dE1hcHBlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdXJsQ29udGV4dDJDb250ZXh0TWFwcGVyID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jb250ZXh0TGVzc01hcHBlciA9IG5ldyBDb250ZXh0TGVzc01hcHBlcigpO1xuICAgICAgICB0aGlzLl9wcmVmaXgyUnVsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2V2ZW50SW5SdWxlcyA9IFtdO1xuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG5cbiAgICAgICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgIGxldCBydWxlczRQcmVmaXggPSB0aGlzLl9wcmVmaXgyUnVsZXMuZ2V0KHJ1bGUucHJlZml4KTtcbiAgICAgICAgICAgIGlmICghIHJ1bGVzNFByZWZpeCkge1xuICAgICAgICAgICAgICAgIHJ1bGVzNFByZWZpeCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZWZpeDJSdWxlcy5zZXQocnVsZS5wcmVmaXgscnVsZXM0UHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bGVzNFByZWZpeC5wdXNoKHJ1bGUpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2V2ZW50SW5SdWxlcy5pbmNsdWRlcyhydWxlLmV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50SW5SdWxlcy5wdXNoKHJ1bGUuZXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocnVsZS5jb250ZXh0Q1NTKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRleHRNYXBwZXI0Q3NzQ29udGV4dCA9IHRoaXMuX2Nzc0NvbnRleHQyQ29udGV4dE1hcHBlci5nZXQocnVsZS5jb250ZXh0Q1NTKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHRNYXBwZXI0Q3NzQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0TWFwcGVyNENzc0NvbnRleHQgPSBuZXcgQ1NTQ29udGV4dE1hcHBlcihydWxlLmNvbnRleHRDU1MpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nzc0NvbnRleHQyQ29udGV4dE1hcHBlci5zZXQocnVsZS5jb250ZXh0Q1NTLCBjb250ZXh0TWFwcGVyNENzc0NvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0TWFwcGVyNENzc0NvbnRleHQuYWRkKHJ1bGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChydWxlLmNvbnRleHRYUGF0aCkge1xuICAgICAgICAgICAgICAgIGxldCBjb250ZXh0TWFwcGVyNFhwYXRoQ29udGV4dCA9IHRoaXMuX3hwYXRoQ29udGV4dDJDb250ZXh0TWFwcGVyLmdldChydWxlLmNvbnRleHRYUGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0TWFwcGVyNFhwYXRoQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0TWFwcGVyNFhwYXRoQ29udGV4dCA9IG5ldyBYUGF0aENvbnRleHRNYXBwZXIocnVsZS5jb250ZXh0WFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94cGF0aENvbnRleHQyQ29udGV4dE1hcHBlci5zZXQocnVsZS5jb250ZXh0WFBhdGgsIGNvbnRleHRNYXBwZXI0WHBhdGhDb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dE1hcHBlcjRYcGF0aENvbnRleHQuYWRkKHJ1bGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChydWxlLmNvbnRleHRVUkwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29udGV4TWFwcGVyNFVSTENvbnRleHQgPSB0aGlzLl91cmxDb250ZXh0MkNvbnRleHRNYXBwZXIuZ2V0KHJ1bGUuY29udGV4dFVSTCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXhNYXBwZXI0VVJMQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXhNYXBwZXI0VVJMQ29udGV4dCA9IG5ldyBVUkxDb250ZXh0TWFwcGVyKHJ1bGUuY29udGV4dFVSTCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VybENvbnRleHQyQ29udGV4dE1hcHBlci5zZXQocnVsZS5jb250ZXh0VVJMLCBjb250ZXhNYXBwZXI0VVJMQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleE1hcHBlcjRVUkxDb250ZXh0LmFkZChydWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dExlc3NNYXBwZXIuYWRkKHJ1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGdldElzTG9hZGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJlZml4MlJ1bGVzLnNpemUgPiAwO1xuICAgIH1cblxuICAgIGdldFJ1bGVMaXN0QnlQcmVmaXgocHJlZml4IDogc3RyaW5nKSA6IFJ1bGVbXSB7XG4gICAgICAgIGxldCBydWxlczRwcmVmaXMgPSB0aGlzLl9wcmVmaXgyUnVsZXMuZ2V0KHByZWZpeCk7XG4gICAgICAgIGlmIChydWxlczRwcmVmaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBydWxlczRwcmVmaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZXZlbnRJblJ1bGVzKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50SW5SdWxlcztcbiAgICB9XG5cbiAgICBidWlsZEVsZW1lbnRUb1J1bGVNYXAoKTogTWFwPEhUTUxFbGVtZW50fFNWR0VsZW1lbnQsIFJ1bGVbXT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgOiBNYXA8SFRNTEVsZW1lbnR8U1ZHRWxlbWVudCwgUnVsZVtdPiA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBtYXBwZXIgb2YgdGhpcy5fdXJsQ29udGV4dDJDb250ZXh0TWFwcGVyLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtlbGVtZW50LCBydWxlc10gb2YgbWFwcGVyLmJ1aWxkRWxlbWVudFRvUnVsZU1hcCgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJ1bGVzNGVsZW1lbnQgPSByZXN1bHQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICghcnVsZXM0ZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBydWxlczRlbGVtZW50ID0gW11cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChlbGVtZW50LHJ1bGVzNGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBydWxlczRlbGVtZW50LnB1c2goLi4ucnVsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbWFwcGVyIG9mIHRoaXMuX2Nzc0NvbnRleHQyQ29udGV4dE1hcHBlci52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZWxlbWVudCwgcnVsZXNdIG9mIG1hcHBlci5idWlsZEVsZW1lbnRUb1J1bGVNYXAoKSkge1xuICAgICAgICAgICAgICAgIGxldCBydWxlczRlbGVtZW50ID0gcmVzdWx0LmdldChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGVzNGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM0ZWxlbWVudCA9IFtdXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoZWxlbWVudCxydWxlczRlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVsZXM0ZWxlbWVudC5wdXNoKC4uLnJ1bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1hcHBlciBvZiB0aGlzLl94cGF0aENvbnRleHQyQ29udGV4dE1hcHBlci52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZWxlbWVudCwgcnVsZXNdIG9mIG1hcHBlci5idWlsZEVsZW1lbnRUb1J1bGVNYXAoKSkge1xuICAgICAgICAgICAgICAgIGxldCBydWxlczRlbGVtZW50ID0gcmVzdWx0LmdldChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGVzNGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM0ZWxlbWVudCA9IFtdXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoZWxlbWVudCxydWxlczRlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVsZXM0ZWxlbWVudC5wdXNoKC4uLnJ1bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtlbGVtZW50LCBydWxlc10gb2YgdGhpcy5fY29udGV4dExlc3NNYXBwZXIuYnVpbGRFbGVtZW50VG9SdWxlTWFwKCkpIHtcbiAgICAgICAgICAgIGxldCBydWxlczRlbGVtZW50ID0gcmVzdWx0LmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmICghcnVsZXM0ZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJ1bGVzNGVsZW1lbnQgPSBbXVxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoZWxlbWVudCxydWxlczRlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bGVzNGVsZW1lbnQucHVzaCguLi5ydWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbn0iLCJpbXBvcnQgUnVsZSBmcm9tIFwiLi9SdWxlXCI7XG5pbXBvcnQgQWN0aW9uIGZyb20gXCIuL0FjdGlvblwiO1xuaW1wb3J0IFJ1bGVNYXBwZXIgZnJvbSBcIi4vUnVsZU1hcHBlclwiO1xuaW1wb3J0IEluZGV4UnVsZSBmcm9tIFwiLi9JbmRleFJ1bGVcIjtcbmltcG9ydCBJbm5lclRleHRSdWxlIGZyb20gXCIuL0lubmVyVGV4dFJ1bGVcIjtcbmltcG9ydCBWYWx1ZVJ1bGUgZnJvbSBcIi4vVmFsdWVSdWxlXCI7XG5pbXBvcnQgU2ltcGxlUnVsZSBmcm9tIFwiLi9TaW1wbGVSdWxlXCI7XG5pbXBvcnQgQ1NTU2VsZWN0b3JSdWxlIGZyb20gXCIuL0NTU1NlbGVjdG9yUnVsZVwiO1xuaW1wb3J0IEF0dHJpYnV0ZVZhbHVlUnVsZSBmcm9tIFwiLi9BdHRyaWJ1dGVWYWx1ZVJ1bGVcIjtcbmltcG9ydCBDU1NTZWxlY3RvcldpdGhWYWx1ZVJ1bGUgZnJvbSBcIi4vQ1NTU2VsZWN0b3JXaXRoVmFsdWVSdWxlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJ1bGVTZXJ2aWNlIHtcbiAgICBlbGVtZW50UnVsZXM6IE1hcDxIVE1MRWxlbWVudHxTVkdFbGVtZW50LCBSdWxlW10+O1xuICAgIHByaXZhdGUgX3J1bGVNYXBwZXIgOiBSdWxlTWFwcGVyO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJ1bGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ydWxlTWFwcGVyID0gbmV3IFJ1bGVNYXBwZXIoW10pO1xuICAgIH1cblxuICAgIGdldCBlbGVtZW50TGlzdE1hdGNoZWRCeVJ1bGUoKTogKEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpW10ge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmVsZW1lbnRSdWxlcy5rZXlzKCkpXG4gICAgfVxuXG4gICAgZ2V0RXZlbnRzVG9IYW5kbGUoKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVsZU1hcHBlci5ldmVudEluUnVsZXM7XG4gICAgfVxuXG4gICAgbG9hZFJ1bGVzKHJ1bGVzIDogUnVsZVtdKTp2b2lkIHtcbiAgICAgICAgdGhpcy5fcnVsZU1hcHBlciA9IG5ldyBSdWxlTWFwcGVyKHJ1bGVzKTtcbiAgICB9XG5cbiAgICBtYXBSdWxlc1RvRWxlbWVudHMoKTp2b2lkIHtcbiAgICAgICAgdGhpcy5lbGVtZW50UnVsZXMgPSB0aGlzLl9ydWxlTWFwcGVyLmJ1aWxkRWxlbWVudFRvUnVsZU1hcCgpO1xuICAgIH1cblxuICAgIGdldE1hdGNoaW5nUnVsZShldmVudCA6IEV2ZW50ICk6IFJ1bGUgfCB1bmRlZmluZWQge1xuICAgICAgICBsZXQgZWxlbWVudHMgPSBldmVudC5jb21wb3NlZFBhdGgoKS5maWx0ZXIoKHRhcmdldCk6IHRhcmdldCBpcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQgPT4gdGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCk7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgcnVsZXMgPSB0aGlzLmVsZW1lbnRSdWxlcy5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAocnVsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nUnVsZSA9IHJ1bGVzLmZpbmQoKHJ1bGUpID0+IHJ1bGUubWF0Y2goZXZlbnQpKVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ1J1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nUnVsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRSdWxlTGlzdEJ5QWN0aW9uKGFjdGlvbjogQWN0aW9uKTogUnVsZVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVNYXBwZXIuZ2V0UnVsZUxpc3RCeVByZWZpeChhY3Rpb24ucHJlZml4KTtcbiAgICB9XG5cbiAgICBnZXRIVE1MRWxlbWVudHNNYXRjaGVkQnlBY3Rpb24oYWN0aW9uOiBBY3Rpb24pOiAoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudClbXSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzIDogU2V0PEhUTUxFbGVtZW50fFNWR0VsZW1lbnQ+ID0gbmV3IFNldCgpO1xuICAgICAgICBhY3Rpb24ucnVsZUxpc3QuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRMaXN0Rm9yUnVsZSA9IHJ1bGUuYWN0aW9uVG9FbGVtZW50cyhhY3Rpb24pO1xuICAgICAgICAgICAgZWxlbWVudExpc3RGb3JSdWxlLmZvckVhY2goZWxlbWVudCA9PiBlbGVtZW50cy5hZGQoZWxlbWVudCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFsuLi5lbGVtZW50cy52YWx1ZXMoKV07XG4gICAgfVxuXG4gICAgY3JlYXRlUnVsZShkYXRhIDoge1xuICAgICAgICBvdXRwdXQgOiB7XG4gICAgICAgICAgICBwcmVmaXggOiBzdHJpbmcsXG4gICAgICAgICAgICBzdWZmaXg/IDogc3RyaW5nLFxuICAgICAgICB9LFxuICAgICAgICBtYXRjaCA6IHtcbiAgICAgICAgICAgIGV2ZW50IDogc3RyaW5nLFxuICAgICAgICAgICAgY3NzPyA6IHN0cmluZyxcbiAgICAgICAgICAgIHhwYXRoPyA6IHN0cmluZyxcbiAgICAgICAgICAgIGNvZGU/IDogc3RyaW5nLFxuICAgICAgICAgICAga2V5PyA6IHN0cmluZyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU/OiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgY29udGV4dD8gOiB7XG4gICAgICAgICAgICB1cmw/IDogc3RyaW5nLFxuICAgICAgICAgICAgY3NzPyA6IHN0cmluZyxcbiAgICAgICAgICAgIHhwYXRoPyA6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBkZXNjcmlwdGlvbiA6IHN0cmluZ1xuICAgIH0pIDogUnVsZSB7XG4gICAgICAgIHN3aXRjaCAoZGF0YS5vdXRwdXQuc3VmZml4KSB7XG4gICAgICAgICAgICBjYXNlIFwiaW5uZXJUZXh0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbm5lclRleHRSdWxlKGRhdGEub3V0cHV0LnByZWZpeCxkYXRhLm91dHB1dD8uc3VmZml4LCBkYXRhLm1hdGNoLmV2ZW50LCBkYXRhLm1hdGNoPy5jc3MsIGRhdGEubWF0Y2g/LnhwYXRoLCBkYXRhLm1hdGNoPy5jb2RlLCBkYXRhLm1hdGNoPy5rZXksIGRhdGE/LmNvbnRleHQ/LnVybCwgZGF0YT8uY29udGV4dD8uY3NzLCBkYXRhPy5jb250ZXh0Py54cGF0aCwgZGF0YS5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBjYXNlIFwiaW5kZXhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEluZGV4UnVsZShkYXRhLm91dHB1dC5wcmVmaXgsZGF0YS5vdXRwdXQuc3VmZml4LCBkYXRhLm1hdGNoLmV2ZW50LCBkYXRhLm1hdGNoPy5jc3MsIGRhdGEubWF0Y2g/LnhwYXRoLCBkYXRhLm1hdGNoPy5jb2RlLCBkYXRhLm1hdGNoPy5rZXksIGRhdGE/LmNvbnRleHQ/LnVybCwgZGF0YT8uY29udGV4dD8uY3NzLCBkYXRhPy5jb250ZXh0Py54cGF0aCwgZGF0YS5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlUnVsZShkYXRhLm91dHB1dC5wcmVmaXgsZGF0YS5vdXRwdXQuc3VmZml4LCBkYXRhLm1hdGNoLmV2ZW50LCBkYXRhLm1hdGNoPy5jc3MsIGRhdGEubWF0Y2g/LnhwYXRoLCBkYXRhLm1hdGNoPy5jb2RlLCBkYXRhLm1hdGNoPy5rZXksIGRhdGE/LmNvbnRleHQ/LnVybCwgZGF0YT8uY29udGV4dD8uY3NzLCBkYXRhPy5jb250ZXh0Py54cGF0aCwgZGF0YS5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBjYXNlIFwiY3NzU2VsZWN0b3JcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENTU1NlbGVjdG9yUnVsZShkYXRhLm91dHB1dC5wcmVmaXgsZGF0YS5vdXRwdXQuc3VmZml4LCBkYXRhLm1hdGNoLmV2ZW50LCBkYXRhLm1hdGNoPy5jc3MsIGRhdGEubWF0Y2g/LnhwYXRoLCBkYXRhLm1hdGNoPy5jb2RlLCBkYXRhLm1hdGNoPy5rZXksIGRhdGE/LmNvbnRleHQ/LnVybCwgZGF0YT8uY29udGV4dD8uY3NzLCBkYXRhPy5jb250ZXh0Py54cGF0aCwgZGF0YS5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBjYXNlIFwiY3NzU2VsZWN0b3JXaXRoVmFsdWVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENTU1NlbGVjdG9yV2l0aFZhbHVlUnVsZShkYXRhLm91dHB1dC5wcmVmaXgsZGF0YS5vdXRwdXQuc3VmZml4LCBkYXRhLm1hdGNoLmV2ZW50LCBkYXRhLm1hdGNoPy5jc3MsIGRhdGEubWF0Y2g/LnhwYXRoLCBkYXRhLm1hdGNoPy5jb2RlLCBkYXRhLm1hdGNoPy5rZXksIGRhdGE/LmNvbnRleHQ/LnVybCwgZGF0YT8uY29udGV4dD8uY3NzLCBkYXRhPy5jb250ZXh0Py54cGF0aCwgZGF0YS5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBjYXNlIFwiYXR0cmlidXRlVmFsdWVcIjpcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5tYXRjaC5hdHRyaWJ1dGVOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVSdWxlKGRhdGEub3V0cHV0LnByZWZpeCxkYXRhLm91dHB1dC5zdWZmaXgsIGRhdGEubWF0Y2guZXZlbnQsIGRhdGEubWF0Y2g/LmNzcywgZGF0YS5tYXRjaD8ueHBhdGgsIGRhdGEubWF0Y2g/LmNvZGUsIGRhdGEubWF0Y2g/LmtleSwgZGF0YT8uY29udGV4dD8udXJsLCBkYXRhPy5jb250ZXh0Py5jc3MsIGRhdGE/LmNvbnRleHQ/LnhwYXRoLCBkYXRhLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZVZhbHVlUnVsZShkYXRhLm91dHB1dC5wcmVmaXgsZGF0YS5vdXRwdXQuc3VmZml4LCBkYXRhLm1hdGNoLmV2ZW50LCBkYXRhLm1hdGNoPy5jc3MsIGRhdGEubWF0Y2g/LnhwYXRoLCBkYXRhLm1hdGNoPy5jb2RlLCBkYXRhLm1hdGNoPy5rZXksIGRhdGE/LmNvbnRleHQ/LnVybCwgZGF0YT8uY29udGV4dD8uY3NzLCBkYXRhPy5jb250ZXh0Py54cGF0aCwgZGF0YS5kZXNjcmlwdGlvbiwgZGF0YS5tYXRjaC5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2ltcGxlUnVsZShkYXRhLm91dHB1dC5wcmVmaXgsZGF0YS5vdXRwdXQuc3VmZml4LCBkYXRhLm1hdGNoLmV2ZW50LCBkYXRhLm1hdGNoPy5jc3MsIGRhdGEubWF0Y2g/LnhwYXRoLCBkYXRhLm1hdGNoPy5jb2RlLCBkYXRhLm1hdGNoPy5rZXksIGRhdGE/LmNvbnRleHQ/LnVybCwgZGF0YT8uY29udGV4dD8uY3NzLCBkYXRhPy5jb250ZXh0Py54cGF0aCwgZGF0YS5kZXNjcmlwdGlvbik7XG4gICAgICAgIH1cblxuICAgIH1cblxuXG59IiwiXG5leHBvcnQgdHlwZSBPdmVybGF5VHlwZSA9IFwicmFpbmJvd1wiIHwgXCJibHVlc2t5XCIgfCBcInNoYWRvd1wiO1xuZXhwb3J0IHR5cGUgUmVjb3JkaW5nTW9kZSA9IFwiYnlleHBsb3JhdGlvblwiIHwgXCJieWludGVyYWN0aW9uXCI7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXNzaW9uIHtcbiAgICByZWFkb25seSBpZCA6IHN0cmluZztcbiAgICByZWFkb25seSB3ZWJTaXRlSWQgOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgYmFzZVVSTDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHJlYWRvbmx5IG5hbWUgOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgZGVzY3JpcHRpb24gOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgcmVhZG9ubHkgb3ZlcmxheVR5cGU6IE92ZXJsYXlUeXBlO1xuICAgIHJlYWRvbmx5IHJlY29yZGluZ01vZGU6IFJlY29yZGluZ01vZGU7XG5cbiAgICBjb25zdHJ1Y3RvcihpZDogc3RyaW5nLCB3ZWJTaXRlSWQ6IHN0cmluZywgYmFzZVVSTDpzdHJpbmcgfCB1bmRlZmluZWQsIG5hbWUgOiBzdHJpbmcsIGRlc2NyaXB0aW9uIDogc3RyaW5nLCBvdmVybGF5VHlwZTogT3ZlcmxheVR5cGUsIHJlY29yZGluZ01vZGU6IFJlY29yZGluZ01vZGUpIHtcbiAgICAgICAgaWYgKGlkID09PSBudWxsIHx8IGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNyZWF0ZSBTZXNzaW9uIHdpdGhvdXQgaWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2ViU2l0ZUlkID09PSBudWxsIHx8IHdlYlNpdGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjcmVhdGUgU2Vzc2lvbiB3aXRob3V0IHdlYlNpdGVJZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy53ZWJTaXRlSWQgPSB3ZWJTaXRlSWQ7XG4gICAgICAgIHRoaXMuYmFzZVVSTCA9IGJhc2VVUkw7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5vdmVybGF5VHlwZSA9IG92ZXJsYXlUeXBlOyAgICAgICAgXG4gICAgICAgIHRoaXMucmVjb3JkaW5nTW9kZSA9IHJlY29yZGluZ01vZGU7XG4gICAgfVxuXG59IiwiaW1wb3J0IEFjdGlvbiBmcm9tICcuL0FjdGlvbic7XG5pbXBvcnQgUnVsZSBmcm9tICcuL1J1bGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaW1wbGVSdWxlIGV4dGVuZHMgUnVsZSB7XG4gICAgY29uc3RydWN0b3IocHJlZml4OiBzdHJpbmcsIHN1ZmZpeDogc3RyaW5nIHwgdW5kZWZpbmVkLCBldmVudDogc3RyaW5nLCBjc3M6IHN0cmluZyB8IHVuZGVmaW5lZCwgeHBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICAgICAgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBrZXk6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dFVSTDogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0Q1NTOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRYUGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkLCBkZXNjcmlwdGlvbjogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKHByZWZpeCwgc3VmZml4LCBldmVudCwgY3NzLCB4cGF0aCwgY29kZSwga2V5LCBjb250ZXh0VVJMLCBjb250ZXh0Q1NTLCBjb250ZXh0WFBhdGgsIGRlc2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICBtYWtlQWN0aW9uKGV2ZW50IDogRXZlbnQpOiBBY3Rpb24gfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gbmV3IEFjdGlvbih0aGlzLnByZWZpeCk7XG4gICAgfVxuXG4gICAgYWN0aW9uVG9FbGVtZW50cyhhY3Rpb246IEFjdGlvbik6IChIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQpW10ge1xuICAgICAgICBpZiAoYWN0aW9uLnByZWZpeCAhPT0gdGhpcy5wcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZmluZE1hdGNoZWRFbGVtZW50cygpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxufVxuIiwiaW1wb3J0IENvbnRleHRNYXBwZXIgZnJvbSBcIi4vQ29udGV4dE1hcHBlclwiO1xuaW1wb3J0IFJ1bGUgZnJvbSBcIi4vUnVsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVUkxDb250ZXh0TWFwcGVyIGV4dGVuZHMgQ29udGV4dE1hcHBlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCA6IHN0cmluZykge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICB9XG5cbiAgICBidWlsZEVsZW1lbnRUb1J1bGVNYXAoKSA6IE1hcDxIVE1MRWxlbWVudHxTVkdFbGVtZW50LCBSdWxlW10+IHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRleHQgJiYgZG9jdW1lbnQuVVJMLnN0YXJ0c1dpdGgodGhpcy5fY29udGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1aWxkRWxlbWVudFRvUnVsZU1hcEZvclNlbGVjdG9ycygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgQWN0aW9uIGZyb20gJy4vQWN0aW9uJztcbmltcG9ydCBTaW1wbGVSdWxlIGZyb20gJy4vU2ltcGxlUnVsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZhbHVlUnVsZSBleHRlbmRzIFNpbXBsZVJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeDogc3RyaW5nLCBzdWZmaXg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IHN0cmluZywgY3NzOiBzdHJpbmcgfCB1bmRlZmluZWQsIHhwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCwga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRVUkw6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dENTUzogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0WFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgICAgICBzdXBlcihwcmVmaXgsIHN1ZmZpeCwgZXZlbnQsIGNzcywgeHBhdGgsIGNvZGUsIGtleSwgY29udGV4dFVSTCwgY29udGV4dENTUywgY29udGV4dFhQYXRoLCBkZXNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgbWFrZUFjdGlvbihldmVudCA6IEV2ZW50KTogQWN0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGlvbih0aGlzLnByZWZpeCwgdGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGlvbih0aGlzLnByZWZpeCwgXCJzdmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3Rpb25Ub0VsZW1lbnRzKGFjdGlvbjogQWN0aW9uKTogKEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpW10ge1xuICAgICAgICBpZiAoYWN0aW9uLnByZWZpeCAhPT0gdGhpcy5wcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uLnN1ZmZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuYWN0aW9uVG9FbGVtZW50cyhhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5maW5kTWF0Y2hlZEVsZW1lbnRzKCk7XG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJTaXRlIHtcbiAgICBwdWJsaWMgaWQ6IHN0cmluZztcbiAgICBwdWJsaWMgbmFtZTogc3RyaW5nO1xuICAgIHB1YmxpYyBtYXBwaW5nTGlzdDoge21hdGNoOiBhbnksIG91dHB1dDogYW55LCBkZXNjcmlwdGlvbjogc3RyaW5nfVtdO1xuXG4gICAgY29uc3RydWN0b3IoaWQ6IHN0cmluZywgbmFtZTogc3RyaW5nLCBtYXBwaW5nTGlzdDoge21hdGNoOiBhbnksIG91dHB1dDogYW55LCBkZXNjcmlwdGlvbjogc3RyaW5nfVtdKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5tYXBwaW5nTGlzdCA9IG1hcHBpbmdMaXN0O1xuICAgIH1cbn0iLCJpbXBvcnQgQ29udGV4dE1hcHBlciBmcm9tIFwiLi9Db250ZXh0TWFwcGVyXCI7XG5pbXBvcnQgUnVsZSBmcm9tIFwiLi9SdWxlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFhQYXRoQ29udGV4dE1hcHBlciBleHRlbmRzIENvbnRleHRNYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQgOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgfVxuXG4gICAgYnVpbGRFbGVtZW50VG9SdWxlTWFwKCkgOiBNYXA8SFRNTEVsZW1lbnR8U1ZHRWxlbWVudCwgUnVsZVtdPiB7XG4gICAgICAgIGlmICh0aGlzLl9jb250ZXh0KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHhwYXRoUXVlcnlSZXN1bHQgPSBkb2N1bWVudC5ldmFsdWF0ZSh0aGlzLl9jb250ZXh0LCBkb2N1bWVudCwgbnVsbCwgWFBhdGhSZXN1bHQuQU5ZX1RZUEUsIG51bGwpO1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHhwYXRoUXVlcnlSZXN1bHQuaXRlcmF0ZU5leHQoKTtcbiAgICAgICAgICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgY29udGV4dCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEVsZW1lbnRUb1J1bGVNYXBGb3JTZWxlY3RvcnMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICAgIH0gICBcbiAgICB9XG59IiwiaW1wb3J0IHtDYXRlZ29yeSxDYXRlZ29yeUxvZ2dlcixDYXRlZ29yeVNlcnZpY2VGYWN0b3J5LENhdGVnb3J5Q29uZmlndXJhdGlvbixMb2dMZXZlbH0gZnJvbSBcInR5cGVzY3JpcHQtbG9nZ2luZ1wiO1xuIFxuLy8gT3B0aW9uYWxseSBjaGFuZ2UgZGVmYXVsdCBzZXR0aW5ncywgaW4gdGhpcyBleGFtcGxlIHNldCBkZWZhdWx0IGxvZ2dpbmcgdG8gSW5mby5cbi8vIFdpdGhvdXQgY2hhbmdpbmcgY29uZmlndXJhdGlvbiwgY2F0ZWdvcmllcyB3aWxsIGxvZyB0byBFcnJvci5cblxubGV0IGxvZ0xldmVsO1xuXG5zd2l0Y2gocHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBjYXNlICdwcm9kdWN0aW9uJzpcbiAgICAgICAgbG9nTGV2ZWwgPSBMb2dMZXZlbC5FcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV2ZWxvcG1lbnQnOiBcbiAgICAgICAgbG9nTGV2ZWwgPSBMb2dMZXZlbC5EZWJ1ZztcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZ2l0aHViJzpcbiAgICAgICAgbG9nTGV2ZWwgPSBMb2dMZXZlbC5FcnJvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDogXG4gICAgICAgIGxvZ0xldmVsID0gTG9nTGV2ZWwuRXJyb3Jcbn1cblxuQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeS5zZXREZWZhdWx0Q29uZmlndXJhdGlvbihuZXcgQ2F0ZWdvcnlDb25maWd1cmF0aW9uKGxvZ0xldmVsKSk7XG4gXG4vLyBDcmVhdGUgY2F0ZWdvcmllcywgdGhleSB3aWxsIGF1dG9yZWdpc3RlciB0aGVtc2VsdmVzLCBvbmUgY2F0ZWdvcnkgd2l0aG91dCBwYXJlbnQgKHJvb3QpIGFuZCBhIGNoaWxkIGNhdGVnb3J5LlxuZXhwb3J0IGNvbnN0IGxvZ2dlciA9IG5ldyBDYXRlZ29yeShcIlRhYlNjcmlwdFwiKTtcbiIsImltcG9ydCBCcm93c2VyU2NyaXB0IGZyb20gXCIuL2RvbWFpbi9Ccm93c2VyU2NyaXB0XCI7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSBcIi4vZnJhbWV3b3JrL0xvZ2dlclwiO1xuaW1wb3J0IEFpZmV4U2VydmljZUhUVFAgZnJvbSBcIi4vX2luZnJhL0FpZmV4U2VydmljZUhUVFBcIjtcbmltcG9ydCBCcm93c2VyU2VydmljZUxvY2FsU3RvcmFnZSBmcm9tIFwiLi9faW5mcmEvQnJvd3NlclNlcnZpY2VMb2NhbFN0b3JhZ2VcIjtcbmltcG9ydCBCcm93c2VyU2VydmljZVNlc3Npb25TdG9yYWdlIGZyb20gXCIuL19pbmZyYS9Ccm93c2VyU2VydmljZVNlc3Npb25TdG9yYWdlXCI7XG5cbmxvZ2dlci5pbmZvKFwiQUlGRVggc2NyaXB0IGlzIHJ1bm5pbmcuXCIpO1xuXG5jb25zdCBBSUZFWF9TQ1JJUFQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIkFJRkVYXCIpO1xuaWYgKEFJRkVYX1NDUklQVCkge1xuICAgIGxvZ2dlci5pbmZvKFwiQUlGRVggU0NSSVBUIEVsZW1lbnQgaXMgZm91bmQuXCIpO1xuICAgIGNvbnN0IENPTk5FWElPTl9VUkwgPSBBSUZFWF9TQ1JJUFQuZ2V0QXR0cmlidXRlKFwiY29ubmV4aW9uLXVybFwiKTtcbiAgICBpZiAoQ09OTkVYSU9OX1VSTCkge1xuICAgICAgICBsb2dnZXIuaW5mbyhcIkFJRkVYIGNvbm5leGlvbi11cmwgRWxlbWVudCBpcyBmb3VuZC5cIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBBSUZFWF9VUkwgPSBuZXcgVVJMKENPTk5FWElPTl9VUkwpO1xuXHRcdFx0bGV0IHNlc3Npb25JZCA9IEFJRkVYX1VSTC5zZWFyY2hQYXJhbXMuZ2V0KCdzZXNzaW9uSWQnKTtcblx0XHRcdGlmIChzZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhcIkFJRkVYIHNlc3Npb25JZCBpcyBmb3VuZC5cIik7XG4gICAgICAgICAgICAgICAgY29uc3QgQUlGRVhfU0VSVklDRSA9IG5ldyBBaWZleFNlcnZpY2VIVFRQKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgQlJPV1NFUl9TRVJWSUNFID0gbmV3IEJyb3dzZXJTZXJ2aWNlU2Vzc2lvblN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBCUk9XU0VSX1NDUklQVCA9IG5ldyBCcm93c2VyU2NyaXB0KEFJRkVYX1VSTC5vcmlnaW4sIHNlc3Npb25JZCwgdW5kZWZpbmVkLCBBSUZFWF9TRVJWSUNFLCBCUk9XU0VSX1NFUlZJQ0UpO1xuICAgICAgICAgICAgICAgIEJST1dTRVJfU0NSSVBULnN0YXJ0KCk7XHRcblx0XHRcdH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBjb25uZXhpb24gVVJMXCIsIG5ldyBFcnJvcihcIkludmFsaWQgY29ubmV4aW9uIFVSTFwiKSk7XG4gICAgICAgIH1cbiAgICB9XG59IGVsc2Uge1xuICAgIGxvZ2dlci5lcnJvcihcIkFJRkVYIFNDUklQVCBFbGVtZW50IGlzIG5vdCBmb3VuZC5cIiwgbmV3IEVycm9yKFwiQUlGRVggU0NSSVBUIEVsZW1lbnQgaXMgbm90IGZvdW5kLlwiKSk7XG59XG5cbi8vIDxzY3JpcHQgaWQ9XCJBSUZFWFwiIGNvbm5leGlvbi11cmw9XCJodHRwczovL2FpZmV4LmNvbS9haWZleC9jb25uZXhpb24/c2Vzc2lvbklkPWExYjJjM2Q0ZTVmNmc3aDhpOWowXCIgc3JjPVwiaHR0cHM6Ly9haWZleC5jb20vYWlmZXgvc2NyaXB0L2FpZmV4LmpzXCI+PC9zY3JpcHQ+IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsID0gdm9pZCAwO1xudmFyIENhdGVnb3J5U2VydmljZV8xID0gcmVxdWlyZShcIi4uL2xvZy9jYXRlZ29yeS9DYXRlZ29yeVNlcnZpY2VcIik7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL2xvZy9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIERhdGFTdHJ1Y3R1cmVzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvRGF0YVN0cnVjdHVyZXNcIik7XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIGNsYXNzIGZvciBDYXRlZ29yeVNlcnZpY2VDb250cm9sLlxuICovXG52YXIgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwoKSB7XG4gICAgfVxuICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLnByb3RvdHlwZS5oZWxwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgIGNvbnNvbGUubG9nKENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9oZWxwKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5wcm90b3R5cGUuZXhhbXBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmxvZyhDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fZXhhbXBsZSk7XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwucHJvdG90eXBlLnNob3dTZXR0aW5ncyA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoaWQgPT09IHZvaWQgMCkgeyBpZCA9IFwiYWxsXCI7IH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRhU3RydWN0dXJlc18xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgdmFyIHNlcnZpY2UgPSBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fZ2V0Q2F0ZWdvcnlTZXJ2aWNlKCk7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2dldENhdGVnb3JpZXMoaWQpO1xuICAgICAgICBjYXRlZ29yaWVzLmZvckVhY2goZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgICAgICBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fcHJvY2Vzc0NhdGVnb3J5KHNlcnZpY2UsIGNhdGVnb3J5LCByZXN1bHQsIDApO1xuICAgICAgICB9KTtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQudG9TdHJpbmcoKSk7XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwucHJvdG90eXBlLmNoYW5nZSA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICB2YXIgc2VydmljZSA9IENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9nZXRDYXRlZ29yeVNlcnZpY2UoKTtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fZ2V0Q2F0ZWdvcmllcyhzZXR0aW5ncy5jYXRlZ29yeSk7XG4gICAgICAgIHZhciBsb2dMZXZlbCA9IG51bGw7XG4gICAgICAgIHZhciBmb3JtYXRFbnVtID0gbnVsbDtcbiAgICAgICAgdmFyIHNob3dDYXRlZ29yeU5hbWUgPSBudWxsO1xuICAgICAgICB2YXIgc2hvd1RpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICB2YXIgYWRkUmVzdWx0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiLCBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYWRkUmVzdWx0KFwicmVjdXJzaXZlPVwiICsgc2V0dGluZ3MucmVjdXJzaXZlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5sb2dMZXZlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbG9nTGV2ZWwgPSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuZnJvbVN0cmluZyhzZXR0aW5ncy5sb2dMZXZlbCk7XG4gICAgICAgICAgICBhZGRSZXN1bHQoXCJsb2dMZXZlbD1cIiArIHNldHRpbmdzLmxvZ0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmxvZ0Zvcm1hdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZm9ybWF0RW51bSA9IExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0RW51bS5mcm9tU3RyaW5nKHNldHRpbmdzLmxvZ0Zvcm1hdCk7XG4gICAgICAgICAgICBhZGRSZXN1bHQoXCJsb2dGb3JtYXQ9XCIgKyBzZXR0aW5ncy5sb2dGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Muc2hvd0NhdGVnb3J5TmFtZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHNob3dDYXRlZ29yeU5hbWUgPSBzZXR0aW5ncy5zaG93Q2F0ZWdvcnlOYW1lO1xuICAgICAgICAgICAgYWRkUmVzdWx0KFwic2hvd0NhdGVnb3J5TmFtZT1cIiArIHNldHRpbmdzLnNob3dDYXRlZ29yeU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Muc2hvd1RpbWVzdGFtcCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHNob3dUaW1lc3RhbXAgPSBzZXR0aW5ncy5zaG93VGltZXN0YW1wO1xuICAgICAgICAgICAgYWRkUmVzdWx0KFwic2hvd1RpbWVzdGFtcD1cIiArIHNldHRpbmdzLnNob3dUaW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcHBseUNoYW5nZXMgPSBmdW5jdGlvbiAoY2F0KSB7XG4gICAgICAgICAgICB2YXIgY2F0ZWdvcnlTZXR0aW5ncyA9IHNlcnZpY2UuZ2V0Q2F0ZWdvcnlTZXR0aW5ncyhjYXQpO1xuICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXBwZW4gYnV0IG1ha2UgdHNsaW50IGhhcHB5XG4gICAgICAgICAgICBpZiAoY2F0ZWdvcnlTZXR0aW5ncyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2dMZXZlbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeVNldHRpbmdzLmxvZ0xldmVsID0gbG9nTGV2ZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXRFbnVtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5U2V0dGluZ3MubG9nRm9ybWF0LmRhdGVGb3JtYXQuZm9ybWF0RW51bSA9IGZvcm1hdEVudW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaG93VGltZXN0YW1wICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5U2V0dGluZ3MubG9nRm9ybWF0LnNob3dUaW1lU3RhbXAgPSBzaG93VGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvd0NhdGVnb3J5TmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeVNldHRpbmdzLmxvZ0Zvcm1hdC5zaG93Q2F0ZWdvcnlOYW1lID0gc2hvd0NhdGVnb3J5TmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNhdGVnb3JpZXMuZm9yRWFjaChmdW5jdGlvbiAoY2F0KSB7IHJldHVybiBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fYXBwbHlUb0NhdGVnb3J5KGNhdCwgc2V0dGluZ3MucmVjdXJzaXZlLCBhcHBseUNoYW5nZXMpOyB9KTtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFwcGxpZWQgY2hhbmdlczogXCIgKyByZXN1bHQgKyBcIiB0byBjYXRlZ29yaWVzICdcIiArIHNldHRpbmdzLmNhdGVnb3J5ICsgXCInLlwiKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSB2b2lkIDApIHsgaWQgPSBcImFsbFwiOyB9XG4gICAgICAgIHZhciBzZXJ2aWNlID0gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2dldENhdGVnb3J5U2VydmljZSgpO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9nZXRDYXRlZ29yaWVzKGlkKTtcbiAgICAgICAgdmFyIGFwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uIChjYXQpIHtcbiAgICAgICAgICAgIHZhciBjYXRlZ29yeVNldHRpbmdzID0gc2VydmljZS5nZXRDYXRlZ29yeVNldHRpbmdzKGNhdCk7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBzZXJ2aWNlLmdldE9yaWdpbmFsQ2F0ZWdvcnlTZXR0aW5ncyhjYXQpO1xuICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXBwZW4gYnV0IG1ha2UgdHNsaW50IGhhcHB5XG4gICAgICAgICAgICBpZiAoY2F0ZWdvcnlTZXR0aW5ncyAhPT0gbnVsbCAmJiBvcmlnaW5hbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5U2V0dGluZ3MubG9nTGV2ZWwgPSBvcmlnaW5hbC5sb2dMZXZlbDtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeVNldHRpbmdzLmxvZ0Zvcm1hdC5kYXRlRm9ybWF0LmZvcm1hdEVudW0gPSBvcmlnaW5hbC5sb2dGb3JtYXQuZGF0ZUZvcm1hdC5mb3JtYXRFbnVtO1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5U2V0dGluZ3MubG9nRm9ybWF0LnNob3dUaW1lU3RhbXAgPSBvcmlnaW5hbC5sb2dGb3JtYXQuc2hvd1RpbWVTdGFtcDtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeVNldHRpbmdzLmxvZ0Zvcm1hdC5zaG93Q2F0ZWdvcnlOYW1lID0gb3JpZ2luYWwubG9nRm9ybWF0LnNob3dDYXRlZ29yeU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNhdGVnb3JpZXMuZm9yRWFjaChmdW5jdGlvbiAoY2F0KSB7IHJldHVybiBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fYXBwbHlUb0NhdGVnb3J5KGNhdCwgdHJ1ZSwgYXBwbHlDaGFuZ2VzKTsgfSk7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2coXCJBcHBsaWVkIHJlc2V0IHRvIGNhdGVnb3J5OiBcIiArIGlkICsgXCIuXCIpO1xuICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9wcm9jZXNzQ2F0ZWdvcnkgPSBmdW5jdGlvbiAoc2VydmljZSwgY2F0ZWdvcnksIHJlc3VsdCwgaW5kZW50KSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHNlcnZpY2UuZ2V0Q2F0ZWdvcnlTZXR0aW5ncyhjYXRlZ29yeSk7XG4gICAgICAgIGlmIChzZXR0aW5ncyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChcIiAgXCIgKyBjYXRlZ29yeS5pZCArIFwiOiBcIik7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChcIiAgXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoY2F0ZWdvcnkubmFtZSArIFwiIChcIiArIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbFtzZXR0aW5ncy5sb2dMZXZlbF0udG9TdHJpbmcoKSArIFwiQFwiICsgTG9nZ2VyT3B0aW9uc18xLkxvZ2dlclR5cGVbc2V0dGluZ3MubG9nZ2VyVHlwZV0udG9TdHJpbmcoKSArIFwiKVxcblwiKTtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yeS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnkuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX3Byb2Nlc3NDYXRlZ29yeShzZXJ2aWNlLCBjaGlsZCwgcmVzdWx0LCBpbmRlbnQgKyAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2FwcGx5VG9DYXRlZ29yeSA9IGZ1bmN0aW9uIChjYXRlZ29yeSwgcmVjdXJzaXZlLCBhcHBseSkge1xuICAgICAgICBhcHBseShjYXRlZ29yeSk7XG4gICAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgIGNhdGVnb3J5LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2FwcGx5VG9DYXRlZ29yeShjaGlsZCwgcmVjdXJzaXZlLCBhcHBseSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2dldENhdGVnb3J5U2VydmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIENhdGVnb3J5U2VydmljZV8xLkNhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKTtcbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9nZXRDYXRlZ29yaWVzID0gZnVuY3Rpb24gKGlkQ2F0ZWdvcnkpIHtcbiAgICAgICAgdmFyIHNlcnZpY2UgPSBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fZ2V0Q2F0ZWdvcnlTZXJ2aWNlKCk7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGlmIChpZENhdGVnb3J5ID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzID0gc2VydmljZS5nZXRSb290Q2F0ZWdvcmllcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5ID0gc2VydmljZS5nZXRDYXRlZ29yeUJ5SWQoaWRDYXRlZ29yeSk7XG4gICAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmluZCBjYXRlZ29yeSB3aXRoIGlkIFwiICsgaWRDYXRlZ29yeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRlZ29yaWVzLnB1c2goY2F0ZWdvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYXRlZ29yaWVzO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2hlbHAgPSBcIlxcbiAgaGVscCgpOiB2b2lkXFxuICAgICoqIFNob3dzIHRoaXMgaGVscC5cXG5cXG4gIGV4YW1wbGUoKTogdm9pZFxcbiAgICAqKiBTaG93cyBhbiBleGFtcGxlIG9uIGhvdyB0byB1c2UgdGhpcy5cXG5cXG4gIHNob3dTZXR0aW5ncyhpZDogbnVtYmVyIHwgXFxcImFsbFxcXCIgPSBcXFwiYWxsXFxcIik6IHZvaWRcXG4gICAgKiogU2hvd3Mgc2V0dGluZ3MgZm9yIGEgc3BlY2lmaWMgY2F0ZWdvcnksIG9yIGZvciBhbGwuIFRoZSBpZCBvZiBjYXRlZ29yaWVzIGNhbiBiZSBmb3VuZCBieSBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGhvdXQgcGFyYW1ldGVyLlxcblxcbiAgY2hhbmdlKHNldHRpbmdzOiBDYXRlZ29yeVNlcnZpY2VDb250cm9sU2V0dGluZ3MpOiB2b2lkXFxuICAgICoqIENoYW5nZXMgdGhlIGN1cnJlbnQgc2V0dGluZ3MgZm9yIG9uZSBvciBhbGwgY2F0ZWdvcmllcy5cXG4gICAgKipcXG4gICAgICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbFNldHRpbmdzLCBwcm9wZXJ0aWVzIG9mIG9iamVjdDpcXG4gICAgICAgICBjYXRlZ29yeTogbnVtYmVyIHwgXFxcImFsbFxcXCJcXG4gICAgICAgICAgICoqIEFwcGx5IHRvIHNwZWNpZmljIGNhdGVnb3J5LCBvciBcXFwiYWxsXFxcIi5cXG4gICAgICAgICAgICoqIFJlcXVpcmVkXFxuXFxuICAgICAgICAgcmVjdXJzaXZlOiBib29sZWFuXFxuICAgICAgICAgICAqKiBBcHBseSB0byBjaGlsZCBjYXRlZ29yaWVzICh0cnVlKSBvciBub3QuXFxuICAgICAgICAgICAqKiBSZXF1aXJlZFxcblxcbiAgICAgICAgIGxvZ0xldmVsOiBcXFwiRmF0YWxcXFwiIHwgXFxcIkVycm9yXFxcIiB8IFxcXCJXYXJuXFxcIiB8IFxcXCJJbmZvXFxcIiB8IFxcXCJEZWJ1Z1xcXCIgfCBcXFwiVHJhY2VcXFwiIHwgdW5kZWZpbmVkXFxuICAgICAgICAgICAqKiBTZXQgbG9nIGxldmVsLCB1bmRlZmluZWQgd2lsbCBub3QgY2hhbmdlIHRoZSBzZXR0aW5nLlxcbiAgICAgICAgICAgKiogT3B0aW9uYWxcXG5cXG4gICAgICAgICBsb2dGb3JtYXQ6IFxcXCJEZWZhdWx0XFxcIiB8IFxcXCJZZWFyTW9udGhEYXlUaW1lXFxcIiB8IFxcXCJZZWFyRGF5TW9udGhXaXRoRnVsbFRpbWVcXFwiIHwgXFxcIlllYXJEYXlNb250aFRpbWVcXFwiIHwgdW5kZWZpbmVkXFxuICAgICAgICAgICAqKiBTZXQgdGhlIGxvZyBmb3JtYXQsIHVuZGVmaW5lZCB3aWxsIG5vdCBjaGFuZ2UgdGhlIHNldHRpbmcuXFxuICAgICAgICAgICAqKiBPcHRpb25hbFxcblxcbiAgICAgICAgIHNob3dUaW1lc3RhbXA6IGJvb2xlYW4gfCB1bmRlZmluZWRcXG4gICAgICAgICAgICoqIFdoZXRoZXIgdG8gc2hvdyB0aW1lc3RhbXAsIHVuZGVmaW5lZCB3aWxsIG5vdCBjaGFuZ2UgdGhlIHNldHRpbmcuXFxuICAgICAgICAgICAqKiBPcHRpb25hbFxcblxcbiAgICAgICAgIHNob3dDYXRlZ29yeU5hbWU6IGJvb2xlYW4gfCB1bmRlZmluZWRcXG4gICAgICAgICAgICoqIFdoZXRoZXIgdG8gc2hvdyB0aGUgY2F0ZWdvcnkgbmFtZSwgdW5kZWZpbmVkIHdpbGwgbm90IGNoYW5nZSB0aGUgc2V0dGluZy5cXG4gICAgICAgICAgICoqIE9wdGlvbmFsXFxuXFxuICAgcmVzZXQoaWQ6IG51bWJlciB8IFxcXCJhbGxcXFwiKTogdm9pZFxcbiAgICAgKiogUmVzZXRzIGV2ZXJ5dGhpbmcgdG8gb3JpZ2luYWwgdmFsdWVzLCBmb3Igb25lIHNwZWNpZmljIG9yIGZvciBhbGwgY2F0ZWdvcmllcy5cXG5cIjtcbiAgICBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fZXhhbXBsZSA9IFwiXFxuICBFeGFtcGxlczpcXG4gICAgY2hhbmdlKHtjYXRlZ29yeTogXFxcImFsbFxcXCIsIHJlY3Vyc2l2ZTp0cnVlLCBsb2dMZXZlbDogXFxcIkluZm9cXFwifSlcXG4gICAgICAqKiBDaGFuZ2UgbG9nbGV2ZWwgdG8gSW5mbyBmb3IgYWxsIGNhdGVnb3JpZXMsIGFwcGx5IHRvIGNoaWxkIGNhdGVnb3JpZXMgYXMgd2VsbC5cXG5cXG4gICAgY2hhbmdlKHtjYXRlZ29yeTogMSwgcmVjdXJzaXZlOmZhbHNlLCBsb2dMZXZlbDogXFxcIldhcm5cXFwifSlcXG4gICAgICAqKiBDaGFuZ2UgbG9nTGV2ZWwgZm9yIGNhdGVnb3J5IDEsIGRvIG5vdCByZWN1cnNlLlxcblxcbiAgICBjaGFuZ2Uoe2NhdGVnb3J5OiBcXFwiYWxsXFxcIiwgcmVjdXJzaXZlOnRydWUsIGxvZ0xldmVsOiBcXFwiRGVidWdcXFwiLCBsb2dGb3JtYXQ6IFxcXCJZZWFyRGF5TW9udGhUaW1lXFxcIiwgc2hvd1RpbWVzdGFtcDpmYWxzZSwgc2hvd0NhdGVnb3J5TmFtZTpmYWxzZX0pXFxuICAgICAgKiogQ2hhbmdlIGxvZ2xldmVsIHRvIERlYnVnIGZvciBhbGwgY2F0ZWdvcmllcywgYXBwbHkgZm9ybWF0LCBkbyBub3Qgc2hvdyB0aW1lc3RhbXAgYW5kIGNhdGVnb3J5IG5hbWVzIC0gcmVjdXJzaXZlbHkgdG8gY2hpbGQgY2F0ZWdvcmllcy5cXG5cXG5cIjtcbiAgICByZXR1cm4gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGw7XG59KCkpO1xuZXhwb3J0cy5DYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbCA9IENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2F0ZWdvcnlTZXJ2aWNlQ29udHJvbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9nZ2VyQ29udHJvbEltcGwgPSB2b2lkIDA7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL2xvZy9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIExGU2VydmljZV8xID0gcmVxdWlyZShcIi4uL2xvZy9zdGFuZGFyZC9MRlNlcnZpY2VcIik7XG52YXIgRGF0YVN0cnVjdHVyZXNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9EYXRhU3RydWN0dXJlc1wiKTtcbnZhciBMb2dnZXJDb250cm9sSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2dnZXJDb250cm9sSW1wbCgpIHtcbiAgICB9XG4gICAgTG9nZ2VyQ29udHJvbEltcGwucHJvdG90eXBlLmhlbHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2coTG9nZ2VyQ29udHJvbEltcGwuX2hlbHApO1xuICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICB9O1xuICAgIExvZ2dlckNvbnRyb2xJbXBsLnByb3RvdHlwZS5saXN0RmFjdG9yaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcnRTZXR0aW5nc0ZhY3RvcmllcyA9IExvZ2dlckNvbnRyb2xJbXBsLl9nZXRSdW50aW1lU2V0dGluZ3NMb2dnZXJGYWN0b3JpZXMoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRhU3RydWN0dXJlc18xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZExpbmUoXCJSZWdpc3RlcmVkIExvZ2dlckZhY3RvcmllcyAoaW5kZXggLyBuYW1lKVwiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydFNldHRpbmdzRmFjdG9yaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcnRTZXR0aW5nc0ZhY3RvcnkgPSBydFNldHRpbmdzRmFjdG9yaWVzW2ldO1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChcIiAgXCIgKyBpKS5hcHBlbmQoXCI6IFwiICsgcnRTZXR0aW5nc0ZhY3RvcnkuZ2V0TmFtZSgpICsgXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQudG9TdHJpbmcoKSk7XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgTG9nZ2VyQ29udHJvbEltcGwucHJvdG90eXBlLnNob3dTZXR0aW5ncyA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoaWQgPT09IHZvaWQgMCkgeyBpZCA9IFwiYWxsXCI7IH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoaWQgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgIHZhciBpZHhfMSA9IDA7XG4gICAgICAgICAgICBMb2dnZXJDb250cm9sSW1wbC5fZ2V0UnVudGltZVNldHRpbmdzTG9nZ2VyRmFjdG9yaWVzKCkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEYXRhU3RydWN0dXJlc18xLlR1cGxlUGFpcihpZHhfMSsrLCBpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IExvZ2dlckNvbnRyb2xJbXBsLl9nZXRSdW50aW1lU2V0dGluZ3NMb2dnZXJGYWN0b3JpZXMoKTtcbiAgICAgICAgICAgIGlmIChpZCA+PSAwICYmIGlkIDwgc2V0dGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IERhdGFTdHJ1Y3R1cmVzXzEuVHVwbGVQYWlyKGlkLCBzZXR0aW5nc1tpZF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVlc3RlZCBudW1iZXI6IFwiICsgaWQgKyBcIiB3YXMgbm90IGZvdW5kLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHJlc3VsdF8xID0gcmVzdWx0OyBfaSA8IHJlc3VsdF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHNldHRpbmcgPSByZXN1bHRfMVtfaV07XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIiAgTG9nZ2VyRmFjdG9yeTogXCIgKyBzZXR0aW5nLnkuZ2V0TmFtZSgpICsgXCIgKGlkPVwiICsgc2V0dGluZy54ICsgXCIpXCIpO1xuICAgICAgICAgICAgdmFyIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzID0gc2V0dGluZy55LmdldExvZ0dyb3VwUnVudGltZVNldHRpbmdzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IGxvZ0dyb3VwUnVudGltZVNldHRpbmdzLmxlbmd0aDsgZysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwU2V0dGluZyA9IGxvZ0dyb3VwUnVudGltZVNldHRpbmdzW2ddO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiICAgICBMb2dHcm91cDogKGlkPVwiICsgZyArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiAgICAgICBSZWdFeHA6IFwiICsgZ3JvdXBTZXR0aW5nLmxvZ0dyb3VwUnVsZS5yZWdFeHAuc291cmNlKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiAgICAgICBMZXZlbDogXCIgKyBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWxbZ3JvdXBTZXR0aW5nLmxldmVsXS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiAgICAgICBMb2dnZXJUeXBlOiBcIiArIExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlW2dyb3VwU2V0dGluZy5sb2dnZXJUeXBlXS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMb2dnZXJDb250cm9sSW1wbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoaWRGYWN0b3J5KSB7XG4gICAgICAgIGlmIChpZEZhY3RvcnkgPT09IHZvaWQgMCkgeyBpZEZhY3RvcnkgPSBcImFsbFwiOyB9XG4gICAgICAgIHZhciBsb2dnZXJGYWN0b3JpZXNTZXR0aW5ncyA9IExvZ2dlckNvbnRyb2xJbXBsLl9nZXRSdW50aW1lU2V0dGluZ3NMb2dnZXJGYWN0b3JpZXMoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAoaWRGYWN0b3J5ID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBsb2dnZXJGYWN0b3JpZXNTZXR0aW5ncztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpZEZhY3RvcnkgPj0gMCAmJiBpZEZhY3RvcnkgPCBsb2dnZXJGYWN0b3JpZXNTZXR0aW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsb2dnZXJGYWN0b3JpZXNTZXR0aW5nc1tpZEZhY3RvcnldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAoc2V0dGluZykge1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZXNldCBhbGwgc2V0dGluZ3MgZm9yIGZhY3RvcnkgXCIgKyBpZEZhY3RvcnkpO1xuICAgICAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgICAgICB2YXIgY29udHJvbCA9IG5ldyBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwoc2V0dGluZyk7XG4gICAgICAgICAgICBjb250cm9sLnJlc2V0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9nZ2VyQ29udHJvbEltcGwucHJvdG90eXBlLmdldExvZ2dlckZhY3RvcnlDb250cm9sID0gZnVuY3Rpb24gKGlkRmFjdG9yeSkge1xuICAgICAgICB2YXIgbG9nZ2VyRmFjdG9yaWVzU2V0dGluZ3MgPSBMb2dnZXJDb250cm9sSW1wbC5fZ2V0UnVudGltZVNldHRpbmdzTG9nZ2VyRmFjdG9yaWVzKCk7XG4gICAgICAgIGlmIChpZEZhY3RvcnkgPj0gMCAmJiBpZEZhY3RvcnkgPCBsb2dnZXJGYWN0b3JpZXNTZXR0aW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsKGxvZ2dlckZhY3Rvcmllc1NldHRpbmdzW2lkRmFjdG9yeV0pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlkRmFjdG9yeSBpcyBpbnZhbGlkIChsZXNzIHRoYW4gMCkgb3Igbm9uIGV4aXN0aW5nIGlkLlwiKTtcbiAgICB9O1xuICAgIExvZ2dlckNvbnRyb2xJbXBsLl9nZXRSdW50aW1lU2V0dGluZ3NMb2dnZXJGYWN0b3JpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMb2dnZXJDb250cm9sSW1wbC5fZ2V0U2V0dGluZ3MoKS5nZXRSdW50aW1lU2V0dGluZ3NGb3JMb2dnZXJGYWN0b3JpZXMoKTtcbiAgICB9O1xuICAgIExvZ2dlckNvbnRyb2xJbXBsLl9nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIExGU2VydmljZV8xLkxGU2VydmljZS5nZXRSdW50aW1lU2V0dGluZ3MoKTtcbiAgICB9O1xuICAgIExvZ2dlckNvbnRyb2xJbXBsLl9oZWxwID0gXCJcXG4gIGhlbHAoKTogdm9pZFxcbiAgICAqKiBTaG93cyB0aGlzIGhlbHAuXFxuXFxuICBsaXN0RmFjdG9yaWVzKCk6IHZvaWRcXG4gICAgKiogTGlzdCBhbGwgcmVnaXN0ZXJlZCBMb2dnZXJGYWN0b3JpZXMgd2l0aCBhc3NvY2lhdGVkIGxvZyBncm91cHMgd2l0aCByZXNwZWN0aXZlIGlkcyAoaWRzIGNhbiBiZSB1c2VkIHRvIHRhcmdldCBhIGZhY3RvcnkgYW5kL29yIGdyb3VwKS5cXG5cXG4gIHNob3dTZXR0aW5ncyhpZEZhY3Rvcnk6IG51bWJlciB8IFxcXCJhbGxcXFwiKTogdm9pZFxcbiAgICAqKiBTaG93IGxvZyBncm91cCBzZXR0aW5ncyBmb3IgaWRGYWN0b3J5ICh1c2UgbGlzdEZhY3RvcmllcyB0byBmaW5kIGlkIGZvciBhIExvZ2dlckZhY3RvcnkpLiBJZiBpZEZhY3RvcnkgaXMgXFxcImFsbFxcXCIgc2hvd3MgYWxsIGZhY3Rvcmllcy5cXG5cXG4gIGdldExvZ2dlckZhY3RvcnlDb250cm9sKGlkRmFjdG9yeTogbnVtYmVyKTogTG9nZ2VyRmFjdG9yeUNvbnRyb2xcXG4gICAgKiogUmV0dXJuIExvZ2dlckZhY3RvcnlDb250cm9sIHdoZW4gZm91bmQgZm9yIGdpdmVuIGlkRmFjdG9yeSBvciB0aHJvd3MgRXJyb3IgaWYgaW52YWxpZCBvciBudWxsLCBnZXQgdGhlIGlkIGJ5IHVzaW5nIGxpc3RGYWN0b3JpZXMoKVxcblxcbiAgcmVzZXQoaWRGYWN0b3J5OiBudW1iZXIgfCBcXFwiYWxsXFxcIik6IHZvaWRcXG4gICAgKiogUmVzZXRzIGdpdmVuIGZhY3Rvcnkgb3IgYWxsIGZhY3RvcmllcyBiYWNrIHRvIG9yaWdpbmFsIHZhbHVlcy5cXG5cIjtcbiAgICByZXR1cm4gTG9nZ2VyQ29udHJvbEltcGw7XG59KCkpO1xuZXhwb3J0cy5Mb2dnZXJDb250cm9sSW1wbCA9IExvZ2dlckNvbnRyb2xJbXBsO1xudmFyIExvZ2dlckZhY3RvcnlDb250cm9sSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwoc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB9XG4gICAgTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLnByb3RvdHlwZS5oZWxwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgIGNvbnNvbGUubG9nKExvZ2dlckZhY3RvcnlDb250cm9sSW1wbC5faGVscCk7XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLnByb3RvdHlwZS5leGFtcGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgIGNvbnNvbGUubG9nKExvZ2dlckZhY3RvcnlDb250cm9sSW1wbC5fZXhhbXBsZSk7XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLnByb3RvdHlwZS5zaG93U2V0dGluZ3MgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSB2b2lkIDApIHsgaWQgPSBcImFsbFwiOyB9XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIHZhciBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyA9IHRoaXMuX3NldHRpbmdzLmdldExvZ0dyb3VwUnVudGltZVNldHRpbmdzKCk7XG4gICAgICAgIHJlc3VsdC5hcHBlbmRMaW5lKFwiUmVnaXN0ZXJlZCBMb2dHcm91cHMgKGluZGV4IC8gZXhwcmVzc2lvbilcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsb2dHcm91cFJ1bnRpbWVTZXR0aW5nID0gbG9nR3JvdXBSdW50aW1lU2V0dGluZ3NbaV07XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kTGluZShcIiAgXCIgKyBpICsgXCI6IFwiICsgbG9nR3JvdXBSdW50aW1lU2V0dGluZy5sb2dHcm91cFJ1bGUucmVnRXhwLnNvdXJjZSArIFwiLCBsb2dMZXZlbD1cIiArXG4gICAgICAgICAgICAgICAgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsW2xvZ0dyb3VwUnVudGltZVNldHRpbmcubGV2ZWxdLnRvU3RyaW5nKCkgKyBcIiwgc2hvd1RpbWVzdGFtcD1cIiArIGxvZ0dyb3VwUnVudGltZVNldHRpbmcubG9nRm9ybWF0LnNob3dUaW1lU3RhbXAgK1xuICAgICAgICAgICAgICAgIFwiLCBzaG93TG9nZ2VyTmFtZT1cIiArIGxvZ0dyb3VwUnVudGltZVNldHRpbmcubG9nRm9ybWF0LnNob3dMb2dnZXJOYW1lICtcbiAgICAgICAgICAgICAgICBcIiwgZm9ybWF0PVwiICsgTG9nZ2VyT3B0aW9uc18xLkRhdGVGb3JtYXRFbnVtW2xvZ0dyb3VwUnVudGltZVNldHRpbmcubG9nRm9ybWF0LmRhdGVGb3JtYXQuZm9ybWF0RW51bV0udG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQudG9TdHJpbmcoKSk7XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLnByb3RvdHlwZS5jaGFuZ2UgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzID0gdGhpcy5fZ2V0TG9nR3JvdXBSdW5UaW1lU2V0dGluZ3NGb3Ioc2V0dGluZ3MuZ3JvdXApO1xuICAgICAgICB2YXIgbG9nTGV2ZWwgPSBudWxsO1xuICAgICAgICB2YXIgZm9ybWF0RW51bSA9IG51bGw7XG4gICAgICAgIHZhciBzaG93TG9nZ2VyTmFtZSA9IG51bGw7XG4gICAgICAgIHZhciBzaG93VGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHZhciBhZGRSZXN1bHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIsIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmxvZ0xldmVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsb2dMZXZlbCA9IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5mcm9tU3RyaW5nKHNldHRpbmdzLmxvZ0xldmVsKTtcbiAgICAgICAgICAgIGFkZFJlc3VsdChcImxvZ0xldmVsPVwiICsgc2V0dGluZ3MubG9nTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MubG9nRm9ybWF0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmb3JtYXRFbnVtID0gTG9nZ2VyT3B0aW9uc18xLkRhdGVGb3JtYXRFbnVtLmZyb21TdHJpbmcoc2V0dGluZ3MubG9nRm9ybWF0KTtcbiAgICAgICAgICAgIGFkZFJlc3VsdChcImxvZ0Zvcm1hdD1cIiArIHNldHRpbmdzLmxvZ0Zvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5zaG93TG9nZ2VyTmFtZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHNob3dMb2dnZXJOYW1lID0gc2V0dGluZ3Muc2hvd0xvZ2dlck5hbWU7XG4gICAgICAgICAgICBhZGRSZXN1bHQoXCJzaG93TG9nZ2VyTmFtZT1cIiArIHNldHRpbmdzLnNob3dMb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnNob3dUaW1lc3RhbXAgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBzaG93VGltZXN0YW1wID0gc2V0dGluZ3Muc2hvd1RpbWVzdGFtcDtcbiAgICAgICAgICAgIGFkZFJlc3VsdChcInNob3dUaW1lc3RhbXA9XCIgKyBzZXR0aW5ncy5zaG93VGltZXN0YW1wKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICBpZiAobG9nTGV2ZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzLmxldmVsID0gbG9nTGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0RW51bSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHMubG9nRm9ybWF0LmRhdGVGb3JtYXQuZm9ybWF0RW51bSA9IGZvcm1hdEVudW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvd1RpbWVzdGFtcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHMubG9nRm9ybWF0LnNob3dUaW1lU3RhbXAgPSBzaG93VGltZXN0YW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3dMb2dnZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcy5sb2dGb3JtYXQuc2hvd0xvZ2dlck5hbWUgPSBzaG93TG9nZ2VyTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2coXCJBcHBsaWVkIGNoYW5nZXM6IFwiICsgcmVzdWx0ICsgXCIgdG8gbG9nIGdyb3VwcyAnXCIgKyBzZXR0aW5ncy5ncm91cCArIFwiJy5cIik7XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChpZEdyb3VwKSB7XG4gICAgICAgIGlmIChpZEdyb3VwID09PSB2b2lkIDApIHsgaWRHcm91cCA9IFwiYWxsXCI7IH1cbiAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5fZ2V0TG9nR3JvdXBSdW5UaW1lU2V0dGluZ3NGb3IoaWRHcm91cCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgc2V0dGluZ3NfMSA9IHNldHRpbmdzOyBfaSA8IHNldHRpbmdzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2V0dGluZyA9IHNldHRpbmdzXzFbX2ldO1xuICAgICAgICAgICAgc2V0dGluZy5sZXZlbCA9IHNldHRpbmcubG9nR3JvdXBSdWxlLmxldmVsO1xuICAgICAgICAgICAgc2V0dGluZy5sb2dGb3JtYXQuc2hvd1RpbWVTdGFtcCA9IHNldHRpbmcubG9nR3JvdXBSdWxlLmxvZ0Zvcm1hdC5zaG93VGltZVN0YW1wO1xuICAgICAgICAgICAgc2V0dGluZy5sb2dGb3JtYXQuc2hvd0xvZ2dlck5hbWUgPSBzZXR0aW5nLmxvZ0dyb3VwUnVsZS5sb2dGb3JtYXQuc2hvd0xvZ2dlck5hbWU7XG4gICAgICAgICAgICBzZXR0aW5nLmxvZ0Zvcm1hdC5kYXRlRm9ybWF0LmZvcm1hdEVudW0gPSBzZXR0aW5nLmxvZ0dyb3VwUnVsZS5sb2dGb3JtYXQuZGF0ZUZvcm1hdC5mb3JtYXRFbnVtO1xuICAgICAgICB9XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2coXCJSZXNldCBhbGwgc2V0dGluZ3MgZm9yIGdyb3VwIFwiICsgaWRHcm91cCk7XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLnByb3RvdHlwZS5fZ2V0TG9nR3JvdXBSdW5UaW1lU2V0dGluZ3NGb3IgPSBmdW5jdGlvbiAoaWRHcm91cCkge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBbXTtcbiAgICAgICAgaWYgKGlkR3JvdXAgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgIHNldHRpbmdzID0gdGhpcy5fc2V0dGluZ3MuZ2V0TG9nR3JvdXBSdW50aW1lU2V0dGluZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrSW5kZXgoaWRHcm91cCk7XG4gICAgICAgICAgICBzZXR0aW5ncy5wdXNoKHRoaXMuX3NldHRpbmdzLmdldExvZ0dyb3VwUnVudGltZVNldHRpbmdzKClbaWRHcm91cF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnlDb250cm9sSW1wbC5wcm90b3R5cGUuX2NoZWNrSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLl9zZXR0aW5ncy5nZXRMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncygpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRleCwgdXNlIGxpc3RMb2dHcm91cHMgdG8gZmluZCBvdXQgYSB2YWxpZCBvbmUuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwuX2hlbHAgPSBcIlxcbiAgaGVscCgpOiB2b2lkXFxuICAgICoqIFNob3dzIHRoaXMgaGVscC5cXG5cXG4gIGV4YW1wbGUoKTogdm9pZFxcbiAgICAqKiBTaG93cyBhbiBleGFtcGxlIG9mIHVzYWdlLlxcblxcbiAgc2hvd1NldHRpbmdzKGlkOiBudW1iZXIgfCBcXFwiYWxsXFxcIik6IHZvaWRcXG4gICAgKiogUHJpbnRzIHNldHRpbmdzIGZvciBnaXZlbiBncm91cCBpZCwgXFxcImFsbFxcXCIgZm9yIGFsbCBncm91cC5cXG5cXG4gIGNoYW5nZShzZXR0aW5nczogTG9nR3JvdXBDb250cm9sU2V0dGluZ3MpOiB2b2lkXFxuICAgICoqIENoYW5nZXMgdGhlIGN1cnJlbnQgc2V0dGluZ3MgZm9yIG9uZSBvciBhbGwgbG9nIGdyb3Vwcy5cXG4gICAgKipcXG4gICAgICAgTG9nR3JvdXBDb250cm9sU2V0dGluZ3MsIHByb3BlcnRpZXMgb2Ygb2JqZWN0OlxcbiAgICAgICAgIGdyb3VwOiBudW1iZXIgfCBcXFwiYWxsXFxcIlxcbiAgICAgICAgICAgKiogQXBwbHkgdG8gc3BlY2lmaWMgZ3JvdXAsIG9yIFxcXCJhbGxcXFwiLlxcbiAgICAgICAgICAgKiogUmVxdWlyZWRcXG5cXG4gICAgICAgICBsb2dMZXZlbDogXFxcIkZhdGFsXFxcIiB8IFxcXCJFcnJvclxcXCIgfCBcXFwiV2FyblxcXCIgfCBcXFwiSW5mb1xcXCIgfCBcXFwiRGVidWdcXFwiIHwgXFxcIlRyYWNlXFxcIiB8IHVuZGVmaW5lZFxcbiAgICAgICAgICAgKiogU2V0IGxvZyBsZXZlbCwgdW5kZWZpbmVkIHdpbGwgbm90IGNoYW5nZSB0aGUgc2V0dGluZy5cXG4gICAgICAgICAgICoqIE9wdGlvbmFsXFxuXFxuICAgICAgICAgbG9nRm9ybWF0OiBcXFwiRGVmYXVsdFxcXCIgfCBcXFwiWWVhck1vbnRoRGF5VGltZVxcXCIgfCBcXFwiWWVhckRheU1vbnRoV2l0aEZ1bGxUaW1lXFxcIiB8IFxcXCJZZWFyRGF5TW9udGhUaW1lXFxcIiB8IHVuZGVmaW5lZFxcbiAgICAgICAgICAgKiogU2V0IHRoZSBsb2cgZm9ybWF0LCB1bmRlZmluZWQgd2lsbCBub3QgY2hhbmdlIHRoZSBzZXR0aW5nLlxcbiAgICAgICAgICAgKiogT3B0aW9uYWxcXG5cXG4gICAgICAgICBzaG93VGltZXN0YW1wOiBib29sZWFuIHwgdW5kZWZpbmVkXFxuICAgICAgICAgICAqKiBXaGV0aGVyIHRvIHNob3cgdGltZXN0YW1wLCB1bmRlZmluZWQgd2lsbCBub3QgY2hhbmdlIHRoZSBzZXR0aW5nLlxcbiAgICAgICAgICAgKiogT3B0aW9uYWxcXG5cXG4gICAgICAgICBzaG93TG9nZ2VyTmFtZTogYm9vbGVhbiB8IHVuZGVmaW5lZFxcbiAgICAgICAgICAgKiogV2hldGhlciB0byBzaG93IHRoZSBsb2dnZXIgbmFtZSwgdW5kZWZpbmVkIHdpbGwgbm90IGNoYW5nZSB0aGUgc2V0dGluZy5cXG4gICAgICAgICAgICoqIE9wdGlvbmFsXFxuXFxuICByZXNldChpZDogbnVtYmVyIHwgXFxcImFsbFxcXCIpOiB2b2lkXFxuICAgICoqIFJlc2V0cyBldmVyeXRoaW5nIHRvIG9yaWdpbmFsIHZhbHVlcywgZm9yIG9uZSBzcGVjaWZpYyBvciBmb3IgYWxsIGdyb3Vwcy5cXG5cXG4gIGhlbHAoKTpcXG4gICAgKiogU2hvd3MgdGhpcyBoZWxwLlxcblwiO1xuICAgIExvZ2dlckZhY3RvcnlDb250cm9sSW1wbC5fZXhhbXBsZSA9IFwiXFxuICBFeGFtcGxlczpcXG4gICAgY2hhbmdlKHtncm91cDogXFxcImFsbFxcXCIsIGxvZ0xldmVsOiBcXFwiSW5mb1xcXCJ9KVxcbiAgICAgICoqIENoYW5nZSBsb2dsZXZlbCB0byBJbmZvIGZvciBhbGwgZ3JvdXBzLlxcblxcbiAgICBjaGFuZ2Uoe2dyb3VwOiAxLCByZWN1cnNpdmU6ZmFsc2UsIGxvZ0xldmVsOiBcXFwiV2FyblxcXCJ9KVxcbiAgICAgICoqIENoYW5nZSBsb2dMZXZlbCBmb3IgZ3JvdXAgMSB0byBXYXJuLlxcblxcbiAgICBjaGFuZ2Uoe2dyb3VwOiBcXFwiYWxsXFxcIiwgbG9nTGV2ZWw6IFxcXCJEZWJ1Z1xcXCIsIGxvZ0Zvcm1hdDogXFxcIlllYXJEYXlNb250aFRpbWVcXFwiLCBzaG93VGltZXN0YW1wOmZhbHNlLCBzaG93TG9nZ2VyTmFtZTpmYWxzZX0pXFxuICAgICAgKiogQ2hhbmdlIGxvZ2xldmVsIHRvIERlYnVnIGZvciBhbGwgZ3JvdXBzLCBhcHBseSBmb3JtYXQsIGRvIG5vdCBzaG93IHRpbWVzdGFtcCBhbmQgbG9nZ2VyIG5hbWVzLlxcblwiO1xuICAgIHJldHVybiBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGw7XG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nR3JvdXBDb250cm9sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FeHRlbnNpb25IZWxwZXIgPSB2b2lkIDA7XG52YXIgQ2F0ZWdvcnlTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbG9nL2NhdGVnb3J5L0NhdGVnb3J5U2VydmljZVwiKTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vbG9nL0xvZ2dlck9wdGlvbnNcIik7XG52YXIgTWVzc2FnZVV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvTWVzc2FnZVV0aWxzXCIpO1xudmFyIEV4dGVuc2lvbkhlbHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFeHRlbnNpb25IZWxwZXIoKSB7XG4gICAgICAgIC8vIFByaXZhdGUgY29uc3RydWN0b3JcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgd2luZG93IGV2ZW50IGxpc3RlbmVyIHRvIGxpc3RlbiB0byBtZXNzYWdlcyAoZnJvbSBleHRlbnNpb25zKS5cbiAgICAgKiBDYW4gYmUgcmVnaXN0ZXJlZC9lbmFibGVkIG9ubHkgb25jZS5cbiAgICAgKi9cbiAgICBFeHRlbnNpb25IZWxwZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gZXZ0LmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKG1zZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBFeHRlbnNpb25IZWxwZXIucHJvY2Vzc01lc3NhZ2VGcm9tRXh0ZW5zaW9uKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFeHRlbnNpb25IZWxwZXIucHJvY2Vzc01lc3NhZ2VGcm9tRXh0ZW5zaW9uID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBpZiAoIUV4dGVuc2lvbkhlbHBlci5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICBpZiAobXNnLmZyb20gPT09IFwidHNsLWV4dGVuc2lvblwiKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IG1zZy5kYXRhO1xuICAgICAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVnaXN0ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgRXh0ZW5zaW9uSGVscGVyLmVuYWJsZUV4dGVuc2lvbkludGVncmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXF1ZXN0LWNoYW5nZS1sb2dsZXZlbFwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVSZXF1ZXN0ID0gZGF0YS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhdHNBcHBsaWVkID0gRXh0ZW5zaW9uSGVscGVyLmFwcGx5TG9nTGV2ZWwodmFsdWVSZXF1ZXN0LmNhdGVnb3J5SWQsIHZhbHVlUmVxdWVzdC5sb2dMZXZlbCwgdmFsdWVSZXF1ZXN0LnJlY3Vyc2l2ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXRzQXBwbGllZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZW5kIGNoYW5nZXMgYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgRXh0ZW5zaW9uSGVscGVyLnNlbmRDYXRlZ29yaWVzUnVudGltZVVwZGF0ZU1lc3NhZ2UoY2F0c0FwcGxpZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBjb21tYW5kIHRvIHByb2Nlc3MgbWVzc2FnZSBmcm9tIGV4dGVuc2lvbiwgY29tbWFuZCB3YXM6IFwiICsgZGF0YS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBFeHRlbnNpb25IZWxwZXIuc2VuZENhdGVnb3J5TG9nTWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKCFFeHRlbnNpb25IZWxwZXIucmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYXRlZ29yeUlkcyA9IG1zZy5jYXRlZ29yaWVzLm1hcChmdW5jdGlvbiAoY2F0KSB7XG4gICAgICAgICAgICByZXR1cm4gY2F0LmlkO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImxvZy1tZXNzYWdlXCIsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGNhdGVnb3JpZXM6IGNhdGVnb3J5SWRzLFxuICAgICAgICAgICAgICAgIGVycm9yQXNTdGFjazogbXNnLmVycm9yQXNTdGFjayxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRNZXNzYWdlOiBNZXNzYWdlVXRpbHNfMS5NZXNzYWdlRm9ybWF0VXRpbHMucmVuZGVyRGVmYXVsdE1lc3NhZ2UobXNnLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgbG9nTGV2ZWw6IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbFttc2cubGV2ZWxdLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnLm1lc3NhZ2VBc1N0cmluZyxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEVycm9yTWVzc2FnZTogbXNnLmlzUmVzb2x2ZWRFcnJvck1lc3NhZ2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBkYXRhOiBjb250ZW50LFxuICAgICAgICAgICAgZnJvbTogXCJ0c2wtbG9nZ2luZ1wiLFxuICAgICAgICB9O1xuICAgICAgICBFeHRlbnNpb25IZWxwZXIuc2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfTtcbiAgICBFeHRlbnNpb25IZWxwZXIuc2VuZENhdGVnb3JpZXNSdW50aW1lVXBkYXRlTWVzc2FnZSA9IGZ1bmN0aW9uIChjYXRlZ29yaWVzKSB7XG4gICAgICAgIGlmICghRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VydmljZSA9IENhdGVnb3J5U2VydmljZV8xLkNhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIGNhdExldmVscyA9IHsgY2F0ZWdvcmllczogQXJyYXkoKSB9O1xuICAgICAgICBjYXRlZ29yaWVzLmZvckVhY2goZnVuY3Rpb24gKGNhdCkge1xuICAgICAgICAgICAgdmFyIGNhdFNldHRpbmdzID0gc2VydmljZS5nZXRDYXRlZ29yeVNldHRpbmdzKGNhdCk7XG4gICAgICAgICAgICBpZiAoY2F0U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNhdExldmVscy5jYXRlZ29yaWVzLnB1c2goeyBpZDogY2F0LmlkLCBsb2dMZXZlbDogTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsW2NhdFNldHRpbmdzLmxvZ0xldmVsXS50b1N0cmluZygpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImNhdGVnb3JpZXMtcnQtdXBkYXRlXCIsXG4gICAgICAgICAgICB2YWx1ZTogY2F0TGV2ZWxzLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGRhdGE6IGNvbnRlbnQsXG4gICAgICAgICAgICBmcm9tOiBcInRzbC1sb2dnaW5nXCJcbiAgICAgICAgfTtcbiAgICAgICAgRXh0ZW5zaW9uSGVscGVyLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSGVscGVyLnNlbmRSb290Q2F0ZWdvcmllc1RvRXh0ZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIUV4dGVuc2lvbkhlbHBlci5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBDYXRlZ29yeVNlcnZpY2VfMS5DYXRlZ29yeVNlcnZpY2VJbXBsLmdldEluc3RhbmNlKCkuZ2V0Um9vdENhdGVnb3JpZXMoKS5tYXAoZnVuY3Rpb24gKGNhdCkge1xuICAgICAgICAgICAgcmV0dXJuIEV4dGVuc2lvbkhlbHBlci5nZXRDYXRlZ29yeUFzSlNPTihjYXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBcInJvb3QtY2F0ZWdvcmllcy10cmVlXCIsXG4gICAgICAgICAgICB2YWx1ZTogY2F0ZWdvcmllc1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGRhdGE6IGNvbnRlbnQsXG4gICAgICAgICAgICBmcm9tOiBcInRzbC1sb2dnaW5nXCJcbiAgICAgICAgfTtcbiAgICAgICAgRXh0ZW5zaW9uSGVscGVyLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgZXh0ZW5zaW9uIGludGVncmF0aW9uIGlzIGVuYWJsZWQsIHdpbGwgc2VuZCB0aGUgcm9vdCBjYXRlZ29yaWVzIG92ZXIgdG8gdGhlIGV4dGVuc2lvbi5cbiAgICAgKiBPdGhlcndpc2UgZG9lcyBub3RoaW5nLlxuICAgICAqL1xuICAgIEV4dGVuc2lvbkhlbHBlci5nZXRDYXRlZ29yeUFzSlNPTiA9IGZ1bmN0aW9uIChjYXQpIHtcbiAgICAgICAgdmFyIGNoaWxkQ2F0ZWdvcmllcyA9IGNhdC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gRXh0ZW5zaW9uSGVscGVyLmdldENhdGVnb3J5QXNKU09OKGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRDYXRlZ29yaWVzLFxuICAgICAgICAgICAgaWQ6IGNhdC5pZCxcbiAgICAgICAgICAgIGxvZ0xldmVsOiBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWxbY2F0LmxvZ0xldmVsXS50b1N0cmluZygpLFxuICAgICAgICAgICAgbmFtZTogY2F0Lm5hbWUsXG4gICAgICAgICAgICBwYXJlbnRJZDogKGNhdC5wYXJlbnQgIT0gbnVsbCA/IGNhdC5wYXJlbnQuaWQgOiBudWxsKSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkhlbHBlci5hcHBseUxvZ0xldmVsID0gZnVuY3Rpb24gKGNhdGVnb3J5SWQsIGxvZ0xldmVsLCByZWN1cnNpdmUpIHtcbiAgICAgICAgdmFyIGNhdHMgPSBbXTtcbiAgICAgICAgdmFyIGNhdGVnb3J5ID0gQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLmdldENhdGVnb3J5QnlJZChjYXRlZ29yeUlkKTtcbiAgICAgICAgaWYgKGNhdGVnb3J5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIEV4dGVuc2lvbkhlbHBlci5fYXBwbHlMb2dMZXZlbFJlY3Vyc2l2ZShjYXRlZ29yeSwgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLmZyb21TdHJpbmcobG9nTGV2ZWwpLCByZWN1cnNpdmUsIGNhdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDb3VsZCBub3QgY2hhbmdlIGxvZyBsZXZlbCwgZmFpbGVkIHRvIGZpbmQgY2F0ZWdvcnkgd2l0aCBpZDogXCIgKyBjYXRlZ29yeUlkKTtcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYXRzO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSGVscGVyLl9hcHBseUxvZ0xldmVsUmVjdXJzaXZlID0gZnVuY3Rpb24gKGNhdGVnb3J5LCBsb2dMZXZlbCwgcmVjdXJzaXZlLCBjYXRzKSB7XG4gICAgICAgIHZhciBjYXRlZ29yeVNldHRpbmdzID0gQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLmdldENhdGVnb3J5U2V0dGluZ3MoY2F0ZWdvcnkpO1xuICAgICAgICBpZiAoY2F0ZWdvcnlTZXR0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjYXRlZ29yeVNldHRpbmdzLmxvZ0xldmVsID0gbG9nTGV2ZWw7XG4gICAgICAgICAgICBjYXRzLnB1c2goY2F0ZWdvcnkpO1xuICAgICAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIEV4dGVuc2lvbkhlbHBlci5fYXBwbHlMb2dMZXZlbFJlY3Vyc2l2ZShjaGlsZCwgbG9nTGV2ZWwsIHJlY3Vyc2l2ZSwgY2F0cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV4dGVuc2lvbkhlbHBlci5nZXRBbGxDYXRlZ29yaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2F0cyA9IFtdO1xuICAgICAgICB2YXIgYWRkQ2F0cyA9IGZ1bmN0aW9uIChjYXQsIGFsbENhdHMpIHtcbiAgICAgICAgICAgIGFsbENhdHMucHVzaChjYXQpO1xuICAgICAgICAgICAgY2F0LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNhdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgYWRkQ2F0cyhjYXRDaGlsZCwgYWxsQ2F0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLmdldFJvb3RDYXRlZ29yaWVzKCkuZm9yRWFjaChmdW5jdGlvbiAoY2F0KSB7XG4gICAgICAgICAgICBhZGRDYXRzKGNhdCwgY2F0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2F0cztcbiAgICB9O1xuICAgIEV4dGVuc2lvbkhlbHBlci5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKCFFeHRlbnNpb25IZWxwZXIucmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cucG9zdE1lc3NhZ2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtc2csIFwiKlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogIEV4dGVuc2lvbiBmcmFtZXdvcmsgd2lsbCBjYWxsIHRoaXMgdG8gZW5hYmxlIHRoZSBpbnRlZ3JhdGlvbiBiZXR3ZWVuIHR3byxcbiAgICAgKiAgYWZ0ZXIgdGhpcyBjYWxsIHRoZSBmcmFtZXdvcmsgd2lsbCByZXNwb25kIHdpdGggcG9zdE1lc3NhZ2UoKSBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBFeHRlbnNpb25IZWxwZXIuZW5hYmxlRXh0ZW5zaW9uSW50ZWdyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBDYXRlZ29yeVNlcnZpY2VfMS5DYXRlZ29yeVNlcnZpY2VJbXBsLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGluc3RhbmNlLmVuYWJsZUV4dGVuc2lvbkludGVncmF0aW9uKCk7XG4gICAgICAgIC8vIFNlbmQgb3ZlciBhbGwgY2F0ZWdvcmllc1xuICAgICAgICBFeHRlbnNpb25IZWxwZXIuc2VuZFJvb3RDYXRlZ29yaWVzVG9FeHRlbnNpb24oKTtcbiAgICAgICAgLy8gU2VuZCBvdmVyIHRoZSBjdXJyZW50IHJ1bnRpbWUgbGV2ZWxzXG4gICAgICAgIHZhciBjYXRzID0gRXh0ZW5zaW9uSGVscGVyLmdldEFsbENhdGVnb3JpZXMoKTtcbiAgICAgICAgRXh0ZW5zaW9uSGVscGVyLnNlbmRDYXRlZ29yaWVzUnVudGltZVVwZGF0ZU1lc3NhZ2UoY2F0cyk7XG4gICAgfTtcbiAgICBFeHRlbnNpb25IZWxwZXIucmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIHJldHVybiBFeHRlbnNpb25IZWxwZXI7XG59KCkpO1xuZXhwb3J0cy5FeHRlbnNpb25IZWxwZXIgPSBFeHRlbnNpb25IZWxwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeHRlbnNpb25IZWxwZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FeHRlbnNpb25NZXNzYWdlSlNPTi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc3NhZ2VzRnJvbUV4dGVuc2lvbkpTT04uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNzYWdlc1RvRXh0ZW5zaW9uSlNPTi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2F0ZWdvcnlMb2dGb3JtYXQgPSBleHBvcnRzLkxvZ0Zvcm1hdCA9IGV4cG9ydHMuRGF0ZUZvcm1hdCA9IGV4cG9ydHMuRGF0ZUZvcm1hdEVudW0gPSBleHBvcnRzLkxvZ2dlclR5cGUgPSBleHBvcnRzLkxvZ0xldmVsID0gdm9pZCAwO1xuLyoqXG4gKiBMb2cgbGV2ZWwgZm9yIGEgbG9nZ2VyLlxuICovXG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJUcmFjZVwiXSA9IDBdID0gXCJUcmFjZVwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRGVidWdcIl0gPSAxXSA9IFwiRGVidWdcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkluZm9cIl0gPSAyXSA9IFwiSW5mb1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV2FyblwiXSA9IDNdID0gXCJXYXJuXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFcnJvclwiXSA9IDRdID0gXCJFcnJvclwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRmF0YWxcIl0gPSA1XSA9IFwiRmF0YWxcIjtcbn0pKExvZ0xldmVsID0gZXhwb3J0cy5Mb2dMZXZlbCB8fCAoZXhwb3J0cy5Mb2dMZXZlbCA9IHt9KSk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1uYW1lc3BhY2UgKi9cbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIExvZ0xldmVsIGJhc2VkIG9uIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSB2YWwgVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TG9nTGV2ZWx9LCBFcnJvciBpcyB0aHJvd24gaWYgaW52YWxpZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0cmFjZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBMb2dMZXZlbC5UcmFjZTtcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBMb2dMZXZlbC5EZWJ1ZztcbiAgICAgICAgICAgIGNhc2UgXCJpbmZvXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvZ0xldmVsLkluZm87XG4gICAgICAgICAgICBjYXNlIFwid2FyblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBMb2dMZXZlbC5XYXJuO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvZ0xldmVsLkVycm9yO1xuICAgICAgICAgICAgY2FzZSBcImZhdGFsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvZ0xldmVsLkZhdGFsO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB2YWx1ZSBmb3IgY29udmVyc2lvbjogXCIgKyB2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIExvZ0xldmVsLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xufSkoTG9nTGV2ZWwgPSBleHBvcnRzLkxvZ0xldmVsIHx8IChleHBvcnRzLkxvZ0xldmVsID0ge30pKTtcbi8qIHRzbGludDpkaXNhYmxlOmVuYWJsZS1uYW1lc3BhY2UgKi9cbi8qKlxuICogV2hlcmUgdG8gbG9nIHRvPyBQaWNrIG9uZSBvZiB0aGUgY29uc3RhbnRzLiBDdXN0b20gcmVxdWlyZXMgYSBjYWxsYmFjayB0byBiZSBwcmVzZW50LCBzZWUgTEZTZXJ2aWNlLmNyZWF0ZUxvZ2dlckZhY3RvcnkoLi4uKVxuICogd2hlcmUgdGhpcyBjb21lcyBpbnRvIHBsYXkuXG4gKi9cbnZhciBMb2dnZXJUeXBlO1xuKGZ1bmN0aW9uIChMb2dnZXJUeXBlKSB7XG4gICAgTG9nZ2VyVHlwZVtMb2dnZXJUeXBlW1wiQ29uc29sZVwiXSA9IDBdID0gXCJDb25zb2xlXCI7XG4gICAgTG9nZ2VyVHlwZVtMb2dnZXJUeXBlW1wiTWVzc2FnZUJ1ZmZlclwiXSA9IDFdID0gXCJNZXNzYWdlQnVmZmVyXCI7XG4gICAgTG9nZ2VyVHlwZVtMb2dnZXJUeXBlW1wiQ3VzdG9tXCJdID0gMl0gPSBcIkN1c3RvbVwiO1xufSkoTG9nZ2VyVHlwZSA9IGV4cG9ydHMuTG9nZ2VyVHlwZSB8fCAoZXhwb3J0cy5Mb2dnZXJUeXBlID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyBzZXZlcmFsIGRhdGUgZW51bXMgdXNlZCBmb3IgZm9ybWF0dGluZyBhIGRhdGUuXG4gKi9cbnZhciBEYXRlRm9ybWF0RW51bTtcbihmdW5jdGlvbiAoRGF0ZUZvcm1hdEVudW0pIHtcbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBhczogeWVhci1tb250aC1kYXkgaG91cjptaW51dGU6c2Vjb25kLG1pbGxpcyAtPiAxOTk5LTAyLTEyIDIzOjU5OjU5LDEyM1xuICAgICAqIE5vdGUgdGhlIGRhdGUgc2VwYXJhdG9yIGNhbiBiZSBzZXQgc2VwYXJhdGVseS5cbiAgICAgKi9cbiAgICBEYXRlRm9ybWF0RW51bVtEYXRlRm9ybWF0RW51bVtcIkRlZmF1bHRcIl0gPSAwXSA9IFwiRGVmYXVsdFwiO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIGFzOiB5ZWFyLW1vbnRoLWRheSBob3VyOm1pbnV0ZTpzZWNvbmQgLT4gMTk5OS0wMi0xMiAyMzo1OTo1OVxuICAgICAqIE5vdGUgdGhlIGRhdGUgc2VwYXJhdG9yIGNhbiBiZSBzZXQgc2VwYXJhdGVseS5cbiAgICAgKi9cbiAgICBEYXRlRm9ybWF0RW51bVtEYXRlRm9ybWF0RW51bVtcIlllYXJNb250aERheVRpbWVcIl0gPSAxXSA9IFwiWWVhck1vbnRoRGF5VGltZVwiO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIGFzOiB5ZWFyLWRheS1tb250aCBob3VyOm1pbnV0ZTpzZWNvbmQsbWlsbGlzIC0+IDE5OTktMTItMDIgMjM6NTk6NTksMTIzXG4gICAgICogTm90ZSB0aGUgZGF0ZSBzZXBhcmF0b3IgY2FuIGJlIHNldCBzZXBhcmF0ZWx5LlxuICAgICAqL1xuICAgIERhdGVGb3JtYXRFbnVtW0RhdGVGb3JtYXRFbnVtW1wiWWVhckRheU1vbnRoV2l0aEZ1bGxUaW1lXCJdID0gMl0gPSBcIlllYXJEYXlNb250aFdpdGhGdWxsVGltZVwiO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIGFzOiB5ZWFyLWRheS1tb250aCBob3VyOm1pbnV0ZTpzZWNvbmQgLT4gMTk5OS0xMi0wMiAyMzo1OTo1OVxuICAgICAqIE5vdGUgdGhlIGRhdGUgc2VwYXJhdG9yIGNhbiBiZSBzZXQgc2VwYXJhdGVseS5cbiAgICAgKi9cbiAgICBEYXRlRm9ybWF0RW51bVtEYXRlRm9ybWF0RW51bVtcIlllYXJEYXlNb250aFRpbWVcIl0gPSAzXSA9IFwiWWVhckRheU1vbnRoVGltZVwiO1xufSkoRGF0ZUZvcm1hdEVudW0gPSBleHBvcnRzLkRhdGVGb3JtYXRFbnVtIHx8IChleHBvcnRzLkRhdGVGb3JtYXRFbnVtID0ge30pKTtcbi8qIHRzbGludDpkaXNhYmxlOm5vLW5hbWVzcGFjZSAqL1xuKGZ1bmN0aW9uIChEYXRlRm9ybWF0RW51bSkge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgTG9nTGV2ZWwgYmFzZWQgb24gc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHBhcmFtIHZhbCBWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtMb2dMZXZlbH0sIEVycm9yIGlzIHRocm93biBpZiBpbnZhbGlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWwudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZUZvcm1hdEVudW0uRGVmYXVsdDtcbiAgICAgICAgICAgIGNhc2UgXCJ5ZWFybW9udGhkYXlUaW1lXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVGb3JtYXRFbnVtLlllYXJNb250aERheVRpbWU7XG4gICAgICAgICAgICBjYXNlIFwieWVhcmRheW1vbnRod2l0aGZ1bGx0aW1lXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVGb3JtYXRFbnVtLlllYXJEYXlNb250aFdpdGhGdWxsVGltZTtcbiAgICAgICAgICAgIGNhc2UgXCJ5ZWFyZGF5bW9udGh0aW1lXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVGb3JtYXRFbnVtLlllYXJEYXlNb250aFRpbWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHZhbHVlIGZvciBjb252ZXJzaW9uOiBcIiArIHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGF0ZUZvcm1hdEVudW0uZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG59KShEYXRlRm9ybWF0RW51bSA9IGV4cG9ydHMuRGF0ZUZvcm1hdEVudW0gfHwgKGV4cG9ydHMuRGF0ZUZvcm1hdEVudW0gPSB7fSkpO1xuLyogdHNsaW50OmRpc2FibGU6ZW5hYmxlLW5hbWVzcGFjZSAqL1xuLyoqXG4gKiBEYXRlRm9ybWF0IGNsYXNzLCBzdG9yZXMgZGF0YSBvbiBob3cgdG8gZm9ybWF0IGEgZGF0ZS5cbiAqL1xudmFyIERhdGVGb3JtYXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgdG8gZGVmaW5lIHRoZSBkYXRlZm9ybWF0IHVzZWQgZm9yIGxvZ2dpbmcsIGNhbiBiZSBjYWxsZWQgZW1wdHkgYXMgaXQgdXNlcyBkZWZhdWx0cy5cbiAgICAgKiBAcGFyYW0gZm9ybWF0RW51bSBEYXRlRm9ybWF0RW51bSwgdXNlIG9uZSBvZiB0aGUgY29uc3RhbnRzIGZyb20gdGhlIGVudW0uIERlZmF1bHRzIHRvIERhdGVGb3JtYXRFbnVtLkRlZmF1bHRcbiAgICAgKiBAcGFyYW0gZGF0ZVNlcGFyYXRvciBTZXBhcmF0b3IgdXNlZCBiZXR3ZWVuIGRhdGVzLCBkZWZhdWx0cyB0byAtXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0ZUZvcm1hdChmb3JtYXRFbnVtLCBkYXRlU2VwYXJhdG9yKSB7XG4gICAgICAgIGlmIChmb3JtYXRFbnVtID09PSB2b2lkIDApIHsgZm9ybWF0RW51bSA9IERhdGVGb3JtYXRFbnVtLkRlZmF1bHQ7IH1cbiAgICAgICAgaWYgKGRhdGVTZXBhcmF0b3IgPT09IHZvaWQgMCkgeyBkYXRlU2VwYXJhdG9yID0gXCItXCI7IH1cbiAgICAgICAgdGhpcy5fZm9ybWF0RW51bSA9IGZvcm1hdEVudW07XG4gICAgICAgIHRoaXMuX2RhdGVTZXBhcmF0b3IgPSBkYXRlU2VwYXJhdG9yO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0ZUZvcm1hdC5wcm90b3R5cGUsIFwiZm9ybWF0RW51bVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdEVudW07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JtYXRFbnVtID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0ZUZvcm1hdC5wcm90b3R5cGUsIFwiZGF0ZVNlcGFyYXRvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVTZXBhcmF0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRlU2VwYXJhdG9yID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBEYXRlRm9ybWF0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGVGb3JtYXQodGhpcy5fZm9ybWF0RW51bSwgdGhpcy5fZGF0ZVNlcGFyYXRvcik7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZUZvcm1hdDtcbn0oKSk7XG5leHBvcnRzLkRhdGVGb3JtYXQgPSBEYXRlRm9ybWF0O1xuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgbG9nIGZvcm1hdCwgd2hhdCB3aWxsIGEgbG9nIGxpbmUgbG9vayBsaWtlP1xuICovXG52YXIgTG9nRm9ybWF0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIExvZ0Zvcm1hdC4gQ2FuIGJlIGNyZWF0ZWQgd2l0aG91dCBwYXJhbWV0ZXJzIHdoZXJlIGl0IHdpbGwgdXNlIHNhbmUgZGVmYXVsdHMuXG4gICAgICogQHBhcmFtIGRhdGVGb3JtYXQgRGF0ZUZvcm1hdCAod2hhdCBuZWVkcyB0aGUgZGF0ZSBsb29rIGxpa2UgaW4gdGhlIGxvZyBsaW5lKVxuICAgICAqIEBwYXJhbSBzaG93VGltZVN0YW1wIFNob3cgZGF0ZSB0aW1lc3RhbXAgYXQgYWxsP1xuICAgICAqIEBwYXJhbSBzaG93TG9nZ2VyTmFtZSBTaG93IHRoZSBsb2dnZXIgbmFtZT9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2dGb3JtYXQoZGF0ZUZvcm1hdCwgc2hvd1RpbWVTdGFtcCwgc2hvd0xvZ2dlck5hbWUpIHtcbiAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT09IHZvaWQgMCkgeyBkYXRlRm9ybWF0ID0gbmV3IERhdGVGb3JtYXQoKTsgfVxuICAgICAgICBpZiAoc2hvd1RpbWVTdGFtcCA9PT0gdm9pZCAwKSB7IHNob3dUaW1lU3RhbXAgPSB0cnVlOyB9XG4gICAgICAgIGlmIChzaG93TG9nZ2VyTmFtZSA9PT0gdm9pZCAwKSB7IHNob3dMb2dnZXJOYW1lID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLl9zaG93VGltZVN0YW1wID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2hvd0xvZ2dlck5hbWUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kYXRlRm9ybWF0ID0gZGF0ZUZvcm1hdDtcbiAgICAgICAgdGhpcy5fc2hvd1RpbWVTdGFtcCA9IHNob3dUaW1lU3RhbXA7XG4gICAgICAgIHRoaXMuX3Nob3dMb2dnZXJOYW1lID0gc2hvd0xvZ2dlck5hbWU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dGb3JtYXQucHJvdG90eXBlLCBcImRhdGVGb3JtYXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlRm9ybWF0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0Zvcm1hdC5wcm90b3R5cGUsIFwic2hvd1RpbWVTdGFtcFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3dUaW1lU3RhbXA7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zaG93VGltZVN0YW1wID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nRm9ybWF0LnByb3RvdHlwZSwgXCJzaG93TG9nZ2VyTmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3dMb2dnZXJOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2hvd0xvZ2dlck5hbWUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBMb2dGb3JtYXQ7XG59KCkpO1xuZXhwb3J0cy5Mb2dGb3JtYXQgPSBMb2dGb3JtYXQ7XG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBsb2cgZm9ybWF0LCB3aGF0IHdpbGwgYSBsb2cgbGluZSBsb29rIGxpa2U/XG4gKi9cbnZhciBDYXRlZ29yeUxvZ0Zvcm1hdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2UgZGVmaW5pbmcgdGhlIGNhdGVnb3J5IGxvZyBmb3JtYXQgdXNlZC5cbiAgICAgKiBAcGFyYW0gZGF0ZUZvcm1hdCBEYXRlIGZvcm1hdCAodXNlcyBkZWZhdWx0KSwgZm9yIGRldGFpbHMgc2VlIERhdGVGb3JtYXQgY2xhc3MuXG4gICAgICogQHBhcmFtIHNob3dUaW1lU3RhbXAgVHJ1ZSB0byBzaG93IHRpbWVzdGFtcCBpbiB0aGUgbG9nZ2luZywgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgKiBAcGFyYW0gc2hvd0NhdGVnb3J5TmFtZSBUcnVlIHRvIHNob3cgY2F0ZWdvcnkgbmFtZSBpbiB0aGUgbG9nZ2luZywgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDYXRlZ29yeUxvZ0Zvcm1hdChkYXRlRm9ybWF0LCBzaG93VGltZVN0YW1wLCBzaG93Q2F0ZWdvcnlOYW1lKSB7XG4gICAgICAgIGlmIChkYXRlRm9ybWF0ID09PSB2b2lkIDApIHsgZGF0ZUZvcm1hdCA9IG5ldyBEYXRlRm9ybWF0KCk7IH1cbiAgICAgICAgaWYgKHNob3dUaW1lU3RhbXAgPT09IHZvaWQgMCkgeyBzaG93VGltZVN0YW1wID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoc2hvd0NhdGVnb3J5TmFtZSA9PT0gdm9pZCAwKSB7IHNob3dDYXRlZ29yeU5hbWUgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMuX2RhdGVGb3JtYXQgPSBkYXRlRm9ybWF0O1xuICAgICAgICB0aGlzLl9zaG93VGltZVN0YW1wID0gc2hvd1RpbWVTdGFtcDtcbiAgICAgICAgdGhpcy5fc2hvd0NhdGVnb3J5TmFtZSA9IHNob3dDYXRlZ29yeU5hbWU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ0Zvcm1hdC5wcm90b3R5cGUsIFwiZGF0ZUZvcm1hdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVGb3JtYXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRlRm9ybWF0ID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dGb3JtYXQucHJvdG90eXBlLCBcInNob3dUaW1lU3RhbXBcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaG93VGltZVN0YW1wO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2hvd1RpbWVTdGFtcCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5TG9nRm9ybWF0LnByb3RvdHlwZSwgXCJzaG93Q2F0ZWdvcnlOYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hvd0NhdGVnb3J5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dDYXRlZ29yeU5hbWUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENhdGVnb3J5TG9nRm9ybWF0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IENhdGVnb3J5TG9nRm9ybWF0KHRoaXMuX2RhdGVGb3JtYXQuY29weSgpLCB0aGlzLl9zaG93VGltZVN0YW1wLCB0aGlzLl9zaG93Q2F0ZWdvcnlOYW1lKTtcbiAgICB9O1xuICAgIHJldHVybiBDYXRlZ29yeUxvZ0Zvcm1hdDtcbn0oKSk7XG5leHBvcnRzLkNhdGVnb3J5TG9nRm9ybWF0ID0gQ2F0ZWdvcnlMb2dGb3JtYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2dnZXJPcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BYnN0cmFjdENhdGVnb3J5TG9nZ2VyID0gdm9pZCAwO1xudmFyIERhdGFTdHJ1Y3R1cmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvRGF0YVN0cnVjdHVyZXNcIik7XG52YXIgTWVzc2FnZVV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvTWVzc2FnZVV0aWxzXCIpO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIENhdGVnb3J5TG9nTWVzc2FnZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbChtZXNzYWdlLCBlcnJvciwgY2F0ZWdvcmllcywgZGF0ZSwgbGV2ZWwsIGxvZ0Zvcm1hdCwgcmVhZHkpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWRFcnJvck1lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZXJyb3JBc1N0YWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuX2NhdGVnb3JpZXMgPSBjYXRlZ29yaWVzO1xuICAgICAgICB0aGlzLl9kYXRlID0gZGF0ZTtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy5fbG9nRm9ybWF0ID0gbG9nRm9ybWF0O1xuICAgICAgICB0aGlzLl9yZWFkeSA9IHJlYWR5O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUsIFwiZXJyb3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJjYXRlZ29yaWVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2F0ZWdvcmllcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJkYXRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJsZXZlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5TG9nTWVzc2FnZUltcGwucHJvdG90eXBlLCBcImxvZ0Zvcm1hdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0Zvcm1hdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJpc01lc3NhZ2VMb2dEYXRhXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mICh0aGlzLl9tZXNzYWdlKSAhPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJtZXNzYWdlQXNTdHJpbmdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKHRoaXMuX21lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZS5tc2c7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUsIFwibG9nRGF0YVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLl9tZXNzYWdlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUsIFwiaXNSZXNvbHZlZEVycm9yTWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkRXJyb3JNZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5TG9nTWVzc2FnZUltcGwucHJvdG90eXBlLCBcImVycm9yQXNTdGFja1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yQXNTdGFjaztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yQXNTdGFjayA9IHN0YWNrO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUuaXNSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5O1xuICAgIH07XG4gICAgQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUuc2V0UmVhZHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSB2YWx1ZTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJyZXNvbHZlZEVycm9yTWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkRXJyb3JNZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRFcnJvck1lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsO1xufSgpKTtcbi8qKlxuICogQWJzdHJhY3QgY2F0ZWdvcnkgbG9nZ2VyLCB1c2UgYXMgeW91ciBiYXNlIGNsYXNzIGZvciBuZXcgdHlwZSBvZiBsb2dnZXJzIChpdFxuICogc2F2ZXMgeW91IGEgbG90IG9mIHdvcmspIGFuZCBvdmVycmlkZSBkb0xvZyhDYXRlZ29yeUxvZ01lc3NhZ2UpLiBUaGUgbWVzc2FnZSBhcmd1bWVudFxuICogcHJvdmlkZXMgZnVsbCBhY2Nlc3MgdG8gYW55dGhpbmcgcmVsYXRlZCB0byB0aGUgbG9nZ2luZyBldmVudC5cbiAqIElmIHlvdSBqdXN0IHdhbnQgdGhlIHN0YW5kYXJkIGxpbmUgb2YgbG9nZ2luZywgY2FsbDogdGhpcy5jcmVhdGVEZWZhdWx0TG9nTWVzc2FnZShtc2cpIG9uXG4gKiB0aGlzIGNsYXNzIHdoaWNoIHdpbGwgcmV0dXJuIHlvdSB0aGUgZm9ybWF0dGVkIGxvZyBtZXNzYWdlIGFzIHN0cmluZyAoZS5nLiB0aGVcbiAqIGRlZmF1bHQgbG9nZ2VycyBhbGwgdXNlIHRoaXMpLlxuICovXG52YXIgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyKHJvb3RDYXRlZ29yeSwgcnVudGltZVNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuYWxsTWVzc2FnZXMgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5MaW5rZWRMaXN0KCk7XG4gICAgICAgIHRoaXMucm9vdENhdGVnb3J5ID0gcm9vdENhdGVnb3J5O1xuICAgICAgICB0aGlzLnJ1bnRpbWVTZXR0aW5ncyA9IHJ1bnRpbWVTZXR0aW5ncztcbiAgICB9XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUudHJhY2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuVHJhY2UsIG1zZywgbnVsbCwgZmFsc2VdLCBjYXRlZ29yaWVzLCBmYWxzZSkpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRGVidWcsIG1zZywgbnVsbCwgZmFsc2VdLCBjYXRlZ29yaWVzLCBmYWxzZSkpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW0xvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5JbmZvLCBtc2csIG51bGwsIGZhbHNlXSwgY2F0ZWdvcmllcywgZmFsc2UpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuV2FybiwgbXNnLCBudWxsLCBmYWxzZV0sIGNhdGVnb3JpZXMsIGZhbHNlKSk7XG4gICAgfTtcbiAgICBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5KFtMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRXJyb3IsIG1zZywgZXJyb3IsIGZhbHNlXSwgY2F0ZWdvcmllcywgZmFsc2UpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLmZhdGFsID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW0xvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5GYXRhbCwgbXNnLCBlcnJvciwgZmFsc2VdLCBjYXRlZ29yaWVzLCBmYWxzZSkpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUucmVzb2x2ZWQgPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yLCBtc2csIGVycm9yLCB0cnVlXSwgY2F0ZWdvcmllcywgZmFsc2UpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgbXNnLCBlcnJvcikge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbbGV2ZWwsIG1zZywgZXJyb3IsIGZhbHNlXSwgY2F0ZWdvcmllcywgZmFsc2UpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLmdldFJvb3RDYXRlZ29yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdENhdGVnb3J5O1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUuY3JlYXRlRGVmYXVsdExvZ01lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHJldHVybiBNZXNzYWdlVXRpbHNfMS5NZXNzYWdlRm9ybWF0VXRpbHMucmVuZGVyRGVmYXVsdE1lc3NhZ2UobXNnLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBvcHRpb25hbCBtZXNzYWdlIGZvcm1hdHRlci4gQWxsIExvZ2dlclR5cGVzIChleGNlcHQgY3VzdG9tKSB3aWxsIHNlZSBpZlxuICAgICAqIHRoZXkgaGF2ZSB0aGlzLCBhbmQgaWYgc28gdXNlIGl0IHRvIGxvZy5cbiAgICAgKiBAcmV0dXJucyB7KChtZXNzYWdlOkNhdGVnb3J5TG9nTWVzc2FnZSk9PnN0cmluZyl8bnVsbH1cbiAgICAgKi9cbiAgICBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyLnByb3RvdHlwZS5fZ2V0TWVzc2FnZUZvcm1hdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhdGVnb3J5U2V0dGluZ3MgPSB0aGlzLnJ1bnRpbWVTZXR0aW5ncy5nZXRDYXRlZ29yeVNldHRpbmdzKHRoaXMucm9vdENhdGVnb3J5KTtcbiAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXBwZW4gYnV0IG1ha2UgdHMgaGFwcHlcbiAgICAgICAgaWYgKGNhdGVnb3J5U2V0dGluZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpZCBub3QgZmluZCBDYXRlZ29yeVNldHRpbmdzIGZvciByb290Q2F0ZWdvcnk6IFwiICsgdGhpcy5yb290Q2F0ZWdvcnkubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhdGVnb3J5U2V0dGluZ3MuZm9ybWF0dGVyTG9nTWVzc2FnZTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLl9sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIG1zZywgZXJyb3IsIHJlc29sdmVkKSB7XG4gICAgICAgIGlmIChlcnJvciA9PT0gdm9pZCAwKSB7IGVycm9yID0gbnVsbDsgfVxuICAgICAgICBpZiAocmVzb2x2ZWQgPT09IHZvaWQgMCkgeyByZXNvbHZlZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gNF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMuX2xvZ0ludGVybmFsKGxldmVsLCAoKSA9PiBtc2csICgpID0+IGVycm9yLCByZXNvbHZlZCwgLi4uY2F0ZWdvcmllcyk7XG4gICAgICAgIHZhciBmdW5jdGlvbk1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1zZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZ1bmN0aW9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbG9nSW50ZXJuYWwuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbbGV2ZWwsIGZ1bmN0aW9uTWVzc2FnZSwgZnVuY3Rpb25FcnJvciwgcmVzb2x2ZWRdLCBjYXRlZ29yaWVzLCBmYWxzZSkpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUuX2xvZ0ludGVybmFsID0gZnVuY3Rpb24gKGxldmVsLCBtc2csIGVycm9yLCByZXNvbHZlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDQ7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9nQ2F0ZWdvcmllcyA9IFt0aGlzLnJvb3RDYXRlZ29yeV07XG4gICAgICAgIC8vIExvZyByb290IGNhdGVnb3J5IGJ5IGRlZmF1bHQgaWYgbm9uZSBwcmVzZW50XG4gICAgICAgIGlmICh0eXBlb2YgY2F0ZWdvcmllcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYXRlZ29yaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvZ0NhdGVnb3JpZXMgPSBsb2dDYXRlZ29yaWVzLmNvbmNhdChjYXRlZ29yaWVzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAhPT0gX3RoaXMucm9vdENhdGVnb3J5OyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5ID0gbG9nQ2F0ZWdvcmllc1tpXTtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYXZlIGEgbnVsbCBlbGVtZW50IHdpdGhpbiBjYXRlZ29yaWVzLCBhdCBpbmRleD1cIiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpc18xLnJ1bnRpbWVTZXR0aW5ncy5nZXRDYXRlZ29yeVNldHRpbmdzKGNhdGVnb3J5KTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhdGVnb3J5IHdpdGggcGF0aDogXCIgKyBjYXRlZ29yeS5nZXRDYXRlZ29yeVBhdGgoKSArIFwiIGlzIG5vdCByZWdpc3RlcmVkIHdpdGggdGhpcyBsb2dnZXIsIG1heWJlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ5b3UgcmVnaXN0ZXJlZCBpdCB3aXRoIGEgZGlmZmVyZW50IHJvb3QgbG9nZ2VyP1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5sb2dMZXZlbCA8PSBsZXZlbCkge1xuICAgICAgICAgICAgICAgIHZhciBhY3R1YWxFcnJvciA9IGVycm9yICE9PSBudWxsID8gZXJyb3IoKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGFjdHVhbEVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2dNZXNzYWdlID0gbmV3IENhdGVnb3J5TG9nTWVzc2FnZUltcGwobXNnKCksIGFjdHVhbEVycm9yLCBsb2dDYXRlZ29yaWVzLCBuZXcgRGF0ZSgpLCBsZXZlbCwgc2V0dGluZ3MubG9nRm9ybWF0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nTWVzc2FnZS5yZXNvbHZlZEVycm9yTWVzc2FnZSA9IHJlc29sdmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYWxsTWVzc2FnZXMuYWRkVGFpbChsb2dNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLnByb2Nlc3NNZXNzYWdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ01lc3NhZ2VfMSA9IG5ldyBDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsKG1zZygpLCBhY3R1YWxFcnJvciwgbG9nQ2F0ZWdvcmllcywgbmV3IERhdGUoKSwgbGV2ZWwsIHNldHRpbmdzLmxvZ0Zvcm1hdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBsb2dNZXNzYWdlXzEucmVzb2x2ZWRFcnJvck1lc3NhZ2UgPSByZXNvbHZlZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmFsbE1lc3NhZ2VzLmFkZFRhaWwobG9nTWVzc2FnZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZVV0aWxzXzEuTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckVycm9yKGFjdHVhbEVycm9yKS50aGVuKGZ1bmN0aW9uIChzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nTWVzc2FnZV8xLmVycm9yQXNTdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nTWVzc2FnZV8xLnNldFJlYWR5KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc01lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ01lc3NhZ2VfMS5lcnJvckFzU3RhY2sgPSBcIjxVTktOT1dOPiB1bmFibGUgdG8gZ2V0IHN0YWNrLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nTWVzc2FnZV8xLnNldFJlYWR5KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc01lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgLy8gR2V0IHRoZSBydW50aW1lIGxldmVscyBmb3IgZ2l2ZW4gY2F0ZWdvcmllcy4gSWYgdGhlaXIgbGV2ZWwgaXMgbG93ZXIgdGhhbiBnaXZlbiBsZXZlbCwgd2UgbG9nLlxuICAgICAgICAvLyBJbiBhZGRpdGlvbiB3ZSBwYXNzIGFsb25nIHdoaWNoIGNhdGVnb3J5L2NhdGVnb3JpZXMgd2UgbG9nIHRoaXMgc3RhdGVtZW50IGZvci5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dDYXRlZ29yaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEoaSk7XG4gICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyLnByb3RvdHlwZS5wcm9jZXNzTWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJhc2ljYWxseSB3ZSB3YWl0IHVudGlsIGVycm9ycyBhcmUgcmVzb2x2ZWQgKHRob3NlIG1lc3NhZ2VzXG4gICAgICAgIC8vIG1heSBub3QgYmUgcmVhZHkpLlxuICAgICAgICB2YXIgbXNncyA9IHRoaXMuYWxsTWVzc2FnZXM7XG4gICAgICAgIGlmIChtc2dzLmdldFNpemUoKSA+IDApIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gbXNncy5nZXRIZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1zZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbXNnLmlzUmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXNncy5yZW1vdmVIZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9Mb2cobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChtc2dzLmdldFNpemUoKSA+IDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcjtcbn0oKSk7XG5leHBvcnRzLkFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIgPSBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2F0ZWdvcnkgPSB2b2lkIDA7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL0xvZ2dlck9wdGlvbnNcIik7XG52YXIgQ2F0ZWdvcnlTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9DYXRlZ29yeVNlcnZpY2VcIik7XG4vKipcbiAqIENhdGVnb3J5IGZvciB1c2Ugd2l0aCBjYXRlZ29yaXplZCBsb2dnaW5nLlxuICogQXQgbWluaW11bSB5b3UgbmVlZCBvbmUgY2F0ZWdvcnksIHdoaWNoIHdpbGwgc2VydmUgYXMgdGhlIHJvb3QgY2F0ZWdvcnkuXG4gKiBZb3UgY2FuIGNyZWF0ZSBjaGlsZCBjYXRlZ29yaWVzIChsaWtlIGEgdHJlZSkuIFlvdSBjYW4gaGF2ZSBtdWx0aXBsZSByb290XG4gKiBjYXRlZ29yaWVzLlxuICovXG52YXIgQ2F0ZWdvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnkobmFtZSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yO1xuICAgICAgICBpZiAobmFtZS5pbmRleE9mKFwiI1wiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgIyBpbiBhIG5hbWUgb2YgYSBDYXRlZ29yeVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pZCA9IENhdGVnb3J5Lm5leHRJZCgpO1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLnJlZ2lzdGVyQ2F0ZWdvcnkodGhpcyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnkucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeS5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeS5wcm90b3R5cGUsIFwibG9nTGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENhdGVnb3J5LnByb3RvdHlwZS50cmFjZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRDYXRlZ29yeUxvZ2dlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLl9sb2dnZXIpLnRyYWNlLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFttc2ddLCBjYXRlZ29yaWVzLCBmYWxzZSkpO1xuICAgIH07XG4gICAgQ2F0ZWdvcnkucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZENhdGVnb3J5TG9nZ2VyKCk7XG4gICAgICAgIChfYSA9IHRoaXMuX2xvZ2dlcikuZGVidWcuYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW21zZ10sIGNhdGVnb3JpZXMsIGZhbHNlKSk7XG4gICAgfTtcbiAgICBDYXRlZ29yeS5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRDYXRlZ29yeUxvZ2dlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLl9sb2dnZXIpLmluZm8uYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW21zZ10sIGNhdGVnb3JpZXMsIGZhbHNlKSk7XG4gICAgfTtcbiAgICBDYXRlZ29yeS5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRDYXRlZ29yeUxvZ2dlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLl9sb2dnZXIpLndhcm4uYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW21zZ10sIGNhdGVnb3JpZXMsIGZhbHNlKSk7XG4gICAgfTtcbiAgICBDYXRlZ29yeS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZENhdGVnb3J5TG9nZ2VyKCk7XG4gICAgICAgIChfYSA9IHRoaXMuX2xvZ2dlcikuZXJyb3IuYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW21zZywgZXJyb3JdLCBjYXRlZ29yaWVzLCBmYWxzZSkpO1xuICAgIH07XG4gICAgQ2F0ZWdvcnkucHJvdG90eXBlLmZhdGFsID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRDYXRlZ29yeUxvZ2dlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLl9sb2dnZXIpLmZhdGFsLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFttc2csIGVycm9yXSwgY2F0ZWdvcmllcywgZmFsc2UpKTtcbiAgICB9O1xuICAgIENhdGVnb3J5LnByb3RvdHlwZS5yZXNvbHZlZCA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkQ2F0ZWdvcnlMb2dnZXIoKTtcbiAgICAgICAgKF9hID0gdGhpcy5fbG9nZ2VyKS5yZXNvbHZlZC5hcHBseShfYSwgX19zcHJlYWRBcnJheShbbXNnLCBlcnJvcl0sIGNhdGVnb3JpZXMsIGZhbHNlKSk7XG4gICAgfTtcbiAgICBDYXRlZ29yeS5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKGxldmVsLCBtc2csIGVycm9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAzXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkQ2F0ZWdvcnlMb2dnZXIoKTtcbiAgICAgICAgKF9hID0gdGhpcy5fbG9nZ2VyKS5sb2cuYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW2xldmVsLCBtc2csIGVycm9yXSwgY2F0ZWdvcmllcywgZmFsc2UpKTtcbiAgICB9O1xuICAgIENhdGVnb3J5LnByb3RvdHlwZS5nZXRDYXRlZ29yeVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLm5hbWU7XG4gICAgICAgIHZhciBjYXQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgd2hpbGUgKGNhdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYXQubmFtZSArIFwiI1wiICsgcmVzdWx0O1xuICAgICAgICAgICAgY2F0ID0gY2F0LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5LnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBpZCBmb3IgdGhpcyBjYXRlZ29yeSAodGhpc1xuICAgICAgICAgKiBpcyBmb3IgaW50ZXJuYWwgcHVycG9zZXMgb25seSkuXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IElkXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENhdGVnb3J5LnByb3RvdHlwZS5sb2FkQ2F0ZWdvcnlMb2dnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9nZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIgPSBDYXRlZ29yeVNlcnZpY2VfMS5DYXRlZ29yeVNlcnZpY2VJbXBsLmdldEluc3RhbmNlKCkuZ2V0TG9nZ2VyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fbG9nZ2VyID09PSBcInVuZGVmaW5lZFwiIHx8IHRoaXMuX2xvZ2dlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgYSBsb2dnZXIgZm9yIGNhdGVnb3J5IChzaG91bGQgbm90IGhhcHBlbik6IFwiICsgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2F0ZWdvcnkubmV4dElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQ2F0ZWdvcnkuY3VycmVudElkKys7XG4gICAgfTtcbiAgICBDYXRlZ29yeS5jdXJyZW50SWQgPSAxO1xuICAgIHJldHVybiBDYXRlZ29yeTtcbn0oKSk7XG5leHBvcnRzLkNhdGVnb3J5ID0gQ2F0ZWdvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXRlZ29yeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2F0ZWdvcnlDb25maWd1cmF0aW9uID0gdm9pZCAwO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJPcHRpb25zXCIpO1xuLyoqXG4gKiBEZWZhdWx0IGNvbmZpZ3VyYXRpb24sIGNhbiBiZSB1c2VkIHRvIGluaXRpYWxseSBzZXQgYSBkaWZmZXJlbnQgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gKiBvbiB0aGUgQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeS4gVGhpcyB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIGNhdGVnb3JpZXMgYWxyZWFkeSByZWdpc3RlcmVkIChvclxuICogcmVnaXN0ZXJlZCBpbiB0aGUgZnV0dXJlKS4gQ2FuIGFsc28gYmUgYXBwbGllZCB0byBvbmUgQ2F0ZWdvcnkgKGFuZCBjaGlsZHMpLlxuICovXG52YXIgQ2F0ZWdvcnlDb25maWd1cmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBsb2dMZXZlbCBMb2cgbGV2ZWwgZm9yIGFsbCBsb2dnZXJzLCBkZWZhdWx0IGlzIExvZ0xldmVsLkVycm9yXG4gICAgICogQHBhcmFtIGxvZ2dlclR5cGUgV2hlcmUgdG8gbG9nLCBkZWZhdWx0IGlzIExvZ2dlclR5cGUuQ29uc29sZVxuICAgICAqIEBwYXJhbSBsb2dGb3JtYXQgV2hhdCBsb2dnaW5nIGZvcm1hdCB0byB1c2UsIHVzZSBkZWZhdWx0IGluc3RhbmNlLCBmb3IgZGVmYXVsdCB2YWx1ZXMgc2VlIENhdGVnb3J5TG9nRm9ybWF0LlxuICAgICAqIEBwYXJhbSBjYWxsQmFja0xvZ2dlciBPcHRpb25hbCBjYWxsYmFjaywgaWYgTG9nZ2VyVHlwZS5DdXN0b20gaXMgdXNlZCBhcyBsb2dnZXJUeXBlLiBJbiB0aGF0IGNhc2UgbXVzdCByZXR1cm4gYSBuZXcgTG9nZ2VyIGluc3RhbmNlLlxuICAgICAqICAgICAgICAgICAgSXQgaXMgcmVjb21tZW5kZWQgdG8gZXh0ZW5kIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIgdG8gbWFrZSB5b3VyIGN1c3RvbSBsb2dnZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlDb25maWd1cmF0aW9uKGxvZ0xldmVsLCBsb2dnZXJUeXBlLCBsb2dGb3JtYXQsIGNhbGxCYWNrTG9nZ2VyKSB7XG4gICAgICAgIGlmIChsb2dMZXZlbCA9PT0gdm9pZCAwKSB7IGxvZ0xldmVsID0gTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yOyB9XG4gICAgICAgIGlmIChsb2dnZXJUeXBlID09PSB2b2lkIDApIHsgbG9nZ2VyVHlwZSA9IExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkNvbnNvbGU7IH1cbiAgICAgICAgaWYgKGxvZ0Zvcm1hdCA9PT0gdm9pZCAwKSB7IGxvZ0Zvcm1hdCA9IG5ldyBMb2dnZXJPcHRpb25zXzEuQ2F0ZWdvcnlMb2dGb3JtYXQoKTsgfVxuICAgICAgICBpZiAoY2FsbEJhY2tMb2dnZXIgPT09IHZvaWQgMCkgeyBjYWxsQmFja0xvZ2dlciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fZm9ybWF0dGVyTG9nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gbG9nTGV2ZWw7XG4gICAgICAgIHRoaXMuX2xvZ2dlclR5cGUgPSBsb2dnZXJUeXBlO1xuICAgICAgICB0aGlzLl9sb2dGb3JtYXQgPSBsb2dGb3JtYXQ7XG4gICAgICAgIHRoaXMuX2NhbGxCYWNrTG9nZ2VyID0gY2FsbEJhY2tMb2dnZXI7XG4gICAgICAgIGlmICh0aGlzLl9sb2dnZXJUeXBlID09PSBMb2dnZXJPcHRpb25zXzEuTG9nZ2VyVHlwZS5DdXN0b20gJiYgdGhpcy5jYWxsQmFja0xvZ2dlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWYgeW91IHNwZWNpZnkgbG9nZ2VyVHlwZSB0byBiZSBDdXN0b20sIHlvdSBtdXN0IHByb3ZpZGUgdGhlIGNhbGxCYWNrTG9nZ2VyIGFyZ3VtZW50XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLCBcImxvZ0xldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlDb25maWd1cmF0aW9uLnByb3RvdHlwZSwgXCJsb2dnZXJUeXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nZ2VyVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLCBcImxvZ0Zvcm1hdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0Zvcm1hdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLCBcImNhbGxCYWNrTG9nZ2VyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbEJhY2tMb2dnZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlDb25maWd1cmF0aW9uLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJMb2dNZXNzYWdlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgZm9ybWF0dGVyTG9nTWVzc2FnZSBmdW5jdGlvbiwgc2VlIGNvbW1lbnQgb24gdGhlIHNldHRlci5cbiAgICAgICAgICogQHJldHVybnMgeygobWVzc2FnZTpDYXRlZ29yeUxvZ01lc3NhZ2UpPT5zdHJpbmcpfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXR0ZXJMb2dNZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBkZWZhdWx0IGZvcm1hdHRlckxvZ01lc3NhZ2UgZnVuY3Rpb24sIGlmIHNldCBpdCBpcyBhcHBsaWVkIHRvIGFsbCB0eXBlIG9mIGxvZ2dlcnMgZXhjZXB0IGZvciBhIGN1c3RvbSBsb2dnZXIuXG4gICAgICAgICAqIEJ5IGRlZmF1bHQgdGhpcyBpcyBudWxsIChub3Qgc2V0KS4gWW91IGNhbiBhc3NpZ24gYSBmdW5jdGlvbiB0byBhbGxvdyBjdXN0b20gZm9ybWF0dGluZyBvZiBhIGxvZyBtZXNzYWdlLlxuICAgICAgICAgKiBFYWNoIGxvZyBtZXNzYWdlIHdpbGwgY2FsbCB0aGlzIGZ1bmN0aW9uIHRoZW4gYW5kIGV4cGVjdHMgeW91ciBmdW5jdGlvbiB0byBmb3JtYXQgdGhlIG1lc3NhZ2UgYW5kIHJldHVybiBhIHN0cmluZy5cbiAgICAgICAgICogV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgYXR0ZW1wdCB0byBzZXQgYSBmb3JtYXR0ZXJMb2dNZXNzYWdlIGlmIHRoZSBMb2dnZXJUeXBlIGlzIGN1c3RvbS5cbiAgICAgICAgICogQHBhcmFtIHZhbHVlIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb24sIG9yIG51bGwgdG8gcmVzZXQgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHRoaXMuX2xvZ2dlclR5cGUgPT09IExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkN1c3RvbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3Qgc3BlY2lmeSBhIGZvcm1hdHRlciBmb3IgbG9nIG1lc3NhZ2VzIGlmIHlvdXIgbG9nZ2VyVHlwZSBpcyBDdXN0b21cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9mb3JtYXR0ZXJMb2dNZXNzYWdlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDYXRlZ29yeUNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBuZXcgQ2F0ZWdvcnlDb25maWd1cmF0aW9uKHRoaXMubG9nTGV2ZWwsIHRoaXMubG9nZ2VyVHlwZSwgdGhpcy5sb2dGb3JtYXQuY29weSgpLCB0aGlzLmNhbGxCYWNrTG9nZ2VyKTtcbiAgICAgICAgY29uZmlnLmZvcm1hdHRlckxvZ01lc3NhZ2UgPSB0aGlzLmZvcm1hdHRlckxvZ01lc3NhZ2U7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcnlDb25maWd1cmF0aW9uO1xufSgpKTtcbmV4cG9ydHMuQ2F0ZWdvcnlDb25maWd1cmF0aW9uID0gQ2F0ZWdvcnlDb25maWd1cmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2F0ZWdvcnlDb25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbCA9IHZvaWQgMDtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbnZhciBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdENhdGVnb3J5TG9nZ2VyXCIpO1xuLyoqXG4gKiBTaW1wbGUgbG9nZ2VyLCB0aGF0IGxvZ3MgdG8gdGhlIGNvbnNvbGUuIElmIHRoZSBjb25zb2xlIGlzIHVuYXZhaWxhYmxlIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICovXG52YXIgQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsKHJvb3RDYXRlZ29yeSwgcnVudGltZVNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCByb290Q2F0ZWdvcnksIHJ1bnRpbWVTZXR0aW5ncykgfHwgdGhpcztcbiAgICB9XG4gICAgQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbC5wcm90b3R5cGUuZG9Mb2cgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmIChjb25zb2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRm9ybWF0dGVyID0gdGhpcy5fZ2V0TWVzc2FnZUZvcm1hdHRlcigpO1xuICAgICAgICAgICAgdmFyIGZ1bGxNc2cgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAobWVzc2FnZUZvcm1hdHRlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZ1bGxNc2cgPSB0aGlzLmNyZWF0ZURlZmF1bHRMb2dNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmdWxsTXNnID0gbWVzc2FnZUZvcm1hdHRlcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICAgICAgc3dpdGNoIChtc2cubGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5UcmFjZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgdHJ5IHRyYWNlIHdlIGRvbid0IHdhbnQgc3RhY2tzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkRlYnVnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCB0cnksIHRvbyBtdWNoIGRpZmZlcmVuY2VzIG9mIGNvbnNvbGVzLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5JbmZvOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5pbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oZnVsbE1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLldhcm46XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihmdWxsTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRXJyb3I6XG4gICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRmF0YWw6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGZ1bGxNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBsZXZlbDogXCIgKyBtc2cubGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsb2dnZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmdWxsTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uc29sZSBpcyBub3QgZGVmaW5lZCwgY2Fubm90IGxvZyBtc2c6IFwiICsgbXNnLm1lc3NhZ2VBc1N0cmluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsO1xufShBYnN0cmFjdENhdGVnb3J5TG9nZ2VyXzEuQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcikpO1xuZXhwb3J0cy5DYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsID0gQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhdGVnb3J5Q29uc29sZUxvZ2dlckltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsID0gdm9pZCAwO1xuLyoqXG4gKiBEZWxlZ2F0ZSBsb2dnZXIsIGRlbGVnYXRlcyBsb2dnaW5nIHRvIGdpdmVuIGxvZ2dlciAoY29uc3RydWN0b3IpLlxuICovXG52YXIgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwoZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsLnByb3RvdHlwZSwgXCJkZWxlZ2F0ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsLnByb3RvdHlwZS50cmFjZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9kZWxlZ2F0ZSkudHJhY2UuYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW21zZ10sIGNhdGVnb3JpZXMsIGZhbHNlKSk7XG4gICAgfTtcbiAgICBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbC5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLmRlYnVnLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFttc2ddLCBjYXRlZ29yaWVzLCBmYWxzZSkpO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLmluZm8uYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW21zZ10sIGNhdGVnb3JpZXMsIGZhbHNlKSk7XG4gICAgfTtcbiAgICBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbC5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9kZWxlZ2F0ZSkud2Fybi5hcHBseShfYSwgX19zcHJlYWRBcnJheShbbXNnXSwgY2F0ZWdvcmllcywgZmFsc2UpKTtcbiAgICB9O1xuICAgIENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLmVycm9yLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFttc2csIGVycm9yXSwgY2F0ZWdvcmllcywgZmFsc2UpKTtcbiAgICB9O1xuICAgIENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsLnByb3RvdHlwZS5mYXRhbCA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLmZhdGFsLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFttc2csIGVycm9yXSwgY2F0ZWdvcmllcywgZmFsc2UpKTtcbiAgICB9O1xuICAgIENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsLnByb3RvdHlwZS5yZXNvbHZlZCA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLnJlc29sdmVkLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFttc2csIGVycm9yXSwgY2F0ZWdvcmllcywgZmFsc2UpKTtcbiAgICB9O1xuICAgIENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9kZWxlZ2F0ZSkubG9nLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFtsZXZlbCwgbXNnLCBlcnJvcl0sIGNhdGVnb3JpZXMsIGZhbHNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGw7XG59KCkpO1xuZXhwb3J0cy5DYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbCA9IENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGwgPSB2b2lkIDA7XG52YXIgRXh0ZW5zaW9uSGVscGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZXh0ZW5zaW9uL0V4dGVuc2lvbkhlbHBlclwiKTtcbnZhciBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdENhdGVnb3J5TG9nZ2VyXCIpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgaXQgaXMgdXNlZCBmb3IgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBleHRlbnNpb24gb25seS5cbiAqL1xudmFyIENhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbChyb290Q2F0ZWdvcnksIHJ1bnRpbWVTZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgcm9vdENhdGVnb3J5LCBydW50aW1lU2V0dGluZ3MpIHx8IHRoaXM7XG4gICAgfVxuICAgIENhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbC5wcm90b3R5cGUuZG9Mb2cgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBFeHRlbnNpb25IZWxwZXJfMS5FeHRlbnNpb25IZWxwZXIuc2VuZENhdGVnb3J5TG9nTWVzc2FnZShtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ3aW5kb3cgaXMgbm90IGF2YWlsYWJsZSwgeW91IG11c3QgYmUgcnVubmluZyBpbiBhIGJyb3dzZXIgZm9yIHRoaXMuIERyb3BwZWQgbWVzc2FnZS5cIik7XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbDtcbn0oQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcl8xLkFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIpKTtcbmV4cG9ydHMuQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsID0gQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbCA9IHZvaWQgMDtcbnZhciBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdENhdGVnb3J5TG9nZ2VyXCIpO1xuLyoqXG4gKiBMb2dnZXIgd2hpY2ggYnVmZmVycyBhbGwgbWVzc2FnZXMsIHVzZSB3aXRoIGNhcmUgZHVlIHRvIHBvc3NpYmxlIGhpZ2ggbWVtb3J5IGZvb3RwcmludC5cbiAqIENhbiBiZSBjb252ZW5pZW50IGluIHNvbWUgY2FzZXMuIENhbGwgdG9TdHJpbmcoKSBmb3IgZnVsbCBvdXRwdXQsIG9yIGNhc3QgdG8gdGhpcyBjbGFzc1xuICogYW5kIGNhbGwgZ2V0TWVzc2FnZXMoKSB0byBkbyBzb21ldGhpbmcgd2l0aCBpdCB5b3Vyc2VsZi5cbiAqL1xudmFyIENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1lc3NhZ2VzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbC5wcm90b3R5cGUuZ2V0TWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLm1hcChmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbC5wcm90b3R5cGUuZG9Mb2cgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBtZXNzYWdlRm9ybWF0dGVyID0gdGhpcy5fZ2V0TWVzc2FnZUZvcm1hdHRlcigpO1xuICAgICAgICB2YXIgZnVsbE1zZztcbiAgICAgICAgaWYgKG1lc3NhZ2VGb3JtYXR0ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGZ1bGxNc2cgPSB0aGlzLmNyZWF0ZURlZmF1bHRMb2dNZXNzYWdlKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmdWxsTXNnID0gbWVzc2FnZUZvcm1hdHRlcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaChmdWxsTXNnKTtcbiAgICB9O1xuICAgIHJldHVybiBDYXRlZ29yeU1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsO1xufShBYnN0cmFjdENhdGVnb3J5TG9nZ2VyXzEuQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcikpO1xuZXhwb3J0cy5DYXRlZ29yeU1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsID0gQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhdGVnb3J5TWVzc2FnZUJ1ZmZlckltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhdGVnb3J5UnVudGltZVNldHRpbmdzID0gdm9pZCAwO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJPcHRpb25zXCIpO1xuLyoqXG4gKiBSdW50aW1lU2V0dGluZ3MgZm9yIGEgY2F0ZWdvcnksIGF0IHJ1bnRpbWUgdGhlc2UgYXJlIGFzc29jaWF0ZWQgdG8gYSBjYXRlZ29yeS5cbiAqL1xudmFyIENhdGVnb3J5UnVudGltZVNldHRpbmdzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhdGVnb3J5UnVudGltZVNldHRpbmdzKGNhdGVnb3J5LCBsb2dMZXZlbCwgbG9nZ2VyVHlwZSwgbG9nRm9ybWF0LCBjYWxsQmFja0xvZ2dlciwgZm9ybWF0dGVyTG9nTWVzc2FnZSkge1xuICAgICAgICBpZiAobG9nTGV2ZWwgPT09IHZvaWQgMCkgeyBsb2dMZXZlbCA9IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5FcnJvcjsgfVxuICAgICAgICBpZiAobG9nZ2VyVHlwZSA9PT0gdm9pZCAwKSB7IGxvZ2dlclR5cGUgPSBMb2dnZXJPcHRpb25zXzEuTG9nZ2VyVHlwZS5Db25zb2xlOyB9XG4gICAgICAgIGlmIChsb2dGb3JtYXQgPT09IHZvaWQgMCkgeyBsb2dGb3JtYXQgPSBuZXcgTG9nZ2VyT3B0aW9uc18xLkNhdGVnb3J5TG9nRm9ybWF0KCk7IH1cbiAgICAgICAgaWYgKGNhbGxCYWNrTG9nZ2VyID09PSB2b2lkIDApIHsgY2FsbEJhY2tMb2dnZXIgPSBudWxsOyB9XG4gICAgICAgIGlmIChmb3JtYXR0ZXJMb2dNZXNzYWdlID09PSB2b2lkIDApIHsgZm9ybWF0dGVyTG9nTWVzc2FnZSA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fZm9ybWF0dGVyTG9nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NhdGVnb3J5ID0gY2F0ZWdvcnk7XG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gbG9nTGV2ZWw7XG4gICAgICAgIHRoaXMuX2xvZ2dlclR5cGUgPSBsb2dnZXJUeXBlO1xuICAgICAgICB0aGlzLl9sb2dGb3JtYXQgPSBsb2dGb3JtYXQ7XG4gICAgICAgIHRoaXMuX2NhbGxCYWNrTG9nZ2VyID0gY2FsbEJhY2tMb2dnZXI7XG4gICAgICAgIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2UgPSBmb3JtYXR0ZXJMb2dNZXNzYWdlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImNhdGVnb3J5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2F0ZWdvcnk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImxvZ0xldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5UnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJsb2dnZXJUeXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nZ2VyVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlclR5cGUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeVJ1bnRpbWVTZXR0aW5ncy5wcm90b3R5cGUsIFwibG9nRm9ybWF0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nRm9ybWF0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nRm9ybWF0ID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImNhbGxCYWNrTG9nZ2VyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbEJhY2tMb2dnZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsQmFja0xvZ2dlciA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5UnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJMb2dNZXNzYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0dGVyTG9nTWVzc2FnZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBDYXRlZ29yeVJ1bnRpbWVTZXR0aW5ncztcbn0oKSk7XG5leHBvcnRzLkNhdGVnb3J5UnVudGltZVNldHRpbmdzID0gQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXRlZ29yeVJ1bnRpbWVTZXR0aW5ncy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2F0ZWdvcnlTZXJ2aWNlSW1wbCA9IHZvaWQgMDtcbnZhciBEYXRhU3RydWN0dXJlc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL0RhdGFTdHJ1Y3R1cmVzXCIpO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIENhdGVnb3J5Q29uc29sZUxvZ2dlckltcGxfMSA9IHJlcXVpcmUoXCIuL0NhdGVnb3J5Q29uc29sZUxvZ2dlckltcGxcIik7XG52YXIgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGxfMSA9IHJlcXVpcmUoXCIuL0NhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsXCIpO1xudmFyIENhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbF8xID0gcmVxdWlyZShcIi4vQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsXCIpO1xudmFyIENhdGVnb3J5TWVzc2FnZUJ1ZmZlckltcGxfMSA9IHJlcXVpcmUoXCIuL0NhdGVnb3J5TWVzc2FnZUJ1ZmZlckltcGxcIik7XG52YXIgRXh0ZW5zaW9uSGVscGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZXh0ZW5zaW9uL0V4dGVuc2lvbkhlbHBlclwiKTtcbnZhciBDYXRlZ29yeVJ1bnRpbWVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3NcIik7XG52YXIgQ2F0ZWdvcnlDb25maWd1cmF0aW9uXzEgPSByZXF1aXJlKFwiLi9DYXRlZ29yeUNvbmZpZ3VyYXRpb25cIik7XG4vKipcbiAqIFRoZSBzZXJ2aWNlIChvbmx5IGF2YWlsYWJsZSBhcyBzaW5nbGV0b24pIGZvciBhbGwgY2F0ZWdvcnkgcmVsYXRlZCBzdHVmZiBhc1xuICogcmV0cmlldmluZywgcmVnaXN0ZXJpbmcgYSBsb2dnZXIuIFlvdSBzaG91bGQgbm9ybWFsbHkgTk9UIHVzZSB0aGlzLFxuICogaW5zdGVhZCB1c2UgQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeSB3aGljaCBpcyBtZWFudCBmb3IgZW5kIHVzZXJzLlxuICovXG52YXIgQ2F0ZWdvcnlTZXJ2aWNlSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXRlZ29yeVNlcnZpY2VJbXBsKCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0Q29uZmlnID0gbmV3IENhdGVnb3J5Q29uZmlndXJhdGlvbl8xLkNhdGVnb3J5Q29uZmlndXJhdGlvbigpO1xuICAgICAgICB0aGlzLl9tYXBTdGF0ZSA9IG5ldyBEYXRhU3RydWN0dXJlc18xLlNpbXBsZU1hcCgpO1xuICAgICAgICAvLyBQcml2YXRlIGNvbnN0cnVjdG9yXG4gICAgICAgIEV4dGVuc2lvbkhlbHBlcl8xLkV4dGVuc2lvbkhlbHBlci5yZWdpc3RlcigpO1xuICAgIH1cbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBMb2FkIG9uLWRlbWFuZCwgdG8gYXNzdXJlIHdlYnBhY2sgb3JkZXJpbmcgb2YgbW9kdWxlIHVzYWdlIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIG92ZXJcbiAgICAgICAgLy8gZm9yIHVzIHdoZW4gd2UgYWNjaWRlbnRhbGx5IGNoYW5nZSB0aGUgb3JkZXIuXG4gICAgICAgIGlmIChDYXRlZ29yeVNlcnZpY2VJbXBsLl9JTlNUQU5DRSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5fSU5TVEFOQ0UgPSBuZXcgQ2F0ZWdvcnlTZXJ2aWNlSW1wbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDYXRlZ29yeVNlcnZpY2VJbXBsLl9JTlNUQU5DRTtcbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUltcGwucHJvdG90eXBlLmdldExvZ2dlciA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVPckdldENhdGVnb3J5U3RhdGUoY2F0ZWdvcnkpLmxvZ2dlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFycyBldmVyeXRoaW5nLCBpbmNsdWRpbmcgYSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24geW91IG1heSBoYXZlIHNldC5cbiAgICAgKiBBZnRlciB0aGlzIHlvdSBuZWVkIHRvIHJlLXJlZ2lzdGVyIHlvdXIgY2F0ZWdvcmllcyBldGMuXG4gICAgICovXG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21hcFN0YXRlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc2V0RGVmYXVsdENvbmZpZ3VyYXRpb24obmV3IENhdGVnb3J5Q29uZmlndXJhdGlvbl8xLkNhdGVnb3J5Q29uZmlndXJhdGlvbigpKTtcbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUltcGwucHJvdG90eXBlLmdldENhdGVnb3J5U2V0dGluZ3MgPSBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3JHZXRDYXRlZ29yeVN0YXRlKGNhdGVnb3J5KS5jdXJyZW50UnVudGltZVNldHRpbmdzO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuZ2V0T3JpZ2luYWxDYXRlZ29yeVNldHRpbmdzID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU9yR2V0Q2F0ZWdvcnlTdGF0ZShjYXRlZ29yeSkub3JpZ2luYWxSdW50aW1lU2V0dGluZ3M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbi4gTmV3IHJvb3QgbG9nZ2VycyBjcmVhdGVkIGdldCB0aGlzXG4gICAgICogYXBwbGllZC4gSWYgeW91IHdhbnQgdG8gcmVzZXQgYWxsIGN1cnJlbnQgbG9nZ2VycyB0byBoYXZlIHRoaXNcbiAgICAgKiBhcHBsaWVkIGFzIHdlbGwsIHBhc3MgaW4gcmVzZXQ9dHJ1ZSAodGhlIGRlZmF1bHQgaXMgZmFsc2UpLiBBbGxcbiAgICAgKiBjYXRlZ29yaWVzIHdpbGwgYmUgcmVzZXQgdGhlbiBhcyB3ZWxsLlxuICAgICAqIEBwYXJhbSBjb25maWcgTmV3IGNvbmZpZ1xuICAgICAqIEBwYXJhbSByZXNldCBEZWZhdWx0cyB0byB0cnVlLiBTZXQgdG8gdHJ1ZSB0byByZXNldCBhbGwgbG9nZ2VycyBhbmQgY3VycmVudCBydW50aW1lc2V0dGluZ3MuXG4gICAgICovXG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuc2V0RGVmYXVsdENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiAoY29uZmlnLCByZXNldCkge1xuICAgICAgICBpZiAocmVzZXQgPT09IHZvaWQgMCkgeyByZXNldCA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5fZGVmYXVsdENvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBTdGF0ZS5mb3JFYWNoVmFsdWUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudXBkYXRlU2V0dGluZ3MoY29uZmlnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgbmV3IGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MgZm9yIGEgY2F0ZWdvcnkgKGFuZCBwb3NzaWJseSBpdHMgY2hpbGQgY2F0ZWdvcmllcylcbiAgICAgKiBAcGFyYW0gY29uZmlnIENvbmZpZ1xuICAgICAqIEBwYXJhbSBjYXRlZ29yeSBDYXRlZ29yeVxuICAgICAqIEBwYXJhbSBhcHBseUNoaWxkcmVuIFRydWUgdG8gYXBwbHkgdG8gY2hpbGQgY2F0ZWdvcmllcywgZGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICovXG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuc2V0Q29uZmlndXJhdGlvbkNhdGVnb3J5ID0gZnVuY3Rpb24gKGNvbmZpZywgY2F0ZWdvcnksIGFwcGx5Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFwcGx5Q2hpbGRyZW4gPT09IHZvaWQgMCkgeyBhcHBseUNoaWxkcmVuID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5jcmVhdGVPckdldENhdGVnb3J5U3RhdGUoY2F0ZWdvcnkpLnVwZGF0ZVNldHRpbmdzKGNvbmZpZyk7XG4gICAgICAgIC8vIEFwcGx5IHRoZSBzZXR0aW5ncyB0byBjaGlsZHJlbiByZWN1cnNpdmUgaWYgcmVxdWVzdGVkXG4gICAgICAgIGlmIChhcHBseUNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjYXRlZ29yeS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIC8vIEZhbHNlIGZsYWcsIGEgY2hpbGQgY2Fubm90IHJlc2V0IGEgcm9vdGxvZ2dlclxuICAgICAgICAgICAgICAgIF90aGlzLnNldENvbmZpZ3VyYXRpb25DYXRlZ29yeShjb25maWcsIGNoaWxkLCBhcHBseUNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5yZWdpc3RlckNhdGVnb3J5ID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgIGlmIChjYXRlZ29yeSA9PT0gbnVsbCB8fCB0eXBlb2YgY2F0ZWdvcnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhdGVnb3J5IENBTk5PVCBiZSBudWxsL3VuZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbWFwU3RhdGUuZXhpc3RzKENhdGVnb3J5U2VydmljZUltcGwuZ2V0Q2F0ZWdvcnlLZXkoY2F0ZWdvcnkpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCB0aGlzIHJvb3QgY2F0ZWdvcnkgd2l0aCBuYW1lOiBcIiArIGNhdGVnb3J5Lm5hbWUgKyBcIiwgaXQgYWxyZWFkeSBleGlzdHMgKHNhbWUgbmFtZSBpbiBoaWVyYXJjaHkpLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWF0ZU9yR2V0Q2F0ZWdvcnlTdGF0ZShjYXRlZ29yeSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGVuYWJsZSBpbnRlZ3JhdGlvbiB3aXRoIGNocm9tZSBleHRlbnNpb24uIERvIG5vdCB1c2UgbWFudWFsbHksIHRoZVxuICAgICAqIGV4dGVuc2lvbiBhbmQgdGhlIGxvZ2dlciBmcmFtZXdvcmsgZGVhbCB3aXRoIHRoaXMuXG4gICAgICovXG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuZW5hYmxlRXh0ZW5zaW9uSW50ZWdyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX21hcFN0YXRlLmZvckVhY2hWYWx1ZShmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLmVuYWJsZUZvckV4dGVuc2lvbihfdGhpcyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFsbCByb290IGNhdGVnb3JpZXMgY3VycmVudGx5IHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuZ2V0Um9vdENhdGVnb3JpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXBTdGF0ZS52YWx1ZXMoKS5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5jYXRlZ29yeS5wYXJlbnQgPT0gbnVsbDsgfSkubWFwKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuY2F0ZWdvcnk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIENhdGVnb3J5IGJ5IGlkXG4gICAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgY2F0ZWdvcnkgdG8gZmluZFxuICAgICAqIEByZXR1cm5zIHtDYXRlZ29yeX0gb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5nZXRDYXRlZ29yeUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX21hcFN0YXRlLnZhbHVlcygpLmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLmNhdGVnb3J5LmlkID09PSBpZDsgfSkubWFwKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuY2F0ZWdvcnk7IH0pO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUltcGwucHJvdG90eXBlLmNyZWF0ZU9yR2V0Q2F0ZWdvcnlTdGF0ZSA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICB2YXIga2V5ID0gQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRDYXRlZ29yeUtleShjYXRlZ29yeSk7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX21hcFN0YXRlLmdldChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1N0YXRlID0gdGhpcy5jcmVhdGVTdGF0ZShjYXRlZ29yeSk7XG4gICAgICAgIHRoaXMuX21hcFN0YXRlLnB1dChrZXksIG5ld1N0YXRlKTtcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuY3JlYXRlU3RhdGUgPSBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBDYXRlZ29yeVN0YXRlKGNhdGVnb3J5LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fZGVmYXVsdENvbmZpZzsgfSwgZnVuY3Rpb24gKGNvbmZpZywgY2F0KSB7IHJldHVybiBfdGhpcy5jcmVhdGVMb2dnZXIoY29uZmlnLCBjYXQpOyB9KTtcbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUltcGwucHJvdG90eXBlLmNyZWF0ZUxvZ2dlciA9IGZ1bmN0aW9uIChjb25maWcsIGNhdGVnb3J5KSB7XG4gICAgICAgIC8vIERlZmF1bHQgaXMgYWx3YXlzIGEgY29uc29sZSBsb2dnZXJcbiAgICAgICAgc3dpdGNoIChjb25maWcubG9nZ2VyVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nZ2VyVHlwZS5Db25zb2xlOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbF8xLkNhdGVnb3J5Q29uc29sZUxvZ2dlckltcGwoY2F0ZWdvcnksIHRoaXMpO1xuICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nZ2VyVHlwZS5NZXNzYWdlQnVmZmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2F0ZWdvcnlNZXNzYWdlQnVmZmVySW1wbF8xLkNhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwoY2F0ZWdvcnksIHRoaXMpO1xuICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nZ2VyVHlwZS5DdXN0b206XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5jYWxsQmFja0xvZ2dlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIGN1c3RvbSBsb2dnZXIsIGN1c3RvbSBjYWxsYmFjayBpcyBudWxsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5jYWxsQmFja0xvZ2dlcihjYXRlZ29yeSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIGEgTG9nZ2VyIGZvciBMb2dnZXJUeXBlOiBcIiArIGNvbmZpZy5sb2dnZXJUeXBlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRDYXRlZ29yeUtleSA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICByZXR1cm4gY2F0ZWdvcnkuZ2V0Q2F0ZWdvcnlQYXRoKCk7XG4gICAgfTtcbiAgICAvLyBTaW5nbGV0b24gY2F0ZWdvcnkgc2VydmljZSwgdXNlZCBieSBDYXRlZ29yeVNlcnZpY2VGYWN0b3J5IGFzIHdlbGwgYXMgQ2F0ZWdvcmllcy5cbiAgICAvLyBMb2FkZWQgb24gZGVtYW5kLiBEbyBOT1QgY2hhbmdlIGFzIHdlYnBhY2sgbWF5IHBhY2sgdGhpbmdzIGluIHdyb25nIG9yZGVyIG90aGVyd2lzZS5cbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLl9JTlNUQU5DRSA9IG51bGw7XG4gICAgcmV0dXJuIENhdGVnb3J5U2VydmljZUltcGw7XG59KCkpO1xuZXhwb3J0cy5DYXRlZ29yeVNlcnZpY2VJbXBsID0gQ2F0ZWdvcnlTZXJ2aWNlSW1wbDtcbnZhciBDYXRlZ29yeVN0YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhdGVnb3J5U3RhdGUoY2F0ZWdvcnksIGRlZmF1bHRDb25maWcsIGNyZWF0ZUxvZ2dlcikge1xuICAgICAgICB0aGlzLl9jYXRlZ29yeSA9IGNhdGVnb3J5O1xuICAgICAgICB0aGlzLl9sYXp5U3RhdGUgPSBuZXcgTGF6eVN0YXRlKGNhdGVnb3J5LCBkZWZhdWx0Q29uZmlnLCBjcmVhdGVMb2dnZXIpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlTdGF0ZS5wcm90b3R5cGUsIFwiY2F0ZWdvcnlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXRlZ29yeTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeVN0YXRlLnByb3RvdHlwZSwgXCJsb2dnZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXp5U3RhdGUuZ2V0TG9nZ2VyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlTdGF0ZS5wcm90b3R5cGUsIFwib3JpZ2luYWxSdW50aW1lU2V0dGluZ3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXp5U3RhdGUuZ2V0T3JpZ2luYWxSdW50aW1lU2V0dGluZ3MoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeVN0YXRlLnByb3RvdHlwZSwgXCJjdXJyZW50UnVudGltZVNldHRpbmdzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF6eVN0YXRlLmdldEN1cnJlbnRSdW50aW1lU2V0dGluZ3MoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENhdGVnb3J5U3RhdGUucHJvdG90eXBlLmVuYWJsZUZvckV4dGVuc2lvbiA9IGZ1bmN0aW9uIChydW50aW1lU2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fbGF6eVN0YXRlLmVuYWJsZUZvckV4dGVuc2lvbihydW50aW1lU2V0dGluZ3MpO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTdGF0ZS5wcm90b3R5cGUudXBkYXRlU2V0dGluZ3MgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2xhenlTdGF0ZS51cGRhdGVTZXR0aW5ncyhjb25maWcpO1xuICAgIH07XG4gICAgcmV0dXJuIENhdGVnb3J5U3RhdGU7XG59KCkpO1xudmFyIExhenlTdGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXp5U3RhdGUoY2F0ZWdvcnksIGRlZmF1bHRDb25maWcsIGNyZWF0ZUxvZ2dlcikge1xuICAgICAgICB0aGlzLl9jYXRlZ29yeSA9IGNhdGVnb3J5O1xuICAgICAgICB0aGlzLl9kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgICAgICAgdGhpcy5fY3JlYXRlTG9nZ2VyID0gY3JlYXRlTG9nZ2VyO1xuICAgIH1cbiAgICBMYXp5U3RhdGUucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB0aGlzLl9sb2dnZXIgIT09IFwidW5kZWZpbmVkXCIpO1xuICAgIH07XG4gICAgTGF6eVN0YXRlLnByb3RvdHlwZS5nZXRMb2dnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9hZExvZ2dlck9uRGVtYW5kKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZUxvZ2dlcjtcbiAgICB9O1xuICAgIExhenlTdGF0ZS5wcm90b3R5cGUuZ2V0T3JpZ2luYWxSdW50aW1lU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9hZExvZ2dlck9uRGVtYW5kKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbFJ1bnRpbWVTZXR0aW5ncztcbiAgICB9O1xuICAgIExhenlTdGF0ZS5wcm90b3R5cGUuZ2V0Q3VycmVudFJ1bnRpbWVTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2FkTG9nZ2VyT25EZW1hbmQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRSdW50aW1lU2V0dGluZ3M7XG4gICAgfTtcbiAgICBMYXp5U3RhdGUucHJvdG90eXBlLmVuYWJsZUZvckV4dGVuc2lvbiA9IGZ1bmN0aW9uIChydW50aW1lU2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5sb2FkTG9nZ2VyT25EZW1hbmQoKTtcbiAgICAgICAgaWYgKCEodGhpcy5fd3JhcHBlZExvZ2dlciBpbnN0YW5jZW9mIENhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbF8xLkNhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbCkpIHtcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVjb25maWd1cmluZyBsb2dnZXIgZm9yIGV4dGVuc2lvbiBmb3IgY2F0ZWdvcnk6IFwiICsgdGhpcy5fY2F0ZWdvcnkubmFtZSk7XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZWRMb2dnZXIgPSBuZXcgQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsXzEuQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsKHRoaXMuX2NhdGVnb3J5LCBydW50aW1lU2V0dGluZ3MpO1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGVMb2dnZXIuZGVsZWdhdGUgPSB0aGlzLl93cmFwcGVkTG9nZ2VyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXp5U3RhdGUucHJvdG90eXBlLnVwZGF0ZVNldHRpbmdzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBpZiAodGhpcy5pc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UnVudGltZVNldHRpbmdzLmxvZ0xldmVsID0gY29uZmlnLmxvZ0xldmVsO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJ1bnRpbWVTZXR0aW5ncy5sb2dnZXJUeXBlID0gY29uZmlnLmxvZ2dlclR5cGU7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UnVudGltZVNldHRpbmdzLmxvZ0Zvcm1hdCA9IGNvbmZpZy5sb2dGb3JtYXQ7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UnVudGltZVNldHRpbmdzLmNhbGxCYWNrTG9nZ2VyID0gY29uZmlnLmNhbGxCYWNrTG9nZ2VyO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJ1bnRpbWVTZXR0aW5ncy5mb3JtYXR0ZXJMb2dNZXNzYWdlID0gY29uZmlnLmZvcm1hdHRlckxvZ01lc3NhZ2U7XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSByZWFsIGxvZ2dlciwgaXQgbWF5IGhhdmUgY2hhbmdlZC5cbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlciA9IHRoaXMuX2NyZWF0ZUxvZ2dlcihjb25maWcsIHRoaXMuX2NhdGVnb3J5KTtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3dyYXBwZWRMb2dnZXIgaW5zdGFuY2VvZiBDYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGxfMS5DYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3JhcHBlZExvZ2dlciA9IHRoaXMuX2xvZ2dlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlTG9nZ2VyLmRlbGVnYXRlID0gdGhpcy5fd3JhcHBlZExvZ2dlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGlzIGNvbmZpZywgaXQgbWF5IGJlIGZvciB0aGUgY2F0ZWdvcnkgc3BlY2lmaWMsIHRoZSBkZWZhdWx0IGlzIHRoZXJlZm9yZSBub3QgZ29vZCBlbm91Z2guXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0Q29uZmlnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXp5U3RhdGUucHJvdG90eXBlLmxvYWRMb2dnZXJPbkRlbWFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9hZGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlciA9IHRoaXMuX2NyZWF0ZUxvZ2dlcih0aGlzLl9kZWZhdWx0Q29uZmlnKCksIHRoaXMuX2NhdGVnb3J5KTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZWRMb2dnZXIgPSB0aGlzLl9sb2dnZXI7XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZUxvZ2dlciA9IG5ldyBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbF8xLkNhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsKHRoaXMuX3dyYXBwZWRMb2dnZXIpO1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxSdW50aW1lU2V0dGluZ3MgPSB0aGlzLmluaXROZXdTZXR0aW5ncygpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJ1bnRpbWVTZXR0aW5ncyA9IHRoaXMuaW5pdE5ld1NldHRpbmdzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExhenlTdGF0ZS5wcm90b3R5cGUuaW5pdE5ld1NldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVmU2V0dGluZ3MgPSB0aGlzLl9kZWZhdWx0Q29uZmlnKCkuY29weSgpO1xuICAgICAgICByZXR1cm4gbmV3IENhdGVnb3J5UnVudGltZVNldHRpbmdzXzEuQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3ModGhpcy5fY2F0ZWdvcnksIGRlZlNldHRpbmdzLmxvZ0xldmVsLCBkZWZTZXR0aW5ncy5sb2dnZXJUeXBlLCBkZWZTZXR0aW5ncy5sb2dGb3JtYXQsIGRlZlNldHRpbmdzLmNhbGxCYWNrTG9nZ2VyLCBkZWZTZXR0aW5ncy5mb3JtYXR0ZXJMb2dNZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBMYXp5U3RhdGU7XG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2F0ZWdvcnlTZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYXRlZ29yeVNlcnZpY2VGYWN0b3J5ID0gdm9pZCAwO1xudmFyIENhdGVnb3J5U2VydmljZV8xID0gcmVxdWlyZShcIi4vQ2F0ZWdvcnlTZXJ2aWNlXCIpO1xuLyoqXG4gKiBDYXRlZ29yaXplZCBzZXJ2aWNlIGZvciBsb2dnaW5nLCB3aGVyZSBsb2dnaW5nIGlzIGJvdW5kIHRvIGNhdGVnb3JpZXMgd2hpY2hcbiAqIGNhbiBsb2cgaG9yaXpvbnRhbGx5IHRocm91Z2ggc3BlY2lmaWMgYXBwbGljYXRpb24gbG9naWMgKHNlcnZpY2VzLCBncm91cChzKSBvZiBjb21wb25lbnRzIGV0YykuXG4gKiBGb3IgdGhlIHN0YW5kYXJkIHdheSBvZiBsb2dnaW5nIGxpa2UgbW9zdCBmcmFtZXdvcmtzIGRvIHRoZXNlIGRheXMsIHVzZSBMRlNlcnZpY2UgaW5zdGVhZC5cbiAqIElmIHlvdSB3YW50IGZpbmUgZ3JhaW5lZCBjb250cm9sIHRvIGRpdmlkZSBzZWN0aW9ucyBvZiB5b3VyIGFwcGxpY2F0aW9uIGluXG4gKiBsb2dpY2FsIHVuaXRzIHRvIGVuYWJsZS9kaXNhYmxlIGxvZ2dpbmcgZm9yLCB0aGlzIGlzIHRoZSBzZXJ2aWNlIHlvdSB3YW50IHRvIHVzZSBpbnN0ZWFkLlxuICogQWxzbyBmb3IgdGhpcyB0eXBlIGEgYnJvd3NlciBwbHVnaW4gd2lsbCBiZSBhdmFpbGFibGUuXG4gKi9cbnZhciBDYXRlZ29yeVNlcnZpY2VGYWN0b3J5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhdGVnb3J5U2VydmljZUZhY3RvcnkoKSB7XG4gICAgICAgIC8vIFByaXZhdGUgY29uc3RydWN0b3IuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIENhdGVnb3J5TG9nZ2VyIGZvciBnaXZlbiBST09UIGNhdGVnb3J5ICh0aHVzIGhhcyBubyBwYXJlbnQpLlxuICAgICAqIFlvdSBjYW4gb25seSByZXRyaWV2ZSBsb2dnZXJzIGZvciB0aGVpciByb290LCB3aGVuIGxvZ2dpbmdcbiAgICAgKiB5b3Ugc3BlY2lmeSB0byBsb2cgZm9yIHdoYXQgKGNoaWxkKWNhdGVnb3JpZXMuXG4gICAgICogQHBhcmFtIHJvb3QgQ2F0ZWdvcnkgcm9vdCAoaGFzIG5vIHBhcmVudClcbiAgICAgKiBAcmV0dXJucyB7Q2F0ZWdvcnlMb2dnZXJ9XG4gICAgICovXG4gICAgQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeS5nZXRMb2dnZXIgPSBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICByZXR1cm4gQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLmdldExvZ2dlcihyb290KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFycyBldmVyeXRoaW5nLCBhbnkgcmVnaXN0ZXJlZCAocm9vdCljYXRlZ29yaWVzIGFuZCBsb2dnZXJzXG4gICAgICogYXJlIGRpc2NhcmRlZC4gUmVzZXRzIHRvIGRlZmF1bHQgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBDYXRlZ29yeVNlcnZpY2VGYWN0b3J5LmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLmNsZWFyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbi4gTmV3IHJvb3QgbG9nZ2VycyBjcmVhdGVkIGdldCB0aGlzXG4gICAgICogYXBwbGllZC4gSWYgeW91IHdhbnQgdG8gcmVzZXQgYWxsIGN1cnJlbnQgbG9nZ2VycyB0byBoYXZlIHRoaXNcbiAgICAgKiBhcHBsaWVkIGFzIHdlbGwsIHBhc3MgaW4gcmVzZXQ9dHJ1ZSAodGhlIGRlZmF1bHQgaXMgZmFsc2UpLiBBbGxcbiAgICAgKiBjYXRlZ29yaWVzIHJ1bnRpbWVzZXR0aW5ncyB3aWxsIGJlIHJlc2V0IHRoZW4gYXMgd2VsbC5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBuZXcgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHJlc2V0IElmIHRydWUsIHdpbGwgcmVzZXQgKmFsbCogcnVudGltZXNldHRpbmdzIGZvciBhbGwgbG9nZ2Vycy9jYXRlZ29yaWVzIHRvIHRoZXNlLiBEZWZhdWx0IGlzIHRydWUuXG4gICAgICovXG4gICAgQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeS5zZXREZWZhdWx0Q29uZmlndXJhdGlvbiA9IGZ1bmN0aW9uIChjb25maWcsIHJlc2V0KSB7XG4gICAgICAgIGlmIChyZXNldCA9PT0gdm9pZCAwKSB7IHJlc2V0ID0gdHJ1ZTsgfVxuICAgICAgICBDYXRlZ29yeVNlcnZpY2VfMS5DYXRlZ29yeVNlcnZpY2VJbXBsLmdldEluc3RhbmNlKCkuc2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oY29uZmlnLCByZXNldCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgbmV3IGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MgZm9yIGEgY2F0ZWdvcnkgKGFuZCBwb3NzaWJseSBpdHMgY2hpbGQgY2F0ZWdvcmllcylcbiAgICAgKiBAcGFyYW0gY29uZmlnIENvbmZpZ1xuICAgICAqIEBwYXJhbSBjYXRlZ29yeSBDYXRlZ29yeVxuICAgICAqIEBwYXJhbSBhcHBseUNoaWxkcmVuIFRydWUgdG8gYXBwbHkgdG8gY2hpbGQgY2F0ZWdvcmllcywgZGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICovXG4gICAgQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeS5zZXRDb25maWd1cmF0aW9uQ2F0ZWdvcnkgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXRlZ29yeSwgYXBwbHlDaGlsZHJlbikge1xuICAgICAgICBpZiAoYXBwbHlDaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGFwcGx5Q2hpbGRyZW4gPSBmYWxzZTsgfVxuICAgICAgICBDYXRlZ29yeVNlcnZpY2VfMS5DYXRlZ29yeVNlcnZpY2VJbXBsLmdldEluc3RhbmNlKCkuc2V0Q29uZmlndXJhdGlvbkNhdGVnb3J5KGNvbmZpZywgY2F0ZWdvcnksIGFwcGx5Q2hpbGRyZW4pO1xuICAgIH07XG4gICAgcmV0dXJuIENhdGVnb3J5U2VydmljZUZhY3Rvcnk7XG59KCkpO1xuZXhwb3J0cy5DYXRlZ29yeVNlcnZpY2VGYWN0b3J5ID0gQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhdGVnb3J5U2VydmljZUZhY3RvcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFic3RyYWN0TG9nZ2VyID0gdm9pZCAwO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIERhdGFTdHJ1Y3R1cmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvRGF0YVN0cnVjdHVyZXNcIik7XG52YXIgTWVzc2FnZVV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvTWVzc2FnZVV0aWxzXCIpO1xudmFyIExvZ01lc3NhZ2VJbnRlcm5hbEltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9nTWVzc2FnZUludGVybmFsSW1wbChsb2dnZXJOYW1lLCBtZXNzYWdlLCBlcnJvckFzU3RhY2ssIGVycm9yLCBsb2dHcm91cFJ1bGUsIGRhdGUsIGxldmVsLCByZWFkeSkge1xuICAgICAgICB0aGlzLl9lcnJvckFzU3RhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvZ2dlck5hbWUgPSBsb2dnZXJOYW1lO1xuICAgICAgICB0aGlzLl9tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5fZXJyb3JBc1N0YWNrID0gZXJyb3JBc1N0YWNrO1xuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9sb2dHcm91cFJ1bGUgPSBsb2dHcm91cFJ1bGU7XG4gICAgICAgIHRoaXMuX2RhdGUgPSBkYXRlO1xuICAgICAgICB0aGlzLl9sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLl9yZWFkeSA9IHJlYWR5O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwibG9nZ2VyTmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2dlck5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwiZXJyb3JBc1N0YWNrXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3JBc1N0YWNrO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JBc1N0YWNrID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwiZXJyb3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwibG9nR3JvdXBSdWxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nR3JvdXBSdWxlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nR3JvdXBSdWxlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwiZGF0ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwibGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xldmVsID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwiaXNNZXNzYWdlTG9nRGF0YVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiAodGhpcy5fbWVzc2FnZSkgIT09IFwic3RyaW5nXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwicmVhZHlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkeTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5ID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwibWVzc2FnZUFzU3RyaW5nXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLl9tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2UubXNnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ01lc3NhZ2VJbnRlcm5hbEltcGwucHJvdG90eXBlLCBcImxvZ0RhdGFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5fbWVzc2FnZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIExvZ01lc3NhZ2VJbnRlcm5hbEltcGw7XG59KCkpO1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGxvZ2dlciwgZXh0ZW5kIHRvIGVhc2lseSBpbXBsZW1lbnQgYSBjdXN0b20gbG9nZ2VyIHRoYXRcbiAqIGxvZ3Mgd2hlcmV2ZXIgeW91IHdhbnQuIFlvdSBvbmx5IG5lZWQgdG8gaW1wbGVtZW50IGRvTG9nKG1zZzogTG9nTWVzc2FnZSkgYW5kXG4gKiBsb2cgdGhhdCBzb21ld2hlcmUgKGl0IHdpbGwgY29udGFpbiBmb3JtYXQgYW5kIGV2ZXJ5dGhpbmcgZWxzZSkuXG4gKi9cbnZhciBBYnN0cmFjdExvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdExvZ2dlcihuYW1lLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9hbGxNZXNzYWdlcyA9IG5ldyBEYXRhU3RydWN0dXJlc18xLkxpbmtlZExpc3QoKTtcbiAgICAgICAgdGhpcy5fb3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyA9IGxvZ0dyb3VwUnVudGltZVNldHRpbmdzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yID09PSB2b2lkIDApIHsgZXJyb3IgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuVHJhY2UsIG1zZywgZXJyb3IpO1xuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yID09PSB2b2lkIDApIHsgZXJyb3IgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRGVidWcsIG1zZywgZXJyb3IpO1xuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLmluZm8gPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5JbmZvLCBtc2csIGVycm9yKTtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yID09PSB2b2lkIDApIHsgZXJyb3IgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuV2FybiwgbXNnLCBlcnJvcik7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5FcnJvciwgbXNnLCBlcnJvcik7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuZmF0YWwgPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5GYXRhbCwgbXNnLCBlcnJvcik7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuaXNUcmFjZUVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sZXZlbCA9PT0gTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLlRyYWNlO1xuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLmlzRGVidWdFbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MubGV2ZWwgPD0gTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkRlYnVnO1xuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLmlzSW5mb0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sZXZlbCA8PSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuSW5mbztcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5pc1dhcm5FbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MubGV2ZWwgPD0gTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLldhcm47XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuaXNFcnJvckVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sZXZlbCA8PSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRXJyb3I7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuaXNGYXRhbEVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sZXZlbCA8PSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRmF0YWw7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuZ2V0TG9nTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sZXZlbDtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2FsbE1lc3NhZ2VzLmNsZWFyKCk7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuY3JlYXRlRGVmYXVsdExvZ01lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHJldHVybiBNZXNzYWdlVXRpbHNfMS5NZXNzYWdlRm9ybWF0VXRpbHMucmVuZGVyRGVmYXVsdExvZzRqTWVzc2FnZShtc2csIHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIG9wdGlvbmFsIG1lc3NhZ2UgZm9ybWF0dGVyLiBBbGwgTG9nZ2VyVHlwZXMgKGV4Y2VwdCBjdXN0b20pIHdpbGwgc2VlIGlmXG4gICAgICogdGhleSBoYXZlIHRoaXMsIGFuZCBpZiBzbyB1c2UgaXQgdG8gbG9nLlxuICAgICAqIEByZXR1cm5zIHsoKG1lc3NhZ2U6TG9nTWVzc2FnZSk9PnN0cmluZyl8bnVsbH1cbiAgICAgKi9cbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuX2dldE1lc3NhZ2VGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5mb3JtYXR0ZXJMb2dNZXNzYWdlO1xuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLl9sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIG1zZywgZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yID09PSB2b2lkIDApIHsgZXJyb3IgPSBudWxsOyB9XG4gICAgICAgIGlmICh0aGlzLl9vcGVuICYmIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzLmxldmVsIDw9IGxldmVsKSB7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25NZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbXNnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1zZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbkVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2FsbE1lc3NhZ2VzLmFkZFRhaWwodGhpcy5jcmVhdGVNZXNzYWdlKGxldmVsLCBmdW5jdGlvbk1lc3NhZ2UsIGZ1bmN0aW9uRXJyb3IsIG5ldyBEYXRlKCkpKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc01lc3NhZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5jcmVhdGVNZXNzYWdlID0gZnVuY3Rpb24gKGxldmVsLCBtc2csIGVycm9yLCBkYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlcnJvclJlc3VsdCA9IGVycm9yKCk7XG4gICAgICAgIGlmIChlcnJvclJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VfMSA9IG5ldyBMb2dNZXNzYWdlSW50ZXJuYWxJbXBsKHRoaXMuX25hbWUsIG1zZygpLCBudWxsLCBlcnJvclJlc3VsdCwgdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MubG9nR3JvdXBSdWxlLCBkYXRlLCBsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgICAgTWVzc2FnZVV0aWxzXzEuTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckVycm9yKGVycm9yUmVzdWx0KS50aGVuKGZ1bmN0aW9uIChzdGFjaykge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VfMS5lcnJvckFzU3RhY2sgPSBzdGFjaztcbiAgICAgICAgICAgICAgICBtZXNzYWdlXzEucmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLnByb2Nlc3NNZXNzYWdlcygpO1xuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VfMS5lcnJvckFzU3RhY2sgPSBcIjxVTktOT1dOPiB1bmFibGUgdG8gZ2V0IHN0YWNrLlwiO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VfMS5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc01lc3NhZ2VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlXzE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMb2dNZXNzYWdlSW50ZXJuYWxJbXBsKHRoaXMuX25hbWUsIG1zZygpLCBudWxsLCBlcnJvclJlc3VsdCwgdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MubG9nR3JvdXBSdWxlLCBkYXRlLCBsZXZlbCwgdHJ1ZSk7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUucHJvY2Vzc01lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBCYXNpY2FsbHkgd2Ugd2FpdCB1bnRpbCBlcnJvcnMgYXJlIHJlc29sdmVkICh0aG9zZSBtZXNzYWdlc1xuICAgICAgICAvLyBtYXkgbm90IGJlIHJlYWR5KS5cbiAgICAgICAgdmFyIG1zZ3MgPSB0aGlzLl9hbGxNZXNzYWdlcztcbiAgICAgICAgaWYgKG1zZ3MuZ2V0U2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSBtc2dzLmdldEhlYWQoKTtcbiAgICAgICAgICAgICAgICBpZiAobXNnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtc2cucmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1zZ3MucmVtb3ZlSGVhZCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBuZXZlciBiZSBudWxsIG5vcm1hbGx5LCBidXQgc3RyaWN0IG51bGwgY2hlY2tpbmcgLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmIChtc2cubWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb0xvZyhtc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAobXNncy5nZXRTaXplKCkgPiAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0TG9nZ2VyO1xufSgpKTtcbmV4cG9ydHMuQWJzdHJhY3RMb2dnZXIgPSBBYnN0cmFjdExvZ2dlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFic3RyYWN0TG9nZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29uc29sZUxvZ2dlckltcGwgPSB2b2lkIDA7XG52YXIgQWJzdHJhY3RMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TG9nZ2VyXCIpO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJPcHRpb25zXCIpO1xuLyoqXG4gKiBTaW1wbGUgbG9nZ2VyLCB0aGF0IGxvZ3MgdG8gdGhlIGNvbnNvbGUuIElmIHRoZSBjb25zb2xlIGlzIHVuYXZhaWxhYmxlIHdpbGwgdGhyb3cgZXhjZXB0aW9uLlxuICovXG52YXIgQ29uc29sZUxvZ2dlckltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnNvbGVMb2dnZXJJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnNvbGVMb2dnZXJJbXBsKG5hbWUsIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncykgfHwgdGhpcztcbiAgICB9XG4gICAgQ29uc29sZUxvZ2dlckltcGwucHJvdG90eXBlLmRvTG9nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGxvZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGxvZ0xldmVsID0gbWVzc2FnZS5sZXZlbDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRm9ybWF0dGVyID0gdGhpcy5fZ2V0TWVzc2FnZUZvcm1hdHRlcigpO1xuICAgICAgICAgICAgdmFyIG1zZyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlRm9ybWF0dGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbXNnID0gdGhpcy5jcmVhdGVEZWZhdWx0TG9nTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgICAgICBzd2l0Y2ggKGxvZ0xldmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuVHJhY2U6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cnkgdHJhY2Ugd2UgZG9uJ3Qgd2FudCBhIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkRlYnVnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCB0cnksIHRvbyBtdWNoIGRpZmZlcmVuY2VzIG9mIGNvbnNvbGVzLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5JbmZvOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5pbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8obXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuV2FybjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yOlxuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkZhdGFsOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2cgbGV2ZWwgbm90IHN1cHBvcnRlZDogXCIgKyBsb2dMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxvZ2dlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnNvbGUgaXMgbm90IGRlZmluZWQsIGNhbm5vdCBsb2cgbXNnOiBcIiArIG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb25zb2xlTG9nZ2VySW1wbDtcbn0oQWJzdHJhY3RMb2dnZXJfMS5BYnN0cmFjdExvZ2dlcikpO1xuZXhwb3J0cy5Db25zb2xlTG9nZ2VySW1wbCA9IENvbnNvbGVMb2dnZXJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29uc29sZUxvZ2dlckltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxGU2VydmljZSA9IHZvaWQgMDtcbnZhciBEYXRhU3RydWN0dXJlc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL0RhdGFTdHJ1Y3R1cmVzXCIpO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIExvZ2dlckZhY3RvcnlJbXBsXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJGYWN0b3J5SW1wbFwiKTtcbnZhciBFeHRlbnNpb25IZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9leHRlbnNpb24vRXh0ZW5zaW9uSGVscGVyXCIpO1xudmFyIExvZ0dyb3VwUnVsZV8xID0gcmVxdWlyZShcIi4vTG9nR3JvdXBSdWxlXCIpO1xudmFyIExvZ2dlckZhY3RvcnlPcHRpb25zXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJGYWN0b3J5T3B0aW9uc1wiKTtcbnZhciBMRlNlcnZpY2VJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExGU2VydmljZUltcGwoKSB7XG4gICAgICAgIC8vIFByaXZhdGUgY29uc3RydWN0b3IuXG4gICAgICAgIHRoaXMuX25hbWVDb3VudGVyID0gMTtcbiAgICAgICAgdGhpcy5fbWFwRmFjdG9yaWVzID0gbmV3IERhdGFTdHJ1Y3R1cmVzXzEuU2ltcGxlTWFwKCk7XG4gICAgICAgIEV4dGVuc2lvbkhlbHBlcl8xLkV4dGVuc2lvbkhlbHBlci5yZWdpc3RlcigpO1xuICAgIH1cbiAgICBMRlNlcnZpY2VJbXBsLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBMb2FkZWQgb24gZGVtYW5kLiBEbyBOT1QgY2hhbmdlIGFzIHdlYnBhY2sgbWF5IHBhY2sgdGhpbmdzIGluIHdyb25nIG9yZGVyIG90aGVyd2lzZS5cbiAgICAgICAgaWYgKExGU2VydmljZUltcGwuX0lOU1RBTkNFID09PSBudWxsKSB7XG4gICAgICAgICAgICBMRlNlcnZpY2VJbXBsLl9JTlNUQU5DRSA9IG5ldyBMRlNlcnZpY2VJbXBsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIExGU2VydmljZUltcGwuX0lOU1RBTkNFO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IExvZ2dlckZhY3Rvcnkgd2l0aCBnaXZlbiBvcHRpb25zIChpZiBhbnkpLiBJZiBubyBvcHRpb25zXG4gICAgICogYXJlIHNwZWNpZmllZCwgdGhlIExvZ2dlckZhY3RvcnksIHdpbGwgYWNjZXB0IGFueSBuYW1lZCBsb2dnZXIgYW5kIHdpbGxcbiAgICAgKiBsb2cgb24gaW5mbyBsZXZlbCBieSBkZWZhdWx0IGZvciwgdG8gdGhlIGNvbnNvbGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucywgb3B0aW9uYWwuXG4gICAgICogQHJldHVybnMge0xvZ2dlckZhY3Rvcnl9XG4gICAgICovXG4gICAgTEZTZXJ2aWNlSW1wbC5wcm90b3R5cGUuY3JlYXRlTG9nZ2VyRmFjdG9yeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG51bGw7IH1cbiAgICAgICAgdmFyIG5hbWUgPSBcIkxvZ2dlckZhY3RvcnlcIiArIHRoaXMuX25hbWVDb3VudGVyKys7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU5hbWVkTG9nZ2VyRmFjdG9yeShuYW1lLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBMb2dnZXJGYWN0b3J5IHVzaW5nIGdpdmVuIG5hbWUgKHVzZWQgZm9yIGNvbnNvbGUgYXBpL2V4dGVuc2lvbikuXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBQaWNrIHNvbWV0aGluZyBzaG9ydCBidXQgZGlzdGluZ3Vpc2hhYmxlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMsIG9wdGlvbmFsXG4gICAgICogQHJldHVybiB7TG9nZ2VyRmFjdG9yeX1cbiAgICAgKi9cbiAgICBMRlNlcnZpY2VJbXBsLnByb3RvdHlwZS5jcmVhdGVOYW1lZExvZ2dlckZhY3RvcnkgPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgICAgIGlmICh0aGlzLl9tYXBGYWN0b3JpZXMuZXhpc3RzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2dnZXJGYWN0b3J5IHdpdGggbmFtZSBcIiArIG5hbWUgKyBcIiBhbHJlYWR5IGV4aXN0cy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZhY3Rvcnk7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gbmV3IExvZ2dlckZhY3RvcnlJbXBsXzEuTG9nZ2VyRmFjdG9yeUltcGwobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gbmV3IExvZ2dlckZhY3RvcnlJbXBsXzEuTG9nZ2VyRmFjdG9yeUltcGwobmFtZSwgTEZTZXJ2aWNlSW1wbC5jcmVhdGVEZWZhdWx0T3B0aW9ucygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXBGYWN0b3JpZXMucHV0KG5hbWUsIGZhY3RvcnkpO1xuICAgICAgICByZXR1cm4gZmFjdG9yeTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsb3NlcyBhbGwgTG9nZ2VycyBmb3IgTG9nZ2VyRmFjdG9yaWVzIHRoYXQgd2VyZSBjcmVhdGVkLlxuICAgICAqIEFmdGVyIHRoaXMgY2FsbCwgYWxsIHByZXZpb3VzbHkgZmV0Y2hlZCBMb2dnZXJzIChmcm9tIHRoZWlyXG4gICAgICogZmFjdG9yaWVzKSBhcmUgdW51c2FibGUuIFRoZSBmYWN0b3JpZXMgcmVtYWluIGFzIHRoZXkgd2VyZS5cbiAgICAgKi9cbiAgICBMRlNlcnZpY2VJbXBsLnByb3RvdHlwZS5jbG9zZUxvZ2dlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21hcEZhY3Rvcmllcy52YWx1ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgICAgICAgICBmYWN0b3J5LmNsb3NlTG9nZ2VycygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbWFwRmFjdG9yaWVzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX25hbWVDb3VudGVyID0gMTtcbiAgICB9O1xuICAgIExGU2VydmljZUltcGwucHJvdG90eXBlLmdldFJ1bnRpbWVTZXR0aW5nc0ZvckxvZ2dlckZhY3RvcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLl9tYXBGYWN0b3JpZXMuZm9yRWFjaFZhbHVlKGZ1bmN0aW9uIChmYWN0b3J5KSB7IHJldHVybiByZXN1bHQucHVzaChmYWN0b3J5KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBMRlNlcnZpY2VJbXBsLnByb3RvdHlwZS5nZXRMb2dHcm91cFNldHRpbmdzID0gZnVuY3Rpb24gKG5hbWVMb2dnZXJGYWN0b3J5LCBpZExvZ0dyb3VwUnVsZSkge1xuICAgICAgICB2YXIgZmFjdG9yeSA9IHRoaXMuX21hcEZhY3Rvcmllcy5nZXQobmFtZUxvZ2dlckZhY3RvcnkpO1xuICAgICAgICBpZiAodHlwZW9mIGZhY3RvcnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmdldExvZ0dyb3VwUnVudGltZVNldHRpbmdzQnlJbmRleChpZExvZ0dyb3VwUnVsZSk7XG4gICAgfTtcbiAgICBMRlNlcnZpY2VJbXBsLnByb3RvdHlwZS5nZXRMb2dnZXJGYWN0b3J5UnVudGltZVNldHRpbmdzQnlOYW1lID0gZnVuY3Rpb24gKG5hbWVMb2dnZXJGYWN0b3J5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9tYXBGYWN0b3JpZXMuZ2V0KG5hbWVMb2dnZXJGYWN0b3J5KTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBMRlNlcnZpY2VJbXBsLmNyZWF0ZURlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IExvZ2dlckZhY3RvcnlPcHRpb25zXzEuTG9nZ2VyRmFjdG9yeU9wdGlvbnMoKS5hZGRMb2dHcm91cFJ1bGUobmV3IExvZ0dyb3VwUnVsZV8xLkxvZ0dyb3VwUnVsZShuZXcgUmVnRXhwKFwiLitcIiksIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5JbmZvKSk7XG4gICAgfTtcbiAgICAvLyBMb2FkZWQgb24gZGVtYW5kLiBEbyBOT1QgY2hhbmdlIGFzIHdlYnBhY2sgbWF5IHBhY2sgdGhpbmdzIGluIHdyb25nIG9yZGVyIG90aGVyd2lzZS5cbiAgICBMRlNlcnZpY2VJbXBsLl9JTlNUQU5DRSA9IG51bGw7XG4gICAgcmV0dXJuIExGU2VydmljZUltcGw7XG59KCkpO1xuLyoqXG4gKiBDcmVhdGUgYW5kIGNvbmZpZ3VyZSB5b3VyIExvZ2dlckZhY3RvcnkgZnJvbSBoZXJlLlxuICovXG52YXIgTEZTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExGU2VydmljZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IExvZ2dlckZhY3Rvcnkgd2l0aCBnaXZlbiBvcHRpb25zIChpZiBhbnkpLiBJZiBubyBvcHRpb25zXG4gICAgICogYXJlIHNwZWNpZmllZCwgdGhlIExvZ2dlckZhY3RvcnksIHdpbGwgYWNjZXB0IGFueSBuYW1lZCBsb2dnZXIgYW5kIHdpbGxcbiAgICAgKiBsb2cgb24gaW5mbyBsZXZlbCBieSBkZWZhdWx0IGZvciwgdG8gdGhlIGNvbnNvbGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucywgb3B0aW9uYWwuXG4gICAgICogQHJldHVybnMge0xvZ2dlckZhY3Rvcnl9XG4gICAgICovXG4gICAgTEZTZXJ2aWNlLmNyZWF0ZUxvZ2dlckZhY3RvcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBMRlNlcnZpY2UuSU5TVEFOQ0VfU0VSVklDRS5jcmVhdGVMb2dnZXJGYWN0b3J5KG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IExvZ2dlckZhY3RvcnkgdXNpbmcgZ2l2ZW4gbmFtZSAodXNlZCBmb3IgY29uc29sZSBhcGkvZXh0ZW5zaW9uKS5cbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIFBpY2sgc29tZXRoaW5nIHNob3J0IGJ1dCBkaXN0aW5ndWlzaGFibGUuIFRoZSB3b3JkIFwiREVGQVVMVFwiIGlzIHJlc2VydmVkIGFuZCBjYW5ub3QgYmUgdGFrZW4sIGl0IGlzIHVzZWRcbiAgICAgKiBmb3IgdGhlIGRlZmF1bHQgTG9nZ2VyRmFjdG9yeS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLCBvcHRpb25hbFxuICAgICAqIEByZXR1cm4ge0xvZ2dlckZhY3Rvcnl9XG4gICAgICovXG4gICAgTEZTZXJ2aWNlLmNyZWF0ZU5hbWVkTG9nZ2VyRmFjdG9yeSA9IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG51bGw7IH1cbiAgICAgICAgaWYgKG5hbWUgPT09IExGU2VydmljZS5ERUZBVUxUX0xPR0dFUl9GQUNUT1JZX05BTUUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvZ2dlckZhY3RvcnkgbmFtZTogXCIgKyBMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWV9OQU1FICsgXCIgaXMgcmVzZXJ2ZWQgYW5kIGNhbm5vdCBiZSB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTEZTZXJ2aWNlLklOU1RBTkNFX1NFUlZJQ0UuY3JlYXRlTmFtZWRMb2dnZXJGYWN0b3J5KG5hbWUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFsbCBMb2dnZXJzIGZvciBMb2dnZXJGYWN0b3JpZXMgdGhhdCB3ZXJlIGNyZWF0ZWQuXG4gICAgICogQWZ0ZXIgdGhpcyBjYWxsLCBhbGwgcHJldmlvdXNseSBmZXRjaGVkIExvZ2dlcnMgKGZyb20gdGhlaXJcbiAgICAgKiBmYWN0b3JpZXMpIGFyZSB1bnVzYWJsZS4gVGhlIGZhY3RvcmllcyByZW1haW4gYXMgdGhleSB3ZXJlLlxuICAgICAqL1xuICAgIExGU2VydmljZS5jbG9zZUxvZ2dlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMRlNlcnZpY2UuSU5TVEFOQ0VfU0VSVklDRS5jbG9zZUxvZ2dlcnMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBMRlNlcnZpY2VSdW50aW1lU2V0dGluZ3MgdG8gcmV0cmlldmUgaW5mb3JtYXRpb24gbG9nZ2VyZmFjdG9yaWVzXG4gICAgICogYW5kIHRoZWlyIHJ1bnRpbWUgc2V0dGluZ3MuXG4gICAgICogQHJldHVybnMge0xGU2VydmljZVJ1bnRpbWVTZXR0aW5nc31cbiAgICAgKi9cbiAgICBMRlNlcnZpY2UuZ2V0UnVudGltZVNldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTEZTZXJ2aWNlLklOU1RBTkNFX1NFUlZJQ0U7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTEZTZXJ2aWNlLCBcIkRFRkFVTFRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBwcm9wZXJ0eSByZXR1cm5zIHRoZSBkZWZhdWx0IExvZ2dlckZhY3RvcnkgKGlmIG5vdCB5ZXQgaW5pdGlhbGl6ZWQgaXQgaXMgaW5pdGlhbGl6ZWQpLlxuICAgICAgICAgKiBUaGlzIExvZ2dlckZhY3RvcnkgY2FuIGJlIHVzZWQgdG8gc2hhcmUgYW1vbmcgbXVsdGlwbGVcbiAgICAgICAgICogYXBwbGljYXRpb25zL2xpYnJhcmllcyAtIHRoYXQgd2F5IHlvdSBjYW4gZW5hYmxlL2NoYW5nZSBsb2dnaW5nIG92ZXIgZXZlcnl0aGluZyBmcm9tXG4gICAgICAgICAqIHlvdXIgb3duIGFwcGxpY2F0aW9uIHdoZW4gcmVxdWlyZWQuXG4gICAgICAgICAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIGJlIHVzZWQgYnkgbGlicmFyeSBkZXZlbG9wZXJzIHRvIG1ha2UgbG9nZ2luZyBlYXNpbHkgYXZhaWxhYmxlIGZvciB0aGVcbiAgICAgICAgICogY29uc3VtZXJzIG9mIHRoZWlyIGxpYnJhcmllcy5cbiAgICAgICAgICogSXQgaXMgaGlnaGx5IHJlY29tbWVuZGVkIHRvIHVzZSBMb2dnZXJzIGZyb20gdGhlIExvZ2dlckZhY3Rvcnkgd2l0aCB1bmlxdWUgZ3JvdXBpbmcvbmFtZXMgdG8gcHJldmVudFxuICAgICAgICAgKiBjbGFzaGVzIG9mIExvZ2dlcnMgYmV0d2VlbiBtdWx0aXBsZSBwcm9qZWN0cy5cbiAgICAgICAgICogQHJldHVybnMge0xvZ2dlckZhY3Rvcnl9IFJldHVybnMgdGhlIGRlZmF1bHQgTG9nZ2VyRmFjdG9yeVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTEZTZXJ2aWNlLmdldERlZmF1bHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIExGU2VydmljZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoTEZTZXJ2aWNlLkRFRkFVTFRfTE9HR0VSX0ZBQ1RPUlkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIExGU2VydmljZS5ERUZBVUxUX0xPR0dFUl9GQUNUT1JZID0gTEZTZXJ2aWNlLkRFRkFVTFRfTE9HR0VSX0ZBQ1RPUlkgPSBMRlNlcnZpY2UuSU5TVEFOQ0VfU0VSVklDRS5jcmVhdGVOYW1lZExvZ2dlckZhY3RvcnkoTEZTZXJ2aWNlLkRFRkFVTFRfTE9HR0VSX0ZBQ1RPUllfTkFNRSwgbmV3IExvZ2dlckZhY3RvcnlPcHRpb25zXzEuTG9nZ2VyRmFjdG9yeU9wdGlvbnMoKS5hZGRMb2dHcm91cFJ1bGUobmV3IExvZ0dyb3VwUnVsZV8xLkxvZ0dyb3VwUnVsZShuZXcgUmVnRXhwKFwiLitcIiksIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5FcnJvcikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTEZTZXJ2aWNlLkRFRkFVTFRfTE9HR0VSX0ZBQ1RPUlk7XG4gICAgfTtcbiAgICBMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWV9OQU1FID0gXCJERUZBVUxUXCI7XG4gICAgTEZTZXJ2aWNlLklOU1RBTkNFX1NFUlZJQ0UgPSBMRlNlcnZpY2VJbXBsLmdldEluc3RhbmNlKCk7XG4gICAgTEZTZXJ2aWNlLkRFRkFVTFRfTE9HR0VSX0ZBQ1RPUlkgPSBudWxsO1xuICAgIHJldHVybiBMRlNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5MRlNlcnZpY2UgPSBMRlNlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MRlNlcnZpY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvZ0dyb3VwUnVsZSA9IHZvaWQgMDtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbi8qKlxuICogRGVmaW5lcyBhIExvZ0dyb3VwUnVsZSwgdGhpcyBhbGxvd3MgeW91IHRvIGVpdGhlciBoYXZlIGV2ZXJ5dGhpbmcgY29uZmlndXJlZCB0aGUgc2FtZSB3YXlcbiAqIG9yIGZvciBleGFtcGxlIGxvZ2dlcnMgdGhhdCBzdGFydCB3aXRoIG5hbWUgbW9kZWwuIEl0IGFsbG93cyB5b3UgdG8gZ3JvdXAgbG9nZ2VycyB0b2dldGhlclxuICogdG8gaGF2ZSBhIGNlcnRhaW4gbG9nbGV2ZWwgYW5kIG90aGVyIHNldHRpbmdzLiBZb3UgY2FuIGNvbmZpZ3VyZSB0aGlzIHdoZW4gY3JlYXRpbmcgdGhlXG4gKiBMb2dnZXJGYWN0b3J5ICh3aGljaCBhY2NlcHRzIG11bHRpcGxlIExvZ0dyb3VwUnVsZXMpLlxuICovXG52YXIgTG9nR3JvdXBSdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIExvZ0dyb3VwUnVsZS4gQmFzaWNhbGx5IHlvdSBkZWZpbmUgd2hhdCBsb2dnZXIgbmFtZShzKSBtYXRjaCBmb3IgdGhpcyBncm91cCwgd2hhdCBsZXZlbCBzaG91bGQgYmUgdXNlZCB3aGF0IGxvZ2dlciB0eXBlICh3aGVyZSB0byBsb2cpXG4gICAgICogYW5kIHdoYXQgZm9ybWF0IHRvIHdyaXRlIGluLiBJZiB0aGUgbG9nZ2VyVHlwZSBpcyBjdXN0b20sIHRoZW4gdGhlIGNhbGxCYWNrTG9nZ2VyIG11c3QgYmUgc3VwcGxpZWQgYXMgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmV0dXJuIGEgY3VzdG9tIGxvZ2dlci5cbiAgICAgKiBAcGFyYW0gcmVnRXhwIFJlZ3VsYXIgZXhwcmVzc2lvbiwgd2hhdCBtYXRjaGVzIGZvciB5b3VyIGxvZ2dlciBuYW1lcyBmb3IgdGhpcyBncm91cFxuICAgICAqIEBwYXJhbSBsZXZlbCBMb2dMZXZlbFxuICAgICAqIEBwYXJhbSBsb2dGb3JtYXQgTG9nRm9ybWF0XG4gICAgICogQHBhcmFtIGxvZ2dlclR5cGUgVHlwZSBvZiBsb2dnZXIsIGlmIEN1c3RvbSwgbWFrZSBzdXJlIHRvIGltcGxlbWVudCBjYWxsQmFja0xvZ2dlciBhbmQgcGFzcyBpbiwgdGhpcyB3aWxsIGJlIGNhbGxlZCBzbyB5b3UgY2FuIHJldHVybiB5b3VyIG93biBsb2dnZXIuXG4gICAgICogQHBhcmFtIGNhbGxCYWNrTG9nZ2VyIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJldHVybiBhIG5ldyBjbGVhbiBjdXN0b20gbG9nZ2VyICh5b3VycyEpXG4gICAgICovXG4gICAgZnVuY3Rpb24gTG9nR3JvdXBSdWxlKHJlZ0V4cCwgbGV2ZWwsIGxvZ0Zvcm1hdCwgbG9nZ2VyVHlwZSwgY2FsbEJhY2tMb2dnZXIpIHtcbiAgICAgICAgaWYgKGxvZ0Zvcm1hdCA9PT0gdm9pZCAwKSB7IGxvZ0Zvcm1hdCA9IG5ldyBMb2dnZXJPcHRpb25zXzEuTG9nRm9ybWF0KCk7IH1cbiAgICAgICAgaWYgKGxvZ2dlclR5cGUgPT09IHZvaWQgMCkgeyBsb2dnZXJUeXBlID0gTG9nZ2VyT3B0aW9uc18xLkxvZ2dlclR5cGUuQ29uc29sZTsgfVxuICAgICAgICBpZiAoY2FsbEJhY2tMb2dnZXIgPT09IHZvaWQgMCkgeyBjYWxsQmFja0xvZ2dlciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fZm9ybWF0dGVyTG9nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JlZ0V4cCA9IHJlZ0V4cDtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy5fbG9nRm9ybWF0ID0gbG9nRm9ybWF0O1xuICAgICAgICB0aGlzLl9sb2dnZXJUeXBlID0gbG9nZ2VyVHlwZTtcbiAgICAgICAgdGhpcy5fY2FsbEJhY2tMb2dnZXIgPSBjYWxsQmFja0xvZ2dlcjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVsZS5wcm90b3R5cGUsIFwicmVnRXhwXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVnRXhwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVsZS5wcm90b3R5cGUsIFwibGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dHcm91cFJ1bGUucHJvdG90eXBlLCBcImxvZ2dlclR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dnZXJUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVsZS5wcm90b3R5cGUsIFwibG9nRm9ybWF0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nRm9ybWF0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVsZS5wcm90b3R5cGUsIFwiY2FsbEJhY2tMb2dnZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsQmFja0xvZ2dlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dHcm91cFJ1bGUucHJvdG90eXBlLCBcImZvcm1hdHRlckxvZ01lc3NhZ2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmb3JtYXR0ZXJMb2dNZXNzYWdlIGZ1bmN0aW9uLCBzZWUgY29tbWVudCBvbiB0aGUgc2V0dGVyLlxuICAgICAgICAgKiBAcmV0dXJucyB7KChtZXNzYWdlOkxvZ01lc3NhZ2UpPT5zdHJpbmcpfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXR0ZXJMb2dNZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBkZWZhdWx0IGZvcm1hdHRlckxvZ01lc3NhZ2UgZnVuY3Rpb24sIGlmIHNldCBpdCBpcyBhcHBsaWVkIHRvIGFsbCB0eXBlIG9mIGxvZ2dlcnMgZXhjZXB0IGZvciBhIGN1c3RvbSBsb2dnZXIuXG4gICAgICAgICAqIEJ5IGRlZmF1bHQgdGhpcyBpcyBudWxsIChub3Qgc2V0KS4gWW91IGNhbiBhc3NpZ24gYSBmdW5jdGlvbiB0byBhbGxvdyBjdXN0b20gZm9ybWF0dGluZyBvZiBhIGxvZyBtZXNzYWdlLlxuICAgICAgICAgKiBFYWNoIGxvZyBtZXNzYWdlIHdpbGwgY2FsbCB0aGlzIGZ1bmN0aW9uIHRoZW4gYW5kIGV4cGVjdHMgeW91ciBmdW5jdGlvbiB0byBmb3JtYXQgdGhlIG1lc3NhZ2UgYW5kIHJldHVybiBhIHN0cmluZy5cbiAgICAgICAgICogV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgYXR0ZW1wdCB0byBzZXQgYSBmb3JtYXR0ZXJMb2dNZXNzYWdlIGlmIHRoZSBMb2dnZXJUeXBlIGlzIGN1c3RvbS5cbiAgICAgICAgICogQHBhcmFtIHZhbHVlIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb24sIG9yIG51bGwgdG8gcmVzZXQgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHRoaXMuX2xvZ2dlclR5cGUgPT09IExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkN1c3RvbSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW5ub3Qgc3BlY2lmeSBhIGZvcm1hdHRlciBmb3IgbG9nIG1lc3NhZ2VzIGlmIHlvdXIgbG9nZ2VyVHlwZSBpcyBDdXN0b21cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9mb3JtYXR0ZXJMb2dNZXNzYWdlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTG9nR3JvdXBSdWxlO1xufSgpKTtcbmV4cG9ydHMuTG9nR3JvdXBSdWxlID0gTG9nR3JvdXBSdWxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nR3JvdXBSdWxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyA9IHZvaWQgMDtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcnVudGltZSBzZXR0aW5ncyBmb3IgYSBMb2dHcm91cCAoTG9nR3JvdXBSdWxlKS5cbiAqL1xudmFyIExvZ0dyb3VwUnVudGltZVNldHRpbmdzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ0dyb3VwUnVudGltZVNldHRpbmdzKGxvZ0dyb3VwUnVsZSkge1xuICAgICAgICB0aGlzLl9mb3JtYXR0ZXJMb2dNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbG9nR3JvdXBSdWxlID0gbG9nR3JvdXBSdWxlO1xuICAgICAgICB0aGlzLl9sZXZlbCA9IGxvZ0dyb3VwUnVsZS5sZXZlbDtcbiAgICAgICAgdGhpcy5fbG9nZ2VyVHlwZSA9IGxvZ0dyb3VwUnVsZS5sb2dnZXJUeXBlO1xuICAgICAgICB0aGlzLl9sb2dGb3JtYXQgPSBuZXcgTG9nZ2VyT3B0aW9uc18xLkxvZ0Zvcm1hdChuZXcgTG9nZ2VyT3B0aW9uc18xLkRhdGVGb3JtYXQobG9nR3JvdXBSdWxlLmxvZ0Zvcm1hdC5kYXRlRm9ybWF0LmZvcm1hdEVudW0sIGxvZ0dyb3VwUnVsZS5sb2dGb3JtYXQuZGF0ZUZvcm1hdC5kYXRlU2VwYXJhdG9yKSwgbG9nR3JvdXBSdWxlLmxvZ0Zvcm1hdC5zaG93VGltZVN0YW1wLCBsb2dHcm91cFJ1bGUubG9nRm9ybWF0LnNob3dMb2dnZXJOYW1lKTtcbiAgICAgICAgdGhpcy5fY2FsbEJhY2tMb2dnZXIgPSBsb2dHcm91cFJ1bGUuY2FsbEJhY2tMb2dnZXI7XG4gICAgICAgIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2UgPSBsb2dHcm91cFJ1bGUuZm9ybWF0dGVyTG9nTWVzc2FnZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJsb2dHcm91cFJ1bGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBvcmlnaW5hbCBMb2dHcm91cFJ1bGUgKHNvIG5vdCBydW50aW1lIHNldHRpbmdzISlcbiAgICAgICAgICogQHJldHVybiB7TG9nR3JvdXBSdWxlfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nR3JvdXBSdWxlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJsZXZlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbGV2ZWwgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5wcm90b3R5cGUsIFwibG9nZ2VyVHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2dlclR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXJUeXBlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nR3JvdXBSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImxvZ0Zvcm1hdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0Zvcm1hdDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ0Zvcm1hdCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJjYWxsQmFja0xvZ2dlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxCYWNrTG9nZ2VyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbEJhY2tMb2dnZXIgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5wcm90b3R5cGUsIFwiZm9ybWF0dGVyTG9nTWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JtYXR0ZXJMb2dNZXNzYWdlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTG9nR3JvdXBSdW50aW1lU2V0dGluZ3M7XG59KCkpO1xuZXhwb3J0cy5Mb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyA9IExvZ0dyb3VwUnVudGltZVNldHRpbmdzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nR3JvdXBSdW50aW1lU2V0dGluZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvZ2dlckZhY3RvcnlJbXBsID0gdm9pZCAwO1xudmFyIERhdGFTdHJ1Y3R1cmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvRGF0YVN0cnVjdHVyZXNcIik7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL0xvZ2dlck9wdGlvbnNcIik7XG52YXIgQ29uc29sZUxvZ2dlckltcGxfMSA9IHJlcXVpcmUoXCIuL0NvbnNvbGVMb2dnZXJJbXBsXCIpO1xudmFyIE1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsXzEgPSByZXF1aXJlKFwiLi9NZXNzYWdlQnVmZmVyTG9nZ2VySW1wbFwiKTtcbnZhciBBYnN0cmFjdExvZ2dlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RMb2dnZXJcIik7XG52YXIgTG9nR3JvdXBSdW50aW1lU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0xvZ0dyb3VwUnVudGltZVNldHRpbmdzXCIpO1xudmFyIExvZ2dlckZhY3RvcnlJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlckZhY3RvcnlJbXBsKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VycyA9IG5ldyBEYXRhU3RydWN0dXJlc18xLlNpbXBsZU1hcCgpO1xuICAgICAgICB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5nc0luZGV4ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5fbG9nZ2VyVG9Mb2dHcm91cFNldHRpbmdzID0gbmV3IERhdGFTdHJ1Y3R1cmVzXzEuU2ltcGxlTWFwKCk7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZShvcHRpb25zKTtcbiAgICB9XG4gICAgTG9nZ2VyRmFjdG9yeUltcGwucHJvdG90eXBlLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvLyBDbG9zZSBhbnkgY3VycmVudCBvcGVuIGxvZ2dlcnMuXG4gICAgICAgIHRoaXMuY2xvc2VMb2dnZXJzKCk7XG4gICAgICAgIHRoaXMuX2xvZ2dlclRvTG9nR3JvdXBTZXR0aW5ncy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5nc0luZGV4ZWQgPSBbXTtcbiAgICAgICAgdmFyIGxvZ0dyb3VwUnVsZXMgPSB0aGlzLl9vcHRpb25zLmxvZ0dyb3VwUnVsZXM7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOnByZWZlci1mb3Itb2YgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dHcm91cFJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5nc0luZGV4ZWQucHVzaChuZXcgTG9nR3JvdXBSdW50aW1lU2V0dGluZ3NfMS5Mb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyhsb2dHcm91cFJ1bGVzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpwcmVmZXItZm9yLW9mICovXG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5SW1wbC5wcm90b3R5cGUuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gKG5hbWVkKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2dnZXJGYWN0b3J5IGlzIG5vdCBlbmFibGVkLCBwbGVhc2UgY2hlY2sgeW91ciBvcHRpb25zIHBhc3NlZCBpblwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9nZ2VyID0gdGhpcy5fbG9nZ2Vycy5nZXQobmFtZWQpO1xuICAgICAgICBpZiAodHlwZW9mIGxvZ2dlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXplIGxvZ2dlciB3aXRoIGFwcHJvcHJpYXRlIGxldmVsXG4gICAgICAgIGxvZ2dlciA9IHRoaXMubG9hZExvZ2dlcihuYW1lZCk7XG4gICAgICAgIHRoaXMuX2xvZ2dlcnMucHV0KG5hbWVkLCBsb2dnZXIpO1xuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeUltcGwucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZW5hYmxlZDtcbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnlJbXBsLnByb3RvdHlwZS5jbG9zZUxvZ2dlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlcnMuZm9yRWFjaFZhbHVlKGZ1bmN0aW9uIChsb2dnZXIpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBvbmx5IGNsb3NlIGlmIEFic3RyYWN0TG9nZ2VyIGlzIHVzZWQgKG91ciBsb2dnZXJzLCBidXQgdXNlciBsb2dnZXJzIG1heSBub3QgZXh0ZW5kIGl0LCBldmVuIHRob3VnaCB1bmxpa2VseSkuXG4gICAgICAgICAgICBpZiAobG9nZ2VyIGluc3RhbmNlb2YgQWJzdHJhY3RMb2dnZXJfMS5BYnN0cmFjdExvZ2dlcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbG9nZ2Vycy5jbGVhcigpO1xuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeUltcGwucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeUltcGwucHJvdG90eXBlLmdldExvZ0dyb3VwUnVudGltZVNldHRpbmdzQnlJbmRleCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8IHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzSW5kZXhlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5nc0luZGV4ZWRbaWR4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnlJbXBsLnByb3RvdHlwZS5nZXRMb2dHcm91cFJ1bnRpbWVTZXR0aW5nc0J5TG9nZ2VyTmFtZSA9IGZ1bmN0aW9uIChuYW1lTG9nZ2VyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9sb2dnZXJUb0xvZ0dyb3VwU2V0dGluZ3MuZ2V0KG5hbWVMb2dnZXIpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnlJbXBsLnByb3RvdHlwZS5nZXRMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzSW5kZXhlZC5zbGljZSgwKTtcbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnlJbXBsLnByb3RvdHlwZS5sb2FkTG9nZ2VyID0gZnVuY3Rpb24gKG5hbWVkKSB7XG4gICAgICAgIHZhciBsb2dHcm91cFJ1bGVzID0gdGhpcy5fb3B0aW9ucy5sb2dHcm91cFJ1bGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ0dyb3VwUnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsb2dHcm91cFJ1bGUgPSBsb2dHcm91cFJ1bGVzW2ldO1xuICAgICAgICAgICAgaWYgKGxvZ0dyb3VwUnVsZS5yZWdFeHAudGVzdChuYW1lZCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MgPSB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5nc0luZGV4ZWRbaV07XG4gICAgICAgICAgICAgICAgdmFyIGxvZ2dlciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGxvZ0dyb3VwUnVsZS5sb2dnZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ2dlclR5cGUuQ29uc29sZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciA9IG5ldyBDb25zb2xlTG9nZ2VySW1wbF8xLkNvbnNvbGVMb2dnZXJJbXBsKG5hbWVkLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nZ2VyVHlwZS5NZXNzYWdlQnVmZmVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyID0gbmV3IE1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsXzEuTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwobmFtZWQsIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkN1c3RvbTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dHcm91cFJ1bGUuY2FsbEJhY2tMb2dnZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciA9IGxvZ0dyb3VwUnVsZS5jYWxsQmFja0xvZ2dlcihuYW1lZCwgbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNyZWF0ZSBhIGN1c3RvbSBsb2dnZXIsIGN1c3RvbSBjYWxsYmFjayBpcyBudWxsXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIGEgTG9nZ2VyIGZvciBMb2dnZXJUeXBlOiBcIiArIGxvZ0dyb3VwUnVsZS5sb2dnZXJUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm9yIGEgbmV3IGxvZ2dlciBtYXAgaXQgYnkgaXRzIG5hbWVcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXJUb0xvZ0dyb3VwU2V0dGluZ3MucHV0KG5hbWVkLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmluZCBhIG1hdGNoIHRvIGNyZWF0ZSBhIExvZ2dlciBmb3I6IFwiICsgbmFtZWQpO1xuICAgIH07XG4gICAgcmV0dXJuIExvZ2dlckZhY3RvcnlJbXBsO1xufSgpKTtcbmV4cG9ydHMuTG9nZ2VyRmFjdG9yeUltcGwgPSBMb2dnZXJGYWN0b3J5SW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvZ2dlckZhY3RvcnlJbXBsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2dnZXJGYWN0b3J5T3B0aW9ucyA9IHZvaWQgMDtcbi8qKlxuICogT3B0aW9ucyBvYmplY3QgeW91IGNhbiB1c2UgdG8gY29uZmlndXJlIHRoZSBMb2dnZXJGYWN0b3J5IHlvdSBjcmVhdGUgYXQgTEZTZXJ2aWNlLlxuICovXG52YXIgTG9nZ2VyRmFjdG9yeU9wdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9nZ2VyRmFjdG9yeU9wdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuX2xvZ0dyb3VwUnVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBMb2dHcm91cFJ1bGUsIHNlZSB7TG9nR3JvdXBSdWxlKSBmb3IgZGV0YWlsc1xuICAgICAqIEBwYXJhbSBydWxlIFJ1bGUgdG8gYWRkXG4gICAgICogQHJldHVybnMge0xvZ2dlckZhY3RvcnlPcHRpb25zfSByZXR1cm5zIGl0c2VsZlxuICAgICAqL1xuICAgIExvZ2dlckZhY3RvcnlPcHRpb25zLnByb3RvdHlwZS5hZGRMb2dHcm91cFJ1bGUgPSBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICB0aGlzLl9sb2dHcm91cFJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgbG9nZ2luZyBjb21wbGV0ZWx5IGZvciB0aGUgTG9nZ2VyRmFjdG9yeS5cbiAgICAgKiBAcGFyYW0gZW5hYmxlZCBUcnVlIGZvciBlbmFibGVkIChkZWZhdWx0KVxuICAgICAqIEByZXR1cm5zIHtMb2dnZXJGYWN0b3J5T3B0aW9uc30gcmV0dXJucyBpdHNlbGZcbiAgICAgKi9cbiAgICBMb2dnZXJGYWN0b3J5T3B0aW9ucy5wcm90b3R5cGUuc2V0RW5hYmxlZCA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dnZXJGYWN0b3J5T3B0aW9ucy5wcm90b3R5cGUsIFwibG9nR3JvdXBSdWxlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVsZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nZ2VyRmFjdG9yeU9wdGlvbnMucHJvdG90eXBlLCBcImVuYWJsZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIExvZ2dlckZhY3RvcnlPcHRpb25zO1xufSgpKTtcbmV4cG9ydHMuTG9nZ2VyRmFjdG9yeU9wdGlvbnMgPSBMb2dnZXJGYWN0b3J5T3B0aW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvZ2dlckZhY3RvcnlPcHRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwgPSB2b2lkIDA7XG52YXIgQWJzdHJhY3RMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TG9nZ2VyXCIpO1xuLyoqXG4gKiBMb2dnZXIgd2hpY2ggYnVmZmVycyBhbGwgbWVzc2FnZXMsIHVzZSB3aXRoIGNhcmUgZHVlIHRvIHBvc3NpYmxlIGhpZ2ggbWVtb3J5IGZvb3RwcmludC5cbiAqIENhbiBiZSBjb252ZW5pZW50IGluIHNvbWUgY2FzZXMuIENhbGwgdG9TdHJpbmcoKSBmb3IgZnVsbCBvdXRwdXQsIG9yIGNhc3QgdG8gdGhpcyBjbGFzc1xuICogYW5kIGNhbGwgZ2V0TWVzc2FnZXMoKSB0byBkbyBzb21ldGhpbmcgd2l0aCBpdCB5b3Vyc2VsZi5cbiAqL1xudmFyIE1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbChuYW1lLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5jbG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwucHJvdG90eXBlLmdldE1lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcztcbiAgICB9O1xuICAgIE1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMubWFwKGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbC5wcm90b3R5cGUuZG9Mb2cgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgbWVzc2FnZUZvcm1hdHRlciA9IHRoaXMuX2dldE1lc3NhZ2VGb3JtYXR0ZXIoKTtcbiAgICAgICAgdmFyIGZ1bGxNc2c7XG4gICAgICAgIGlmIChtZXNzYWdlRm9ybWF0dGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICBmdWxsTXNnID0gdGhpcy5jcmVhdGVEZWZhdWx0TG9nTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxNc2cgPSBtZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaChmdWxsTXNnKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbDtcbn0oQWJzdHJhY3RMb2dnZXJfMS5BYnN0cmFjdExvZ2dlcikpO1xuZXhwb3J0cy5NZXNzYWdlQnVmZmVyTG9nZ2VySW1wbCA9IE1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Q2F0ZWdvcnlDb250cm9sID0gZXhwb3J0cy5nZXRMb2dDb250cm9sID0gZXhwb3J0cy5oZWxwID0gZXhwb3J0cy5NZXNzYWdlRm9ybWF0VXRpbHMgPSBleHBvcnRzLkxpbmtlZExpc3QgPSBleHBvcnRzLlNpbXBsZU1hcCA9IGV4cG9ydHMuTG9nTGV2ZWwgPSBleHBvcnRzLkxvZ2dlclR5cGUgPSBleHBvcnRzLkxvZ0Zvcm1hdCA9IGV4cG9ydHMuRGF0ZUZvcm1hdEVudW0gPSBleHBvcnRzLkRhdGVGb3JtYXQgPSBleHBvcnRzLkNhdGVnb3J5TG9nRm9ybWF0ID0gZXhwb3J0cy5NZXNzYWdlQnVmZmVyTG9nZ2VySW1wbCA9IGV4cG9ydHMuQ29uc29sZUxvZ2dlckltcGwgPSBleHBvcnRzLkFic3RyYWN0TG9nZ2VyID0gZXhwb3J0cy5MRlNlcnZpY2UgPSBleHBvcnRzLkxvZ0dyb3VwUnVsZSA9IGV4cG9ydHMuTG9nZ2VyRmFjdG9yeU9wdGlvbnMgPSBleHBvcnRzLkNhdGVnb3J5U2VydmljZUZhY3RvcnkgPSBleHBvcnRzLkNhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwgPSBleHBvcnRzLkNhdGVnb3J5Q29uZmlndXJhdGlvbiA9IGV4cG9ydHMuQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MgPSBleHBvcnRzLkNhdGVnb3J5ID0gZXhwb3J0cy5DYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbCA9IGV4cG9ydHMuQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbCA9IGV4cG9ydHMuQWJzdHJhY3RDYXRlZ29yeUxvZ2dlciA9IGV4cG9ydHMuRXh0ZW5zaW9uSGVscGVyID0gdm9pZCAwO1xudmFyIExvZ0dyb3VwQ29udHJvbF8xID0gcmVxdWlyZShcIi4vY29udHJvbC9Mb2dHcm91cENvbnRyb2xcIik7XG52YXIgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbF8xID0gcmVxdWlyZShcIi4vY29udHJvbC9DYXRlZ29yeVNlcnZpY2VDb250cm9sXCIpO1xuLy8gUHVibGljIHN0dWZmIHdlIGV4cG9ydCBmb3IgZXh0ZW5zaW9uXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXh0ZW5zaW9uL01lc3NhZ2VzVG9FeHRlbnNpb25KU09OXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHRlbnNpb24vTWVzc2FnZXNGcm9tRXh0ZW5zaW9uSlNPTlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXh0ZW5zaW9uL0V4dGVuc2lvbk1lc3NhZ2VKU09OXCIpLCBleHBvcnRzKTtcbnZhciBFeHRlbnNpb25IZWxwZXJfMSA9IHJlcXVpcmUoXCIuL2V4dGVuc2lvbi9FeHRlbnNpb25IZWxwZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeHRlbnNpb25IZWxwZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEV4dGVuc2lvbkhlbHBlcl8xLkV4dGVuc2lvbkhlbHBlcjsgfSB9KTtcbi8vIENhdGVnb3J5IHJlbGF0ZWRcbnZhciBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9sb2cvY2F0ZWdvcnkvQWJzdHJhY3RDYXRlZ29yeUxvZ2dlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0Q2F0ZWdvcnlMb2dnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXJfMS5BYnN0cmFjdENhdGVnb3J5TG9nZ2VyOyB9IH0pO1xudmFyIENhdGVnb3J5Q29uc29sZUxvZ2dlckltcGxfMSA9IHJlcXVpcmUoXCIuL2xvZy9jYXRlZ29yeS9DYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbF8xLkNhdGVnb3J5Q29uc29sZUxvZ2dlckltcGw7IH0gfSk7XG52YXIgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGxfMSA9IHJlcXVpcmUoXCIuL2xvZy9jYXRlZ29yeS9DYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbF8xLkNhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsOyB9IH0pO1xudmFyIENhdGVnb3J5XzEgPSByZXF1aXJlKFwiLi9sb2cvY2F0ZWdvcnkvQ2F0ZWdvcnlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYXRlZ29yeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ2F0ZWdvcnlfMS5DYXRlZ29yeTsgfSB9KTtcbnZhciBDYXRlZ29yeVJ1bnRpbWVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vbG9nL2NhdGVnb3J5L0NhdGVnb3J5UnVudGltZVNldHRpbmdzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENhdGVnb3J5UnVudGltZVNldHRpbmdzXzEuQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3M7IH0gfSk7XG52YXIgQ2F0ZWdvcnlDb25maWd1cmF0aW9uXzEgPSByZXF1aXJlKFwiLi9sb2cvY2F0ZWdvcnkvQ2F0ZWdvcnlDb25maWd1cmF0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2F0ZWdvcnlDb25maWd1cmF0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDYXRlZ29yeUNvbmZpZ3VyYXRpb25fMS5DYXRlZ29yeUNvbmZpZ3VyYXRpb247IH0gfSk7XG52YXIgQ2F0ZWdvcnlNZXNzYWdlQnVmZmVySW1wbF8xID0gcmVxdWlyZShcIi4vbG9nL2NhdGVnb3J5L0NhdGVnb3J5TWVzc2FnZUJ1ZmZlckltcGxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYXRlZ29yeU1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDYXRlZ29yeU1lc3NhZ2VCdWZmZXJJbXBsXzEuQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbDsgfSB9KTtcbnZhciBDYXRlZ29yeVNlcnZpY2VGYWN0b3J5XzEgPSByZXF1aXJlKFwiLi9sb2cvY2F0ZWdvcnkvQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhdGVnb3J5U2VydmljZUZhY3RvcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENhdGVnb3J5U2VydmljZUZhY3RvcnlfMS5DYXRlZ29yeVNlcnZpY2VGYWN0b3J5OyB9IH0pO1xudmFyIExvZ2dlckZhY3RvcnlPcHRpb25zXzEgPSByZXF1aXJlKFwiLi9sb2cvc3RhbmRhcmQvTG9nZ2VyRmFjdG9yeU9wdGlvbnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2dnZXJGYWN0b3J5T3B0aW9uc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTG9nZ2VyRmFjdG9yeU9wdGlvbnNfMS5Mb2dnZXJGYWN0b3J5T3B0aW9uczsgfSB9KTtcbnZhciBMb2dHcm91cFJ1bGVfMSA9IHJlcXVpcmUoXCIuL2xvZy9zdGFuZGFyZC9Mb2dHcm91cFJ1bGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2dHcm91cFJ1bGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIExvZ0dyb3VwUnVsZV8xLkxvZ0dyb3VwUnVsZTsgfSB9KTtcbnZhciBMRlNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2xvZy9zdGFuZGFyZC9MRlNlcnZpY2VcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMRlNlcnZpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIExGU2VydmljZV8xLkxGU2VydmljZTsgfSB9KTtcbnZhciBBYnN0cmFjdExvZ2dlcl8xID0gcmVxdWlyZShcIi4vbG9nL3N0YW5kYXJkL0Fic3RyYWN0TG9nZ2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RMb2dnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFic3RyYWN0TG9nZ2VyXzEuQWJzdHJhY3RMb2dnZXI7IH0gfSk7XG52YXIgQ29uc29sZUxvZ2dlckltcGxfMSA9IHJlcXVpcmUoXCIuL2xvZy9zdGFuZGFyZC9Db25zb2xlTG9nZ2VySW1wbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnNvbGVMb2dnZXJJbXBsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDb25zb2xlTG9nZ2VySW1wbF8xLkNvbnNvbGVMb2dnZXJJbXBsOyB9IH0pO1xudmFyIE1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsXzEgPSByZXF1aXJlKFwiLi9sb2cvc3RhbmRhcmQvTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGxfMS5NZXNzYWdlQnVmZmVyTG9nZ2VySW1wbDsgfSB9KTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi9sb2cvTG9nZ2VyT3B0aW9uc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhdGVnb3J5TG9nRm9ybWF0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBMb2dnZXJPcHRpb25zXzEuQ2F0ZWdvcnlMb2dGb3JtYXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEYXRlRm9ybWF0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBMb2dnZXJPcHRpb25zXzEuRGF0ZUZvcm1hdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGVGb3JtYXRFbnVtXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBMb2dnZXJPcHRpb25zXzEuRGF0ZUZvcm1hdEVudW07IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2dGb3JtYXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIExvZ2dlck9wdGlvbnNfMS5Mb2dGb3JtYXQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2dnZXJUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBMb2dnZXJPcHRpb25zXzEuTG9nZ2VyVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvZ0xldmVsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWw7IH0gfSk7XG4vLyBVdGlsaXRpZXNcbnZhciBEYXRhU3RydWN0dXJlc18xID0gcmVxdWlyZShcIi4vdXRpbHMvRGF0YVN0cnVjdHVyZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaW1wbGVNYXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERhdGFTdHJ1Y3R1cmVzXzEuU2ltcGxlTWFwOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGlua2VkTGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRGF0YVN0cnVjdHVyZXNfMS5MaW5rZWRMaXN0OyB9IH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzL0pTT05IZWxwZXJcIiksIGV4cG9ydHMpO1xudmFyIE1lc3NhZ2VVdGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHMvTWVzc2FnZVV0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZUZvcm1hdFV0aWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBNZXNzYWdlVXRpbHNfMS5NZXNzYWdlRm9ybWF0VXRpbHM7IH0gfSk7XG4vKlxuIEZ1bmN0aW9ucyB0byBleHBvcnQgb24gVFNMIGxpYmFyYXJ5IHZhci5cbiovXG4vLyBFeHBvcnQgaGVscCBmdW5jdGlvblxuZnVuY3Rpb24gaGVscCgpIHtcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgY29uc29sZS5sb2coXCJoZWxwKClcXG4gICAqKiBTaG93cyB0aGlzIGhlbHBcXG5cXG4gZ2V0TG9nQ29udHJvbCgpOiBMb2dnZXJDb250cm9sXFxuICAgKiogUmV0dXJucyBMb2dnZXJDb250cm9sIE9iamVjdCwgdXNlIHRvIGR5bmFtaWNhbGx5IGNoYW5nZSBsb2dsZXZlbHMgZm9yIGxvZzRqIGxvZ2dpbmcuXFxuICAgKiogQ2FsbCAuaGVscCgpIG9uIExvZ2dlckNvbnRyb2wgb2JqZWN0IGZvciBhdmFpbGFibGUgb3B0aW9ucy5cXG5cXG4gZ2V0Q2F0ZWdvcnlDb250cm9sKCk6IENhdGVnb3J5U2VydmljZUNvbnRyb2xcXG4gICAqKiBSZXR1cm5zIENhdGVnb3J5U2VydmljZUNvbnRyb2wgT2JqZWN0LCB1c2UgdG8gZHluYW1pY2FsbHkgY2hhbmdlIGxvZ2xldmVscyBmb3IgY2F0ZWdvcnkgbG9nZ2luZy5cXG4gICAqKiBDYWxsIC5oZWxwKCkgb24gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbCBvYmplY3QgZm9yIGF2YWlsYWJsZSBvcHRpb25zLlxcblwiKTtcbiAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbn1cbmV4cG9ydHMuaGVscCA9IGhlbHA7XG4vLyBFeHBvcnQgTG9nQ29udHJvbCBmdW5jdGlvbiAobG9nNGopXG5mdW5jdGlvbiBnZXRMb2dDb250cm9sKCkge1xuICAgIHJldHVybiBuZXcgTG9nR3JvdXBDb250cm9sXzEuTG9nZ2VyQ29udHJvbEltcGwoKTtcbn1cbmV4cG9ydHMuZ2V0TG9nQ29udHJvbCA9IGdldExvZ0NvbnRyb2w7XG4vLyBFeHBvcnQgQ2F0ZWdvcnlDb250cm9sIGZ1bmN0aW9uXG5mdW5jdGlvbiBnZXRDYXRlZ29yeUNvbnRyb2woKSB7XG4gICAgcmV0dXJuIG5ldyBDYXRlZ29yeVNlcnZpY2VDb250cm9sXzEuQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwoKTtcbn1cbmV4cG9ydHMuZ2V0Q2F0ZWdvcnlDb250cm9sID0gZ2V0Q2F0ZWdvcnlDb250cm9sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXNjcmlwdC1sb2dnaW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJpbmdCdWlsZGVyID0gZXhwb3J0cy5UdXBsZVBhaXIgPSBleHBvcnRzLlNpbXBsZU1hcCA9IGV4cG9ydHMuTGlua2VkTGlzdCA9IHZvaWQgMDtcbnZhciBMaW5rZWROb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmtlZE5vZGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmtlZE5vZGUucHJvdG90eXBlLCBcInByZXZpb3VzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91cyA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmtlZE5vZGUucHJvdG90eXBlLCBcIm5leHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZXh0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmtlZE5vZGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTGlua2VkTm9kZTtcbn0oKSk7XG4vKipcbiAqIERvdWJsZSBsaW5rZWRsaXN0IGltcGxlbWVudGF0aW9uLlxuICovXG52YXIgTGlua2VkTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5rZWRMaXN0KCkge1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5hZGRIZWFkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5jcmVhdGVIZWFkSWZOZWVkZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dE5vZGUgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgICAgICAgICAgICB2YXIgbmV3SGVhZE5vZGUgPSBuZXcgTGlua2VkTm9kZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHROb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUucHJldmlvdXMgPSBuZXdIZWFkTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3SGVhZE5vZGUubmV4dCA9IG5leHROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBuZXdIZWFkTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgbGlzdCBpbXBsZW1lbnRhdGlvbiBicm9rZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5hZGRUYWlsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5jcmVhdGVIZWFkSWZOZWVkZWQodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgb2xkVGFpbE5vZGUgPSB0aGlzLmdldFRhaWxOb2RlKCk7XG4gICAgICAgICAgICBpZiAob2xkVGFpbE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdUYWlsTm9kZSA9IG5ldyBMaW5rZWROb2RlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBvbGRUYWlsTm9kZS5uZXh0ID0gbmV3VGFpbE5vZGU7XG4gICAgICAgICAgICAgICAgbmV3VGFpbE5vZGUucHJldmlvdXMgPSBvbGRUYWlsTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxpc3QgaW1wbGVtZW50YXRpb24gYnJva2VuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5nZXRIZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oZWFkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlYWQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZW1vdmVIZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oZWFkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBvbGRIZWFkID0gdGhpcy5oZWFkO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2xkSGVhZC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG9sZEhlYWQubmV4dDtcbiAgICAgICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZ2V0VGFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldFRhaWxOb2RlKCk7XG4gICAgICAgIGlmIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUucmVtb3ZlVGFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldFRhaWxOb2RlKCk7XG4gICAgICAgIGlmIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzTm9kZSA9IG5vZGUucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxpc3QgaW1wbGVtZW50YXRpb24gaXMgYnJva2VuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdmFyIHJlY3Vyc2UgPSBmdW5jdGlvbiAoZm4sIG5vZGUsIHZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGZuKG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gobm9kZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV4dE5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICBpZiAobmV4dE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2UoZm4sIG5leHROb2RlLCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMuaGVhZDtcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlY3Vyc2UoZiwgY3VycmVudE5vZGUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmNyZWF0ZUhlYWRJZk5lZWRlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5oZWFkID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5ldyBMaW5rZWROb2RlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmdldFRhaWxOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5oZWFkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZSAobm9kZS5uZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICByZXR1cm4gTGlua2VkTGlzdDtcbn0oKSk7XG5leHBvcnRzLkxpbmtlZExpc3QgPSBMaW5rZWRMaXN0O1xuLyoqXG4gKiBNYXAgaW1wbGVtZW50YXRpb24ga2V5ZWQgYnkgc3RyaW5nIChhbHdheXMpLlxuICovXG52YXIgU2ltcGxlTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpbXBsZU1hcCgpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IHt9O1xuICAgIH1cbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXJyYXlba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gICAgU2ltcGxlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5W2tleV07XG4gICAgfTtcbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hcnJheVtrZXldO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgfTtcbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hcnJheVtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hcnJheVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFNpbXBsZU1hcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgcmFuZG9tIHN0dWZmIHRvIGFwcGVhclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG4gICAgU2ltcGxlTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgcmFuZG9tIHN0dWZmIHRvIGFwcGVhclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuZ2V0KGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMoKS5sZW5ndGg7XG4gICAgfTtcbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUoKSA9PT0gMDtcbiAgICB9O1xuICAgIFNpbXBsZU1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSB7fTtcbiAgICB9O1xuICAgIFNpbXBsZU1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYkZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmFycmF5KSB7XG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IHJhbmRvbSBzdHVmZiB0byBhcHBlYXJcbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmFycmF5W2tleV07XG4gICAgICAgICAgICAgICAgY2JGdW5jdGlvbihrZXksIHZhbHVlLCBjb3VudCk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2ltcGxlTWFwLnByb3RvdHlwZS5mb3JFYWNoVmFsdWUgPSBmdW5jdGlvbiAoY2JGdW5jdGlvbikge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5hcnJheSkge1xuICAgICAgICAgICAgLy8gVG8gcHJldmVudCByYW5kb20gc3R1ZmYgdG8gYXBwZWFyXG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hcnJheVtrZXldO1xuICAgICAgICAgICAgICAgIGNiRnVuY3Rpb24odmFsdWUsIGNvdW50KTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2ltcGxlTWFwO1xufSgpKTtcbmV4cG9ydHMuU2ltcGxlTWFwID0gU2ltcGxlTWFwO1xuLyoqXG4gKiBUdXBsZSB0byBob2xkIHR3byB2YWx1ZXMuXG4gKi9cbnZhciBUdXBsZVBhaXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHVwbGVQYWlyKHgsIHkpIHtcbiAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgIHRoaXMuX3kgPSB5O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHVwbGVQYWlyLnByb3RvdHlwZSwgXCJ4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUdXBsZVBhaXIucHJvdG90eXBlLCBcInlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFR1cGxlUGFpcjtcbn0oKSk7XG5leHBvcnRzLlR1cGxlUGFpciA9IFR1cGxlUGFpcjtcbi8qKlxuICogVXRpbGl0eSBjbGFzcyB0byBidWlsZCB1cCBhIHN0cmluZy5cbiAqL1xudmFyIFN0cmluZ0J1aWxkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nQnVpbGRlcigpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgfVxuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQgfHwgbGluZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgbXVzdCBiZSBzZXQsIGNhbm5vdCBhcHBlbmQgbnVsbCBvciB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhLnB1c2gobGluZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKGxpbmUgKyBcIlxcblwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTdHJpbmdCdWlsZGVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9O1xuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHNlcGFyYXRvcikge1xuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDApIHsgc2VwYXJhdG9yID0gXCJcIjsgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdCdWlsZGVyO1xufSgpKTtcbmV4cG9ydHMuU3RyaW5nQnVpbGRlciA9IFN0cmluZ0J1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhU3RydWN0dXJlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpTT05IZWxwZXIgPSBleHBvcnRzLkpTT05BcnJheSA9IGV4cG9ydHMuSlNPTk9iamVjdCA9IHZvaWQgMDtcbi8qKlxuICogTW9kdWxlIGNvbnRhaW5pbmcgYnVuY2ggb2YgSlNPTiByZWxhdGVkIHN0dWZmLlxuICovXG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL2xvZy9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIERhdGFTdHJ1Y3R1cmVzXzEgPSByZXF1aXJlKFwiLi9EYXRhU3RydWN0dXJlc1wiKTtcbnZhciBKU09OVHlwZUltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNPTlR5cGVJbXBsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIEpTT05UeXBlSW1wbC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBKU09OVHlwZUltcGw7XG59KCkpO1xudmFyIEpTT05Cb29sZWFuVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSlNPTkJvb2xlYW5UeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTT05Cb29sZWFuVHlwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdmFsdWUpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBKU09OQm9vbGVhblR5cGU7XG59KEpTT05UeXBlSW1wbCkpO1xudmFyIEpTT05OdW1iZXJUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhKU09OTnVtYmVyVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKU09OTnVtYmVyVHlwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdmFsdWUpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBKU09OTnVtYmVyVHlwZTtcbn0oSlNPTlR5cGVJbXBsKSk7XG52YXIgSlNPTlN0cmluZ1R5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTT05TdHJpbmdUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTT05TdHJpbmdUeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgSlNPTlN0cmluZ1R5cGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05TdHJpbmdUeXBlO1xufShKU09OVHlwZUltcGwpKTtcbnZhciBKU09OT2JqZWN0VHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSlNPTk9iamVjdFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSlNPTk9iamVjdFR5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHZhbHVlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTk9iamVjdFR5cGU7XG59KEpTT05UeXBlSW1wbCkpO1xudmFyIEpTT05BcnJheVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTT05BcnJheVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSlNPTkFycmF5VHlwZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdmFsdWUpIHx8IHRoaXM7XG4gICAgfVxuICAgIEpTT05BcnJheVR5cGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTkFycmF5VHlwZTtcbn0oSlNPTlR5cGVJbXBsKSk7XG52YXIgSlNPTk51bGxUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhKU09OTnVsbFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSlNPTk51bGxUeXBlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbnVsbCkgfHwgdGhpcztcbiAgICB9XG4gICAgSlNPTk51bGxUeXBlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05OdWxsVHlwZTtcbn0oSlNPTlR5cGVJbXBsKSk7XG52YXIgSlNPTlR5cGVDb252ZXJ0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNPTlR5cGVDb252ZXJ0ZXIoKSB7XG4gICAgfVxuICAgIEpTT05UeXBlQ29udmVydGVyLnRvSlNPTlR5cGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05OdWxsVHlwZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTlN0cmluZ1R5cGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTk51bWJlclR5cGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05Cb29sZWFuVHlwZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSlNPTk9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OT2JqZWN0VHlwZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBub3Qgc3VwcG9ydGVkIGZvciB2YWx1ZTogXCIgKyB2YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTlR5cGVDb252ZXJ0ZXI7XG59KCkpO1xudmFyIEpTT05PYmplY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNPTk9iamVjdCgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5TaW1wbGVNYXAoKTtcbiAgICB9XG4gICAgSlNPTk9iamVjdC5wcm90b3R5cGUuYWRkQm9vbGVhbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrTmFtZShuYW1lKTtcbiAgICAgICAgSlNPTk9iamVjdC5jaGVja1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZXMucHV0KG5hbWUsIG5ldyBKU09OQm9vbGVhblR5cGUodmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBKU09OT2JqZWN0LnByb3RvdHlwZS5hZGROdW1iZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGVja05hbWUobmFtZSk7XG4gICAgICAgIEpTT05PYmplY3QuY2hlY2tWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWVzLnB1dChuYW1lLCBuZXcgSlNPTk51bWJlclR5cGUodmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBKU09OT2JqZWN0LnByb3RvdHlwZS5hZGRTdHJpbmcgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGVja05hbWUobmFtZSk7XG4gICAgICAgIEpTT05PYmplY3QuY2hlY2tWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMudmFsdWVzLnB1dChuYW1lLCBuZXcgSlNPTlN0cmluZ1R5cGUodmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBKU09OT2JqZWN0LnByb3RvdHlwZS5hZGROdWxsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5jaGVja05hbWUobmFtZSk7XG4gICAgICAgIHRoaXMudmFsdWVzLnB1dChuYW1lLCBuZXcgSlNPTk51bGxUeXBlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEpTT05PYmplY3QucHJvdG90eXBlLmFkZEFycmF5ID0gZnVuY3Rpb24gKG5hbWUsIGFycmF5KSB7XG4gICAgICAgIHRoaXMuY2hlY2tOYW1lKG5hbWUpO1xuICAgICAgICBKU09OT2JqZWN0LmNoZWNrVmFsdWUoYXJyYXkpO1xuICAgICAgICBpZiAoYXJyYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBhcnJheSBhcyBudWxsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVzLnB1dChuYW1lLCBuZXcgSlNPTkFycmF5VHlwZShhcnJheSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEpTT05PYmplY3QucHJvdG90eXBlLmFkZE9iamVjdCA9IGZ1bmN0aW9uIChuYW1lLCBvYmplY3QpIHtcbiAgICAgICAgdGhpcy5jaGVja05hbWUobmFtZSk7XG4gICAgICAgIEpTT05PYmplY3QuY2hlY2tWYWx1ZShvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgb2JqZWN0IGFzIG51bGxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZXMucHV0KG5hbWUsIG5ldyBKU09OT2JqZWN0VHlwZShvYmplY3QpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBKU09OT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChwcmV0dHkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHByZXR0eSA9PT0gdm9pZCAwKSB7IHByZXR0eSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBjb21tYSA9IGZhbHNlO1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IERhdGFTdHJ1Y3R1cmVzXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICBidWZmZXIuYXBwZW5kKFwie1wiKTtcbiAgICAgICAgdGhpcy52YWx1ZXMua2V5cygpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMudmFsdWVzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLmFwcGVuZChcIixcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQoJ1wiJykuYXBwZW5kKGtleSkuYXBwZW5kKCdcIjonKS5hcHBlbmQodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgY29tbWEgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYnVmZmVyLmFwcGVuZChcIn1cIik7XG4gICAgICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIEpTT05PYmplY3QucHJvdG90eXBlLmNoZWNrTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09IG51bGwgfHwgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYW1lIGlzIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbHVlcy5leGlzdHMobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5hbWUgXCIgKyBuYW1lICsgXCIgaXMgYWxyZWFkeSBwcmVzZW50IGZvciB0aGlzIG9iamVjdFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSlNPTk9iamVjdC5jaGVja1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBpcyB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBKU09OT2JqZWN0O1xufSgpKTtcbmV4cG9ydHMuSlNPTk9iamVjdCA9IEpTT05PYmplY3Q7XG52YXIgSlNPTkFycmF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT05BcnJheSgpIHtcbiAgICAgICAgdGhpcy5vYmplY3RzID0gW107XG4gICAgfVxuICAgIEpTT05BcnJheS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCBpcyBub3QgYWxsb3dlZCB0byBiZSB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goSlNPTlR5cGVDb252ZXJ0ZXIudG9KU09OVHlwZShvYmplY3QpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBKU09OQXJyYXkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHByZXR0eSkge1xuICAgICAgICBpZiAocHJldHR5ID09PSB2b2lkIDApIHsgcHJldHR5ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBEYXRhU3RydWN0dXJlc18xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgYnVmZmVyLmFwcGVuZChcIltcIik7XG4gICAgICAgIHRoaXMub2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXIuYXBwZW5kKFwiXVwiKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05BcnJheTtcbn0oKSk7XG5leHBvcnRzLkpTT05BcnJheSA9IEpTT05BcnJheTtcbi8qKlxuICogVXRpbGl0eSBjbGFzcyB0aGF0IGhlbHBzIHVzIGNvbnZlcnQgdGhpbmdzIHRvIGFuZCBmcm9tIGpzb24gKG5vdCBmb3Igbm9ybWFsIHVzYWdlKS5cbiAqL1xudmFyIEpTT05IZWxwZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNPTkhlbHBlcigpIHtcbiAgICB9XG4gICAgSlNPTkhlbHBlci5jYXRlZ29yeVRvSlNPTiA9IGZ1bmN0aW9uIChjYXQsIHJlY3Vyc2l2ZSkge1xuICAgICAgICAvKlxuICAgICAgICAge1xuICAgICAgICAgXCJjYXRlZ29yaWVzXCI6XG4gICAgICAgICBbXG4gICAgICAgICB7IGlkPTEsXG4gICAgICAgICBuYW1lOiBcInhcIixcbiAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgIGxvZ0xldmVsOiBcIkVycm9yXCJcbiAgICAgICAgIH0sXG4gICAgICAgICB7IGlkPTIsXG4gICAgICAgICBuYW1lOiBcInlcIixcbiAgICAgICAgIHBhcmVudDogMSxcbiAgICAgICAgIGxvZ0xldmVsOiBcIkVycm9yXCJcbiAgICAgICAgIH1cbiAgICAgICAgIF1cbiAgICAgICAgIH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBhcnIgPSBuZXcgSlNPTkFycmF5KCk7XG4gICAgICAgIEpTT05IZWxwZXIuX2NhdGVnb3J5VG9KU09OKGNhdCwgYXJyLCByZWN1cnNpdmUpO1xuICAgICAgICB2YXIgb2JqZWN0ID0gbmV3IEpTT05PYmplY3QoKTtcbiAgICAgICAgb2JqZWN0LmFkZEFycmF5KFwiY2F0ZWdvcmllc1wiLCBhcnIpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG4gICAgSlNPTkhlbHBlci5fY2F0ZWdvcnlUb0pTT04gPSBmdW5jdGlvbiAoY2F0LCBhcnIsIHJlY3Vyc2l2ZSkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gbmV3IEpTT05PYmplY3QoKTtcbiAgICAgICAgb2JqZWN0LmFkZE51bWJlcihcImlkXCIsIGNhdC5pZCk7XG4gICAgICAgIG9iamVjdC5hZGRTdHJpbmcoXCJuYW1lXCIsIGNhdC5uYW1lKTtcbiAgICAgICAgb2JqZWN0LmFkZFN0cmluZyhcImxvZ0xldmVsXCIsIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbFtjYXQubG9nTGV2ZWxdLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoY2F0LnBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvYmplY3QuYWRkTnVtYmVyKFwicGFyZW50XCIsIGNhdC5wYXJlbnQuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqZWN0LmFkZE51bGwoXCJwYXJlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgYXJyLmFkZChvYmplY3QpO1xuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICBjYXQuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBKU09OSGVscGVyLl9jYXRlZ29yeVRvSlNPTihjaGlsZCwgYXJyLCByZWN1cnNpdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBKU09OSGVscGVyO1xufSgpKTtcbmV4cG9ydHMuSlNPTkhlbHBlciA9IEpTT05IZWxwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1KU09OSGVscGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXNzYWdlRm9ybWF0VXRpbHMgPSB2b2lkIDA7XG52YXIgU1QgPSByZXF1aXJlKFwic3RhY2t0cmFjZS1qc1wiKTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vbG9nL0xvZ2dlck9wdGlvbnNcIik7XG4vKipcbiAqIFNvbWUgdXRpbGl0aWVzIHRvIGZvcm1hdCBtZXNzYWdlcy5cbiAqL1xudmFyIE1lc3NhZ2VGb3JtYXRVdGlscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXNzYWdlRm9ybWF0VXRpbHMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlciBnaXZlbiBkYXRlIGluIGdpdmVuIERhdGVGb3JtYXQgYW5kIHJldHVybiBhcyBTdHJpbmcuXG4gICAgICogQHBhcmFtIGRhdGUgRGF0ZVxuICAgICAqIEBwYXJhbSBkYXRlRm9ybWF0IEZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBkYXRlXG4gICAgICovXG4gICAgTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckRhdGUgPSBmdW5jdGlvbiAoZGF0ZSwgZGF0ZUZvcm1hdCkge1xuICAgICAgICB2YXIgbHBhZCA9IGZ1bmN0aW9uICh2YWx1ZSwgY2hhcnMsIHBhZFdpdGgpIHtcbiAgICAgICAgICAgIHZhciBob3dNYW55ID0gY2hhcnMgLSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaG93TWFueSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvd01hbnk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gcGFkV2l0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmdWxsWWVhciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSwgNCwgXCIwXCIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbW9udGggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxwYWQoKGQuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCksIDIsIFwiMFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRheSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldERhdGUoKS50b1N0cmluZygpLCAyLCBcIjBcIik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBob3VycyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldEhvdXJzKCkudG9TdHJpbmcoKSwgMiwgXCIwXCIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWludXRlcyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldE1pbnV0ZXMoKS50b1N0cmluZygpLCAyLCBcIjBcIik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZWNvbmRzID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBscGFkKGQuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCksIDIsIFwiMFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1pbGxpcyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldE1pbGxpc2Vjb25kcygpLnRvU3RyaW5nKCksIDMsIFwiMFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRhdGVTZXBhcmF0b3IgPSBkYXRlRm9ybWF0LmRhdGVTZXBhcmF0b3I7XG4gICAgICAgIHZhciBkcyA9IFwiXCI7XG4gICAgICAgIHN3aXRjaCAoZGF0ZUZvcm1hdC5mb3JtYXRFbnVtKSB7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0RW51bS5EZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIHl5eXktbW0tZGQgaGg6bW06c3MsbVxuICAgICAgICAgICAgICAgIGRzID0gZnVsbFllYXIoZGF0ZSkgKyBkYXRlU2VwYXJhdG9yICsgbW9udGgoZGF0ZSkgKyBkYXRlU2VwYXJhdG9yICsgZGF5KGRhdGUpICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICBob3VycyhkYXRlKSArIFwiOlwiICsgbWludXRlcyhkYXRlKSArIFwiOlwiICsgc2Vjb25kcyhkYXRlKSArIFwiLFwiICsgbWlsbGlzKGRhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuRGF0ZUZvcm1hdEVudW0uWWVhck1vbnRoRGF5VGltZTpcbiAgICAgICAgICAgICAgICBkcyA9IGZ1bGxZZWFyKGRhdGUpICsgZGF0ZVNlcGFyYXRvciArIG1vbnRoKGRhdGUpICsgZGF0ZVNlcGFyYXRvciArIGRheShkYXRlKSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgaG91cnMoZGF0ZSkgKyBcIjpcIiArIG1pbnV0ZXMoZGF0ZSkgKyBcIjpcIiArIHNlY29uZHMoZGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0RW51bS5ZZWFyRGF5TW9udGhXaXRoRnVsbFRpbWU6XG4gICAgICAgICAgICAgICAgZHMgPSBmdWxsWWVhcihkYXRlKSArIGRhdGVTZXBhcmF0b3IgKyBkYXkoZGF0ZSkgKyBkYXRlU2VwYXJhdG9yICsgbW9udGgoZGF0ZSkgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgIGhvdXJzKGRhdGUpICsgXCI6XCIgKyBtaW51dGVzKGRhdGUpICsgXCI6XCIgKyBzZWNvbmRzKGRhdGUpICsgXCIsXCIgKyBtaWxsaXMoZGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0RW51bS5ZZWFyRGF5TW9udGhUaW1lOlxuICAgICAgICAgICAgICAgIGRzID0gZnVsbFllYXIoZGF0ZSkgKyBkYXRlU2VwYXJhdG9yICsgZGF5KGRhdGUpICsgZGF0ZVNlcGFyYXRvciArIG1vbnRoKGRhdGUpICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICBob3VycyhkYXRlKSArIFwiOlwiICsgbWludXRlcyhkYXRlKSArIFwiOlwiICsgc2Vjb25kcyhkYXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0ZSBmb3JtYXQgZW51bTogXCIgKyBkYXRlRm9ybWF0LmZvcm1hdEVudW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgZ2l2ZW4gY2F0ZWdvcnkgbG9nIG1lc3NhZ2UgaW4gZGVmYXVsdCBmb3JtYXQuXG4gICAgICogQHBhcmFtIG1zZyBNZXNzYWdlIHRvIGZvcm1hdFxuICAgICAqIEBwYXJhbSBhZGRTdGFjayBJZiB0cnVlIGFkZHMgdGhlIHN0YWNrIHRvIHRoZSBvdXRwdXQsIG90aGVyd2lzZSBza2lwcyBpdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBtZXNzYWdlXG4gICAgICovXG4gICAgTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckRlZmF1bHRNZXNzYWdlID0gZnVuY3Rpb24gKG1zZywgYWRkU3RhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHZhciBsb2dGb3JtYXQgPSBtc2cubG9nRm9ybWF0O1xuICAgICAgICBpZiAobG9nRm9ybWF0LnNob3dUaW1lU3RhbXApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBNZXNzYWdlRm9ybWF0VXRpbHMucmVuZGVyRGF0ZShtc2cuZGF0ZSwgbG9nRm9ybWF0LmRhdGVGb3JtYXQpICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbFttc2cubGV2ZWxdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChtc2cuaXNSZXNvbHZlZEVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiIChyZXNvbHZlZClcIjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gXCIgXCI7XG4gICAgICAgIGlmIChsb2dGb3JtYXQuc2hvd0NhdGVnb3J5TmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiW1wiO1xuICAgICAgICAgICAgbXNnLmNhdGVnb3JpZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChpZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiwgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZS5uYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBub3JtYWwgc3RyaW5nIG1lc3NhZ2UgZmlyc3RcbiAgICAgICAgdmFyIGFjdHVhbFN0cmluZ01zZyA9IFwiXCI7XG4gICAgICAgIHZhciBkYXRhU3RyaW5nID0gXCJcIjtcbiAgICAgICAgdmFyIG1lc3NhZ2VPckxvZ0RhdGEgPSBtc2cubWVzc2FnZTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlT3JMb2dEYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhY3R1YWxTdHJpbmdNc2cgPSBtZXNzYWdlT3JMb2dEYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxvZ0RhdGEgPSBtZXNzYWdlT3JMb2dEYXRhO1xuICAgICAgICAgICAgYWN0dWFsU3RyaW5nTXNnID0gbG9nRGF0YS5tc2c7XG4gICAgICAgICAgICAvLyBXZSBkbyBoYXZlIGRhdGE/XG4gICAgICAgICAgICBpZiAobG9nRGF0YS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YVN0cmluZyA9IFwiIFtkYXRhXTogXCIgKyAobG9nRGF0YS5kcyA/IGxvZ0RhdGEuZHMobG9nRGF0YS5kYXRhKSA6IEpTT04uc3RyaW5naWZ5KGxvZ0RhdGEuZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIiBcIiArIGFjdHVhbFN0cmluZ01zZyArIFwiXCIgKyBkYXRhU3RyaW5nO1xuICAgICAgICBpZiAoYWRkU3RhY2sgJiYgbXNnLmVycm9yQXNTdGFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCIgKyBtc2cuZXJyb3JBc1N0YWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGdpdmVuIGxvZzRqIGxvZyBtZXNzYWdlIGluIGRlZmF1bHQgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBtc2cgTWVzc2FnZSB0byBmb3JtYXRcbiAgICAgKiBAcGFyYW0gYWRkU3RhY2sgSWYgdHJ1ZSBhZGRzIHRoZSBzdGFjayB0byB0aGUgb3V0cHV0LCBvdGhlcndpc2Ugc2tpcHMgaXRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBGb3JtYXR0ZWQgbWVzc2FnZVxuICAgICAqL1xuICAgIE1lc3NhZ2VGb3JtYXRVdGlscy5yZW5kZXJEZWZhdWx0TG9nNGpNZXNzYWdlID0gZnVuY3Rpb24gKG1zZywgYWRkU3RhY2spIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IG1zZy5sb2dHcm91cFJ1bGUubG9nRm9ybWF0O1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKGZvcm1hdC5zaG93VGltZVN0YW1wKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckRhdGUobXNnLmRhdGUsIGZvcm1hdC5kYXRlRm9ybWF0KSArIFwiIFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWxbbXNnLmxldmVsXS50b1VwcGVyQ2FzZSgpICsgXCIgXCI7XG4gICAgICAgIGlmIChmb3JtYXQuc2hvd0xvZ2dlck5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIltcIiArIG1zZy5sb2dnZXJOYW1lICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBub3JtYWwgc3RyaW5nIG1lc3NhZ2UgZmlyc3RcbiAgICAgICAgdmFyIGFjdHVhbFN0cmluZ01zZyA9IFwiXCI7XG4gICAgICAgIHZhciBkYXRhU3RyaW5nID0gXCJcIjtcbiAgICAgICAgaWYgKHR5cGVvZiBtc2cubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWN0dWFsU3RyaW5nTXNnID0gbXNnLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbG9nRGF0YSA9IG1zZy5tZXNzYWdlO1xuICAgICAgICAgICAgYWN0dWFsU3RyaW5nTXNnID0gbG9nRGF0YS5tc2c7XG4gICAgICAgICAgICAvLyBXZSBkbyBoYXZlIGRhdGE/XG4gICAgICAgICAgICBpZiAobG9nRGF0YS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YVN0cmluZyA9IFwiIFtkYXRhXTogXCIgKyAobG9nRGF0YS5kcyA/IGxvZ0RhdGEuZHMobG9nRGF0YS5kYXRhKSA6IEpTT04uc3RyaW5naWZ5KGxvZ0RhdGEuZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIiBcIiArIGFjdHVhbFN0cmluZ01zZyArIFwiXCIgKyBkYXRhU3RyaW5nO1xuICAgICAgICBpZiAoYWRkU3RhY2sgJiYgbXNnLmVycm9yQXNTdGFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCIgKyBtc2cuZXJyb3JBc1N0YWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZXJyb3IgYXMgc3RhY2tcbiAgICAgKiBAcGFyYW0gZXJyb3IgUmV0dXJuIGVycm9yIGFzIFByb21pc2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fFByb21pc2V9IFByb21pc2UgZm9yIHN0YWNrXG4gICAgICovXG4gICAgTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBlcnJvci5uYW1lICsgXCI6IFwiICsgZXJyb3IubWVzc2FnZSArIFwiXFxuQFwiO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgb25lIGhhcyBhIHByb21pc2UgdG9vXG4gICAgICAgICAgICBTVC5mcm9tRXJyb3IoZXJyb3IsIHsgb2ZmbGluZTogdHJ1ZSB9KS50aGVuKGZ1bmN0aW9uIChmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tTdHIgPSAoZnJhbWVzLm1hcChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfSkpLmpvaW4oXCJcXG4gIFwiKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cIiArIHN0YWNrU3RyO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVzb2x2ZXMgb3VyIHJldHVybmVkIHByb21pc2VcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gXCJVbmV4cGVjdGVkIGVycm9yIG9iamVjdCB3YXMgcGFzc2VkIGluLiBcIjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJDb3VsZCBub3QgcmVzb2x2ZSBpdCwgc3RyaW5naWZpZWQgb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2Fubm90IHN0cmluZ2lmeSBjYW4gb25seSB0ZWxsIHNvbWV0aGluZyB3YXMgd3JvbmcuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIkNvdWxkIG5vdCByZXNvbHZlIGl0IG9yIHN0cmluZ2lmeSBpdC5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VGb3JtYXRVdGlscztcbn0oKSk7XG5leHBvcnRzLk1lc3NhZ2VGb3JtYXRVdGlscyA9IE1lc3NhZ2VGb3JtYXRVdGlscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc3NhZ2VVdGlscy5qcy5tYXAiLCIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLkNzc1NlbGVjdG9yR2VuZXJhdG9yPWUoKTp0LkNzc1NlbGVjdG9yR2VuZXJhdG9yPWUoKX0oc2VsZiwoKCk9PigoKT0+e3ZhciB0PXs0MjY6KHQsZSxuKT0+e3ZhciByPW4oNTI5KTtmdW5jdGlvbiBvKHQsZSxuKXtBcnJheS5pc0FycmF5KHQpP3QucHVzaChlKTp0W25dPWV9dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlLG4saSxjPVtdO2lmKEFycmF5LmlzQXJyYXkodCkpbj1bXSxlPXQubGVuZ3RoLTE7ZWxzZXtpZihcIm9iamVjdFwiIT10eXBlb2YgdHx8bnVsbD09PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGluZyBhbiBBcnJheSBvciBhbiBPYmplY3QsIGJ1dCBgXCIrKG51bGw9PT10P1wibnVsbFwiOnR5cGVvZiB0KStcImAgcHJvdmlkZWQuXCIpO249e30saT1PYmplY3Qua2V5cyh0KSxlPWkubGVuZ3RoLTF9cmV0dXJuIGZ1bmN0aW9uIG4odSxhKXt2YXIgbCxzLGYsZDtmb3Iocz1pP2lbYV06YSxBcnJheS5pc0FycmF5KHRbc10pfHwodm9pZCAwPT09dFtzXT90W3NdPVtdOnRbc109W3Rbc11dKSxsPTA7bDx0W3NdLmxlbmd0aDtsKyspbygoZD11LGY9QXJyYXkuaXNBcnJheShkKT9bXS5jb25jYXQoZCk6cihkKSksdFtzXVtsXSxzKSxhPj1lP2MucHVzaChmKTpuKGYsYSsxKX0obiwwKSxjfX0sNTI5OnQ9Pnt0LmV4cG9ydHM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9e30sbj0wO248YXJndW1lbnRzLmxlbmd0aDtuKyspe3ZhciByPWFyZ3VtZW50c1tuXTtmb3IodmFyIG8gaW4gcillLmNhbGwocixvKSYmKHRbb109cltvXSl9cmV0dXJuIHR9O3ZhciBlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHl9fSxlPXt9O2Z1bmN0aW9uIG4ocil7dmFyIG89ZVtyXTtpZih2b2lkIDAhPT1vKXJldHVybiBvLmV4cG9ydHM7dmFyIGk9ZVtyXT17ZXhwb3J0czp7fX07cmV0dXJuIHRbcl0oaSxpLmV4cG9ydHMsbiksaS5leHBvcnRzfW4uZD0odCxlKT0+e2Zvcih2YXIgciBpbiBlKW4ubyhlLHIpJiYhbi5vKHQscikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIse2VudW1lcmFibGU6ITAsZ2V0OmVbcl19KX0sbi5vPSh0LGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSxuLnI9dD0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9O3ZhciByPXt9O3JldHVybigoKT0+e1widXNlIHN0cmljdFwiO24ucihyKSxuLmQocix7ZGVmYXVsdDooKT0+SyxnZXRDc3NTZWxlY3RvcjooKT0+Sn0pO3ZhciB0LGUsbz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sP1wic3ltYm9sXCI6dHlwZW9mIHR9O2Z1bmN0aW9uIGkodCl7cmV0dXJuIG51bGwhPXQmJlwib2JqZWN0XCI9PT0odm9pZCAwPT09dD9cInVuZGVmaW5lZFwiOm8odCkpJiYxPT09dC5ub2RlVHlwZSYmXCJvYmplY3RcIj09PW8odC5zdHlsZSkmJlwib2JqZWN0XCI9PT1vKHQub3duZXJEb2N1bWVudCl9ZnVuY3Rpb24gYyh0PVwidW5rbm93biBwcm9ibGVtXCIsLi4uZSl7Y29uc29sZS53YXJuKGBDc3NTZWxlY3RvckdlbmVyYXRvcjogJHt0fWAsLi4uZSl9IWZ1bmN0aW9uKHQpe3QuTk9ORT1cIm5vbmVcIix0LkRFU0NFTkRBTlQ9XCJkZXNjZW5kYW50XCIsdC5DSElMRD1cImNoaWxkXCJ9KHR8fCh0PXt9KSksZnVuY3Rpb24odCl7dC5pZD1cImlkXCIsdC5jbGFzcz1cImNsYXNzXCIsdC50YWc9XCJ0YWdcIix0LmF0dHJpYnV0ZT1cImF0dHJpYnV0ZVwiLHQubnRoY2hpbGQ9XCJudGhjaGlsZFwiLHQubnRob2Z0eXBlPVwibnRob2Z0eXBlXCJ9KGV8fChlPXt9KSk7Y29uc3QgdT17c2VsZWN0b3JzOltlLmlkLGUuY2xhc3MsZS50YWcsZS5hdHRyaWJ1dGVdLGluY2x1ZGVUYWc6ITEsd2hpdGVsaXN0OltdLGJsYWNrbGlzdDpbXSxjb21iaW5lV2l0aGluU2VsZWN0b3I6ITAsY29tYmluZUJldHdlZW5TZWxlY3RvcnM6ITAscm9vdDpudWxsLG1heENvbWJpbmF0aW9uczpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksbWF4Q2FuZGlkYXRlczpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9O2Z1bmN0aW9uIGEodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBSZWdFeHB9ZnVuY3Rpb24gbCh0KXtyZXR1cm5bXCJzdHJpbmdcIixcImZ1bmN0aW9uXCJdLmluY2x1ZGVzKHR5cGVvZiB0KXx8YSh0KX1mdW5jdGlvbiBzKHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpP3QuZmlsdGVyKGwpOltdfWZ1bmN0aW9uIGYodCl7Y29uc3QgZT1bTm9kZS5ET0NVTUVOVF9OT0RFLE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSxOb2RlLkVMRU1FTlRfTk9ERV07cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgTm9kZX0odCkmJmUuaW5jbHVkZXModC5ub2RlVHlwZSl9ZnVuY3Rpb24gZCh0LGUpe2lmKGYodCkpcmV0dXJuIHQuY29udGFpbnMoZSl8fGMoXCJlbGVtZW50IHJvb3QgbWlzbWF0Y2hcIixcIlByb3ZpZGVkIHJvb3QgZG9lcyBub3QgY29udGFpbiB0aGUgZWxlbWVudC4gVGhpcyB3aWxsIG1vc3QgbGlrZWx5IHJlc3VsdCBpbiBwcm9kdWNpbmcgYSBmYWxsYmFjayBzZWxlY3RvciB1c2luZyBlbGVtZW50J3MgcmVhbCByb290IG5vZGUuIElmIHlvdSBwbGFuIHRvIHVzZSB0aGUgc2VsZWN0b3IgdXNpbmcgcHJvdmlkZWQgcm9vdCAoZS5nLiBgcm9vdC5xdWVyeVNlbGVjdG9yYCksIGl0IHdpbGwgbnRvIHdvcmsgYXMgaW50ZW5kZWQuXCIpLHQ7Y29uc3Qgbj1lLmdldFJvb3ROb2RlKHtjb21wb3NlZDohMX0pO3JldHVybiBmKG4pPyhuIT09ZG9jdW1lbnQmJmMoXCJzaGFkb3cgcm9vdCBpbmZlcnJlZFwiLFwiWW91IGRpZCBub3QgcHJvdmlkZSBhIHJvb3QgYW5kIHRoZSBlbGVtZW50IGlzIGEgY2hpbGQgb2YgU2hhZG93IERPTS4gVGhpcyB3aWxsIHByb2R1Y2UgYSBzZWxlY3RvciB1c2luZyBTaGFkb3dSb290IGFzIGEgcm9vdC4gSWYgeW91IHBsYW4gdG8gdXNlIHRoZSBzZWxlY3RvciB1c2luZyBkb2N1bWVudCBhcyBhIHJvb3QgKGUuZy4gYGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JgKSwgaXQgd2lsbCBub3Qgd29yayBhcyBpbnRlbmRlZC5cIiksbik6ZS5vd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCI6cm9vdFwiKX1mdW5jdGlvbiBwKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0P3Q6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfWZ1bmN0aW9uIG0odD1bXSl7Y29uc3RbZT1bXSwuLi5uXT10O3JldHVybiAwPT09bi5sZW5ndGg/ZTpuLnJlZHVjZSgoKHQsZSk9PnQuZmlsdGVyKCh0PT5lLmluY2x1ZGVzKHQpKSkpLGUpfWZ1bmN0aW9uIGgodCl7cmV0dXJuW10uY29uY2F0KC4uLnQpfWZ1bmN0aW9uIHkodCl7Y29uc3QgZT10Lm1hcCgodD0+e2lmKGEodCkpcmV0dXJuIGU9PnQudGVzdChlKTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KXJldHVybiBlPT57Y29uc3Qgbj10KGUpO3JldHVyblwiYm9vbGVhblwiIT10eXBlb2Ygbj8oYyhcInBhdHRlcm4gbWF0Y2hlciBmdW5jdGlvbiBpbnZhbGlkXCIsXCJQcm92aWRlZCBwYXR0ZXJuIG1hdGNoaW5nIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBib29sZWFuLiBJdCdzIHJlc3VsdCB3aWxsIGJlIGlnbm9yZWQuXCIsdCksITEpOm59O2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXtjb25zdCBlPW5ldyBSZWdFeHAoXCJeXCIrdC5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLFwiXFxcXCQmXCIpLnJlcGxhY2UoL1xcKi9nLFwiLitcIikrXCIkXCIpO3JldHVybiB0PT5lLnRlc3QodCl9cmV0dXJuIGMoXCJwYXR0ZXJuIG1hdGNoZXIgaW52YWxpZFwiLFwiUGF0dGVybiBtYXRjaGluZyBvbmx5IGFjY2VwdHMgc3RyaW5ncywgcmVndWxhciBleHByZXNzaW9ucyBhbmQvb3IgZnVuY3Rpb25zLiBUaGlzIGl0ZW0gaXMgaW52YWxpZCBhbmQgd2lsbCBiZSBpZ25vcmVkLlwiLHQpLCgpPT4hMX0pKTtyZXR1cm4gdD0+ZS5zb21lKChlPT5lKHQpKSl9ZnVuY3Rpb24gZyh0LGUsbil7Y29uc3Qgcj1BcnJheS5mcm9tKGQobix0WzBdKS5xdWVyeVNlbGVjdG9yQWxsKGUpKTtyZXR1cm4gci5sZW5ndGg9PT10Lmxlbmd0aCYmdC5ldmVyeSgodD0+ci5pbmNsdWRlcyh0KSkpfWZ1bmN0aW9uIGIodCxlKXtlPW51bGwhPWU/ZTpmdW5jdGlvbih0KXtyZXR1cm4gdC5vd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCI6cm9vdFwiKX0odCk7Y29uc3Qgbj1bXTtsZXQgcj10O2Zvcig7aShyKSYmciE9PWU7KW4ucHVzaChyKSxyPXIucGFyZW50RWxlbWVudDtyZXR1cm4gbn1mdW5jdGlvbiBOKHQsZSl7cmV0dXJuIG0odC5tYXAoKHQ9PmIodCxlKSkpKX1jb25zdCB2PXtbdC5OT05FXTp7dHlwZTp0Lk5PTkUsdmFsdWU6XCJcIn0sW3QuREVTQ0VOREFOVF06e3R5cGU6dC5ERVNDRU5EQU5ULHZhbHVlOlwiID4gXCJ9LFt0LkNISUxEXTp7dHlwZTp0LkNISUxELHZhbHVlOlwiIFwifX0sUz1uZXcgUmVnRXhwKFtcIl4kXCIsXCJcXFxcc1wiXS5qb2luKFwifFwiKSksRT1uZXcgUmVnRXhwKFtcIl4kXCJdLmpvaW4oXCJ8XCIpKSx3PVtlLm50aG9mdHlwZSxlLnRhZyxlLmlkLGUuY2xhc3MsZS5hdHRyaWJ1dGUsZS5udGhjaGlsZF07dmFyIHg9big0MjYpO2NvbnN0IEE9eShbXCJjbGFzc1wiLFwiaWRcIixcIm5nLSpcIl0pO2Z1bmN0aW9uIEMoe25vZGVOYW1lOnR9KXtyZXR1cm5gWyR7dH1dYH1mdW5jdGlvbiBPKHtub2RlTmFtZTp0LG5vZGVWYWx1ZTplfSl7cmV0dXJuYFske3R9PScke0YoZSl9J11gfWZ1bmN0aW9uIFQodCl7Y29uc3QgZT1BcnJheS5mcm9tKHQuYXR0cmlidXRlcykuZmlsdGVyKChlPT5mdW5jdGlvbih7bm9kZU5hbWU6dH0sZSl7Y29uc3Qgbj1lLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4hKFtcImlucHV0XCIsXCJvcHRpb25cIl0uaW5jbHVkZXMobikmJlwidmFsdWVcIj09PXR8fEEodCkpfShlLHQpKSk7cmV0dXJuWy4uLmUubWFwKEMpLC4uLmUubWFwKE8pXX1mdW5jdGlvbiBJKHQpe3JldHVybih0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwiKS50cmltKCkuc3BsaXQoL1xccysvKS5maWx0ZXIoKHQ9PiFFLnRlc3QodCkpKS5tYXAoKHQ9PmAuJHtGKHQpfWApKX1mdW5jdGlvbiBqKHQpe2NvbnN0IGU9dC5nZXRBdHRyaWJ1dGUoXCJpZFwiKXx8XCJcIixuPWAjJHtGKGUpfWAscj10LmdldFJvb3ROb2RlKHtjb21wb3NlZDohMX0pO3JldHVybiFTLnRlc3QoZSkmJmcoW3RdLG4scik/W25dOltdfWZ1bmN0aW9uIEQodCl7Y29uc3QgZT10LnBhcmVudE5vZGU7aWYoZSl7Y29uc3Qgbj1BcnJheS5mcm9tKGUuY2hpbGROb2RlcykuZmlsdGVyKGkpLmluZGV4T2YodCk7aWYobj4tMSlyZXR1cm5bYDpudGgtY2hpbGQoJHtuKzF9KWBdfXJldHVybltdfWZ1bmN0aW9uICQodCl7cmV0dXJuW0YodC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXX1mdW5jdGlvbiBQKHQpe2NvbnN0IGU9Wy4uLm5ldyBTZXQoaCh0Lm1hcCgkKSkpXTtyZXR1cm4gMD09PWUubGVuZ3RofHxlLmxlbmd0aD4xP1tdOltlWzBdXX1mdW5jdGlvbiBSKHQpe2NvbnN0IGU9UChbdF0pWzBdLG49dC5wYXJlbnRFbGVtZW50O2lmKG4pe2NvbnN0IHI9QXJyYXkuZnJvbShuLmNoaWxkcmVuKS5maWx0ZXIoKHQ9PnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT09ZSkpLG89ci5pbmRleE9mKHQpO2lmKG8+LTEpcmV0dXJuW2Ake2V9Om50aC1vZi10eXBlKCR7bysxfSlgXX1yZXR1cm5bXX1mdW5jdGlvbiBrKHQ9W10se21heFJlc3VsdHM6ZT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9PXt9KXtjb25zdCBuPVtdO2xldCByPTAsbz1MKDEpO2Zvcig7by5sZW5ndGg8PXQubGVuZ3RoJiZyPGU7KXIrPTEsbi5wdXNoKG8ubWFwKChlPT50W2VdKSkpLG89XyhvLHQubGVuZ3RoLTEpO3JldHVybiBufWZ1bmN0aW9uIF8odD1bXSxlPTApe2NvbnN0IG49dC5sZW5ndGg7aWYoMD09PW4pcmV0dXJuW107Y29uc3Qgcj1bLi4udF07cltuLTFdKz0xO2ZvcihsZXQgdD1uLTE7dD49MDt0LS0paWYoclt0XT5lKXtpZigwPT09dClyZXR1cm4gTChuKzEpO3JbdC0xXSsrLHJbdF09clt0LTFdKzF9cmV0dXJuIHJbbi0xXT5lP0wobisxKTpyfWZ1bmN0aW9uIEwodD0xKXtyZXR1cm4gQXJyYXkuZnJvbShBcnJheSh0KS5rZXlzKCkpfWNvbnN0IE09XCI6XCIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSxxPS9bICFcIiMkJSYnKClcXFtcXF17fH08PiorLC4vOz0/QF5gflxcXFxdLztmdW5jdGlvbiBGKHQ9XCJcIil7dmFyIGUsbjtyZXR1cm4gbnVsbCE9PShuPW51bGw9PT0oZT1udWxsPT09Q1NTfHx2b2lkIDA9PT1DU1M/dm9pZCAwOkNTUy5lc2NhcGUpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmNhbGwoQ1NTLHQpKSYmdm9pZCAwIT09bj9uOmZ1bmN0aW9uKHQ9XCJcIil7cmV0dXJuIHQuc3BsaXQoXCJcIikubWFwKCh0PT5cIjpcIj09PXQ/YFxcXFwke019IGA6cS50ZXN0KHQpP2BcXFxcJHt0fWA6ZXNjYXBlKHQpLnJlcGxhY2UoLyUvZyxcIlxcXFxcIikpKS5qb2luKFwiXCIpfSh0KX1jb25zdCBWPXt0YWc6UCxpZDpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQubGVuZ3RofHx0Lmxlbmd0aD4xP1tdOmoodFswXSl9LGNsYXNzOmZ1bmN0aW9uKHQpe3JldHVybiBtKHQubWFwKEkpKX0sYXR0cmlidXRlOmZ1bmN0aW9uKHQpe3JldHVybiBtKHQubWFwKFQpKX0sbnRoY2hpbGQ6ZnVuY3Rpb24odCl7cmV0dXJuIG0odC5tYXAoRCkpfSxudGhvZnR5cGU6ZnVuY3Rpb24odCl7cmV0dXJuIG0odC5tYXAoUikpfX0sWT17dGFnOiQsaWQ6aixjbGFzczpJLGF0dHJpYnV0ZTpULG50aGNoaWxkOkQsbnRob2Z0eXBlOlJ9O2Z1bmN0aW9uIEIodCl7cmV0dXJuIHQuaW5jbHVkZXMoZS50YWcpfHx0LmluY2x1ZGVzKGUubnRob2Z0eXBlKT9bLi4udF06Wy4uLnQsZS50YWddfWZ1bmN0aW9uIEcodD17fSl7Y29uc3Qgbj1bLi4ud107cmV0dXJuIHRbZS50YWddJiZ0W2UubnRob2Z0eXBlXSYmbi5zcGxpY2Uobi5pbmRleE9mKGUudGFnKSwxKSxuLm1hcCgoZT0+e3JldHVybihyPXQpW249ZV0/cltuXS5qb2luKFwiXCIpOlwiXCI7dmFyIG4scn0pKS5qb2luKFwiXCIpfWZ1bmN0aW9uIFcodCxlLG49XCJcIixyKXtjb25zdCBvPWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJcIj09PWU/dDpmdW5jdGlvbih0LGUpe3JldHVyblsuLi50Lm1hcCgodD0+ZStcIiBcIit0KSksLi4udC5tYXAoKHQ9PmUrXCIgPiBcIit0KSldfSh0LGUpfShmdW5jdGlvbih0LGUsbil7Y29uc3Qgcj1mdW5jdGlvbih0LGUpe2NvbnN0e2JsYWNrbGlzdDpuLHdoaXRlbGlzdDpyLGNvbWJpbmVXaXRoaW5TZWxlY3RvcjpvLG1heENvbWJpbmF0aW9uczppfT1lLGM9eShuKSx1PXkocik7cmV0dXJuIGZ1bmN0aW9uKHQpe2NvbnN0e3NlbGVjdG9yczplLGluY2x1ZGVUYWc6bn09dCxyPVtdLmNvbmNhdChlKTtyZXR1cm4gbiYmIXIuaW5jbHVkZXMoXCJ0YWdcIikmJnIucHVzaChcInRhZ1wiKSxyfShlKS5yZWR1Y2UoKChlLG4pPT57Y29uc3Qgcj1mdW5jdGlvbih0LGUpe3ZhciBuO3JldHVybihudWxsIT09KG49VltlXSkmJnZvaWQgMCE9PW4/bjooKT0+W10pKHQpfSh0LG4pLGE9ZnVuY3Rpb24odD1bXSxlLG4pe3JldHVybiB0LmZpbHRlcigodD0+bih0KXx8IWUodCkpKX0ocixjLHUpLGw9ZnVuY3Rpb24odD1bXSxlKXtyZXR1cm4gdC5zb3J0KCgodCxuKT0+e2NvbnN0IHI9ZSh0KSxvPWUobik7cmV0dXJuIHImJiFvPy0xOiFyJiZvPzE6MH0pKX0oYSx1KTtyZXR1cm4gZVtuXT1vP2sobCx7bWF4UmVzdWx0czppfSk6bC5tYXAoKHQ9Plt0XSkpLGV9KSx7fSl9KHQsbiksbz1mdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbih0KXtjb25zdHtzZWxlY3RvcnM6ZSxjb21iaW5lQmV0d2VlblNlbGVjdG9yczpuLGluY2x1ZGVUYWc6cixtYXhDYW5kaWRhdGVzOm99PXQsaT1uP2soZSx7bWF4UmVzdWx0czpvfSk6ZS5tYXAoKHQ9Plt0XSkpO3JldHVybiByP2kubWFwKEIpOml9KGUpLm1hcCgoZT0+ZnVuY3Rpb24odCxlKXtjb25zdCBuPXt9O3JldHVybiB0LmZvckVhY2goKHQ9Pntjb25zdCByPWVbdF07ci5sZW5ndGg+MCYmKG5bdF09cil9KSkseChuKS5tYXAoRyl9KGUsdCkpKS5maWx0ZXIoKHQ9PnQubGVuZ3RoPjApKX0ocixuKSxpPWgobyk7cmV0dXJuWy4uLm5ldyBTZXQoaSldfSh0LHIucm9vdCxyKSxuKTtmb3IoY29uc3QgZSBvZiBvKWlmKGcodCxlLHIucm9vdCkpcmV0dXJuIGU7cmV0dXJuIG51bGx9ZnVuY3Rpb24gSCh0KXtyZXR1cm57dmFsdWU6dCxpbmNsdWRlOiExfX1mdW5jdGlvbiBVKHtzZWxlY3RvcnM6dCxvcGVyYXRvcjpufSl7bGV0IHI9Wy4uLnddO3RbZS50YWddJiZ0W2UubnRob2Z0eXBlXSYmKHI9ci5maWx0ZXIoKHQ9PnQhPT1lLnRhZykpKTtsZXQgbz1cIlwiO3JldHVybiByLmZvckVhY2goKGU9PnsodFtlXXx8W10pLmZvckVhY2goKCh7dmFsdWU6dCxpbmNsdWRlOmV9KT0+e2UmJihvKz10KX0pKX0pKSxuLnZhbHVlK299ZnVuY3Rpb24geihuKXtyZXR1cm5bXCI6cm9vdFwiLC4uLmIobikucmV2ZXJzZSgpLm1hcCgobj0+e2NvbnN0IHI9ZnVuY3Rpb24oZSxuLHI9dC5OT05FKXtjb25zdCBvPXt9O3JldHVybiBuLmZvckVhY2goKHQ9PntSZWZsZWN0LnNldChvLHQsZnVuY3Rpb24odCxlKXtyZXR1cm4gWVtlXSh0KX0oZSx0KS5tYXAoSCkpfSkpLHtlbGVtZW50OmUsb3BlcmF0b3I6dltyXSxzZWxlY3RvcnM6b319KG4sW2UubnRoY2hpbGRdLHQuREVTQ0VOREFOVCk7cmV0dXJuIHIuc2VsZWN0b3JzLm50aGNoaWxkLmZvckVhY2goKHQ9Pnt0LmluY2x1ZGU9ITB9KSkscn0pKS5tYXAoVSldLmpvaW4oXCJcIil9ZnVuY3Rpb24gSih0LG49e30pe2NvbnN0IHI9ZnVuY3Rpb24odCl7Y29uc3QgZT0oQXJyYXkuaXNBcnJheSh0KT90Olt0XSkuZmlsdGVyKGkpO3JldHVyblsuLi5uZXcgU2V0KGUpXX0odCksbz1mdW5jdGlvbih0LG49e30pe2NvbnN0IHI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLG4pO3JldHVybntzZWxlY3RvcnM6KG89ci5zZWxlY3RvcnMsQXJyYXkuaXNBcnJheShvKT9vLmZpbHRlcigodD0+e3JldHVybiBuPWUscj10LE9iamVjdC52YWx1ZXMobikuaW5jbHVkZXMocik7dmFyIG4scn0pKTpbXSksd2hpdGVsaXN0OnMoci53aGl0ZWxpc3QpLGJsYWNrbGlzdDpzKHIuYmxhY2tsaXN0KSxyb290OmQoci5yb290LHQpLGNvbWJpbmVXaXRoaW5TZWxlY3RvcjohIXIuY29tYmluZVdpdGhpblNlbGVjdG9yLGNvbWJpbmVCZXR3ZWVuU2VsZWN0b3JzOiEhci5jb21iaW5lQmV0d2VlblNlbGVjdG9ycyxpbmNsdWRlVGFnOiEhci5pbmNsdWRlVGFnLG1heENvbWJpbmF0aW9uczpwKHIubWF4Q29tYmluYXRpb25zKSxtYXhDYW5kaWRhdGVzOnAoci5tYXhDYW5kaWRhdGVzKX07dmFyIG99KHJbMF0sbik7bGV0IGM9XCJcIixhPW8ucm9vdDtmdW5jdGlvbiBsKCl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuPVwiXCIscil7aWYoMD09PXQubGVuZ3RoKXJldHVybiBudWxsO2NvbnN0IG89W3QubGVuZ3RoPjE/dDpbXSwuLi5OKHQsZSkubWFwKCh0PT5bdF0pKV07Zm9yKGNvbnN0IHQgb2Ygbyl7Y29uc3QgZT1XKHQsMCxuLHIpO2lmKGUpcmV0dXJue2ZvdW5kRWxlbWVudHM6dCxzZWxlY3RvcjplfX1yZXR1cm4gbnVsbH0ocixhLGMsbyl9bGV0IGY9bCgpO2Zvcig7Zjspe2NvbnN0e2ZvdW5kRWxlbWVudHM6dCxzZWxlY3RvcjplfT1mO2lmKGcocixlLG8ucm9vdCkpcmV0dXJuIGU7YT10WzBdLGM9ZSxmPWwoKX1yZXR1cm4gci5sZW5ndGg+MT9yLm1hcCgodD0+Sih0LG8pKSkuam9pbihcIiwgXCIpOmZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcCh6KS5qb2luKFwiLCBcIil9KHIpfWNvbnN0IEs9Sn0pKCkscn0pKCkpKTsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2luZGV4LnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9