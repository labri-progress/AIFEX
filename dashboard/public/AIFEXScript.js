/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/error-stack-parser/error-stack-parser.js":
/*!***************************************************************!*\
  !*** ./node_modules/error-stack-parser/error-stack-parser.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function ErrorStackParser(StackFrame) {
    'use strict';

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;

    function _map(array, fn, thisArg) {
        if (typeof Array.prototype.map === 'function') {
            return array.map(fn, thisArg);
        } else {
            var output = new Array(array.length);
            for (var i = 0; i < array.length; i++) {
                output[i] = fn.call(thisArg, array[i]);
            }
            return output;
        }
    }

    function _filter(array, fn, thisArg) {
        if (typeof Array.prototype.filter === 'function') {
            return array.filter(fn, thisArg);
        } else {
            var output = [];
            for (var i = 0; i < array.length; i++) {
                if (fn.call(thisArg, array[i])) {
                    output.push(array[i]);
                }
            }
            return output;
        }
    }

    function _indexOf(array, target) {
        if (typeof Array.prototype.indexOf === 'function') {
            return array.indexOf(target);
        } else {
            for (var i = 0; i < array.length; i++) {
                if (array[i] === target) {
                    return i;
                }
            }
            return -1;
        }
    }

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = _filter(error.stack.split('\n'), function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return _map(filtered, function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
                }
                var tokens = line.replace(/^\s+/, '').replace(/\(eval code/g, '(').split(/\s+/).slice(1);
                var locationParts = this.extractLocation(tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = _indexOf(['eval', '<anonymous>'], locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame(functionName, undefined, fileName, locationParts[1], locationParts[2], line);
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = _filter(error.stack.split('\n'), function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return _map(filtered, function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame(line);
                } else {
                    var tokens = line.split('@');
                    var locationParts = this.extractLocation(tokens.pop());
                    var functionName = tokens.join('@') || undefined;
                    return new StackFrame(functionName,
                        undefined,
                        locationParts[0],
                        locationParts[1],
                        locationParts[2],
                        line);
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame(undefined, undefined, match[2], match[1], undefined, lines[i]));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame(
                            match[3] || undefined,
                            undefined,
                            match[2],
                            match[1],
                            undefined,
                            lines[i]
                        )
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = _filter(error.stack.split('\n'), function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return _map(filtered, function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                        .replace(/<anonymous function(: (\w+))?>/, '$2')
                        .replace(/\([^\)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^\)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');
                return new StackFrame(
                    functionName,
                    args,
                    locationParts[0],
                    locationParts[1],
                    locationParts[2],
                    line);
            }, this);
        }
    };
}));



/***/ }),

/***/ "./node_modules/query-selector-shadow-dom/src/normalize.js":
/*!*****************************************************************!*\
  !*** ./node_modules/query-selector-shadow-dom/src/normalize.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normalizeSelector": () => (/* binding */ normalizeSelector)
/* harmony export */ });
/* istanbul ignore file */


// normalize-selector-rev-02.js
/*
  author: kyle simpson (@getify)
  original source: https://gist.github.com/getify/9679380

  modified for tests by david kaye (@dfkaye)
  21 march 2014

  rev-02 incorporate kyle's changes 3/2/42014
*/

function normalizeSelector(sel) {
  // save unmatched text, if any
  function saveUnmatched() {
    if (unmatched) {
      // whitespace needed after combinator?
      if (tokens.length > 0 && /^[~+>]$/.test(tokens[tokens.length - 1])) {
        tokens.push(" ");
      }

      // save unmatched text
      tokens.push(unmatched);
    }
  }

  var tokens = [],
    match,
    unmatched,
    regex,
    state = [0],
    next_match_idx = 0,
    prev_match_idx,
    not_escaped_pattern = /(?:[^\\]|(?:^|[^\\])(?:\\\\)+)$/,
    whitespace_pattern = /^\s+$/,
    state_patterns = [
      /\s+|\/\*|["'>~+[(]/g, // general
      /\s+|\/\*|["'[\]()]/g, // [..] set
      /\s+|\/\*|["'[\]()]/g, // (..) set
      null, // string literal (placeholder)
      /\*\//g, // comment
    ];
  sel = sel.trim();

  // eslint-disable-next-line no-constant-condition
  while (true) {
    unmatched = "";

    regex = state_patterns[state[state.length - 1]];

    regex.lastIndex = next_match_idx;
    match = regex.exec(sel);

    // matched text to process?
    if (match) {
      prev_match_idx = next_match_idx;
      next_match_idx = regex.lastIndex;

      // collect the previous string chunk not matched before this token
      if (prev_match_idx < next_match_idx - match[0].length) {
        unmatched = sel.substring(
          prev_match_idx,
          next_match_idx - match[0].length
        );
      }

      // general, [ ] pair, ( ) pair?
      if (state[state.length - 1] < 3) {
        saveUnmatched();

        // starting a [ ] pair?
        if (match[0] === "[") {
          state.push(1);
        }
        // starting a ( ) pair?
        else if (match[0] === "(") {
          state.push(2);
        }
        // starting a string literal?
        else if (/^["']$/.test(match[0])) {
          state.push(3);
          state_patterns[3] = new RegExp(match[0], "g");
        }
        // starting a comment?
        else if (match[0] === "/*") {
          state.push(4);
        }
        // ending a [ ] or ( ) pair?
        else if (/^[\])]$/.test(match[0]) && state.length > 0) {
          state.pop();
        }
        // handling whitespace or a combinator?
        else if (/^(?:\s+|[~+>])$/.test(match[0])) {
          // need to insert whitespace before?
          if (
            tokens.length > 0 &&
            !whitespace_pattern.test(tokens[tokens.length - 1]) &&
            state[state.length - 1] === 0
          ) {
            // add normalized whitespace
            tokens.push(" ");
          }

          // case-insensitive attribute selector CSS L4
          if (
            state[state.length - 1] === 1 &&
            tokens.length === 5 &&
            tokens[2].charAt(tokens[2].length - 1) === "="
          ) {
            tokens[4] = " " + tokens[4];
          }

          // whitespace token we can skip?
          if (whitespace_pattern.test(match[0])) {
            continue;
          }
        }

        // save matched text
        tokens.push(match[0]);
      }
      // otherwise, string literal or comment
      else {
        // save unmatched text
        tokens[tokens.length - 1] += unmatched;

        // unescaped terminator to string literal or comment?
        if (not_escaped_pattern.test(tokens[tokens.length - 1])) {
          // comment terminator?
          if (state[state.length - 1] === 4) {
            // ok to drop comment?
            if (
              tokens.length < 2 ||
              whitespace_pattern.test(tokens[tokens.length - 2])
            ) {
              tokens.pop();
            }
            // otherwise, turn comment into whitespace
            else {
              tokens[tokens.length - 1] = " ";
            }

            // handled already
            match[0] = "";
          }

          state.pop();
        }

        // append matched text to existing token
        tokens[tokens.length - 1] += match[0];
      }
    }
    // otherwise, end of processing (no more matches)
    else {
      unmatched = sel.substr(next_match_idx);
      saveUnmatched();

      break;
    }
  }

  return tokens.join("").trim();
}


/***/ }),

/***/ "./node_modules/query-selector-shadow-dom/src/querySelectorDeep.js":
/*!*************************************************************************!*\
  !*** ./node_modules/query-selector-shadow-dom/src/querySelectorDeep.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "querySelectorAllDeep": () => (/* binding */ querySelectorAllDeep),
/* harmony export */   "querySelectorDeep": () => (/* binding */ querySelectorDeep),
/* harmony export */   "collectAllElementsDeep": () => (/* binding */ collectAllElementsDeep)
/* harmony export */ });
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normalize */ "./node_modules/query-selector-shadow-dom/src/normalize.js");
/**
 * @author Georgegriff@ (George Griffiths)
 * License Apache-2.0
 */



/**
* Finds first matching elements on the page that may be in a shadow root using a complex selector of n-depth
*
* Don't have to specify all shadow roots to button, tree is travered to find the correct element
*
* Example querySelectorAllDeep('downloads-item:nth-child(4) #remove');
*
* Example should work on chrome://downloads outputting the remove button inside of a download card component
*
* Example find first active download link element querySelectorDeep('#downloads-list .is-active a[href^="https://"]');
*
* Another example querySelectorAllDeep('#downloads-list div#title-area + a');
e.g.
*/
function querySelectorAllDeep(selector, root = document, allElements = null) {
    return _querySelectorDeep(selector, true, root, allElements);
}

function querySelectorDeep(selector, root = document, allElements = null) {
    return _querySelectorDeep(selector, false, root, allElements);
}

function _querySelectorDeep(selector, findMany, root, allElements = null) {
    selector = (0,_normalize__WEBPACK_IMPORTED_MODULE_0__.normalizeSelector)(selector);
    let lightElement = root.querySelector(selector);

    if (document.head.createShadowRoot || document.head.attachShadow) {
        // no need to do any special if selector matches something specific in light-dom
        if (!findMany && lightElement) {
            return lightElement;
        }

        // split on commas because those are a logical divide in the operation
        const selectionsToMake = splitByCharacterUnlessQuoted(selector, ',');

        return selectionsToMake.reduce((acc, minimalSelector) => {
            // if not finding many just reduce the first match
            if (!findMany && acc) {
                return acc;
            }
            // do best to support complex selectors and split the query
            const splitSelector = splitByCharacterUnlessQuoted(minimalSelector
                    //remove white space at start of selector
                    .replace(/^\s+/g, '')
                    .replace(/\s*([>+~]+)\s*/g, '$1'), ' ')
                    // filter out entry white selectors
                    .filter((entry) => !!entry)
                    // convert "a > b" to ["a", "b"]
                    .map((entry) => splitByCharacterUnlessQuoted(entry, '>'));

            const possibleElementsIndex = splitSelector.length - 1;
            const lastSplitPart = splitSelector[possibleElementsIndex][splitSelector[possibleElementsIndex].length - 1];
            const possibleElements = collectAllElementsDeep(lastSplitPart, root, allElements);
            const findElements = findMatchingElement(splitSelector, possibleElementsIndex, root);
            if (findMany) {
                acc = acc.concat(possibleElements.filter(findElements));
                return acc;
            } else {
                acc = possibleElements.find(findElements);
                return acc || null;
            }
        }, findMany ? [] : null);


    } else {
        if (!findMany) {
            return lightElement;
        } else {
            return root.querySelectorAll(selector);
        }
    }

}

function findMatchingElement(splitSelector, possibleElementsIndex, root) {
    return (element) => {
        let position = possibleElementsIndex;
        let parent = element;
        let foundElement = false;
        while (parent && !isDocumentNode(parent)) {
            let foundMatch = true;
            if (splitSelector[position].length === 1) {
                foundMatch = parent.matches(splitSelector[position]);
            } else {
                // selector is in the format "a > b"
                // make sure a few parents match in order
                const reversedParts = ([]).concat(splitSelector[position]).reverse();
                let newParent = parent;
                for (const part of reversedParts) {
                    if (!newParent || !newParent.matches(part)) {
                        foundMatch = false;
                        break;
                    }
                    newParent = findParentOrHost(newParent, root);
                }
            }

            if (foundMatch && position === 0) {
                foundElement = true;
                break;
            }
            if (foundMatch) {
                position--;
            }
            parent = findParentOrHost(parent, root);
        }
        return foundElement;
    };

}

function splitByCharacterUnlessQuoted(selector, character) {
    return selector.match(/\\?.|^$/g).reduce((p, c) => {
        if (c === '"' && !p.sQuote) {
            p.quote ^= 1;
            p.a[p.a.length - 1] += c;
        } else if (c === '\'' && !p.quote) {
            p.sQuote ^= 1;
            p.a[p.a.length - 1] += c;

        } else if (!p.quote && !p.sQuote && c === character) {
            p.a.push('');
        } else {
            p.a[p.a.length - 1] += c;
        }
        return p;
    }, { a: [''] }).a;
}

/**
 * Checks if the node is a document node or not.
 * @param {Node} node
 * @returns {node is Document | DocumentFragment}
 */
function isDocumentNode(node) {
    return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.DOCUMENT_NODE;
}

function findParentOrHost(element, root) {
    const parentNode = element.parentNode;
    return (parentNode && parentNode.host && parentNode.nodeType === 11) ? parentNode.host : parentNode === root ? null : parentNode;
}

/**
 * Finds all elements on the page, inclusive of those within shadow roots.
 * @param {string=} selector Simple selector to filter the elements by. e.g. 'a', 'div.main'
 * @return {!Array<string>} List of anchor hrefs.
 * @author ebidel@ (Eric Bidelman)
 * License Apache-2.0
 */
function collectAllElementsDeep(selector = null, root, cachedElements = null) {
    let allElements = [];

    if (cachedElements) {
        allElements = cachedElements;
    } else {
        const findAllElements = function(nodes) {
            for (let i = 0; i < nodes.length; i++) {
                const el = nodes[i];
                allElements.push(el);
                // If the element has a shadow root, dig deeper.
                if (el.shadowRoot) {
                    findAllElements(el.shadowRoot.querySelectorAll('*'));
                }
            }
        };
        if(root.shadowRoot) {
            findAllElements(root.shadowRoot.querySelectorAll('*'));
        }
        findAllElements(root.querySelectorAll('*'));
    }

    return selector ? allElements.filter(el => el.matches(selector)) : allElements;	}



/***/ }),

/***/ "./node_modules/source-map/lib/array-set.js":
/*!**************************************************!*\
  !*** ./node_modules/source-map/lib/array-set.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var has = Object.prototype.hasOwnProperty;

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = util.toSetString(aStr);
  var isDuplicate = has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    this._set[sStr] = idx;
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  var sStr = util.toSetString(aStr);
  return has.call(this._set, sStr);
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  var sStr = util.toSetString(aStr);
  if (has.call(this._set, sStr)) {
    return this._set[sStr];
  }
  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;


/***/ }),

/***/ "./node_modules/source-map/lib/base64-vlq.js":
/*!***************************************************!*\
  !*** ./node_modules/source-map/lib/base64-vlq.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(/*! ./base64 */ "./node_modules/source-map/lib/base64.js");

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),

/***/ "./node_modules/source-map/lib/base64.js":
/*!***********************************************!*\
  !*** ./node_modules/source-map/lib/base64.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),

/***/ "./node_modules/source-map/lib/binary-search.js":
/*!******************************************************!*\
  !*** ./node_modules/source-map/lib/binary-search.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ "./node_modules/source-map/lib/mapping-list.js":
/*!*****************************************************!*\
  !*** ./node_modules/source-map/lib/mapping-list.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;


/***/ }),

/***/ "./node_modules/source-map/lib/quick-sort.js":
/*!***************************************************!*\
  !*** ./node_modules/source-map/lib/quick-sort.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),

/***/ "./node_modules/source-map/lib/source-map-consumer.js":
/*!************************************************************!*\
  !*** ./node_modules/source-map/lib/source-map-consumer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var binarySearch = __webpack_require__(/*! ./binary-search */ "./node_modules/source-map/lib/binary-search.js");
var ArraySet = (__webpack_require__(/*! ./array-set */ "./node_modules/source-map/lib/array-set.js").ArraySet);
var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/source-map/lib/base64-vlq.js");
var quickSort = (__webpack_require__(/*! ./quick-sort */ "./node_modules/source-map/lib/quick-sort.js").quickSort);

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),

/***/ "./node_modules/source-map/lib/source-map-generator.js":
/*!*************************************************************!*\
  !*** ./node_modules/source-map/lib/source-map-generator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/source-map/lib/base64-vlq.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var ArraySet = (__webpack_require__(/*! ./array-set */ "./node_modules/source-map/lib/array-set.js").ArraySet);
var MappingList = (__webpack_require__(/*! ./mapping-list */ "./node_modules/source-map/lib/mapping-list.js").MappingList);

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),

/***/ "./node_modules/source-map/lib/source-node.js":
/*!****************************************************!*\
  !*** ./node_modules/source-map/lib/source-node.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = (__webpack_require__(/*! ./source-map-generator */ "./node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator);
var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are removed from this array, by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var shiftNextLine = function() {
      var lineContents = remainingLines.shift();
      // The last line of a file might not have a newline.
      var newLine = remainingLines.shift() || "";
      return lineContents + newLine;
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[0];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[0];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[0] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLines.length > 0) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),

/***/ "./node_modules/source-map/lib/util.js":
/*!*********************************************!*\
  !*** ./node_modules/source-map/lib/util.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


/***/ }),

/***/ "./node_modules/source-map/source-map.js":
/*!***********************************************!*\
  !*** ./node_modules/source-map/source-map.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ "./node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ "./node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer;
exports.SourceNode = __webpack_require__(/*! ./lib/source-node */ "./node_modules/source-map/lib/source-node.js").SourceNode;


/***/ }),

/***/ "./node_modules/stack-generator/node_modules/stackframe/stackframe.js":
/*!****************************************************************************!*\
  !*** ./node_modules/stack-generator/node_modules/stackframe/stackframe.js ***!
  \****************************************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function() {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];
    var objectProps = ['evalOrigin'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);

    function StackFrame(obj) {
        if (!obj) return;
        for (var i = 0; i < props.length; i++) {
            if (obj[props[i]] !== undefined) {
                this['set' + _capitalize(props[i])](obj[props[i]]);
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var fileName = this.getFileName() || '';
            var lineNumber = this.getLineNumber() || '';
            var columnNumber = this.getColumnNumber() || '';
            var functionName = this.getFunctionName() || '';
            if (this.getIsEval()) {
                if (fileName) {
                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
                }
                return '[eval]:' + lineNumber + ':' + columnNumber;
            }
            if (functionName) {
                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
            }
            return fileName + ':' + lineNumber + ':' + columnNumber;
        }
    };

    StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf('(');
        var argsEndIndex = str.lastIndexOf(')');

        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
        var locationString = str.substring(argsEndIndex + 1);

        if (locationString.indexOf('@') === 0) {
            var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
            var fileName = parts[1];
            var lineNumber = parts[2];
            var columnNumber = parts[3];
        }

        return new StackFrame({
            functionName: functionName,
            args: args || undefined,
            fileName: fileName,
            lineNumber: lineNumber || undefined,
            columnNumber: columnNumber || undefined
        });
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));


/***/ }),

/***/ "./node_modules/stack-generator/stack-generator.js":
/*!*********************************************************!*\
  !*** ./node_modules/stack-generator/stack-generator.js ***!
  \*********************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/stack-generator/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function (StackFrame) {
    return {
        backtrace: function StackGenerator$$backtrace(opts) {
            var stack = [];
            var maxStackSize = 10;

            if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {
                maxStackSize = opts.maxStackSize;
            }

            var curr = arguments.callee;
            while (curr && stack.length < maxStackSize) {
                // Allow V8 optimizations
                var args = new Array(curr['arguments'].length);
                for(var i = 0; i < args.length; ++i) {
                    args[i] = curr['arguments'][i];
                }
                if (/function(?:\s+([\w$]+))+\s*\(/.test(curr.toString())) {
                    stack.push(new StackFrame({functionName: RegExp.$1 || undefined, args: args}));
                } else {
                    stack.push(new StackFrame({args: args}));
                }

                try {
                    curr = curr.caller;
                } catch (e) {
                    break;
                }
            }
            return stack;
        }
    };
}));


/***/ }),

/***/ "./node_modules/stackframe/stackframe.js":
/*!***********************************************!*\
  !*** ./node_modules/stackframe/stackframe.js ***!
  \***********************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function StackFrame(functionName, args, fileName, lineNumber, columnNumber, source) {
        if (functionName !== undefined) {
            this.setFunctionName(functionName);
        }
        if (args !== undefined) {
            this.setArgs(args);
        }
        if (fileName !== undefined) {
            this.setFileName(fileName);
        }
        if (lineNumber !== undefined) {
            this.setLineNumber(lineNumber);
        }
        if (columnNumber !== undefined) {
            this.setColumnNumber(columnNumber);
        }
        if (source !== undefined) {
            this.setSource(source);
        }
    }

    StackFrame.prototype = {
        getFunctionName: function () {
            return this.functionName;
        },
        setFunctionName: function (v) {
            this.functionName = String(v);
        },

        getArgs: function () {
            return this.args;
        },
        setArgs: function (v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        // NOTE: Property name may be misleading as it includes the path,
        // but it somewhat mirrors V8's JavaScriptStackTraceApi
        // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi and Gecko's
        // http://mxr.mozilla.org/mozilla-central/source/xpcom/base/nsIException.idl#14
        getFileName: function () {
            return this.fileName;
        },
        setFileName: function (v) {
            this.fileName = String(v);
        },

        getLineNumber: function () {
            return this.lineNumber;
        },
        setLineNumber: function (v) {
            if (!_isNumber(v)) {
                throw new TypeError('Line Number must be a Number');
            }
            this.lineNumber = Number(v);
        },

        getColumnNumber: function () {
            return this.columnNumber;
        },
        setColumnNumber: function (v) {
            if (!_isNumber(v)) {
                throw new TypeError('Column Number must be a Number');
            }
            this.columnNumber = Number(v);
        },

        getSource: function () {
            return this.source;
        },
        setSource: function (v) {
            this.source = String(v);
        },

        toString: function() {
            var functionName = this.getFunctionName() || '{anonymous}';
            var args = '(' + (this.getArgs() || []).join(',') + ')';
            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';
            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';
            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';
            return functionName + args + fileName + lineNumber + columnNumber;
        }
    };

    return StackFrame;
}));


/***/ }),

/***/ "./node_modules/stacktrace-gps/stacktrace-gps.js":
/*!*******************************************************!*\
  !*** ./node_modules/stacktrace-gps/stacktrace-gps.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! source-map */ "./node_modules/source-map/source-map.js"), __webpack_require__(/*! stackframe */ "./node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function(SourceMap, StackFrame) {
    'use strict';

    /**
     * Make a X-Domain request to url and callback.
     *
     * @param {String} url
     * @returns {Promise} with response text if fulfilled
     */
    function _xdr(url) {
        return new Promise(function(resolve, reject) {
            var req = new XMLHttpRequest();
            req.open('get', url);
            req.onerror = reject;
            req.onreadystatechange = function onreadystatechange() {
                if (req.readyState === 4) {
                    if (req.status >= 200 && req.status < 300) {
                        resolve(req.responseText);
                    } else {
                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));
                    }
                }
            };
            req.send();
        });

    }

    /**
     * Convert a Base64-encoded string into its original representation.
     * Used for inline sourcemaps.
     *
     * @param {String} b64str Base-64 encoded string
     * @returns {String} original representation of the base64-encoded string.
     */
    function _atob(b64str) {
        if (typeof window !== 'undefined' && window.atob) {
            return window.atob(b64str);
        } else {
            throw new Error('You must supply a polyfill for window.atob in this environment');
        }
    }

    function _parseJson(string) {
        if (typeof JSON !== 'undefined' && JSON.parse) {
            return JSON.parse(string);
        } else {
            throw new Error('You must supply a polyfill for JSON.parse in this environment');
        }
    }

    function _findFunctionName(source, lineNumber/*, columnNumber*/) {
        // function {name}({args}) m[1]=name m[2]=args
        var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
        // {name} = function ({args}) TODO args capture
        var reFunctionExpression = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*function\b/;
        // {name} = eval()
        var reFunctionEvaluation = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
        var lines = source.split('\n');

        // Walk backwards in the source lines until we find the line which matches one of the patterns above
        var code = '';
        var maxLines = Math.min(lineNumber, 20);
        var m;
        for (var i = 0; i < maxLines; ++i) {
            // lineNo is 1-based, source[] is 0-based
            var line = lines[lineNumber - i - 1];
            var commentPos = line.indexOf('//');
            if (commentPos >= 0) {
                line = line.substr(0, commentPos);
            }

            if (line) {
                code = line + code;
                m = reFunctionExpression.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
                m = reFunctionDeclaration.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
                m = reFunctionEvaluation.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
            }
        }
        return undefined;
    }

    function _ensureSupportedEnvironment() {
        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {
            throw new Error('Unable to consume source maps in older browsers');
        }
    }

    function _ensureStackFrameIsLegit(stackframe) {
        if (typeof stackframe !== 'object') {
            throw new TypeError('Given StackFrame is not an object');
        } else if (typeof stackframe.fileName !== 'string') {
            throw new TypeError('Given file name is not a String');
        } else if (typeof stackframe.lineNumber !== 'number' ||
            stackframe.lineNumber % 1 !== 0 ||
            stackframe.lineNumber < 1) {
            throw new TypeError('Given line number must be a positive integer');
        } else if (typeof stackframe.columnNumber !== 'number' ||
            stackframe.columnNumber % 1 !== 0 ||
            stackframe.columnNumber < 0) {
            throw new TypeError('Given column number must be a non-negative integer');
        }
        return true;
    }

    function _findSourceMappingURL(source) {
        var m = /\/\/[#@] ?sourceMappingURL=([^\s'"]+)\s*$/.exec(source);
        if (m && m[1]) {
            return m[1];
        } else {
            throw new Error('sourceMappingURL not found');
        }
    }

    function _extractLocationInfoFromSourceMap(stackframe, rawSourceMap, sourceCache) {
        return new Promise(function(resolve, reject) {
            var mapConsumer = new SourceMap.SourceMapConsumer(rawSourceMap);

            var loc = mapConsumer.originalPositionFor({
                line: stackframe.lineNumber,
                column: stackframe.columnNumber
            });

            if (loc.source) {
                var mappedSource = mapConsumer.sourceContentFor(loc.source);
                if (mappedSource) {
                    sourceCache[loc.source] = mappedSource;
                }
                resolve(
                    new StackFrame(
                        loc.name || stackframe.functionName,
                        stackframe.args,
                        loc.source,
                        loc.line,
                        loc.column));
            } else {
                reject(new Error('Could not get original source for given stackframe and source map'));
            }
        });
    }

    /**
     * @constructor
     * @param {Object} opts
     *      opts.sourceCache = {url: "Source String"} => preload source cache
     *      opts.offline = True to prevent network requests.
     *              Best effort without sources or source maps.
     *      opts.ajax = Promise returning function to make X-Domain requests
     */
    return function StackTraceGPS(opts) {
        if (!(this instanceof StackTraceGPS)) {
            return new StackTraceGPS(opts);
        }
        opts = opts || {};

        this.sourceCache = opts.sourceCache || {};

        this.ajax = opts.ajax || _xdr;

        this._atob = opts.atob || _atob;

        this._get = function _get(location) {
            return new Promise(function(resolve, reject) {
                var isDataUrl = location.substr(0, 5) === 'data:';
                if (this.sourceCache[location]) {
                    resolve(this.sourceCache[location]);
                } else if (opts.offline && !isDataUrl) {
                    reject(new Error('Cannot make network requests in offline mode'));
                } else {
                    if (isDataUrl) {
                        // data URLs can have parameters.
                        // see http://tools.ietf.org/html/rfc2397
                        var supportedEncodingRegexp =
                            /^data:application\/json;([\w=:"-]+;)*base64,/;
                        var match = location.match(supportedEncodingRegexp);
                        if (match) {
                            var sourceMapStart = match[0].length;
                            var encodedSource = location.substr(sourceMapStart);
                            var source = this._atob(encodedSource);
                            this.sourceCache[location] = source;
                            resolve(source);
                        } else {
                            reject(new Error('The encoding of the inline sourcemap is not supported'));
                        }
                    } else {
                        var xhrPromise = this.ajax(location, {method: 'get'});
                        // Cache the Promise to prevent duplicate in-flight requests
                        this.sourceCache[location] = xhrPromise;
                        xhrPromise.then(resolve, reject);
                    }
                }
            }.bind(this));
        };

        /**
         * Given a StackFrame, enhance function name and use source maps for a
         * better StackFrame.
         *
         * @param {StackFrame} stackframe object
         * @returns {Promise} that resolves with with source-mapped StackFrame
         */
        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {
            return new Promise(function(resolve, reject) {
                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {
                    function resolveMappedStackFrame() {
                        resolve(mappedStackFrame);
                    }

                    this.findFunctionName(mappedStackFrame)
                        .then(resolve, resolveMappedStackFrame)
                        ['catch'](resolveMappedStackFrame);
                }.bind(this), reject);
            }.bind(this));
        };

        /**
         * Given a StackFrame, guess function name from location information.
         *
         * @param {StackFrame} stackframe
         * @returns {Promise} that resolves with enhanced StackFrame.
         */
        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {
            return new Promise(function(resolve, reject) {
                _ensureStackFrameIsLegit(stackframe);
                this._get(stackframe.fileName).then(function getSourceCallback(source) {
                    var lineNumber = stackframe.lineNumber;
                    var columnNumber = stackframe.columnNumber;
                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);
                    // Only replace functionName if we found something
                    if (guessedFunctionName) {
                        resolve(new StackFrame(guessedFunctionName,
                            stackframe.args,
                            stackframe.fileName,
                            lineNumber,
                            columnNumber));
                    } else {
                        resolve(stackframe);
                    }
                }, reject)['catch'](reject);
            }.bind(this));
        };

        /**
         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.
         *
         * @param {StackFrame} stackframe
         * @returns {Promise} that resolves with enhanced StackFrame.
         */
        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {
            return new Promise(function(resolve, reject) {
                _ensureSupportedEnvironment();
                _ensureStackFrameIsLegit(stackframe);

                var sourceCache = this.sourceCache;
                var fileName = stackframe.fileName;
                this._get(fileName).then(function(source) {
                    var sourceMappingURL = _findSourceMappingURL(source);
                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';
                    var base = fileName.substring(0, fileName.lastIndexOf('/') + 1);

                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\/\/|^\/\//i).test(sourceMappingURL)) {
                        sourceMappingURL = base + sourceMappingURL;
                    }

                    this._get(sourceMappingURL).then(function(sourceMap) {
                        if (typeof sourceMap === 'string') {
                            sourceMap = _parseJson(sourceMap.replace(/^\)\]\}'/, ''));
                        }
                        if (typeof sourceMap.sourceRoot === 'undefined') {
                            sourceMap.sourceRoot = base;
                        }

                        _extractLocationInfoFromSourceMap(stackframe, sourceMap, sourceCache)
                            .then(resolve)['catch'](function() {
                            resolve(stackframe);
                        });
                    }, reject)['catch'](reject);
                }.bind(this), reject)['catch'](reject);
            }.bind(this));
        };
    };
}));


/***/ }),

/***/ "./node_modules/stacktrace-js/stacktrace.js":
/*!**************************************************!*\
  !*** ./node_modules/stacktrace-js/stacktrace.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! error-stack-parser */ "./node_modules/error-stack-parser/error-stack-parser.js"), __webpack_require__(/*! stack-generator */ "./node_modules/stack-generator/stack-generator.js"), __webpack_require__(/*! stacktrace-gps */ "./node_modules/stacktrace-gps/stacktrace-gps.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {
    var _options = {
        filter: function(stackframe) {
            // Filter out stackframes for this library by default
            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&
                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&
                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&
                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;
        },
        sourceCache: {}
    };

    var _generateError = function StackTrace$$GenerateError() {
        try {
            // Error must be thrown to get stack in IE
            throw new Error();
        } catch (err) {
            return err;
        }
    };

    /**
     * Merge 2 given Objects. If a conflict occurs the second object wins.
     * Does not do deep merges.
     *
     * @param {Object} first base object
     * @param {Object} second overrides
     * @returns {Object} merged first and second
     * @private
     */
    function _merge(first, second) {
        var target = {};

        [first, second].forEach(function(obj) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    target[prop] = obj[prop];
                }
            }
            return target;
        });

        return target;
    }

    function _isShapedLikeParsableError(err) {
        return err.stack || err['opera#sourceloc'];
    }

    function _filtered(stackframes, filter) {
        if (typeof filter === 'function') {
            return stackframes.filter(filter);
        }
        return stackframes;
    }

    return {
        /**
         * Get a backtrace from invocation point.
         *
         * @param {Object} opts
         * @returns {Array} of StackFrame
         */
        get: function StackTrace$$get(opts) {
            var err = _generateError();
            return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);
        },

        /**
         * Get a backtrace from invocation point.
         * IMPORTANT: Does not handle source maps or guess function names!
         *
         * @param {Object} opts
         * @returns {Array} of StackFrame
         */
        getSync: function StackTrace$$getSync(opts) {
            opts = _merge(_options, opts);
            var err = _generateError();
            var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);
            return _filtered(stack, opts.filter);
        },

        /**
         * Given an error object, parse it.
         *
         * @param {Error} error object
         * @param {Object} opts
         * @returns {Promise} for Array[StackFrame}
         */
        fromError: function StackTrace$$fromError(error, opts) {
            opts = _merge(_options, opts);
            var gps = new StackTraceGPS(opts);
            return new Promise(function(resolve) {
                var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);
                resolve(Promise.all(stackframes.map(function(sf) {
                    return new Promise(function(resolve) {
                        function resolveOriginal() {
                            resolve(sf);
                        }

                        gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);
                    });
                })));
            }.bind(this));
        },

        /**
         * Use StackGenerator to generate a backtrace.
         *
         * @param {Object} opts
         * @returns {Promise} of Array[StackFrame]
         */
        generateArtificially: function StackTrace$$generateArtificially(opts) {
            opts = _merge(_options, opts);
            var stackFrames = StackGenerator.backtrace(opts);
            if (typeof opts.filter === 'function') {
                stackFrames = stackFrames.filter(opts.filter);
            }
            return Promise.resolve(stackFrames);
        },

        /**
         * Given a function, wrap it such that invocations trigger a callback that
         * is called with a stack trace.
         *
         * @param {Function} fn to be instrumented
         * @param {Function} callback function to call with a stack trace on invocation
         * @param {Function} errback optional function to call with error if unable to get stack trace.
         * @param {Object} thisArg optional context object (e.g. window)
         */
        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot instrument non-function object');
            } else if (typeof fn.__stacktraceOriginalFn === 'function') {
                // Already instrumented, return given Function
                return fn;
            }

            var instrumented = function StackTrace$$instrumented() {
                try {
                    this.get().then(callback, errback)['catch'](errback);
                    return fn.apply(thisArg || this, arguments);
                } catch (e) {
                    if (_isShapedLikeParsableError(e)) {
                        this.fromError(e).then(callback, errback)['catch'](errback);
                    }
                    throw e;
                }
            }.bind(this);
            instrumented.__stacktraceOriginalFn = fn;

            return instrumented;
        },

        /**
         * Given a function that has been instrumented,
         * revert the function to it's original (non-instrumented) state.
         *
         * @param {Function} fn to de-instrument
         */
        deinstrument: function StackTrace$$deinstrument(fn) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot de-instrument non-function object');
            } else if (typeof fn.__stacktraceOriginalFn === 'function') {
                return fn.__stacktraceOriginalFn;
            } else {
                // Function not instrumented, return original
                return fn;
            }
        },

        /**
         * Given an error message and Array of StackFrames, serialize and POST to given URL.
         *
         * @param {Array} stackframes
         * @param {String} url
         * @param {String} errorMsg
         */
        report: function StackTrace$$report(stackframes, url, errorMsg) {
            return new Promise(function(resolve, reject) {
                var req = new XMLHttpRequest();
                req.onerror = reject;
                req.onreadystatechange = function onreadystatechange() {
                    if (req.readyState === 4) {
                        if (req.status >= 200 && req.status < 400) {
                            resolve(req.responseText);
                        } else {
                            reject(new Error('POST to ' + url + ' failed with status: ' + req.status));
                        }
                    }
                };
                req.open('post', url);
                req.setRequestHeader('Content-Type', 'application/json');

                var reportPayload = {stack: stackframes};
                if (errorMsg !== undefined) {
                    reportPayload.message = errorMsg;
                }

                req.send(JSON.stringify(reportPayload));
            });
        }
    };
}));


/***/ }),

/***/ "./src/_infra/AifexServiceHTTP.ts":
/*!****************************************!*\
  !*** ./src/_infra/AifexServiceHTTP.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Website_1 = __importDefault(__webpack_require__(/*! ../domain/Website */ "./src/domain/Website.ts"));
const Session_1 = __importDefault(__webpack_require__(/*! ../domain/Session */ "./src/domain/Session.ts"));
const AifexPluginInfo_1 = __importDefault(__webpack_require__(/*! ../domain/AifexPluginInfo */ "./src/domain/AifexPluginInfo.ts"));
const OK_STATUS = 200;
const INVALID_PARAMETERS_STATUS = 400;
const FORBIDDEN_STATUS = 403;
const NOT_FOUND_STATUS = 404;
const INTERNAL_SERVER_ERROR_STATUS = 500;
class AifexServiceHTTP {
    ping(serverURL) {
        return fetch(`${serverURL}/api/ping`, {
            method: "GET",
            headers: { "Content-Type": "application/json" },
        })
            .then(response => {
            console.log(response);
            if (response.ok) {
                console.log('ok');
                return;
            }
            else {
                console.log('error');
                throw new Error(response.statusText);
            }
        });
    }
    getPluginInfo(serverURL) {
        const option = {
            method: "GET",
            headers: { "Content-Type": "application/json" },
        };
        return fetch(`${serverURL}/api/plugin-info`, option)
            .then(response => {
            if (!response.ok) {
                throw new Error(response.statusText);
            }
            return response.json();
        })
            .then(details => {
            details.url = `${serverURL}/download`;
            return new AifexPluginInfo_1.default(details.version, details.name, details.description, details.url);
        });
    }
    getSession(serverURL, sessionId, token) {
        const SESSION_URL = serverURL + '/api/sessions/' + sessionId;
        return fetch(SESSION_URL, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json', "Authorization": `Bearer ${token === null || token === void 0 ? void 0 : token.token}` },
        })
            .then((response) => {
            if (response.status === OK_STATUS) {
                return response
                    .json()
                    .then((session) => {
                    return new Session_1.default(session.id, session.webSite.id, session.baseURL, session.name, session.description, session.overlayType, session.recordingMode);
                });
            }
            if (response.status === INVALID_PARAMETERS_STATUS) {
                return undefined;
            }
            if (response.status === NOT_FOUND_STATUS) {
                return undefined;
            }
            if (response.status === FORBIDDEN_STATUS) {
                return "Unauthorized";
            }
            if (response.status === INTERNAL_SERVER_ERROR_STATUS) {
                return Promise.reject(`server error`);
            }
        });
    }
    getWebSite(serverURL, webSiteId, token) {
        return fetch(`${serverURL}/api/websites/${webSiteId}`, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json', "Authorization": `Bearer ${token === null || token === void 0 ? void 0 : token.token}` },
        })
            .then((response) => {
            if (response.status === OK_STATUS) {
                return response
                    .json()
                    .then(websiteData => {
                    return new Website_1.default(websiteData.id, websiteData.name, websiteData.mappingList);
                });
            }
            if (response.status === INVALID_PARAMETERS_STATUS) {
                return Promise.reject(`sessionId is malformed`);
            }
            if (response.status === NOT_FOUND_STATUS) {
                return;
            }
            if (response.status === INTERNAL_SERVER_ERROR_STATUS) {
                return Promise.reject(`server error`);
            }
        });
    }
    createEmptyExploration(testerName, serverURL, sessionId) {
        const body = {
            testerName,
            interactionList: [],
        };
        const option = {
            method: "POST",
            body: JSON.stringify(body),
            headers: { "Content-Type": "application/json" },
        };
        return fetch(`${serverURL}/api/sessions/${sessionId}/explorations`, option)
            .then((response) => {
            if (response.status === OK_STATUS) {
                return response.json().then(data => {
                    return data.explorationNumber;
                });
            }
            if (response.status === NOT_FOUND_STATUS) {
                return Promise.reject(new Error(`no session not found for Id`));
            }
            if (response.status === INVALID_PARAMETERS_STATUS) {
                return Promise.reject(new Error(`sessionId and/or exploration is malformed`));
            }
            if (response.status === INTERNAL_SERVER_ERROR_STATUS) {
                return Promise.reject(new Error(`server error`));
            }
        });
    }
    sendAction(explorationNumber, action, serverURL, sessionId) {
        const body = {
            interactionList: [{
                    concreteType: action.getConcreteType(),
                    kind: action.prefix,
                    value: action.suffix,
                    date: action.date
                }]
        };
        const option = {
            method: "POST",
            body: JSON.stringify(body),
            headers: { "Content-Type": "application/json" },
        };
        return fetch(`${serverURL}/api/sessions/${sessionId}/explorations/${explorationNumber}/interactions`, option)
            .then((response) => {
            if (response.status === OK_STATUS) {
                return;
            }
            if (response.status === NOT_FOUND_STATUS) {
                return Promise.reject(new Error(`sessionId not found`));
            }
            if (response.status === INVALID_PARAMETERS_STATUS) {
                return Promise.reject(new Error(`sessionId and/or exploration is malformed`));
            }
            if (response.status === INTERNAL_SERVER_ERROR_STATUS) {
                return Promise.reject(new Error(`server error`));
            }
        }).catch(error => {
            console.error(error);
            throw new Error("Service Failed to push new action");
        });
    }
}
exports["default"] = AifexServiceHTTP;


/***/ }),

/***/ "./src/_infra/BrowserServiceSessionStorage.ts":
/*!****************************************************!*\
  !*** ./src/_infra/BrowserServiceSessionStorage.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
const EXPLORATION_NUMBER_KEY = 'EXPLORATION_NUMBER_KEY';
class BrowserServiceSessionStorage {
    getExplorationNumber() {
        Logger_1.logger.debug("BrowserServiceSessionStorage.getExplorationNumber");
        const explorationNumberItem = sessionStorage.getItem(EXPLORATION_NUMBER_KEY);
        if (explorationNumberItem) {
            const parsedNumber = parseInt(explorationNumberItem);
            if (isNaN(parsedNumber)) {
                Logger_1.logger.debug("BrowserServiceSessionStorage.getExplorationNumber: NaN");
                return undefined;
            }
            else {
                Logger_1.logger.debug("BrowserServiceSessionStorage.getExplorationNumber: " + parsedNumber);
                return parsedNumber;
            }
        }
        Logger_1.logger.debug("BrowserServiceSessionStorage.getExplorationNumber: undefined");
    }
    saveExplorationNumber(explorationNumber) {
        Logger_1.logger.debug("BrowserServiceSessionStorage.saveExplorationNumber: " + explorationNumber);
        sessionStorage.setItem(EXPLORATION_NUMBER_KEY, explorationNumber.toString());
    }
}
exports["default"] = BrowserServiceSessionStorage;


/***/ }),

/***/ "./src/domain/Action.ts":
/*!******************************!*\
  !*** ./src/domain/Action.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Action {
    constructor(prefix, suffix, ruleList = [], htmlElementList = []) {
        this.prefix = prefix;
        this.suffix = suffix;
        this.ruleList = ruleList;
        this.htmlElementList = htmlElementList;
        this.date = new Date();
    }
    setRuleList(ruleList) {
        this.ruleList = ruleList;
    }
    getConcreteType() {
        return "Action";
    }
    toString() {
        if (this.suffix) {
            return `${this.prefix}$${this.suffix}`;
        }
        else {
            return this.prefix;
        }
    }
    equals(action) {
        return ((this.prefix === action.prefix) && (this.suffix === action.suffix));
    }
    static parseAction(actionText) {
        const parts = actionText.split("$");
        if (parts.length === 1) {
            return new Action(parts[0]);
        }
        else if (parts.length === 2) {
            return new Action(parts[0], parts[1]);
        }
        else {
            throw new Error("Failed to parse action : " + actionText);
        }
    }
}
exports["default"] = Action;


/***/ }),

/***/ "./src/domain/AifexPluginInfo.ts":
/*!***************************************!*\
  !*** ./src/domain/AifexPluginInfo.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class AifexPluginInfo {
    constructor(version, name, description, url) {
        this.version = version;
        this.name = name;
        this.description = description;
        this.url = url;
    }
}
exports["default"] = AifexPluginInfo;


/***/ }),

/***/ "./src/domain/AttributeValueRule.ts":
/*!******************************************!*\
  !*** ./src/domain/AttributeValueRule.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
class AttributeValueRule extends SimpleRule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description, attributeName) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
        this.attributeName = attributeName;
    }
    makeAction(event) {
        const element = this.findActionMappedTarget(event);
        if (element !== undefined) {
            let attributeValue = element.getAttribute(this.attributeName);
            if (attributeValue) {
                return new Action_1.default(this.prefix, attributeValue);
            }
        }
        return new Action_1.default(this.prefix);
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix === undefined) {
            return super.actionToElements(action);
        }
        else {
            let suffix = action.suffix;
            const elements = this.findMatchedElements();
            return elements.filter(domElement => {
                if (domElement instanceof HTMLElement) {
                    return domElement.getAttribute(this.attributeName) === suffix;
                }
                else {
                    return false;
                }
            });
        }
    }
}
exports["default"] = AttributeValueRule;


/***/ }),

/***/ "./src/domain/BrowserScript.ts":
/*!*************************************!*\
  !*** ./src/domain/BrowserScript.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const ClassMutationHandler_1 = __importDefault(__webpack_require__(/*! ./ClassMutationHandler */ "./src/domain/ClassMutationHandler.ts"));
const EventListener_1 = __importDefault(__webpack_require__(/*! ./EventListener */ "./src/domain/EventListener.ts"));
const PageMutationHandler_1 = __importDefault(__webpack_require__(/*! ./PageMutationHandler */ "./src/domain/PageMutationHandler.ts"));
const RuleService_1 = __importDefault(__webpack_require__(/*! ./RuleService */ "./src/domain/RuleService.ts"));
class BrowserScript {
    constructor(serverURL, sessionId, token, aifexService, browserService) {
        this._serverURL = serverURL;
        this._sessionId = sessionId;
        this._token = token;
        this._aifexService = aifexService;
        this._browserService = browserService;
        this._ruleService = new RuleService_1.default();
        this._eventListener = new EventListener_1.default(this._ruleService);
        this._eventListener.addObserver(this.processNewAction.bind(this));
        new ClassMutationHandler_1.default();
        this._pageMutationHandler = new PageMutationHandler_1.default(this.onMutation.bind(this));
        this._pageMutationHandler.init();
    }
    start() {
        return this._aifexService.getSession(this._serverURL, this._sessionId, undefined)
            .then((sessionResult) => {
            if (sessionResult && sessionResult !== "Unauthorized") {
                this._webSiteId = sessionResult.webSiteId;
                this._aifexService.getWebSite(this._serverURL, this._webSiteId, undefined)
                    .then((webSiteResult) => {
                    if (webSiteResult && webSiteResult !== 'Unauthorized') {
                        const rules = webSiteResult.mappingList.map((ru) => this._ruleService.createRule(ru));
                        this._ruleService.loadRules(rules);
                        this._ruleService.mapRulesToElements();
                        Logger_1.logger.debug(`Rules loaded : ${rules.length}`);
                        this._eventListener.start();
                    }
                })
                    .then(() => {
                    const currentExplorationNumber = this._browserService.getExplorationNumber();
                    if (currentExplorationNumber !== undefined) {
                        this._explorationNumber = currentExplorationNumber;
                    }
                    else {
                        this._aifexService.createEmptyExploration("BROWSER_SCRIPT", this._serverURL, this._sessionId)
                            .then((explorationNumber) => {
                            this._explorationNumber = explorationNumber;
                            this._browserService.saveExplorationNumber(this._explorationNumber);
                        })
                            .then(() => {
                            this.processNewAction(new Action_1.default("start", undefined));
                        });
                    }
                });
            }
        });
    }
    processNewAction(action) {
        if (this._explorationNumber === undefined) {
            throw new Error("The exploration has not been correctly started");
        }
        this._aifexService.sendAction(this._explorationNumber, action, this._serverURL, this._sessionId);
    }
    onMutation() {
        this._ruleService.mapRulesToElements();
    }
}
exports["default"] = BrowserScript;


/***/ }),

/***/ "./src/domain/CSSContextMapper.ts":
/*!****************************************!*\
  !*** ./src/domain/CSSContextMapper.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ContextMapper_1 = __importDefault(__webpack_require__(/*! ./ContextMapper */ "./src/domain/ContextMapper.ts"));
class CSSContextMapper extends ContextMapper_1.default {
    constructor(context) {
        super(context);
    }
    buildElementToRuleMap() {
        if (this._context) {
            const cssQueryResult = document.querySelector(this._context);
            if (cssQueryResult && cssQueryResult instanceof HTMLElement) {
                return this.buildElementToRuleMapForSelectors(cssQueryResult);
            }
            else {
                return new Map();
            }
        }
        else {
            return new Map();
        }
    }
}
exports["default"] = CSSContextMapper;


/***/ }),

/***/ "./src/domain/CSSSelectorRule.ts":
/*!***************************************!*\
  !*** ./src/domain/CSSSelectorRule.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const Rule_1 = __importDefault(__webpack_require__(/*! ./Rule */ "./src/domain/Rule.ts"));
const css_selector_generator_1 = __importDefault(__webpack_require__(/*! css-selector-generator */ "./node_modules/css-selector-generator/build/index.js"));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class CSSSelectorRule extends Rule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        if (event.target) {
            if (event.target instanceof HTMLElement || event.target instanceof SVGElement) {
                let suffix;
                try {
                    suffix = (0, css_selector_generator_1.default)(event.target, {
                        selectors: [
                            "id",
                            "class",
                            "tag",
                            "attribute"
                        ],
                        blacklist: [
                            /.*data.*/i,
                            /.*aifex.*/i,
                            /.*over.*/i,
                            /.*auto.*/i,
                            /.*value.*/i,
                            /.*checked.*/i,
                            '[placeholder]',
                            /.*href.*/i,
                            /.*src.*/i,
                            /.*onclick.*/i,
                            /.*onload.*/i,
                            /.*onkeyup.*/i,
                            /.*width.*/i,
                            /.*height.*/i,
                            /.*style.*/i,
                            /.*size.*/i,
                            /.*maxlength.*/i
                        ],
                        combineBetweenSelectors: true,
                        maxCandidates: 100
                    });
                }
                catch (e) {
                    Logger_1.logger.error(`exception`, new Error('css exception'));
                }
                return new Action_1.default(this.prefix, suffix);
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix) {
            const elements = [];
            const parentElements = this.findMatchedElements();
            document.querySelectorAll(action.suffix).forEach((element) => {
                if (parentElements.some((parent) => parent.contains(element))) {
                    if (element instanceof HTMLElement || element instanceof SVGElement) {
                        elements.push(element);
                    }
                }
            });
            return elements;
        }
        else {
            return [];
        }
    }
}
exports["default"] = CSSSelectorRule;


/***/ }),

/***/ "./src/domain/CSSSelectorWithValueRule.ts":
/*!************************************************!*\
  !*** ./src/domain/CSSSelectorWithValueRule.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const Rule_1 = __importDefault(__webpack_require__(/*! ./Rule */ "./src/domain/Rule.ts"));
const css_selector_generator_1 = __importDefault(__webpack_require__(/*! css-selector-generator */ "./node_modules/css-selector-generator/build/index.js"));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class CSSSelectorWithValueRule extends Rule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        if (event.target) {
            if (event.target instanceof HTMLElement || event.target instanceof SVGElement) {
                let value = this.getValue(event.target);
                let suffix;
                try {
                    suffix = (0, css_selector_generator_1.default)(event.target, {
                        selectors: [
                            "id",
                            "class",
                            "tag",
                            "attribute"
                        ],
                        blacklist: [
                            /.*data.*/i,
                            /.*aifex.*/i,
                            /.*over.*/i,
                            /.*auto.*/i,
                            /.*value.*/i,
                            /.*checked.*/i,
                            '[placeholder]',
                            /.*href.*/i,
                            /.*src.*/i,
                            /.*onclick.*/i,
                            /.*onload.*/i,
                            /.*onkeyup.*/i,
                            /.*width.*/i,
                            /.*height.*/i,
                            /.*style.*/i,
                            /.*size.*/i,
                            /.*maxlength.*/i
                        ],
                        combineBetweenSelectors: true,
                        maxCandidates: 100
                    });
                }
                catch (e) {
                    Logger_1.logger.error(`exception`, new Error('css exception'));
                }
                if (value !== undefined && value.trim().length > 0) {
                    suffix += `?${value}`;
                }
                return new Action_1.default(this.prefix, suffix);
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix) {
            const elements = [];
            const parentElements = this.findMatchedElements();
            let sharpCharIndex = action.suffix.indexOf('?');
            let cssSelector = sharpCharIndex === -1 ? action.suffix : action.suffix.substring(0, sharpCharIndex);
            document.querySelectorAll(cssSelector).forEach((element) => {
                if (parentElements.some((parent) => parent.contains(element))) {
                    if (element instanceof HTMLElement || element instanceof SVGElement) {
                        elements.push(element);
                    }
                }
            });
            return elements;
        }
        else {
            return [];
        }
    }
    getValue(element) {
        if (element instanceof HTMLInputElement) {
            return element.value;
        }
        const valueAttribute = element.getAttribute('value');
        if (valueAttribute) {
            return valueAttribute;
        }
    }
}
exports["default"] = CSSSelectorWithValueRule;


/***/ }),

/***/ "./src/domain/ClassMutationHandler.ts":
/*!********************************************!*\
  !*** ./src/domain/ClassMutationHandler.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class ClassMutationHandler {
    constructor() {
        this._observer = new MutationObserver((records) => {
            for (const record of records) {
                if (record.type === "attributes") {
                    if (record.attributeName === "class") {
                        if (record.target instanceof HTMLElement) {
                            Logger_1.logger.debug('class mutation');
                            if (record.target.matches(':hover')) {
                                let currentClass = record.target.getAttribute('class');
                                let createEvent = false;
                                if (record.oldValue) {
                                    if (currentClass && currentClass.includes(record.oldValue)) {
                                        createEvent = true;
                                    }
                                }
                                else {
                                    if (currentClass) {
                                        createEvent = true;
                                    }
                                }
                                if (createEvent) {
                                    Logger_1.logger.debug('create event');
                                    let event = new Event('css-class-added', { bubbles: true });
                                    record.target.dispatchEvent(event);
                                }
                            }
                        }
                    }
                }
            }
        });
        const config = { attributes: true, subtree: true, attributeOldValue: true };
        this._observer.observe(document.body, config);
        Logger_1.logger.info('class mutation handler initialized');
    }
}
exports["default"] = ClassMutationHandler;


/***/ }),

/***/ "./src/domain/ContextLessMapper.ts":
/*!*****************************************!*\
  !*** ./src/domain/ContextLessMapper.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ContextMapper_1 = __importDefault(__webpack_require__(/*! ./ContextMapper */ "./src/domain/ContextMapper.ts"));
class ContextLessMapper extends ContextMapper_1.default {
    constructor() {
        super(undefined);
    }
    buildElementToRuleMap() {
        return this.buildElementToRuleMapForSelectors();
    }
}
exports["default"] = ContextLessMapper;


/***/ }),

/***/ "./src/domain/ContextMapper.ts":
/*!*************************************!*\
  !*** ./src/domain/ContextMapper.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class ContextMapper {
    constructor(context) {
        this._context = context;
        this._cssSelector2Rules = new Map();
        this._xpathSelector2Rules = new Map();
    }
    add(rule) {
        if (rule.contextCSS !== this._context && rule.contextURL !== this._context && rule.contextXPath !== this._context) {
            throw new Error('cannot add rule with a different context ');
        }
        if (rule.css) {
            if (!this._cssSelector2Rules.has(rule.css)) {
                this._cssSelector2Rules.set(rule.css, []);
            }
            let rules4Selector = this._cssSelector2Rules.get(rule.css);
            if (rules4Selector) {
                rules4Selector.push(rule);
            }
        }
        if (rule.xpath) {
            if (!this._xpathSelector2Rules.has(rule.xpath)) {
                this._xpathSelector2Rules.set(rule.xpath, []);
            }
            let rules4Selector = this._xpathSelector2Rules.get(rule.xpath);
            if (rules4Selector) {
                rules4Selector.push(rule);
            }
        }
    }
    buildElementToRuleMapForSelectors(context) {
        const elementToRules = new Map();
        for (const [selector, rules] of this._cssSelector2Rules) {
            let querySelector;
            if (context) {
                querySelector = context.querySelectorAll(selector);
            }
            else {
                querySelector = document.querySelectorAll(selector);
            }
            querySelector.forEach(element => {
                let rules4Element = elementToRules.get(element);
                if (!rules4Element) {
                    rules4Element = [];
                    elementToRules.set(element, rules4Element);
                }
                rules4Element.push(...rules);
            });
        }
        for (const [selector, rules] of this._xpathSelector2Rules) {
            let queryXpath;
            let queryXpathResult;
            try {
                if (context) {
                    queryXpath = document.evaluate(selector, context, null, XPathResult.ANY_TYPE, null);
                }
                else {
                    queryXpath = document.evaluate(selector, document, null, XPathResult.ANY_TYPE, null);
                }
            }
            catch (e) {
                Logger_1.logger.error('XPath Error:', new Error("e"));
            }
            if (queryXpath) {
                queryXpathResult = queryXpath.iterateNext();
                while (queryXpathResult) {
                    if (queryXpathResult instanceof HTMLElement || queryXpathResult instanceof SVGElement) {
                        let noContext = !context;
                        let resultInContext = context && context.contains(queryXpathResult);
                        if (noContext || resultInContext) {
                            let rules4Element = elementToRules.get(queryXpathResult);
                            if (!rules4Element) {
                                rules4Element = [];
                                elementToRules.set(queryXpathResult, rules4Element);
                            }
                            rules4Element.push(...rules);
                        }
                    }
                    queryXpathResult = queryXpath.iterateNext();
                }
            }
        }
        return elementToRules;
    }
}
exports["default"] = ContextMapper;


/***/ }),

/***/ "./src/domain/EventListener.ts":
/*!*************************************!*\
  !*** ./src/domain/EventListener.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class EventListener {
    constructor(ruleService) {
        this._ruleService = ruleService;
        this._handledEvents = [];
        this._observers = [];
    }
    start() {
        this._handledEvents = this._ruleService.getEventsToHandle();
        Logger_1.logger.debug(`EventListener: there are ${this._handledEvents.length} events to handle`);
        this._handledEvents.forEach((handledEvent) => {
            document.addEventListener(handledEvent, this.exploratoryListener.bind(this), true);
        });
    }
    addObserver(observerFunction) {
        this._observers.push(observerFunction);
    }
    exploratoryListener(event) {
        let unsafeEvent = event;
        if (unsafeEvent.isTrusted) {
            if (!unsafeEvent.explored) {
                unsafeEvent.explored = true;
                Logger_1.logger.debug(`EventListener: event ${unsafeEvent.type} is being handled`);
                const rule = this._ruleService.getMatchingRule(event);
                if (rule) {
                    const action = rule.makeAction(event);
                    if (action) {
                        Logger_1.logger.info(`action : ${action.toString()}`);
                        this._observers.forEach((observer) => {
                            observer(action);
                        });
                    }
                    else {
                        Logger_1.logger.debug('no action');
                    }
                }
            }
        }
    }
}
exports["default"] = EventListener;


/***/ }),

/***/ "./src/domain/IndexRule.ts":
/*!*********************************!*\
  !*** ./src/domain/IndexRule.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
class IndexRule extends SimpleRule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        const matchingElements = this.findMatchedElements();
        for (let i = 0; i < matchingElements.length; i++) {
            let targetElements = event.composedPath().filter((target) => target instanceof HTMLElement || target instanceof SVGElement);
            if (targetElements.length > 0 && matchingElements[i].contains(targetElements[0])) {
                return new Action_1.default(this.prefix, i.toString());
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix === undefined) {
            return super.actionToElements(action);
        }
        const index = parseInt(action.suffix, 10);
        const elements = this.findMatchedElements();
        if (index !== undefined || null) {
            if (elements.length > index) {
                return [elements[index]];
            }
            else {
                return [];
            }
        }
        else {
            return elements;
        }
    }
}
exports["default"] = IndexRule;


/***/ }),

/***/ "./src/domain/InnerTextRule.ts":
/*!*************************************!*\
  !*** ./src/domain/InnerTextRule.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
class InnerTextRule extends SimpleRule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        const element = this.findActionMappedTarget(event);
        if (element) {
            if (element instanceof HTMLElement) {
                return new Action_1.default(this.prefix, element.innerText.trim());
            }
            else {
                return new Action_1.default(this.prefix, "svg");
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix === undefined) {
            return super.actionToElements(action);
        }
        else {
            let suffix = action.suffix;
            const elements = this.findMatchedElements();
            return elements.filter(domElement => {
                if (domElement instanceof HTMLElement) {
                    return domElement.innerText.trim() === suffix.trim();
                }
                else if (domElement instanceof SVGElement) {
                    return "svg" === suffix.trim();
                }
                else {
                    return false;
                }
            });
        }
    }
}
exports["default"] = InnerTextRule;


/***/ }),

/***/ "./src/domain/PageMutationHandler.ts":
/*!*******************************************!*\
  !*** ./src/domain/PageMutationHandler.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const MUTATION_REFRESH_CHECK = 1000;
const DOM_IDS = ["AIFEX_probabilityPopup", "AIFEX_tab"];
class PageMutationHandler {
    constructor(onPageMutation) {
        this.onPageMutation = onPageMutation;
        this.beRefreshing = false;
        this.mutationHasOccured = false;
        this.willRefresh = false;
    }
    init() {
        this.lastMutation = Date.now();
        this.observer = new MutationObserver((records) => {
            let watchedPageHasMutated = false;
            for (const record of records) {
                if (record.type === "childList") {
                    if (this.isWatchedNodeList(record.addedNodes) && !this.isIncludedInAIFEXElement(record.addedNodes)) {
                        watchedPageHasMutated = true;
                    }
                }
            }
            if (watchedPageHasMutated) {
                if (!this.beRefreshing) {
                    this.beRefreshing = true;
                    this.onPageMutation();
                    setTimeout(() => {
                        this.beRefreshing = false;
                    }, MUTATION_REFRESH_CHECK);
                }
                else {
                    if (!this.willRefresh) {
                        this.willRefresh = true;
                        const TIME_CHECK_MULTIPLIER = 2;
                        setTimeout(() => {
                            this.beRefreshing = true;
                            this.onPageMutation();
                            setTimeout(() => {
                                this.beRefreshing = false;
                                this.willRefresh = false;
                            }, MUTATION_REFRESH_CHECK);
                        }, TIME_CHECK_MULTIPLIER * MUTATION_REFRESH_CHECK);
                    }
                }
            }
        });
        const config = { attributes: false, childList: true, characterData: false, subtree: true };
        this.observer.observe(document.body, config);
    }
    isWatchedNodeList(nodeList) {
        let isWatched = false;
        nodeList.forEach(node => {
            if (node instanceof HTMLElement) {
                if (node.tagName !== "SCRIPT" && node.tagName !== "IFRAME" && node.tagName !== "IMG") {
                    if (!node.style) {
                        isWatched = true;
                    }
                    if (!node.style.display) {
                        isWatched = true;
                    }
                    if (node.style.display !== "none") {
                        isWatched = true;
                    }
                }
            }
        });
        return isWatched;
    }
    isIncludedInAIFEXElement(nodeList) {
        const AIFEXElementList = DOM_IDS.map(id => document.getElementById(id)).filter((element) => element !== null);
        let isIncluded = true;
        nodeList.forEach(node => {
            if (node instanceof HTMLElement) {
                if (!AIFEXElementList.some((aifexNode) => {
                    return aifexNode.contains(node);
                })) {
                    isIncluded = false;
                }
            }
        });
        return isIncluded;
    }
}
exports["default"] = PageMutationHandler;


/***/ }),

/***/ "./src/domain/Rule.ts":
/*!****************************!*\
  !*** ./src/domain/Rule.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const query_selector_shadow_dom_1 = __webpack_require__(/*! query-selector-shadow-dom */ "./node_modules/query-selector-shadow-dom/src/querySelectorDeep.js");
class Rule {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        this.event = event;
        this.code = code;
        this.css = css;
        this.xpath = xpath;
        this.prefix = prefix;
        this.suffix = suffix;
        this.key = key;
        this.contextURL = contextURL;
        this.contextCSS = contextCSS;
        this.contextXPath = contextXPath;
        this.description = description;
    }
    match(event) {
        if (event.type !== this.event) {
            return false;
        }
        if (event instanceof KeyboardEvent) {
            if (this.event === "keyup" || this.event === "keydown" || this.event === "keypress") {
                if (this.code && event.code !== this.code) {
                    return false;
                }
                if (this.key && event.key !== this.key) {
                    return false;
                }
            }
            return true;
        }
        else {
            return true;
        }
    }
    findActionMappedTarget(event) {
        const target = event.composedPath()[0];
        if (target instanceof HTMLElement || target instanceof SVGElement) {
            if (target.hasAttribute("aifex_style")) {
                return target;
            }
            else {
                let closest = target.closest("[aifex_style]");
                if (closest && (closest instanceof HTMLElement || closest instanceof SVGElement)) {
                    return closest;
                }
            }
        }
    }
    findMatchedElements() {
        let context;
        if (this.contextXPath) {
            try {
                const result = document.evaluate(this.contextXPath, document, null, XPathResult.ANY_TYPE, null);
                context = result.iterateNext();
            }
            catch (e) {
                console.error(e);
            }
            if (!context) {
                return [];
            }
        }
        if (this.contextCSS) {
            context = document.querySelector(this.contextCSS);
            if (!context) {
                return [];
            }
        }
        let elements = [];
        if (this.xpath) {
            try {
                let result;
                if (context) {
                    result = document.evaluate(this.xpath, context, null, XPathResult.ANY_TYPE, null);
                }
                else {
                    result = document.evaluate(this.xpath, document, null, XPathResult.ANY_TYPE, null);
                }
                let node = result.iterateNext();
                while (node) {
                    elements.push(node);
                    node = result.iterateNext();
                }
            }
            catch (e) {
                console.error(e);
            }
        }
        if (this.css) {
            if (context) {
                elements = (0, query_selector_shadow_dom_1.querySelectorAllDeep)(this.css, context);
            }
            else {
                elements = (0, query_selector_shadow_dom_1.querySelectorAllDeep)(this.css);
            }
        }
        return elements.filter((element) => element instanceof HTMLElement || element instanceof SVGElement);
    }
}
exports["default"] = Rule;


/***/ }),

/***/ "./src/domain/RuleMapper.ts":
/*!**********************************!*\
  !*** ./src/domain/RuleMapper.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const URLContextMapper_1 = __importDefault(__webpack_require__(/*! ./URLContextMapper */ "./src/domain/URLContextMapper.ts"));
const XPathContextMapper_1 = __importDefault(__webpack_require__(/*! ./XPathContextMapper */ "./src/domain/XPathContextMapper.ts"));
const ContextLessMapper_1 = __importDefault(__webpack_require__(/*! ./ContextLessMapper */ "./src/domain/ContextLessMapper.ts"));
const CSSContextMapper_1 = __importDefault(__webpack_require__(/*! ./CSSContextMapper */ "./src/domain/CSSContextMapper.ts"));
class RuleMapper {
    constructor(rules) {
        this._cssContext2ContextMapper = new Map();
        this._xpathContext2ContextMapper = new Map();
        this._urlContext2ContextMapper = new Map();
        this._contextLessMapper = new ContextLessMapper_1.default();
        this._prefix2Rules = new Map();
        this._eventInRules = [];
        this.rules = rules;
        rules.forEach(rule => {
            let rules4Prefix = this._prefix2Rules.get(rule.prefix);
            if (!rules4Prefix) {
                rules4Prefix = [];
                this._prefix2Rules.set(rule.prefix, rules4Prefix);
            }
            rules4Prefix.push(rule);
            if (!this._eventInRules.includes(rule.event)) {
                this._eventInRules.push(rule.event);
            }
            if (rule.contextCSS) {
                let contextMapper4CssContext = this._cssContext2ContextMapper.get(rule.contextCSS);
                if (!contextMapper4CssContext) {
                    contextMapper4CssContext = new CSSContextMapper_1.default(rule.contextCSS);
                    this._cssContext2ContextMapper.set(rule.contextCSS, contextMapper4CssContext);
                }
                contextMapper4CssContext.add(rule);
            }
            else if (rule.contextXPath) {
                let contextMapper4XpathContext = this._xpathContext2ContextMapper.get(rule.contextXPath);
                if (!contextMapper4XpathContext) {
                    contextMapper4XpathContext = new XPathContextMapper_1.default(rule.contextXPath);
                    this._xpathContext2ContextMapper.set(rule.contextXPath, contextMapper4XpathContext);
                }
                contextMapper4XpathContext.add(rule);
            }
            else if (rule.contextURL) {
                let contexMapper4URLContext = this._urlContext2ContextMapper.get(rule.contextURL);
                if (!contexMapper4URLContext) {
                    contexMapper4URLContext = new URLContextMapper_1.default(rule.contextURL);
                    this._urlContext2ContextMapper.set(rule.contextURL, contexMapper4URLContext);
                }
                contexMapper4URLContext.add(rule);
            }
            else {
                this._contextLessMapper.add(rule);
            }
        });
    }
    getIsLoaded() {
        return this._prefix2Rules.size > 0;
    }
    getRuleListByPrefix(prefix) {
        let rules4prefis = this._prefix2Rules.get(prefix);
        if (rules4prefis) {
            return rules4prefis;
        }
        else {
            return [];
        }
    }
    get eventInRules() {
        return this._eventInRules;
    }
    buildElementToRuleMap() {
        const result = new Map();
        for (const mapper of this._urlContext2ContextMapper.values()) {
            for (const [element, rules] of mapper.buildElementToRuleMap()) {
                let rules4element = result.get(element);
                if (!rules4element) {
                    rules4element = [];
                    result.set(element, rules4element);
                }
                rules4element.push(...rules);
            }
        }
        for (const mapper of this._cssContext2ContextMapper.values()) {
            for (const [element, rules] of mapper.buildElementToRuleMap()) {
                let rules4element = result.get(element);
                if (!rules4element) {
                    rules4element = [];
                    result.set(element, rules4element);
                }
                rules4element.push(...rules);
            }
        }
        for (const mapper of this._xpathContext2ContextMapper.values()) {
            for (const [element, rules] of mapper.buildElementToRuleMap()) {
                let rules4element = result.get(element);
                if (!rules4element) {
                    rules4element = [];
                    result.set(element, rules4element);
                }
                rules4element.push(...rules);
            }
        }
        for (const [element, rules] of this._contextLessMapper.buildElementToRuleMap()) {
            let rules4element = result.get(element);
            if (!rules4element) {
                rules4element = [];
                result.set(element, rules4element);
            }
            rules4element.push(...rules);
        }
        return result;
    }
}
exports["default"] = RuleMapper;


/***/ }),

/***/ "./src/domain/RuleService.ts":
/*!***********************************!*\
  !*** ./src/domain/RuleService.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const RuleMapper_1 = __importDefault(__webpack_require__(/*! ./RuleMapper */ "./src/domain/RuleMapper.ts"));
const IndexRule_1 = __importDefault(__webpack_require__(/*! ./IndexRule */ "./src/domain/IndexRule.ts"));
const InnerTextRule_1 = __importDefault(__webpack_require__(/*! ./InnerTextRule */ "./src/domain/InnerTextRule.ts"));
const ValueRule_1 = __importDefault(__webpack_require__(/*! ./ValueRule */ "./src/domain/ValueRule.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
const CSSSelectorRule_1 = __importDefault(__webpack_require__(/*! ./CSSSelectorRule */ "./src/domain/CSSSelectorRule.ts"));
const AttributeValueRule_1 = __importDefault(__webpack_require__(/*! ./AttributeValueRule */ "./src/domain/AttributeValueRule.ts"));
const CSSSelectorWithValueRule_1 = __importDefault(__webpack_require__(/*! ./CSSSelectorWithValueRule */ "./src/domain/CSSSelectorWithValueRule.ts"));
class RuleService {
    constructor() {
        this.elementRules = new Map();
        this._ruleMapper = new RuleMapper_1.default([]);
    }
    get elementListMatchedByRule() {
        return Array.from(this.elementRules.keys());
    }
    getEventsToHandle() {
        return this._ruleMapper.eventInRules;
    }
    loadRules(rules) {
        this._ruleMapper = new RuleMapper_1.default(rules);
    }
    mapRulesToElements() {
        this.elementRules = this._ruleMapper.buildElementToRuleMap();
    }
    getMatchingRule(event) {
        let elements = event.composedPath().filter((target) => target instanceof HTMLElement || target instanceof SVGElement);
        for (const element of elements) {
            const rules = this.elementRules.get(element);
            if (rules !== undefined) {
                const matchingRule = rules.find((rule) => rule.match(event));
                if (matchingRule) {
                    return matchingRule;
                }
            }
        }
    }
    getRuleListByAction(action) {
        return this._ruleMapper.getRuleListByPrefix(action.prefix);
    }
    getHTMLElementsMatchedByAction(action) {
        const elements = new Set();
        action.ruleList.forEach(rule => {
            const elementListForRule = rule.actionToElements(action);
            elementListForRule.forEach(element => elements.add(element));
        });
        return [...elements.values()];
    }
    createRule(data) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32;
        switch (data.output.suffix) {
            case "innerText":
                return new InnerTextRule_1.default(data.output.prefix, (_a = data.output) === null || _a === void 0 ? void 0 : _a.suffix, data.match.event, (_b = data.match) === null || _b === void 0 ? void 0 : _b.css, (_c = data.match) === null || _c === void 0 ? void 0 : _c.xpath, (_d = data.match) === null || _d === void 0 ? void 0 : _d.code, (_e = data.match) === null || _e === void 0 ? void 0 : _e.key, (_f = data === null || data === void 0 ? void 0 : data.context) === null || _f === void 0 ? void 0 : _f.url, (_g = data === null || data === void 0 ? void 0 : data.context) === null || _g === void 0 ? void 0 : _g.css, (_h = data === null || data === void 0 ? void 0 : data.context) === null || _h === void 0 ? void 0 : _h.xpath, data.description);
            case "index":
                return new IndexRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_j = data.match) === null || _j === void 0 ? void 0 : _j.css, (_k = data.match) === null || _k === void 0 ? void 0 : _k.xpath, (_l = data.match) === null || _l === void 0 ? void 0 : _l.code, (_m = data.match) === null || _m === void 0 ? void 0 : _m.key, (_o = data === null || data === void 0 ? void 0 : data.context) === null || _o === void 0 ? void 0 : _o.url, (_p = data === null || data === void 0 ? void 0 : data.context) === null || _p === void 0 ? void 0 : _p.css, (_q = data === null || data === void 0 ? void 0 : data.context) === null || _q === void 0 ? void 0 : _q.xpath, data.description);
            case "value":
                return new ValueRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_r = data.match) === null || _r === void 0 ? void 0 : _r.css, (_s = data.match) === null || _s === void 0 ? void 0 : _s.xpath, (_t = data.match) === null || _t === void 0 ? void 0 : _t.code, (_u = data.match) === null || _u === void 0 ? void 0 : _u.key, (_v = data === null || data === void 0 ? void 0 : data.context) === null || _v === void 0 ? void 0 : _v.url, (_w = data === null || data === void 0 ? void 0 : data.context) === null || _w === void 0 ? void 0 : _w.css, (_x = data === null || data === void 0 ? void 0 : data.context) === null || _x === void 0 ? void 0 : _x.xpath, data.description);
            case "cssSelector":
                return new CSSSelectorRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_y = data.match) === null || _y === void 0 ? void 0 : _y.css, (_z = data.match) === null || _z === void 0 ? void 0 : _z.xpath, (_0 = data.match) === null || _0 === void 0 ? void 0 : _0.code, (_1 = data.match) === null || _1 === void 0 ? void 0 : _1.key, (_2 = data === null || data === void 0 ? void 0 : data.context) === null || _2 === void 0 ? void 0 : _2.url, (_3 = data === null || data === void 0 ? void 0 : data.context) === null || _3 === void 0 ? void 0 : _3.css, (_4 = data === null || data === void 0 ? void 0 : data.context) === null || _4 === void 0 ? void 0 : _4.xpath, data.description);
            case "cssSelectorWithValue":
                return new CSSSelectorWithValueRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_5 = data.match) === null || _5 === void 0 ? void 0 : _5.css, (_6 = data.match) === null || _6 === void 0 ? void 0 : _6.xpath, (_7 = data.match) === null || _7 === void 0 ? void 0 : _7.code, (_8 = data.match) === null || _8 === void 0 ? void 0 : _8.key, (_9 = data === null || data === void 0 ? void 0 : data.context) === null || _9 === void 0 ? void 0 : _9.url, (_10 = data === null || data === void 0 ? void 0 : data.context) === null || _10 === void 0 ? void 0 : _10.css, (_11 = data === null || data === void 0 ? void 0 : data.context) === null || _11 === void 0 ? void 0 : _11.xpath, data.description);
            case "attributeValue":
                if (data.match.attributeName === undefined) {
                    return new SimpleRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_12 = data.match) === null || _12 === void 0 ? void 0 : _12.css, (_13 = data.match) === null || _13 === void 0 ? void 0 : _13.xpath, (_14 = data.match) === null || _14 === void 0 ? void 0 : _14.code, (_15 = data.match) === null || _15 === void 0 ? void 0 : _15.key, (_16 = data === null || data === void 0 ? void 0 : data.context) === null || _16 === void 0 ? void 0 : _16.url, (_17 = data === null || data === void 0 ? void 0 : data.context) === null || _17 === void 0 ? void 0 : _17.css, (_18 = data === null || data === void 0 ? void 0 : data.context) === null || _18 === void 0 ? void 0 : _18.xpath, data.description);
                }
                else {
                    return new AttributeValueRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_19 = data.match) === null || _19 === void 0 ? void 0 : _19.css, (_20 = data.match) === null || _20 === void 0 ? void 0 : _20.xpath, (_21 = data.match) === null || _21 === void 0 ? void 0 : _21.code, (_22 = data.match) === null || _22 === void 0 ? void 0 : _22.key, (_23 = data === null || data === void 0 ? void 0 : data.context) === null || _23 === void 0 ? void 0 : _23.url, (_24 = data === null || data === void 0 ? void 0 : data.context) === null || _24 === void 0 ? void 0 : _24.css, (_25 = data === null || data === void 0 ? void 0 : data.context) === null || _25 === void 0 ? void 0 : _25.xpath, data.description, data.match.attributeName);
                }
            default:
                return new SimpleRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_26 = data.match) === null || _26 === void 0 ? void 0 : _26.css, (_27 = data.match) === null || _27 === void 0 ? void 0 : _27.xpath, (_28 = data.match) === null || _28 === void 0 ? void 0 : _28.code, (_29 = data.match) === null || _29 === void 0 ? void 0 : _29.key, (_30 = data === null || data === void 0 ? void 0 : data.context) === null || _30 === void 0 ? void 0 : _30.url, (_31 = data === null || data === void 0 ? void 0 : data.context) === null || _31 === void 0 ? void 0 : _31.css, (_32 = data === null || data === void 0 ? void 0 : data.context) === null || _32 === void 0 ? void 0 : _32.xpath, data.description);
        }
    }
}
exports["default"] = RuleService;


/***/ }),

/***/ "./src/domain/Session.ts":
/*!*******************************!*\
  !*** ./src/domain/Session.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Session {
    constructor(id, webSiteId, baseURL, name, description, overlayType, recordingMode) {
        if (id === null || id === undefined) {
            throw new Error('cannot create Session without id');
        }
        if (webSiteId === null || webSiteId === undefined) {
            throw new Error('cannot create Session without webSiteId');
        }
        this.id = id;
        this.webSiteId = webSiteId;
        this.baseURL = baseURL;
        this.name = name;
        this.description = description;
        this.overlayType = overlayType;
        this.recordingMode = recordingMode;
    }
}
exports["default"] = Session;


/***/ }),

/***/ "./src/domain/SimpleRule.ts":
/*!**********************************!*\
  !*** ./src/domain/SimpleRule.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const Rule_1 = __importDefault(__webpack_require__(/*! ./Rule */ "./src/domain/Rule.ts"));
class SimpleRule extends Rule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        return new Action_1.default(this.prefix);
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        const elements = this.findMatchedElements();
        return elements;
    }
}
exports["default"] = SimpleRule;


/***/ }),

/***/ "./src/domain/URLContextMapper.ts":
/*!****************************************!*\
  !*** ./src/domain/URLContextMapper.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ContextMapper_1 = __importDefault(__webpack_require__(/*! ./ContextMapper */ "./src/domain/ContextMapper.ts"));
class URLContextMapper extends ContextMapper_1.default {
    constructor(context) {
        super(context);
    }
    buildElementToRuleMap() {
        if (this._context && document.URL.startsWith(this._context)) {
            return this.buildElementToRuleMapForSelectors();
        }
        else {
            return new Map();
        }
    }
}
exports["default"] = URLContextMapper;


/***/ }),

/***/ "./src/domain/ValueRule.ts":
/*!*********************************!*\
  !*** ./src/domain/ValueRule.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
class ValueRule extends SimpleRule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        let target = event.target;
        if (target) {
            if (target instanceof HTMLInputElement) {
                return new Action_1.default(this.prefix, target.value);
            }
            else if (target instanceof HTMLSelectElement) {
                return new Action_1.default(this.prefix, "svg");
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix === undefined) {
            return super.actionToElements(action);
        }
        const elements = this.findMatchedElements();
        return elements;
    }
}
exports["default"] = ValueRule;


/***/ }),

/***/ "./src/domain/Website.ts":
/*!*******************************!*\
  !*** ./src/domain/Website.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class WebSite {
    constructor(id, name, mappingList) {
        this.id = id;
        this.name = name;
        this.mappingList = mappingList;
    }
}
exports["default"] = WebSite;


/***/ }),

/***/ "./src/domain/XPathContextMapper.ts":
/*!******************************************!*\
  !*** ./src/domain/XPathContextMapper.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ContextMapper_1 = __importDefault(__webpack_require__(/*! ./ContextMapper */ "./src/domain/ContextMapper.ts"));
class XPathContextMapper extends ContextMapper_1.default {
    constructor(context) {
        super(context);
    }
    buildElementToRuleMap() {
        if (this._context) {
            const xpathQueryResult = document.evaluate(this._context, document, null, XPathResult.ANY_TYPE, null);
            const context = xpathQueryResult.iterateNext();
            if (context instanceof HTMLElement || context instanceof SVGElement) {
                return this.buildElementToRuleMapForSelectors();
            }
            else {
                return new Map();
            }
        }
        else {
            return new Map();
        }
    }
}
exports["default"] = XPathContextMapper;


/***/ }),

/***/ "./src/framework/Logger.ts":
/*!*********************************!*\
  !*** ./src/framework/Logger.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logger = void 0;
const typescript_logging_1 = __webpack_require__(/*! typescript-logging */ "./node_modules/typescript-logging/dist/commonjs/typescript-logging.js");
let logLevel;
switch ("development") {
    case 'production':
        logLevel = typescript_logging_1.LogLevel.Error;
        break;
    case 'development':
        logLevel = typescript_logging_1.LogLevel.Debug;
        break;
    case 'github':
        logLevel = typescript_logging_1.LogLevel.Error;
        break;
    default:
        logLevel = typescript_logging_1.LogLevel.Error;
}
typescript_logging_1.CategoryServiceFactory.setDefaultConfiguration(new typescript_logging_1.CategoryConfiguration(logLevel));
exports.logger = new typescript_logging_1.Category("TabScript");


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const BrowserScript_1 = __importDefault(__webpack_require__(/*! ./domain/BrowserScript */ "./src/domain/BrowserScript.ts"));
const Logger_1 = __webpack_require__(/*! ./framework/Logger */ "./src/framework/Logger.ts");
const AifexServiceHTTP_1 = __importDefault(__webpack_require__(/*! ./_infra/AifexServiceHTTP */ "./src/_infra/AifexServiceHTTP.ts"));
const BrowserServiceSessionStorage_1 = __importDefault(__webpack_require__(/*! ./_infra/BrowserServiceSessionStorage */ "./src/_infra/BrowserServiceSessionStorage.ts"));
Logger_1.logger.info("AIFEX script is running.");
const AIFEX_SCRIPT = document.getElementById("AIFEX");
if (AIFEX_SCRIPT) {
    Logger_1.logger.info("AIFEX SCRIPT Element is found.");
    const CONNEXION_URL = AIFEX_SCRIPT.getAttribute("connexion-url");
    if (CONNEXION_URL) {
        Logger_1.logger.info("AIFEX connexion-url Element is found.");
        try {
            const AIFEX_URL = new URL(CONNEXION_URL);
            let sessionId = AIFEX_URL.searchParams.get('sessionId');
            if (sessionId) {
                Logger_1.logger.info("AIFEX sessionId is found.");
                const AIFEX_SERVICE = new AifexServiceHTTP_1.default();
                const BROWSER_SERVICE = new BrowserServiceSessionStorage_1.default();
                const BROWSER_SCRIPT = new BrowserScript_1.default(AIFEX_URL.origin, sessionId, undefined, AIFEX_SERVICE, BROWSER_SERVICE);
                BROWSER_SCRIPT.start();
            }
        }
        catch (e) {
            Logger_1.logger.error("Invalid connexion URL", new Error("Invalid connexion URL"));
        }
    }
}
else {
    Logger_1.logger.error("AIFEX SCRIPT Element is not found.", new Error("AIFEX SCRIPT Element is not found."));
}


/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/control/CategoryServiceControl.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/control/CategoryServiceControl.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var CategoryService_1 = __webpack_require__(/*! ../log/category/CategoryService */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js");
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var DataStructures_1 = __webpack_require__(/*! ../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
/**
 * Implementation class for CategoryServiceControl.
 */
var CategoryServiceControlImpl = (function () {
    function CategoryServiceControlImpl() {
    }
    CategoryServiceControlImpl.prototype.help = function () {
        /* tslint:disable:no-console */
        console.log(CategoryServiceControlImpl._help);
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl.prototype.example = function () {
        /* tslint:disable:no-console */
        console.log(CategoryServiceControlImpl._example);
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl.prototype.showSettings = function (id) {
        if (id === void 0) { id = "all"; }
        var result = new DataStructures_1.StringBuilder();
        var service = CategoryServiceControlImpl._getCategoryService();
        var categories = CategoryServiceControlImpl._getCategories(id);
        categories.forEach(function (category) {
            CategoryServiceControlImpl._processCategory(service, category, result, 0);
        });
        /* tslint:disable:no-console */
        console.log(result.toString());
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl.prototype.change = function (settings) {
        var service = CategoryServiceControlImpl._getCategoryService();
        var categories = CategoryServiceControlImpl._getCategories(settings.category);
        var logLevel = null;
        var formatEnum = null;
        var showCategoryName = null;
        var showTimestamp = null;
        var result = null;
        var addResult = function (value) {
            if (result !== null) {
                result += ", ";
            }
            if (result === null) {
                result = value;
            }
            else {
                result += value;
            }
        };
        addResult("recursive=" + settings.recursive);
        if (typeof settings.logLevel === "string") {
            logLevel = LoggerOptions_1.LogLevel.fromString(settings.logLevel);
            addResult("logLevel=" + settings.logLevel);
        }
        if (typeof settings.logFormat === "string") {
            formatEnum = LoggerOptions_1.DateFormatEnum.fromString(settings.logFormat);
            addResult("logFormat=" + settings.logFormat);
        }
        if (typeof settings.showCategoryName === "boolean") {
            showCategoryName = settings.showCategoryName;
            addResult("showCategoryName=" + settings.showCategoryName);
        }
        if (typeof settings.showTimestamp === "boolean") {
            showTimestamp = settings.showTimestamp;
            addResult("showTimestamp=" + settings.showTimestamp);
        }
        var applyChanges = function (cat) {
            var categorySettings = service.getCategorySettings(cat);
            // Should not happen but make tslint happy
            if (categorySettings !== null) {
                if (logLevel !== null) {
                    categorySettings.logLevel = logLevel;
                }
                if (formatEnum !== null) {
                    categorySettings.logFormat.dateFormat.formatEnum = formatEnum;
                }
                if (showTimestamp !== null) {
                    categorySettings.logFormat.showTimeStamp = showTimestamp;
                }
                if (showCategoryName !== null) {
                    categorySettings.logFormat.showCategoryName = showCategoryName;
                }
            }
        };
        categories.forEach(function (cat) { return CategoryServiceControlImpl._applyToCategory(cat, settings.recursive, applyChanges); });
        /* tslint:disable:no-console */
        console.log("Applied changes: " + result + " to categories '" + settings.category + "'.");
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl.prototype.reset = function (id) {
        if (id === void 0) { id = "all"; }
        var service = CategoryServiceControlImpl._getCategoryService();
        var categories = CategoryServiceControlImpl._getCategories(id);
        var applyChanges = function (cat) {
            var categorySettings = service.getCategorySettings(cat);
            var original = service.getOriginalCategorySettings(cat);
            // Should not happen but make tslint happy
            if (categorySettings !== null && original !== null) {
                categorySettings.logLevel = original.logLevel;
                categorySettings.logFormat.dateFormat.formatEnum = original.logFormat.dateFormat.formatEnum;
                categorySettings.logFormat.showTimeStamp = original.logFormat.showTimeStamp;
                categorySettings.logFormat.showCategoryName = original.logFormat.showCategoryName;
            }
        };
        categories.forEach(function (cat) { return CategoryServiceControlImpl._applyToCategory(cat, true, applyChanges); });
        /* tslint:disable:no-console */
        console.log("Applied reset to category: " + id + ".");
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl._processCategory = function (service, category, result, indent) {
        var settings = service.getCategorySettings(category);
        if (settings !== null) {
            result.append("  " + category.id + ": ");
            if (indent > 0) {
                for (var i = 0; i < indent; i++) {
                    result.append("  ");
                }
            }
            result.append(category.name + " (" + LoggerOptions_1.LogLevel[settings.logLevel].toString() + "@" + LoggerOptions_1.LoggerType[settings.loggerType].toString() + ")\n");
            if (category.children.length > 0) {
                category.children.forEach(function (child) {
                    CategoryServiceControlImpl._processCategory(service, child, result, indent + 1);
                });
            }
        }
    };
    CategoryServiceControlImpl._applyToCategory = function (category, recursive, apply) {
        apply(category);
        if (recursive) {
            category.children.forEach(function (child) {
                CategoryServiceControlImpl._applyToCategory(child, recursive, apply);
            });
        }
    };
    CategoryServiceControlImpl._getCategoryService = function () {
        return CategoryService_1.CategoryServiceImpl.getInstance();
    };
    CategoryServiceControlImpl._getCategories = function (idCategory) {
        var service = CategoryServiceControlImpl._getCategoryService();
        var categories = [];
        if (idCategory === "all") {
            categories = service.getRootCategories();
        }
        else {
            var category = service.getCategoryById(idCategory);
            if (category === null) {
                throw new Error("Failed to find category with id " + idCategory);
            }
            categories.push(category);
        }
        return categories;
    };
    CategoryServiceControlImpl._help = "\n  help(): void\n    ** Shows this help.\n\n  example(): void\n    ** Shows an example on how to use this.\n\n  showSettings(id: number | \"all\" = \"all\"): void\n    ** Shows settings for a specific category, or for all. The id of categories can be found by calling this method without parameter.\n\n  change(settings: CategoryServiceControlSettings): void\n    ** Changes the current settings for one or all categories.\n    **\n       CategoryServiceControlSettings, properties of object:\n         category: number | \"all\"\n           ** Apply to specific category, or \"all\".\n           ** Required\n\n         recursive: boolean\n           ** Apply to child categories (true) or not.\n           ** Required\n\n         logLevel: \"Fatal\" | \"Error\" | \"Warn\" | \"Info\" | \"Debug\" | \"Trace\" | undefined\n           ** Set log level, undefined will not change the setting.\n           ** Optional\n\n         logFormat: \"Default\" | \"YearMonthDayTime\" | \"YearDayMonthWithFullTime\" | \"YearDayMonthTime\" | undefined\n           ** Set the log format, undefined will not change the setting.\n           ** Optional\n\n         showTimestamp: boolean | undefined\n           ** Whether to show timestamp, undefined will not change the setting.\n           ** Optional\n\n         showCategoryName: boolean | undefined\n           ** Whether to show the category name, undefined will not change the setting.\n           ** Optional\n\n   reset(id: number | \"all\"): void\n     ** Resets everything to original values, for one specific or for all categories.\n";
    CategoryServiceControlImpl._example = "\n  Examples:\n    change({category: \"all\", recursive:true, logLevel: \"Info\"})\n      ** Change loglevel to Info for all categories, apply to child categories as well.\n\n    change({category: 1, recursive:false, logLevel: \"Warn\"})\n      ** Change logLevel for category 1, do not recurse.\n\n    change({category: \"all\", recursive:true, logLevel: \"Debug\", logFormat: \"YearDayMonthTime\", showTimestamp:false, showCategoryName:false})\n      ** Change loglevel to Debug for all categories, apply format, do not show timestamp and category names - recursively to child categories.\n\n";
    return CategoryServiceControlImpl;
}());
exports.CategoryServiceControlImpl = CategoryServiceControlImpl;
//# sourceMappingURL=CategoryServiceControl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/control/LogGroupControl.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/control/LogGroupControl.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var LFService_1 = __webpack_require__(/*! ../log/standard/LFService */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LFService.js");
var DataStructures_1 = __webpack_require__(/*! ../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var LoggerControlImpl = (function () {
    function LoggerControlImpl() {
    }
    LoggerControlImpl.prototype.help = function () {
        /* tslint:disable:no-console */
        console.log(LoggerControlImpl._help);
        /* tslint:enable:no-console */
    };
    LoggerControlImpl.prototype.listFactories = function () {
        var rtSettingsFactories = LoggerControlImpl._getRuntimeSettingsLoggerFactories();
        var result = new DataStructures_1.StringBuilder();
        result.appendLine("Registered LoggerFactories (index / name)");
        for (var i = 0; i < rtSettingsFactories.length; i++) {
            var rtSettingsFactory = rtSettingsFactories[i];
            result.append("  " + i).append(": " + rtSettingsFactory.getName() + "\n");
        }
        /* tslint:disable:no-console */
        console.log(result.toString());
        /* tslint:enable:no-console */
    };
    LoggerControlImpl.prototype.showSettings = function (id) {
        if (id === void 0) { id = "all"; }
        var result = [];
        if (id === "all") {
            var idx_1 = 0;
            LoggerControlImpl._getRuntimeSettingsLoggerFactories().forEach(function (item) {
                result.push(new DataStructures_1.TuplePair(idx_1++, item));
            });
        }
        else {
            var settings = LoggerControlImpl._getRuntimeSettingsLoggerFactories();
            if (id >= 0 && id < settings.length) {
                result.push(new DataStructures_1.TuplePair(id, settings[id]));
            }
            else {
                throw new Error("Requested number: " + id + " was not found.");
            }
        }
        for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
            var setting = result_1[_i];
            /* tslint:disable:no-console */
            console.log("  LoggerFactory: " + setting.y.getName() + " (id=" + setting.x + ")");
            var logGroupRuntimeSettings = setting.y.getLogGroupRuntimeSettings();
            for (var g = 0; g < logGroupRuntimeSettings.length; g++) {
                var groupSetting = logGroupRuntimeSettings[g];
                console.log("     LogGroup: (id=" + g + ")");
                console.log("       RegExp: " + groupSetting.logGroupRule.regExp.source);
                console.log("       Level: " + LoggerOptions_1.LogLevel[groupSetting.level].toString());
                console.log("       LoggerType: " + LoggerOptions_1.LoggerType[groupSetting.loggerType].toString());
            }
            /* tslint:enable:no-console */
        }
    };
    LoggerControlImpl.prototype.reset = function (idFactory) {
        if (idFactory === void 0) { idFactory = "all"; }
        var loggerFactoriesSettings = LoggerControlImpl._getRuntimeSettingsLoggerFactories();
        var result = [];
        if (idFactory === "all") {
            result = loggerFactoriesSettings;
        }
        else {
            if (idFactory >= 0 && idFactory < loggerFactoriesSettings.length) {
                result.push(loggerFactoriesSettings[idFactory]);
            }
        }
        result.forEach(function (setting) {
            /* tslint:disable:no-console */
            console.log("Reset all settings for factory " + idFactory);
            /* tslint:enable:no-console */
            var control = new LoggerFactoryControlImpl(setting);
            control.reset();
        });
    };
    LoggerControlImpl.prototype.getLoggerFactoryControl = function (idFactory) {
        var loggerFactoriesSettings = LoggerControlImpl._getRuntimeSettingsLoggerFactories();
        if (idFactory >= 0 && idFactory < loggerFactoriesSettings.length) {
            return new LoggerFactoryControlImpl(loggerFactoriesSettings[idFactory]);
        }
        throw new Error("idFactory is invalid (less than 0) or non existing id.");
    };
    LoggerControlImpl._getRuntimeSettingsLoggerFactories = function () {
        return LoggerControlImpl._getSettings().getRuntimeSettingsForLoggerFactories();
    };
    LoggerControlImpl._getSettings = function () {
        return LFService_1.LFService.getRuntimeSettings();
    };
    LoggerControlImpl._help = "\n  help(): void\n    ** Shows this help.\n\n  listFactories(): void\n    ** List all registered LoggerFactories with associated log groups with respective ids (ids can be used to target a factory and/or group).\n\n  showSettings(idFactory: number | \"all\"): void\n    ** Show log group settings for idFactory (use listFactories to find id for a LoggerFactory). If idFactory is \"all\" shows all factories.\n\n  getLoggerFactoryControl(idFactory: number): LoggerFactoryControl\n    ** Return LoggerFactoryControl when found for given idFactory or throws Error if invalid or null, get the id by using listFactories()\n\n  reset(idFactory: number | \"all\"): void\n    ** Resets given factory or all factories back to original values.\n";
    return LoggerControlImpl;
}());
exports.LoggerControlImpl = LoggerControlImpl;
var LoggerFactoryControlImpl = (function () {
    function LoggerFactoryControlImpl(settings) {
        this._settings = settings;
    }
    LoggerFactoryControlImpl.prototype.help = function () {
        /* tslint:disable:no-console */
        console.log(LoggerFactoryControlImpl._help);
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype.example = function () {
        /* tslint:disable:no-console */
        console.log(LoggerFactoryControlImpl._example);
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype.showSettings = function (id) {
        if (id === void 0) { id = "all"; }
        var result = new DataStructures_1.StringBuilder();
        var logGroupRuntimeSettings = this._settings.getLogGroupRuntimeSettings();
        result.appendLine("Registered LogGroups (index / expression)");
        for (var i = 0; i < logGroupRuntimeSettings.length; i++) {
            var logGroupRuntimeSetting = logGroupRuntimeSettings[i];
            result.appendLine("  " + i + ": " + logGroupRuntimeSetting.logGroupRule.regExp.source + ", logLevel=" +
                LoggerOptions_1.LogLevel[logGroupRuntimeSetting.level].toString() + ", showTimestamp=" + logGroupRuntimeSetting.logFormat.showTimeStamp +
                ", showLoggerName=" + logGroupRuntimeSetting.logFormat.showLoggerName +
                ", format=" + LoggerOptions_1.DateFormatEnum[logGroupRuntimeSetting.logFormat.dateFormat.formatEnum].toString());
        }
        /* tslint:disable:no-console */
        console.log(result.toString());
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype.change = function (settings) {
        var logGroupRuntimeSettings = this._getLogGroupRunTimeSettingsFor(settings.group);
        var logLevel = null;
        var formatEnum = null;
        var showLoggerName = null;
        var showTimestamp = null;
        var result = null;
        var addResult = function (value) {
            if (result !== null) {
                result += ", ";
            }
            if (result === null) {
                result = value;
            }
            else {
                result += value;
            }
        };
        if (typeof settings.logLevel === "string") {
            logLevel = LoggerOptions_1.LogLevel.fromString(settings.logLevel);
            addResult("logLevel=" + settings.logLevel);
        }
        if (typeof settings.logFormat === "string") {
            formatEnum = LoggerOptions_1.DateFormatEnum.fromString(settings.logFormat);
            addResult("logFormat=" + settings.logFormat);
        }
        if (typeof settings.showLoggerName === "boolean") {
            showLoggerName = settings.showLoggerName;
            addResult("showLoggerName=" + settings.showLoggerName);
        }
        if (typeof settings.showTimestamp === "boolean") {
            showTimestamp = settings.showTimestamp;
            addResult("showTimestamp=" + settings.showTimestamp);
        }
        logGroupRuntimeSettings.forEach(function (s) {
            if (logLevel !== null) {
                s.level = logLevel;
            }
            if (formatEnum !== null) {
                s.logFormat.dateFormat.formatEnum = formatEnum;
            }
            if (showTimestamp !== null) {
                s.logFormat.showTimeStamp = showTimestamp;
            }
            if (showLoggerName !== null) {
                s.logFormat.showLoggerName = showLoggerName;
            }
        });
        /* tslint:disable:no-console */
        console.log("Applied changes: " + result + " to log groups '" + settings.group + "'.");
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype.reset = function (idGroup) {
        if (idGroup === void 0) { idGroup = "all"; }
        var settings = this._getLogGroupRunTimeSettingsFor(idGroup);
        for (var _i = 0, settings_1 = settings; _i < settings_1.length; _i++) {
            var setting = settings_1[_i];
            setting.level = setting.logGroupRule.level;
            setting.logFormat.showTimeStamp = setting.logGroupRule.logFormat.showTimeStamp;
            setting.logFormat.showLoggerName = setting.logGroupRule.logFormat.showLoggerName;
            setting.logFormat.dateFormat.formatEnum = setting.logGroupRule.logFormat.dateFormat.formatEnum;
        }
        /* tslint:disable:no-console */
        console.log("Reset all settings for group " + idGroup);
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype._getLogGroupRunTimeSettingsFor = function (idGroup) {
        var settings = [];
        if (idGroup === "all") {
            settings = this._settings.getLogGroupRuntimeSettings();
        }
        else {
            this._checkIndex(idGroup);
            settings.push(this._settings.getLogGroupRuntimeSettings()[idGroup]);
        }
        return settings;
    };
    LoggerFactoryControlImpl.prototype._checkIndex = function (index) {
        if (index < 0 || index >= this._settings.getLogGroupRuntimeSettings().length) {
            throw new Error("Invalid index, use listLogGroups to find out a valid one.");
        }
    };
    LoggerFactoryControlImpl._help = "\n  help(): void\n    ** Shows this help.\n\n  example(): void\n    ** Shows an example of usage.\n\n  showSettings(id: number | \"all\"): void\n    ** Prints settings for given group id, \"all\" for all group.\n\n  change(settings: LogGroupControlSettings): void\n    ** Changes the current settings for one or all log groups.\n    **\n       LogGroupControlSettings, properties of object:\n         group: number | \"all\"\n           ** Apply to specific group, or \"all\".\n           ** Required\n\n         logLevel: \"Fatal\" | \"Error\" | \"Warn\" | \"Info\" | \"Debug\" | \"Trace\" | undefined\n           ** Set log level, undefined will not change the setting.\n           ** Optional\n\n         logFormat: \"Default\" | \"YearMonthDayTime\" | \"YearDayMonthWithFullTime\" | \"YearDayMonthTime\" | undefined\n           ** Set the log format, undefined will not change the setting.\n           ** Optional\n\n         showTimestamp: boolean | undefined\n           ** Whether to show timestamp, undefined will not change the setting.\n           ** Optional\n\n         showLoggerName: boolean | undefined\n           ** Whether to show the logger name, undefined will not change the setting.\n           ** Optional\n\n  reset(id: number | \"all\"): void\n    ** Resets everything to original values, for one specific or for all groups.\n\n  help():\n    ** Shows this help.\n";
    LoggerFactoryControlImpl._example = "\n  Examples:\n    change({group: \"all\", logLevel: \"Info\"})\n      ** Change loglevel to Info for all groups.\n\n    change({group: 1, recursive:false, logLevel: \"Warn\"})\n      ** Change logLevel for group 1 to Warn.\n\n    change({group: \"all\", logLevel: \"Debug\", logFormat: \"YearDayMonthTime\", showTimestamp:false, showLoggerName:false})\n      ** Change loglevel to Debug for all groups, apply format, do not show timestamp and logger names.\n";
    return LoggerFactoryControlImpl;
}());
//# sourceMappingURL=LogGroupControl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js":
/*!************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var CategoryService_1 = __webpack_require__(/*! ../log/category/CategoryService */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js");
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var MessageUtils_1 = __webpack_require__(/*! ../utils/MessageUtils */ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js");
var ExtensionHelper = (function () {
    function ExtensionHelper() {
        // Private constructor
    }
    /**
     * Enables the window event listener to listen to messages (from extensions).
     * Can be registered/enabled only once.
     */
    ExtensionHelper.register = function () {
        if (!ExtensionHelper.registered) {
            var listener = function (evt) {
                var msg = evt.data;
                if (msg !== null) {
                    ExtensionHelper.processMessageFromExtension(msg);
                }
            };
            if (typeof window !== "undefined" && typeof window.removeEventListener !== "undefined" && typeof window.addEventListener !== "undefined") {
                window.removeEventListener("message", listener);
                window.addEventListener("message", listener);
                ExtensionHelper.registered = true;
            }
        }
    };
    ExtensionHelper.processMessageFromExtension = function (msg) {
        if (!ExtensionHelper.registered) {
            return;
        }
        /* tslint:disable:no-console */
        if (msg.from === "tsl-extension") {
            var data = msg.data;
            switch (data.type) {
                case "register":
                    ExtensionHelper.enableExtensionIntegration();
                    break;
                case "request-change-loglevel":
                    var valueRequest = data.value;
                    var catsApplied = ExtensionHelper.applyLogLevel(valueRequest.categoryId, valueRequest.logLevel, valueRequest.recursive);
                    if (catsApplied.length > 0) {
                        // Send changes back
                        ExtensionHelper.sendCategoriesRuntimeUpdateMessage(catsApplied);
                    }
                    break;
                default:
                    console.log("Unknown command to process message from extension, command was: " + data.type);
                    break;
            }
        }
        /* tslint:enable:no-console */
    };
    ExtensionHelper.sendCategoryLogMessage = function (msg) {
        if (!ExtensionHelper.registered) {
            return;
        }
        var categoryIds = msg.categories.map(function (cat) {
            return cat.id;
        });
        var content = {
            type: "log-message",
            value: {
                categories: categoryIds,
                errorAsStack: msg.errorAsStack,
                formattedMessage: MessageUtils_1.MessageFormatUtils.renderDefaultMessage(msg, false),
                logLevel: LoggerOptions_1.LogLevel[msg.level].toString(),
                message: msg.messageAsString,
                resolvedErrorMessage: msg.isResolvedErrorMessage
            }
        };
        var message = {
            data: content,
            from: "tsl-logging",
        };
        ExtensionHelper.sendMessage(message);
    };
    ExtensionHelper.sendCategoriesRuntimeUpdateMessage = function (categories) {
        if (!ExtensionHelper.registered) {
            return;
        }
        var service = CategoryService_1.CategoryServiceImpl.getInstance();
        var catLevels = { categories: Array() };
        categories.forEach(function (cat) {
            var catSettings = service.getCategorySettings(cat);
            if (catSettings != null) {
                catLevels.categories.push({ id: cat.id, logLevel: LoggerOptions_1.LogLevel[catSettings.logLevel].toString() });
            }
        });
        var content = {
            type: "categories-rt-update",
            value: catLevels,
        };
        var message = {
            data: content,
            from: "tsl-logging"
        };
        ExtensionHelper.sendMessage(message);
    };
    ExtensionHelper.sendRootCategoriesToExtension = function () {
        if (!ExtensionHelper.registered) {
            return;
        }
        var categories = CategoryService_1.CategoryServiceImpl.getInstance().getRootCategories().map(function (cat) {
            return ExtensionHelper.getCategoryAsJSON(cat);
        });
        var content = {
            type: "root-categories-tree",
            value: categories
        };
        var message = {
            data: content,
            from: "tsl-logging"
        };
        ExtensionHelper.sendMessage(message);
    };
    /**
     * If extension integration is enabled, will send the root categories over to the extension.
     * Otherwise does nothing.
     */
    ExtensionHelper.getCategoryAsJSON = function (cat) {
        var childCategories = cat.children.map(function (child) {
            return ExtensionHelper.getCategoryAsJSON(child);
        });
        return {
            children: childCategories,
            id: cat.id,
            logLevel: LoggerOptions_1.LogLevel[cat.logLevel].toString(),
            name: cat.name,
            parentId: (cat.parent != null ? cat.parent.id : null),
        };
    };
    ExtensionHelper.applyLogLevel = function (categoryId, logLevel, recursive) {
        var cats = [];
        var category = CategoryService_1.CategoryServiceImpl.getInstance().getCategoryById(categoryId);
        if (category != null) {
            ExtensionHelper._applyLogLevelRecursive(category, LoggerOptions_1.LogLevel.fromString(logLevel), recursive, cats);
        }
        else {
            /* tslint:disable:no-console */
            console.log("Could not change log level, failed to find category with id: " + categoryId);
            /* tslint:enable:no-console */
        }
        return cats;
    };
    ExtensionHelper._applyLogLevelRecursive = function (category, logLevel, recursive, cats) {
        var categorySettings = CategoryService_1.CategoryServiceImpl.getInstance().getCategorySettings(category);
        if (categorySettings != null) {
            categorySettings.logLevel = logLevel;
            cats.push(category);
            if (recursive) {
                category.children.forEach(function (child) {
                    ExtensionHelper._applyLogLevelRecursive(child, logLevel, recursive, cats);
                });
            }
        }
    };
    ExtensionHelper.getAllCategories = function () {
        var cats = [];
        var addCats = function (cat, allCats) {
            allCats.push(cat);
            cat.children.forEach(function (catChild) {
                addCats(catChild, allCats);
            });
        };
        CategoryService_1.CategoryServiceImpl.getInstance().getRootCategories().forEach(function (cat) {
            addCats(cat, cats);
        });
        return cats;
    };
    ExtensionHelper.sendMessage = function (msg) {
        if (!ExtensionHelper.registered) {
            return;
        }
        if (typeof window !== "undefined" && typeof window.postMessage !== "undefined") {
            window.postMessage(msg, "*");
        }
    };
    /**
     *  Extension framework will call this to enable the integration between two,
     *  after this call the framework will respond with postMessage() messages.
     */
    ExtensionHelper.enableExtensionIntegration = function () {
        if (!ExtensionHelper.registered) {
            return;
        }
        var instance = CategoryService_1.CategoryServiceImpl.getInstance();
        instance.enableExtensionIntegration();
        // Send over all categories
        ExtensionHelper.sendRootCategoriesToExtension();
        // Send over the current runtime levels
        var cats = ExtensionHelper.getAllCategories();
        ExtensionHelper.sendCategoriesRuntimeUpdateMessage(cats);
    };
    ExtensionHelper.registered = false;
    return ExtensionHelper;
}());
exports.ExtensionHelper = ExtensionHelper;
//# sourceMappingURL=ExtensionHelper.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js":
/*!****************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Log level for a logger.
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Warn"] = 3] = "Warn";
    LogLevel[LogLevel["Error"] = 4] = "Error";
    LogLevel[LogLevel["Fatal"] = 5] = "Fatal";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/* tslint:disable:no-namespace */
(function (LogLevel) {
    /**
     * Returns LogLevel based on string representation
     * @param val Value
     * @returns {LogLevel}, Error is thrown if invalid.
     */
    function fromString(val) {
        if (val == null) {
            throw new Error("Argument must be set");
        }
        switch (val.toLowerCase()) {
            case "trace":
                return LogLevel.Trace;
            case "debug":
                return LogLevel.Debug;
            case "info":
                return LogLevel.Info;
            case "warn":
                return LogLevel.Warn;
            case "error":
                return LogLevel.Error;
            case "fatal":
                return LogLevel.Fatal;
            default:
                throw new Error("Unsupported value for conversion: " + val);
        }
    }
    LogLevel.fromString = fromString;
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/* tslint:disable:enable-namespace */
/**
 * Where to log to? Pick one of the constants. Custom requires a callback to be present, see LFService.createLoggerFactory(...)
 * where this comes into play.
 */
var LoggerType;
(function (LoggerType) {
    LoggerType[LoggerType["Console"] = 0] = "Console";
    LoggerType[LoggerType["MessageBuffer"] = 1] = "MessageBuffer";
    LoggerType[LoggerType["Custom"] = 2] = "Custom";
})(LoggerType = exports.LoggerType || (exports.LoggerType = {}));
/**
 * Defines several date enums used for formatting a date.
 */
var DateFormatEnum;
(function (DateFormatEnum) {
    /**
     * Displays as: year-month-day hour:minute:second,millis -> 1999-02-12 23:59:59,123
     * Note the date separator can be set separately.
     */
    DateFormatEnum[DateFormatEnum["Default"] = 0] = "Default";
    /**
     * Displays as: year-month-day hour:minute:second -> 1999-02-12 23:59:59
     * Note the date separator can be set separately.
     */
    DateFormatEnum[DateFormatEnum["YearMonthDayTime"] = 1] = "YearMonthDayTime";
    /**
     * Displays as: year-day-month hour:minute:second,millis -> 1999-12-02 23:59:59,123
     * Note the date separator can be set separately.
     */
    DateFormatEnum[DateFormatEnum["YearDayMonthWithFullTime"] = 2] = "YearDayMonthWithFullTime";
    /**
     * Displays as: year-day-month hour:minute:second -> 1999-12-02 23:59:59
     * Note the date separator can be set separately.
     */
    DateFormatEnum[DateFormatEnum["YearDayMonthTime"] = 3] = "YearDayMonthTime";
})(DateFormatEnum = exports.DateFormatEnum || (exports.DateFormatEnum = {}));
/* tslint:disable:no-namespace */
(function (DateFormatEnum) {
    /**
     * Returns LogLevel based on string representation
     * @param val Value
     * @returns {LogLevel}, Error is thrown if invalid.
     */
    function fromString(val) {
        if (val == null) {
            throw new Error("Argument must be set");
        }
        switch (val.toLowerCase()) {
            case "default":
                return DateFormatEnum.Default;
            case "yearmonthdayTime":
                return DateFormatEnum.YearMonthDayTime;
            case "yeardaymonthwithfulltime":
                return DateFormatEnum.YearDayMonthWithFullTime;
            case "yeardaymonthtime":
                return DateFormatEnum.YearDayMonthTime;
            default:
                throw new Error("Unsupported value for conversion: " + val);
        }
    }
    DateFormatEnum.fromString = fromString;
})(DateFormatEnum = exports.DateFormatEnum || (exports.DateFormatEnum = {}));
/* tslint:disable:enable-namespace */
/**
 * DateFormat class, stores data on how to format a date.
 */
var DateFormat = (function () {
    /**
     * Constructor to define the dateformat used for logging, can be called empty as it uses defaults.
     * @param formatEnum DateFormatEnum, use one of the constants from the enum. Defaults to DateFormatEnum.Default
     * @param dateSeparator Separator used between dates, defaults to -
     */
    function DateFormat(formatEnum, dateSeparator) {
        if (formatEnum === void 0) { formatEnum = DateFormatEnum.Default; }
        if (dateSeparator === void 0) { dateSeparator = "-"; }
        this._formatEnum = formatEnum;
        this._dateSeparator = dateSeparator;
    }
    Object.defineProperty(DateFormat.prototype, "formatEnum", {
        get: function () {
            return this._formatEnum;
        },
        set: function (value) {
            this._formatEnum = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateFormat.prototype, "dateSeparator", {
        get: function () {
            return this._dateSeparator;
        },
        set: function (value) {
            this._dateSeparator = value;
        },
        enumerable: true,
        configurable: true
    });
    DateFormat.prototype.copy = function () {
        return new DateFormat(this._formatEnum, this._dateSeparator);
    };
    return DateFormat;
}());
exports.DateFormat = DateFormat;
/**
 * Information about the log format, what will a log line look like?
 */
var LogFormat = (function () {
    /**
     * Constructor to create a LogFormat. Can be created without parameters where it will use sane defaults.
     * @param dateFormat DateFormat (what needs the date look like in the log line)
     * @param showTimeStamp Show date timestamp at all?
     * @param showLoggerName Show the logger name?
     */
    function LogFormat(dateFormat, showTimeStamp, showLoggerName) {
        if (dateFormat === void 0) { dateFormat = new DateFormat(); }
        if (showTimeStamp === void 0) { showTimeStamp = true; }
        if (showLoggerName === void 0) { showLoggerName = true; }
        this._showTimeStamp = true;
        this._showLoggerName = true;
        this._dateFormat = dateFormat;
        this._showTimeStamp = showTimeStamp;
        this._showLoggerName = showLoggerName;
    }
    Object.defineProperty(LogFormat.prototype, "dateFormat", {
        get: function () {
            return this._dateFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogFormat.prototype, "showTimeStamp", {
        get: function () {
            return this._showTimeStamp;
        },
        set: function (value) {
            this._showTimeStamp = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogFormat.prototype, "showLoggerName", {
        get: function () {
            return this._showLoggerName;
        },
        set: function (value) {
            this._showLoggerName = value;
        },
        enumerable: true,
        configurable: true
    });
    return LogFormat;
}());
exports.LogFormat = LogFormat;
/**
 * Information about the log format, what will a log line look like?
 */
var CategoryLogFormat = (function () {
    /**
     * Create an instance defining the category log format used.
     * @param dateFormat Date format (uses default), for details see DateFormat class.
     * @param showTimeStamp True to show timestamp in the logging, defaults to true.
     * @param showCategoryName True to show category name in the logging, defaults to true.
     */
    function CategoryLogFormat(dateFormat, showTimeStamp, showCategoryName) {
        if (dateFormat === void 0) { dateFormat = new DateFormat(); }
        if (showTimeStamp === void 0) { showTimeStamp = true; }
        if (showCategoryName === void 0) { showCategoryName = true; }
        this._dateFormat = dateFormat;
        this._showTimeStamp = showTimeStamp;
        this._showCategoryName = showCategoryName;
    }
    Object.defineProperty(CategoryLogFormat.prototype, "dateFormat", {
        get: function () {
            return this._dateFormat;
        },
        set: function (value) {
            this._dateFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogFormat.prototype, "showTimeStamp", {
        get: function () {
            return this._showTimeStamp;
        },
        set: function (value) {
            this._showTimeStamp = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogFormat.prototype, "showCategoryName", {
        get: function () {
            return this._showCategoryName;
        },
        set: function (value) {
            this._showCategoryName = value;
        },
        enumerable: true,
        configurable: true
    });
    CategoryLogFormat.prototype.copy = function () {
        return new CategoryLogFormat(this._dateFormat.copy(), this._showTimeStamp, this._showCategoryName);
    };
    return CategoryLogFormat;
}());
exports.CategoryLogFormat = CategoryLogFormat;
//# sourceMappingURL=LoggerOptions.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var MessageUtils_1 = __webpack_require__(/*! ../../utils/MessageUtils */ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var CategoryLogMessageImpl = (function () {
    function CategoryLogMessageImpl(message, error, categories, date, level, logFormat, ready) {
        this._resolvedErrorMessage = false;
        this._errorAsStack = null;
        this._message = message;
        this._error = error;
        this._categories = categories;
        this._date = date;
        this._level = level;
        this._logFormat = logFormat;
        this._ready = ready;
    }
    Object.defineProperty(CategoryLogMessageImpl.prototype, "message", {
        get: function () {
            return this._message;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "error", {
        get: function () {
            return this._error;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "categories", {
        get: function () {
            return this._categories;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "date", {
        get: function () {
            return this._date;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "level", {
        get: function () {
            return this._level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "isMessageLogData", {
        get: function () {
            return typeof (this._message) !== "string";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "messageAsString", {
        get: function () {
            if (typeof (this._message) === "string") {
                return this._message;
            }
            return this._message.msg;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "logData", {
        get: function () {
            var result = null;
            if (typeof (this._message) !== "string") {
                result = this.message;
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "isResolvedErrorMessage", {
        get: function () {
            return this._resolvedErrorMessage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "errorAsStack", {
        get: function () {
            return this._errorAsStack;
        },
        set: function (stack) {
            this._errorAsStack = stack;
        },
        enumerable: true,
        configurable: true
    });
    CategoryLogMessageImpl.prototype.isReady = function () {
        return this._ready;
    };
    CategoryLogMessageImpl.prototype.setReady = function (value) {
        this._ready = value;
    };
    Object.defineProperty(CategoryLogMessageImpl.prototype, "resolvedErrorMessage", {
        get: function () {
            return this._resolvedErrorMessage;
        },
        set: function (value) {
            this._resolvedErrorMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    return CategoryLogMessageImpl;
}());
/**
 * Abstract category logger, use as your base class for new type of loggers (it
 * saves you a lot of work) and override doLog(CategoryLogMessage). The message argument
 * provides full access to anything related to the logging event.
 * If you just want the standard line of logging, call: this.createDefaultLogMessage(msg) on
 * this class which will return you the formatted log message as string (e.g. the
 * default loggers all use this).
 */
var AbstractCategoryLogger = (function () {
    function AbstractCategoryLogger(rootCategory, runtimeSettings) {
        this.allMessages = new DataStructures_1.LinkedList();
        this.rootCategory = rootCategory;
        this.runtimeSettings = runtimeSettings;
    }
    AbstractCategoryLogger.prototype.trace = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Trace, msg, null, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.debug = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Debug, msg, null, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.info = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Info, msg, null, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.warn = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Warn, msg, null, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.error = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Error, msg, error, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.fatal = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Fatal, msg, error, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.resolved = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Error, msg, error, true].concat(categories));
    };
    AbstractCategoryLogger.prototype.log = function (level, msg, error) {
        var categories = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            categories[_i - 3] = arguments[_i];
        }
        this._log.apply(this, [level, msg, error, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.getRootCategory = function () {
        return this.rootCategory;
    };
    AbstractCategoryLogger.prototype.createDefaultLogMessage = function (msg) {
        return MessageUtils_1.MessageFormatUtils.renderDefaultMessage(msg, true);
    };
    /**
     * Return optional message formatter. All LoggerTypes (except custom) will see if
     * they have this, and if so use it to log.
     * @returns {((message:CategoryLogMessage)=>string)|null}
     */
    AbstractCategoryLogger.prototype._getMessageFormatter = function () {
        var categorySettings = this.runtimeSettings.getCategorySettings(this.rootCategory);
        // Should not happen but make ts happy
        if (categorySettings === null) {
            throw new Error("Did not find CategorySettings for rootCategory: " + this.rootCategory.name);
        }
        return categorySettings.formatterLogMessage;
    };
    AbstractCategoryLogger.prototype._log = function (level, msg, error, resolved) {
        if (error === void 0) { error = null; }
        if (resolved === void 0) { resolved = false; }
        var categories = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            categories[_i - 4] = arguments[_i];
        }
        // this._logInternal(level, () => msg, () => error, resolved, ...categories);
        var functionMessage = function () {
            if (typeof msg === "function") {
                return msg();
            }
            return msg;
        };
        var functionError = function () {
            if (typeof error === "function") {
                return error();
            }
            return error;
        };
        this._logInternal.apply(this, [level, functionMessage, functionError, resolved].concat(categories));
    };
    AbstractCategoryLogger.prototype._logInternal = function (level, msg, error, resolved) {
        var _this = this;
        var categories = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            categories[_i - 4] = arguments[_i];
        }
        var logCategories = [this.rootCategory];
        // Log root category by default if none present
        if (typeof categories !== "undefined" && categories.length > 0) {
            logCategories = logCategories.concat(categories.filter(function (c) { return c !== _this.rootCategory; }));
        }
        var _loop_1 = function (i) {
            var category = logCategories[i];
            if (category === null) {
                throw new Error("Cannot have a null element within categories, at index=" + i);
            }
            var settings = this_1.runtimeSettings.getCategorySettings(category);
            if (settings === null) {
                throw new Error("Category with path: " + category.getCategoryPath() + " is not registered with this logger, maybe " +
                    "you registered it with a different root logger?");
            }
            if (settings.logLevel <= level) {
                var actualError = error !== null ? error() : null;
                if (actualError === null) {
                    var logMessage = new CategoryLogMessageImpl(msg(), actualError, logCategories, new Date(), level, settings.logFormat, true);
                    logMessage.resolvedErrorMessage = resolved;
                    this_1.allMessages.addTail(logMessage);
                    this_1.processMessages();
                }
                else {
                    var logMessage_1 = new CategoryLogMessageImpl(msg(), actualError, logCategories, new Date(), level, settings.logFormat, false);
                    logMessage_1.resolvedErrorMessage = resolved;
                    this_1.allMessages.addTail(logMessage_1);
                    MessageUtils_1.MessageFormatUtils.renderError(actualError).then(function (stack) {
                        logMessage_1.errorAsStack = stack;
                        logMessage_1.setReady(true);
                        _this.processMessages();
                    }).catch(function () {
                        logMessage_1.errorAsStack = "<UNKNOWN> unable to get stack.";
                        logMessage_1.setReady(true);
                        _this.processMessages();
                    });
                }
                return "break";
            }
        };
        var this_1 = this;
        // Get the runtime levels for given categories. If their level is lower than given level, we log.
        // In addition we pass along which category/categories we log this statement for.
        for (var i = 0; i < logCategories.length; i++) {
            var state_1 = _loop_1(i);
            if (state_1 === "break")
                break;
        }
    };
    AbstractCategoryLogger.prototype.processMessages = function () {
        // Basically we wait until errors are resolved (those messages
        // may not be ready).
        var msgs = this.allMessages;
        if (msgs.getSize() > 0) {
            do {
                var msg = msgs.getHead();
                if (msg != null) {
                    if (!msg.isReady()) {
                        break;
                    }
                    msgs.removeHead();
                    this.doLog(msg);
                }
            } while (msgs.getSize() > 0);
        }
    };
    return AbstractCategoryLogger;
}());
exports.AbstractCategoryLogger = AbstractCategoryLogger;
//# sourceMappingURL=AbstractCategoryLogger.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/Category.js":
/*!********************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/Category.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var CategoryService_1 = __webpack_require__(/*! ./CategoryService */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js");
/**
 * Category for use with categorized logging.
 * At minimum you need one category, which will serve as the root category.
 * You can create child categories (like a tree). You can have multiple root
 * categories.
 */
var Category = (function () {
    function Category(name, parent) {
        if (parent === void 0) { parent = null; }
        this._children = [];
        this._logLevel = LoggerOptions_1.LogLevel.Error;
        if (name.indexOf("#") !== -1) {
            throw new Error("Cannot use # in a name of a Category");
        }
        this._id = Category.nextId();
        this._name = name;
        this._parent = parent;
        if (this._parent !== null) {
            this._parent._children.push(this);
        }
        CategoryService_1.CategoryServiceImpl.getInstance().registerCategory(this);
    }
    Object.defineProperty(Category.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Category.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Category.prototype, "children", {
        get: function () {
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Category.prototype, "logLevel", {
        get: function () {
            return this._logLevel;
        },
        enumerable: true,
        configurable: true
    });
    Category.prototype.trace = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).trace.apply(_a, [msg].concat(categories));
        var _a;
    };
    Category.prototype.debug = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).debug.apply(_a, [msg].concat(categories));
        var _a;
    };
    Category.prototype.info = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).info.apply(_a, [msg].concat(categories));
        var _a;
    };
    Category.prototype.warn = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).warn.apply(_a, [msg].concat(categories));
        var _a;
    };
    Category.prototype.error = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).error.apply(_a, [msg, error].concat(categories));
        var _a;
    };
    Category.prototype.fatal = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).fatal.apply(_a, [msg, error].concat(categories));
        var _a;
    };
    Category.prototype.resolved = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).resolved.apply(_a, [msg, error].concat(categories));
        var _a;
    };
    Category.prototype.log = function (level, msg, error) {
        var categories = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            categories[_i - 3] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).log.apply(_a, [level, msg, error].concat(categories));
        var _a;
    };
    Category.prototype.getCategoryPath = function () {
        var result = this.name;
        var cat = this.parent;
        while (cat != null) {
            result = cat.name + "#" + result;
            cat = cat.parent;
        }
        return result;
    };
    Object.defineProperty(Category.prototype, "id", {
        /**
         * Returns the id for this category (this
         * is for internal purposes only).
         * @returns {number} Id
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Category.prototype.loadCategoryLogger = function () {
        if (!this._logger) {
            this._logger = CategoryService_1.CategoryServiceImpl.getInstance().getLogger(this);
        }
        if (typeof this._logger === "undefined" || this._logger === null) {
            throw new Error("Failed to load a logger for category (should not happen): " + this.name);
        }
    };
    Category.nextId = function () {
        return Category.currentId++;
    };
    Category.currentId = 1;
    return Category;
}());
exports.Category = Category;
//# sourceMappingURL=Category.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConfiguration.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConfiguration.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Default configuration, can be used to initially set a different default configuration
 * on the CategoryServiceFactory. This will be applied to all categories already registered (or
 * registered in the future). Can also be applied to one Category (and childs).
 */
var CategoryConfiguration = (function () {
    /**
     * Create a new instance
     * @param logLevel Log level for all loggers, default is LogLevel.Error
     * @param loggerType Where to log, default is LoggerType.Console
     * @param logFormat What logging format to use, use default instance, for default values see CategoryLogFormat.
     * @param callBackLogger Optional callback, if LoggerType.Custom is used as loggerType. In that case must return a new Logger instance.
     *            It is recommended to extend AbstractCategoryLogger to make your custom logger.
     */
    function CategoryConfiguration(logLevel, loggerType, logFormat, callBackLogger) {
        if (logLevel === void 0) { logLevel = LoggerOptions_1.LogLevel.Error; }
        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }
        if (logFormat === void 0) { logFormat = new LoggerOptions_1.CategoryLogFormat(); }
        if (callBackLogger === void 0) { callBackLogger = null; }
        this._formatterLogMessage = null;
        this._logLevel = logLevel;
        this._loggerType = loggerType;
        this._logFormat = logFormat;
        this._callBackLogger = callBackLogger;
        if (this._loggerType === LoggerOptions_1.LoggerType.Custom && this.callBackLogger === null) {
            throw new Error("If you specify loggerType to be Custom, you must provide the callBackLogger argument");
        }
    }
    Object.defineProperty(CategoryConfiguration.prototype, "logLevel", {
        get: function () {
            return this._logLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryConfiguration.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryConfiguration.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryConfiguration.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryConfiguration.prototype, "formatterLogMessage", {
        /**
         * Get the formatterLogMessage function, see comment on the setter.
         * @returns {((message:CategoryLogMessage)=>string)|null}
         */
        get: function () {
            return this._formatterLogMessage;
        },
        /**
         * Set the default formatterLogMessage function, if set it is applied to all type of loggers except for a custom logger.
         * By default this is null (not set). You can assign a function to allow custom formatting of a log message.
         * Each log message will call this function then and expects your function to format the message and return a string.
         * Will throw an error if you attempt to set a formatterLogMessage if the LoggerType is custom.
         * @param value The formatter function, or null to reset it.
         */
        set: function (value) {
            if (value !== null && this._loggerType === LoggerOptions_1.LoggerType.Custom) {
                throw new Error("You cannot specify a formatter for log messages if your loggerType is Custom");
            }
            this._formatterLogMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    CategoryConfiguration.prototype.copy = function () {
        var config = new CategoryConfiguration(this.logLevel, this.loggerType, this.logFormat.copy(), this.callBackLogger);
        config.formatterLogMessage = this.formatterLogMessage;
        return config;
    };
    return CategoryConfiguration;
}());
exports.CategoryConfiguration = CategoryConfiguration;
//# sourceMappingURL=CategoryConfiguration.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConsoleLoggerImpl.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConsoleLoggerImpl.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var AbstractCategoryLogger_1 = __webpack_require__(/*! ./AbstractCategoryLogger */ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js");
/**
 * Simple logger, that logs to the console. If the console is unavailable will throw an exception.
 */
var CategoryConsoleLoggerImpl = (function (_super) {
    __extends(CategoryConsoleLoggerImpl, _super);
    function CategoryConsoleLoggerImpl(rootCategory, runtimeSettings) {
        return _super.call(this, rootCategory, runtimeSettings) || this;
    }
    CategoryConsoleLoggerImpl.prototype.doLog = function (msg) {
        if (console !== undefined) {
            var messageFormatter = this._getMessageFormatter();
            var fullMsg = void 0;
            if (messageFormatter === null) {
                fullMsg = this.createDefaultLogMessage(msg);
            }
            else {
                fullMsg = messageFormatter(msg);
            }
            var logged = false;
            /* tslint:disable:no-console */
            switch (msg.level) {
                case LoggerOptions_1.LogLevel.Trace:
                    // Don't try trace we don't want stacks
                    break;
                case LoggerOptions_1.LogLevel.Debug:
                    // Don't try, too much differences of consoles.
                    break;
                case LoggerOptions_1.LogLevel.Info:
                    if (console.info) {
                        console.info(fullMsg);
                        logged = true;
                    }
                    break;
                case LoggerOptions_1.LogLevel.Warn:
                    if (console.warn) {
                        console.warn(fullMsg);
                        logged = true;
                    }
                    break;
                case LoggerOptions_1.LogLevel.Error:
                case LoggerOptions_1.LogLevel.Fatal:
                    if (console.error) {
                        console.error(fullMsg);
                        logged = true;
                    }
                    break;
                default:
                    throw new Error("Unsupported level: " + msg.level);
            }
            if (!logged) {
                console.log(fullMsg);
            }
            /* tslint:enable:no-console */
        }
        else {
            throw new Error("Console is not defined, cannot log msg: " + msg.messageAsString);
        }
    };
    return CategoryConsoleLoggerImpl;
}(AbstractCategoryLogger_1.AbstractCategoryLogger));
exports.CategoryConsoleLoggerImpl = CategoryConsoleLoggerImpl;
//# sourceMappingURL=CategoryConsoleLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryDelegateLoggerImpl.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryDelegateLoggerImpl.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Delegate logger, delegates logging to given logger (constructor).
 */
var CategoryDelegateLoggerImpl = (function () {
    function CategoryDelegateLoggerImpl(delegate) {
        this._delegate = delegate;
    }
    Object.defineProperty(CategoryDelegateLoggerImpl.prototype, "delegate", {
        get: function () {
            return this._delegate;
        },
        set: function (value) {
            this._delegate = value;
        },
        enumerable: true,
        configurable: true
    });
    CategoryDelegateLoggerImpl.prototype.trace = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        (_a = this._delegate).trace.apply(_a, [msg].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.debug = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        (_a = this._delegate).debug.apply(_a, [msg].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.info = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        (_a = this._delegate).info.apply(_a, [msg].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.warn = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        (_a = this._delegate).warn.apply(_a, [msg].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.error = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        (_a = this._delegate).error.apply(_a, [msg, error].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.fatal = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        (_a = this._delegate).fatal.apply(_a, [msg, error].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.resolved = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        (_a = this._delegate).resolved.apply(_a, [msg, error].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.log = function (level, msg, error) {
        var categories = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            categories[_i - 3] = arguments[_i];
        }
        (_a = this._delegate).log.apply(_a, [level, msg, error].concat(categories));
        var _a;
    };
    return CategoryDelegateLoggerImpl;
}());
exports.CategoryDelegateLoggerImpl = CategoryDelegateLoggerImpl;
//# sourceMappingURL=CategoryDelegateLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryExtensionLoggerImpl.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryExtensionLoggerImpl.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ExtensionHelper_1 = __webpack_require__(/*! ../../extension/ExtensionHelper */ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js");
var AbstractCategoryLogger_1 = __webpack_require__(/*! ./AbstractCategoryLogger */ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js");
/**
 * This class should not be used directly, it is used for communication with the extension only.
 */
var CategoryExtensionLoggerImpl = (function (_super) {
    __extends(CategoryExtensionLoggerImpl, _super);
    function CategoryExtensionLoggerImpl(rootCategory, runtimeSettings) {
        return _super.call(this, rootCategory, runtimeSettings) || this;
    }
    CategoryExtensionLoggerImpl.prototype.doLog = function (msg) {
        if (typeof window !== "undefined") {
            ExtensionHelper_1.ExtensionHelper.sendCategoryLogMessage(msg);
        }
        else {
            /* tslint:disable:no-console */
            console.log("window is not available, you must be running in a browser for this. Dropped message.");
            /* tslint:enable:no-console */
        }
    };
    return CategoryExtensionLoggerImpl;
}(AbstractCategoryLogger_1.AbstractCategoryLogger));
exports.CategoryExtensionLoggerImpl = CategoryExtensionLoggerImpl;
//# sourceMappingURL=CategoryExtensionLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryMessageBufferImpl.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryMessageBufferImpl.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var AbstractCategoryLogger_1 = __webpack_require__(/*! ./AbstractCategoryLogger */ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js");
/**
 * Logger which buffers all messages, use with care due to possible high memory footprint.
 * Can be convenient in some cases. Call toString() for full output, or cast to this class
 * and call getMessages() to do something with it yourself.
 */
var CategoryMessageBufferLoggerImpl = (function (_super) {
    __extends(CategoryMessageBufferLoggerImpl, _super);
    function CategoryMessageBufferLoggerImpl() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.messages = [];
        return _this;
    }
    CategoryMessageBufferLoggerImpl.prototype.getMessages = function () {
        return this.messages;
    };
    CategoryMessageBufferLoggerImpl.prototype.toString = function () {
        return this.messages.map(function (msg) {
            return msg;
        }).join("\n");
    };
    CategoryMessageBufferLoggerImpl.prototype.doLog = function (msg) {
        var messageFormatter = this._getMessageFormatter();
        var fullMsg;
        if (messageFormatter === null) {
            fullMsg = this.createDefaultLogMessage(msg);
        }
        else {
            fullMsg = messageFormatter(msg);
        }
        this.messages.push(fullMsg);
    };
    return CategoryMessageBufferLoggerImpl;
}(AbstractCategoryLogger_1.AbstractCategoryLogger));
exports.CategoryMessageBufferLoggerImpl = CategoryMessageBufferLoggerImpl;
//# sourceMappingURL=CategoryMessageBufferImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryRuntimeSettings.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryRuntimeSettings.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * RuntimeSettings for a category, at runtime these are associated to a category.
 */
var CategoryRuntimeSettings = (function () {
    function CategoryRuntimeSettings(category, logLevel, loggerType, logFormat, callBackLogger, formatterLogMessage) {
        if (logLevel === void 0) { logLevel = LoggerOptions_1.LogLevel.Error; }
        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }
        if (logFormat === void 0) { logFormat = new LoggerOptions_1.CategoryLogFormat(); }
        if (callBackLogger === void 0) { callBackLogger = null; }
        if (formatterLogMessage === void 0) { formatterLogMessage = null; }
        this._formatterLogMessage = null;
        this._category = category;
        this._logLevel = logLevel;
        this._loggerType = loggerType;
        this._logFormat = logFormat;
        this._callBackLogger = callBackLogger;
        this._formatterLogMessage = formatterLogMessage;
    }
    Object.defineProperty(CategoryRuntimeSettings.prototype, "category", {
        get: function () {
            return this._category;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "logLevel", {
        get: function () {
            return this._logLevel;
        },
        set: function (value) {
            this._logLevel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        set: function (value) {
            this._loggerType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        set: function (value) {
            this._logFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        set: function (value) {
            this._callBackLogger = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "formatterLogMessage", {
        get: function () {
            return this._formatterLogMessage;
        },
        set: function (value) {
            this._formatterLogMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    return CategoryRuntimeSettings;
}());
exports.CategoryRuntimeSettings = CategoryRuntimeSettings;
//# sourceMappingURL=CategoryRuntimeSettings.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var CategoryConsoleLoggerImpl_1 = __webpack_require__(/*! ./CategoryConsoleLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConsoleLoggerImpl.js");
var CategoryDelegateLoggerImpl_1 = __webpack_require__(/*! ./CategoryDelegateLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryDelegateLoggerImpl.js");
var CategoryExtensionLoggerImpl_1 = __webpack_require__(/*! ./CategoryExtensionLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryExtensionLoggerImpl.js");
var CategoryMessageBufferImpl_1 = __webpack_require__(/*! ./CategoryMessageBufferImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryMessageBufferImpl.js");
var ExtensionHelper_1 = __webpack_require__(/*! ../../extension/ExtensionHelper */ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js");
var CategoryRuntimeSettings_1 = __webpack_require__(/*! ./CategoryRuntimeSettings */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryRuntimeSettings.js");
var CategoryConfiguration_1 = __webpack_require__(/*! ./CategoryConfiguration */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConfiguration.js");
/**
 * The service (only available as singleton) for all category related stuff as
 * retrieving, registering a logger. You should normally NOT use this,
 * instead use CategoryServiceFactory which is meant for end users.
 */
var CategoryServiceImpl = (function () {
    function CategoryServiceImpl() {
        this._defaultConfig = new CategoryConfiguration_1.CategoryConfiguration();
        this._mapState = new DataStructures_1.SimpleMap();
        // Private constructor
        ExtensionHelper_1.ExtensionHelper.register();
    }
    CategoryServiceImpl.getInstance = function () {
        // Load on-demand, to assure webpack ordering of module usage doesn't screw things over
        // for us when we accidentally change the order.
        if (CategoryServiceImpl._INSTANCE === null) {
            CategoryServiceImpl._INSTANCE = new CategoryServiceImpl();
        }
        return CategoryServiceImpl._INSTANCE;
    };
    CategoryServiceImpl.prototype.getLogger = function (category) {
        return this.createOrGetCategoryState(category).logger;
    };
    /**
     * Clears everything, including a default configuration you may have set.
     * After this you need to re-register your categories etc.
     */
    CategoryServiceImpl.prototype.clear = function () {
        this._mapState.clear();
        this.setDefaultConfiguration(new CategoryConfiguration_1.CategoryConfiguration());
    };
    CategoryServiceImpl.prototype.getCategorySettings = function (category) {
        return this.createOrGetCategoryState(category).currentRuntimeSettings;
    };
    CategoryServiceImpl.prototype.getOriginalCategorySettings = function (category) {
        return this.createOrGetCategoryState(category).originalRuntimeSettings;
    };
    /**
     * Set the default configuration. New root loggers created get this
     * applied. If you want to reset all current loggers to have this
     * applied as well, pass in reset=true (the default is false). All
     * categories will be reset then as well.
     * @param config New config
     * @param reset Defaults to true. Set to true to reset all loggers and current runtimesettings.
     */
    CategoryServiceImpl.prototype.setDefaultConfiguration = function (config, reset) {
        if (reset === void 0) { reset = true; }
        this._defaultConfig = config;
        if (reset) {
            this._mapState.forEachValue(function (state) {
                state.updateSettings(config);
            });
        }
    };
    /**
     * Set new configuration settings for a category (and possibly its child categories)
     * @param config Config
     * @param category Category
     * @param applyChildren True to apply to child categories, defaults to false.
     */
    CategoryServiceImpl.prototype.setConfigurationCategory = function (config, category, applyChildren) {
        var _this = this;
        if (applyChildren === void 0) { applyChildren = false; }
        this.createOrGetCategoryState(category).updateSettings(config);
        // Apply the settings to children recursive if requested
        if (applyChildren) {
            category.children.forEach(function (child) {
                // False flag, a child cannot reset a rootlogger
                _this.setConfigurationCategory(config, child, applyChildren);
            });
        }
    };
    CategoryServiceImpl.prototype.registerCategory = function (category) {
        if (category === null || typeof category === "undefined") {
            throw new Error("Category CANNOT be null/undefined");
        }
        if (this._mapState.exists(CategoryServiceImpl.getCategoryKey(category))) {
            throw new Error("Cannot add this root category with name: " + category.name + ", it already exists (same name in hierarchy).");
        }
        this.createOrGetCategoryState(category);
    };
    /**
     * Used to enable integration with chrome extension. Do not use manually, the
     * extension and the logger framework deal with this.
     */
    CategoryServiceImpl.prototype.enableExtensionIntegration = function () {
        var _this = this;
        this._mapState.forEachValue(function (state) { return state.enableForExtension(_this); });
    };
    /**
     * Return all root categories currently registered.
     */
    CategoryServiceImpl.prototype.getRootCategories = function () {
        return this._mapState.values().filter(function (state) { return state.category.parent == null; }).map(function (state) { return state.category; });
    };
    /**
     * Return Category by id
     * @param id The id of the category to find
     * @returns {Category} or null if not found
     */
    CategoryServiceImpl.prototype.getCategoryById = function (id) {
        var result = this._mapState.values().filter(function (state) { return state.category.id === id; }).map(function (state) { return state.category; });
        if (result.length === 1) {
            return result[0];
        }
        return null;
    };
    CategoryServiceImpl.prototype.createOrGetCategoryState = function (category) {
        var key = CategoryServiceImpl.getCategoryKey(category);
        var state = this._mapState.get(key);
        if (typeof state !== "undefined") {
            return state;
        }
        var newState = this.createState(category);
        this._mapState.put(key, newState);
        return newState;
    };
    CategoryServiceImpl.prototype.createState = function (category) {
        var _this = this;
        return new CategoryState(category, function () { return _this._defaultConfig; }, function (config, cat) { return _this.createLogger(config, cat); });
    };
    CategoryServiceImpl.prototype.createLogger = function (config, category) {
        // Default is always a console logger
        switch (config.loggerType) {
            case LoggerOptions_1.LoggerType.Console:
                return new CategoryConsoleLoggerImpl_1.CategoryConsoleLoggerImpl(category, this);
            case LoggerOptions_1.LoggerType.MessageBuffer:
                return new CategoryMessageBufferImpl_1.CategoryMessageBufferLoggerImpl(category, this);
            case LoggerOptions_1.LoggerType.Custom:
                if (config.callBackLogger === null) {
                    throw new Error("Cannot create custom logger, custom callback is null");
                }
                else {
                    return config.callBackLogger(category, this);
                }
            default:
                throw new Error("Cannot create a Logger for LoggerType: " + config.loggerType);
        }
    };
    CategoryServiceImpl.getCategoryKey = function (category) {
        return category.getCategoryPath();
    };
    // Singleton category service, used by CategoryServiceFactory as well as Categories.
    // Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.
    CategoryServiceImpl._INSTANCE = null;
    return CategoryServiceImpl;
}());
exports.CategoryServiceImpl = CategoryServiceImpl;
var CategoryState = (function () {
    function CategoryState(category, defaultConfig, createLogger) {
        this._category = category;
        this._lazyState = new LazyState(category, defaultConfig, createLogger);
    }
    Object.defineProperty(CategoryState.prototype, "category", {
        get: function () {
            return this._category;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryState.prototype, "logger", {
        get: function () {
            return this._lazyState.getLogger();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryState.prototype, "originalRuntimeSettings", {
        get: function () {
            return this._lazyState.getOriginalRuntimeSettings();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryState.prototype, "currentRuntimeSettings", {
        get: function () {
            return this._lazyState.getCurrentRuntimeSettings();
        },
        enumerable: true,
        configurable: true
    });
    CategoryState.prototype.enableForExtension = function (runtimeSettings) {
        this._lazyState.enableForExtension(runtimeSettings);
    };
    CategoryState.prototype.updateSettings = function (config) {
        this._lazyState.updateSettings(config);
    };
    return CategoryState;
}());
var LazyState = (function () {
    function LazyState(category, defaultConfig, createLogger) {
        this._category = category;
        this._defaultConfig = defaultConfig;
        this._createLogger = createLogger;
    }
    LazyState.prototype.isLoaded = function () {
        return (typeof this._logger !== "undefined");
    };
    LazyState.prototype.getLogger = function () {
        this.loadLoggerOnDemand();
        return this._delegateLogger;
    };
    LazyState.prototype.getOriginalRuntimeSettings = function () {
        this.loadLoggerOnDemand();
        return this._originalRuntimeSettings;
    };
    LazyState.prototype.getCurrentRuntimeSettings = function () {
        this.loadLoggerOnDemand();
        return this._currentRuntimeSettings;
    };
    LazyState.prototype.enableForExtension = function (runtimeSettings) {
        this.loadLoggerOnDemand();
        if (!(this._wrappedLogger instanceof CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl)) {
            /* tslint:disable no-console */
            console.log("Reconfiguring logger for extension for category: " + this._category.name);
            /* tslint:enable no-console */
            this._wrappedLogger = new CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl(this._category, runtimeSettings);
            this._delegateLogger.delegate = this._wrappedLogger;
        }
    };
    LazyState.prototype.updateSettings = function (config) {
        if (this.isLoaded()) {
            this._currentRuntimeSettings.logLevel = config.logLevel;
            this._currentRuntimeSettings.loggerType = config.loggerType;
            this._currentRuntimeSettings.logFormat = config.logFormat;
            this._currentRuntimeSettings.callBackLogger = config.callBackLogger;
            this._currentRuntimeSettings.formatterLogMessage = config.formatterLogMessage;
            // Replace the real logger, it may have changed.
            this._logger = this._createLogger(config, this._category);
            if (!(this._wrappedLogger instanceof CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl)) {
                this._wrappedLogger = this._logger;
            }
            this._delegateLogger.delegate = this._wrappedLogger;
        }
        else {
            // Set this config, it may be for the category specific, the default is therefore not good enough.
            this._defaultConfig = function () { return config; };
        }
    };
    LazyState.prototype.loadLoggerOnDemand = function () {
        if (!this.isLoaded()) {
            this._logger = this._createLogger(this._defaultConfig(), this._category);
            this._wrappedLogger = this._logger;
            this._delegateLogger = new CategoryDelegateLoggerImpl_1.CategoryDelegateLoggerImpl(this._wrappedLogger);
            this._originalRuntimeSettings = this.initNewSettings();
            this._currentRuntimeSettings = this.initNewSettings();
        }
    };
    LazyState.prototype.initNewSettings = function () {
        var defSettings = this._defaultConfig().copy();
        return new CategoryRuntimeSettings_1.CategoryRuntimeSettings(this._category, defSettings.logLevel, defSettings.loggerType, defSettings.logFormat, defSettings.callBackLogger, defSettings.formatterLogMessage);
    };
    return LazyState;
}());
//# sourceMappingURL=CategoryService.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryServiceFactory.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryServiceFactory.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var CategoryService_1 = __webpack_require__(/*! ./CategoryService */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js");
/**
 * Categorized service for logging, where logging is bound to categories which
 * can log horizontally through specific application logic (services, group(s) of components etc).
 * For the standard way of logging like most frameworks do these days, use LFService instead.
 * If you want fine grained control to divide sections of your application in
 * logical units to enable/disable logging for, this is the service you want to use instead.
 * Also for this type a browser plugin will be available.
 */
var CategoryServiceFactory = (function () {
    function CategoryServiceFactory() {
        // Private constructor.
    }
    /**
     * Return a CategoryLogger for given ROOT category (thus has no parent).
     * You can only retrieve loggers for their root, when logging
     * you specify to log for what (child)categories.
     * @param root Category root (has no parent)
     * @returns {CategoryLogger}
     */
    CategoryServiceFactory.getLogger = function (root) {
        return CategoryService_1.CategoryServiceImpl.getInstance().getLogger(root);
    };
    /**
     * Clears everything, any registered (root)categories and loggers
     * are discarded. Resets to default configuration.
     */
    CategoryServiceFactory.clear = function () {
        return CategoryService_1.CategoryServiceImpl.getInstance().clear();
    };
    /**
     * Set the default configuration. New root loggers created get this
     * applied. If you want to reset all current loggers to have this
     * applied as well, pass in reset=true (the default is false). All
     * categories runtimesettings will be reset then as well.
     * @param config The new default configuration
     * @param reset If true, will reset *all* runtimesettings for all loggers/categories to these. Default is true.
     */
    CategoryServiceFactory.setDefaultConfiguration = function (config, reset) {
        if (reset === void 0) { reset = true; }
        CategoryService_1.CategoryServiceImpl.getInstance().setDefaultConfiguration(config, reset);
    };
    /**
     * Set new configuration settings for a category (and possibly its child categories)
     * @param config Config
     * @param category Category
     * @param applyChildren True to apply to child categories, defaults to false.
     */
    CategoryServiceFactory.setConfigurationCategory = function (config, category, applyChildren) {
        if (applyChildren === void 0) { applyChildren = false; }
        CategoryService_1.CategoryServiceImpl.getInstance().setConfigurationCategory(config, category, applyChildren);
    };
    return CategoryServiceFactory;
}());
exports.CategoryServiceFactory = CategoryServiceFactory;
//# sourceMappingURL=CategoryServiceFactory.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var MessageUtils_1 = __webpack_require__(/*! ../../utils/MessageUtils */ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js");
var LogMessageInternalImpl = (function () {
    function LogMessageInternalImpl(loggerName, message, errorAsStack, error, logGroupRule, date, level, ready) {
        this._errorAsStack = null;
        this._error = null;
        this._loggerName = loggerName;
        this._message = message;
        this._errorAsStack = errorAsStack;
        this._error = error;
        this._logGroupRule = logGroupRule;
        this._date = date;
        this._level = level;
        this._ready = ready;
    }
    Object.defineProperty(LogMessageInternalImpl.prototype, "loggerName", {
        get: function () {
            return this._loggerName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "message", {
        get: function () {
            return this._message;
        },
        set: function (value) {
            this._message = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "errorAsStack", {
        get: function () {
            return this._errorAsStack;
        },
        set: function (value) {
            this._errorAsStack = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "error", {
        get: function () {
            return this._error;
        },
        set: function (value) {
            this._error = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "logGroupRule", {
        get: function () {
            return this._logGroupRule;
        },
        set: function (value) {
            this._logGroupRule = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "date", {
        get: function () {
            return this._date;
        },
        set: function (value) {
            this._date = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "level", {
        get: function () {
            return this._level;
        },
        set: function (value) {
            this._level = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "isMessageLogData", {
        get: function () {
            return typeof (this._message) !== "string";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "ready", {
        get: function () {
            return this._ready;
        },
        set: function (value) {
            this._ready = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "messageAsString", {
        get: function () {
            if (typeof (this._message) === "string") {
                return this._message;
            }
            return this._message.msg;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "logData", {
        get: function () {
            var result = null;
            if (typeof (this._message) !== "string") {
                result = this.message;
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    return LogMessageInternalImpl;
}());
/**
 * Abstract base logger, extend to easily implement a custom logger that
 * logs wherever you want. You only need to implement doLog(msg: LogMessage) and
 * log that somewhere (it will contain format and everything else).
 */
var AbstractLogger = (function () {
    function AbstractLogger(name, logGroupRuntimeSettings) {
        this._allMessages = new DataStructures_1.LinkedList();
        this._open = true;
        this._name = name;
        this._logGroupRuntimeSettings = logGroupRuntimeSettings;
    }
    Object.defineProperty(AbstractLogger.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    AbstractLogger.prototype.trace = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Trace, msg, error);
    };
    AbstractLogger.prototype.debug = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Debug, msg, error);
    };
    AbstractLogger.prototype.info = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Info, msg, error);
    };
    AbstractLogger.prototype.warn = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Warn, msg, error);
    };
    AbstractLogger.prototype.error = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Error, msg, error);
    };
    AbstractLogger.prototype.fatal = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Fatal, msg, error);
    };
    AbstractLogger.prototype.isTraceEnabled = function () {
        return this._logGroupRuntimeSettings.level === LoggerOptions_1.LogLevel.Trace;
    };
    AbstractLogger.prototype.isDebugEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Debug;
    };
    AbstractLogger.prototype.isInfoEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Info;
    };
    AbstractLogger.prototype.isWarnEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Warn;
    };
    AbstractLogger.prototype.isErrorEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Error;
    };
    AbstractLogger.prototype.isFatalEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Fatal;
    };
    AbstractLogger.prototype.getLogLevel = function () {
        return this._logGroupRuntimeSettings.level;
    };
    AbstractLogger.prototype.isOpen = function () {
        return this._open;
    };
    AbstractLogger.prototype.close = function () {
        this._open = false;
        this._allMessages.clear();
    };
    AbstractLogger.prototype.createDefaultLogMessage = function (msg) {
        return MessageUtils_1.MessageFormatUtils.renderDefaultLog4jMessage(msg, true);
    };
    /**
     * Return optional message formatter. All LoggerTypes (except custom) will see if
     * they have this, and if so use it to log.
     * @returns {((message:LogMessage)=>string)|null}
     */
    AbstractLogger.prototype._getMessageFormatter = function () {
        return this._logGroupRuntimeSettings.formatterLogMessage;
    };
    AbstractLogger.prototype._log = function (level, msg, error) {
        if (error === void 0) { error = null; }
        if (this._open && this._logGroupRuntimeSettings.level <= level) {
            var functionMessage = function () {
                if (typeof msg === "function") {
                    return msg();
                }
                return msg;
            };
            var functionError = function () {
                if (typeof error === "function") {
                    return error();
                }
                return error;
            };
            this._allMessages.addTail(this.createMessage(level, functionMessage, functionError, new Date()));
            this.processMessages();
        }
    };
    AbstractLogger.prototype.createMessage = function (level, msg, error, date) {
        var _this = this;
        var errorResult = error();
        if (errorResult !== null) {
            var message_1 = new LogMessageInternalImpl(this._name, msg(), null, errorResult, this._logGroupRuntimeSettings.logGroupRule, date, level, false);
            MessageUtils_1.MessageFormatUtils.renderError(errorResult).then(function (stack) {
                message_1.errorAsStack = stack;
                message_1.ready = true;
                _this.processMessages();
            }).catch(function () {
                message_1.errorAsStack = "<UNKNOWN> unable to get stack.";
                message_1.ready = true;
                _this.processMessages();
            });
            return message_1;
        }
        return new LogMessageInternalImpl(this._name, msg(), null, errorResult, this._logGroupRuntimeSettings.logGroupRule, date, level, true);
    };
    AbstractLogger.prototype.processMessages = function () {
        // Basically we wait until errors are resolved (those messages
        // may not be ready).
        var msgs = this._allMessages;
        if (msgs.getSize() > 0) {
            do {
                var msg = msgs.getHead();
                if (msg != null) {
                    if (!msg.ready) {
                        break;
                    }
                    msgs.removeHead();
                    // This can never be null normally, but strict null checking ...
                    if (msg.message !== null) {
                        this.doLog(msg);
                    }
                }
            } while (msgs.getSize() > 0);
        }
    };
    return AbstractLogger;
}());
exports.AbstractLogger = AbstractLogger;
//# sourceMappingURL=AbstractLogger.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/ConsoleLoggerImpl.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/ConsoleLoggerImpl.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var AbstractLogger_1 = __webpack_require__(/*! ./AbstractLogger */ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Simple logger, that logs to the console. If the console is unavailable will throw exception.
 */
var ConsoleLoggerImpl = (function (_super) {
    __extends(ConsoleLoggerImpl, _super);
    function ConsoleLoggerImpl(name, logGroupRuntimeSettings) {
        return _super.call(this, name, logGroupRuntimeSettings) || this;
    }
    ConsoleLoggerImpl.prototype.doLog = function (message) {
        if (console !== undefined) {
            var logged = false;
            var logLevel = message.level;
            var messageFormatter = this._getMessageFormatter();
            var msg = void 0;
            if (messageFormatter === null) {
                msg = this.createDefaultLogMessage(message);
            }
            else {
                msg = messageFormatter(message);
            }
            /* tslint:disable:no-console */
            switch (logLevel) {
                case LoggerOptions_1.LogLevel.Trace:
                    // Do not try trace we don't want a stack
                    break;
                case LoggerOptions_1.LogLevel.Debug:
                    // Don't try, too much differences of consoles.
                    break;
                case LoggerOptions_1.LogLevel.Info:
                    if (console.info) {
                        console.info(msg);
                        logged = true;
                    }
                    break;
                case LoggerOptions_1.LogLevel.Warn:
                    if (console.warn) {
                        console.warn(msg);
                        logged = true;
                    }
                    break;
                case LoggerOptions_1.LogLevel.Error:
                case LoggerOptions_1.LogLevel.Fatal:
                    if (console.error) {
                        console.error(msg);
                        logged = true;
                    }
                    break;
                default:
                    throw new Error("Log level not supported: " + logLevel);
            }
            if (!logged) {
                console.log(msg);
            }
            /* tslint:enable:no-console */
        }
        else {
            throw new Error("Console is not defined, cannot log msg: " + message.message);
        }
    };
    return ConsoleLoggerImpl;
}(AbstractLogger_1.AbstractLogger));
exports.ConsoleLoggerImpl = ConsoleLoggerImpl;
//# sourceMappingURL=ConsoleLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LFService.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LFService.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var LoggerFactoryImpl_1 = __webpack_require__(/*! ./LoggerFactoryImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryImpl.js");
var ExtensionHelper_1 = __webpack_require__(/*! ../../extension/ExtensionHelper */ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js");
var LogGroupRule_1 = __webpack_require__(/*! ./LogGroupRule */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRule.js");
var LoggerFactoryOptions_1 = __webpack_require__(/*! ./LoggerFactoryOptions */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryOptions.js");
var LFServiceImpl = (function () {
    function LFServiceImpl() {
        // Private constructor.
        this._nameCounter = 1;
        this._mapFactories = new DataStructures_1.SimpleMap();
        ExtensionHelper_1.ExtensionHelper.register();
    }
    LFServiceImpl.getInstance = function () {
        // Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.
        if (LFServiceImpl._INSTANCE === null) {
            LFServiceImpl._INSTANCE = new LFServiceImpl();
        }
        return LFServiceImpl._INSTANCE;
    };
    /**
     * Create a new LoggerFactory with given options (if any). If no options
     * are specified, the LoggerFactory, will accept any named logger and will
     * log on info level by default for, to the console.
     * @param options Options, optional.
     * @returns {LoggerFactory}
     */
    LFServiceImpl.prototype.createLoggerFactory = function (options) {
        if (options === void 0) { options = null; }
        var name = "LoggerFactory" + this._nameCounter++;
        return this.createNamedLoggerFactory(name, options);
    };
    /**
     * Create a new LoggerFactory using given name (used for console api/extension).
     * @param name Name Pick something short but distinguishable.
     * @param options Options, optional
     * @return {LoggerFactory}
     */
    LFServiceImpl.prototype.createNamedLoggerFactory = function (name, options) {
        if (options === void 0) { options = null; }
        if (this._mapFactories.exists(name)) {
            throw new Error("LoggerFactory with name " + name + " already exists.");
        }
        var factory;
        if (options !== null) {
            factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(name, options);
        }
        else {
            factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(name, LFServiceImpl.createDefaultOptions());
        }
        this._mapFactories.put(name, factory);
        return factory;
    };
    /**
     * Closes all Loggers for LoggerFactories that were created.
     * After this call, all previously fetched Loggers (from their
     * factories) are unusable. The factories remain as they were.
     */
    LFServiceImpl.prototype.closeLoggers = function () {
        this._mapFactories.values().forEach(function (factory) {
            factory.closeLoggers();
        });
        this._mapFactories.clear();
        this._nameCounter = 1;
    };
    LFServiceImpl.prototype.getRuntimeSettingsForLoggerFactories = function () {
        var result = [];
        this._mapFactories.forEachValue(function (factory) { return result.push(factory); });
        return result;
    };
    LFServiceImpl.prototype.getLogGroupSettings = function (nameLoggerFactory, idLogGroupRule) {
        var factory = this._mapFactories.get(nameLoggerFactory);
        if (typeof factory === "undefined") {
            return null;
        }
        return factory.getLogGroupRuntimeSettingsByIndex(idLogGroupRule);
    };
    LFServiceImpl.prototype.getLoggerFactoryRuntimeSettingsByName = function (nameLoggerFactory) {
        var result = this._mapFactories.get(nameLoggerFactory);
        if (typeof result === "undefined") {
            return null;
        }
        return result;
    };
    LFServiceImpl.createDefaultOptions = function () {
        return new LoggerFactoryOptions_1.LoggerFactoryOptions().addLogGroupRule(new LogGroupRule_1.LogGroupRule(new RegExp(".+"), LoggerOptions_1.LogLevel.Info));
    };
    // Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.
    LFServiceImpl._INSTANCE = null;
    return LFServiceImpl;
}());
/**
 * Create and configure your LoggerFactory from here.
 */
var LFService = (function () {
    function LFService() {
    }
    /**
     * Create a new LoggerFactory with given options (if any). If no options
     * are specified, the LoggerFactory, will accept any named logger and will
     * log on info level by default for, to the console.
     * @param options Options, optional.
     * @returns {LoggerFactory}
     */
    LFService.createLoggerFactory = function (options) {
        if (options === void 0) { options = null; }
        return LFService.INSTANCE_SERVICE.createLoggerFactory(options);
    };
    /**
     * Create a new LoggerFactory using given name (used for console api/extension).
     * @param name Name Pick something short but distinguishable. The word "DEFAULT" is reserved and cannot be taken, it is used
     * for the default LoggerFactory.
     * @param options Options, optional
     * @return {LoggerFactory}
     */
    LFService.createNamedLoggerFactory = function (name, options) {
        if (options === void 0) { options = null; }
        if (name === LFService.DEFAULT_LOGGER_FACTORY_NAME) {
            throw new Error("LoggerFactory name: " + LFService.DEFAULT_LOGGER_FACTORY_NAME + " is reserved and cannot be used.");
        }
        return LFService.INSTANCE_SERVICE.createNamedLoggerFactory(name, options);
    };
    /**
     * Closes all Loggers for LoggerFactories that were created.
     * After this call, all previously fetched Loggers (from their
     * factories) are unusable. The factories remain as they were.
     */
    LFService.closeLoggers = function () {
        return LFService.INSTANCE_SERVICE.closeLoggers();
    };
    /**
     * Return LFServiceRuntimeSettings to retrieve information loggerfactories
     * and their runtime settings.
     * @returns {LFServiceRuntimeSettings}
     */
    LFService.getRuntimeSettings = function () {
        return LFService.INSTANCE_SERVICE;
    };
    Object.defineProperty(LFService, "DEFAULT", {
        /**
         * This property returns the default LoggerFactory (if not yet initialized it is initialized).
         * This LoggerFactory can be used to share among multiple
         * applications/libraries - that way you can enable/change logging over everything from
         * your own application when required.
         * It is recommended to be used by library developers to make logging easily available for the
         * consumers of their libraries.
         * It is highly recommended to use Loggers from the LoggerFactory with unique grouping/names to prevent
         * clashes of Loggers between multiple projects.
         * @returns {LoggerFactory} Returns the default LoggerFactory
         */
        get: function () {
            return LFService.getDefault();
        },
        enumerable: true,
        configurable: true
    });
    LFService.getDefault = function () {
        if (LFService.DEFAULT_LOGGER_FACTORY === null) {
            LFService.DEFAULT_LOGGER_FACTORY = LFService.DEFAULT_LOGGER_FACTORY = LFService.INSTANCE_SERVICE.createNamedLoggerFactory(LFService.DEFAULT_LOGGER_FACTORY_NAME, new LoggerFactoryOptions_1.LoggerFactoryOptions().addLogGroupRule(new LogGroupRule_1.LogGroupRule(new RegExp(".+"), LoggerOptions_1.LogLevel.Error)));
        }
        return LFService.DEFAULT_LOGGER_FACTORY;
    };
    LFService.DEFAULT_LOGGER_FACTORY_NAME = "DEFAULT";
    LFService.INSTANCE_SERVICE = LFServiceImpl.getInstance();
    LFService.DEFAULT_LOGGER_FACTORY = null;
    return LFService;
}());
exports.LFService = LFService;
//# sourceMappingURL=LFService.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRule.js":
/*!************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRule.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Defines a LogGroupRule, this allows you to either have everything configured the same way
 * or for example loggers that start with name model. It allows you to group loggers together
 * to have a certain loglevel and other settings. You can configure this when creating the
 * LoggerFactory (which accepts multiple LogGroupRules).
 */
var LogGroupRule = (function () {
    /**
     * Create a LogGroupRule. Basically you define what logger name(s) match for this group, what level should be used what logger type (where to log)
     * and what format to write in. If the loggerType is custom, then the callBackLogger must be supplied as callback function to return a custom logger.
     * @param regExp Regular expression, what matches for your logger names for this group
     * @param level LogLevel
     * @param logFormat LogFormat
     * @param loggerType Type of logger, if Custom, make sure to implement callBackLogger and pass in, this will be called so you can return your own logger.
     * @param callBackLogger Callback function to return a new clean custom logger (yours!)
     */
    function LogGroupRule(regExp, level, logFormat, loggerType, callBackLogger) {
        if (logFormat === void 0) { logFormat = new LoggerOptions_1.LogFormat(); }
        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }
        if (callBackLogger === void 0) { callBackLogger = null; }
        this._formatterLogMessage = null;
        this._regExp = regExp;
        this._level = level;
        this._logFormat = logFormat;
        this._loggerType = loggerType;
        this._callBackLogger = callBackLogger;
    }
    Object.defineProperty(LogGroupRule.prototype, "regExp", {
        get: function () {
            return this._regExp;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "level", {
        get: function () {
            return this._level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "formatterLogMessage", {
        /**
         * Get the formatterLogMessage function, see comment on the setter.
         * @returns {((message:LogMessage)=>string)|null}
         */
        get: function () {
            return this._formatterLogMessage;
        },
        /**
         * Set the default formatterLogMessage function, if set it is applied to all type of loggers except for a custom logger.
         * By default this is null (not set). You can assign a function to allow custom formatting of a log message.
         * Each log message will call this function then and expects your function to format the message and return a string.
         * Will throw an error if you attempt to set a formatterLogMessage if the LoggerType is custom.
         * @param value The formatter function, or null to reset it.
         */
        set: function (value) {
            if (value !== null && this._loggerType === LoggerOptions_1.LoggerType.Custom) {
                throw new Error("You cannot specify a formatter for log messages if your loggerType is Custom");
            }
            this._formatterLogMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    return LogGroupRule;
}());
exports.LogGroupRule = LogGroupRule;
//# sourceMappingURL=LogGroupRule.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRuntimeSettings.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRuntimeSettings.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Represents the runtime settings for a LogGroup (LogGroupRule).
 */
var LogGroupRuntimeSettings = (function () {
    function LogGroupRuntimeSettings(logGroupRule) {
        this._formatterLogMessage = null;
        this._logGroupRule = logGroupRule;
        this._level = logGroupRule.level;
        this._loggerType = logGroupRule.loggerType;
        this._logFormat = new LoggerOptions_1.LogFormat(new LoggerOptions_1.DateFormat(logGroupRule.logFormat.dateFormat.formatEnum, logGroupRule.logFormat.dateFormat.dateSeparator), logGroupRule.logFormat.showTimeStamp, logGroupRule.logFormat.showLoggerName);
        this._callBackLogger = logGroupRule.callBackLogger;
        this._formatterLogMessage = logGroupRule.formatterLogMessage;
    }
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "logGroupRule", {
        /**
         * Returns original LogGroupRule (so not runtime settings!)
         * @return {LogGroupRule}
         */
        get: function () {
            return this._logGroupRule;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "level", {
        get: function () {
            return this._level;
        },
        set: function (value) {
            this._level = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        set: function (value) {
            this._loggerType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        set: function (value) {
            this._logFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        set: function (value) {
            this._callBackLogger = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "formatterLogMessage", {
        get: function () {
            return this._formatterLogMessage;
        },
        set: function (value) {
            this._formatterLogMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    return LogGroupRuntimeSettings;
}());
exports.LogGroupRuntimeSettings = LogGroupRuntimeSettings;
//# sourceMappingURL=LogGroupRuntimeSettings.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryImpl.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryImpl.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var ConsoleLoggerImpl_1 = __webpack_require__(/*! ./ConsoleLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/ConsoleLoggerImpl.js");
var MessageBufferLoggerImpl_1 = __webpack_require__(/*! ./MessageBufferLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/MessageBufferLoggerImpl.js");
var AbstractLogger_1 = __webpack_require__(/*! ./AbstractLogger */ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js");
var LogGroupRuntimeSettings_1 = __webpack_require__(/*! ./LogGroupRuntimeSettings */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRuntimeSettings.js");
var LoggerFactoryImpl = (function () {
    function LoggerFactoryImpl(name, options) {
        this._loggers = new DataStructures_1.SimpleMap();
        this._logGroupRuntimeSettingsIndexed = [];
        this._loggerToLogGroupSettings = new DataStructures_1.SimpleMap();
        this._name = name;
        this.configure(options);
    }
    LoggerFactoryImpl.prototype.configure = function (options) {
        this._options = options;
        // Close any current open loggers.
        this.closeLoggers();
        this._loggerToLogGroupSettings.clear();
        this._logGroupRuntimeSettingsIndexed = [];
        var logGroupRules = this._options.logGroupRules;
        /* tslint:disable:prefer-for-of */
        for (var i = 0; i < logGroupRules.length; i++) {
            this._logGroupRuntimeSettingsIndexed.push(new LogGroupRuntimeSettings_1.LogGroupRuntimeSettings(logGroupRules[i]));
        }
        /* tslint:enable:prefer-for-of */
    };
    LoggerFactoryImpl.prototype.getLogger = function (named) {
        if (!this._options.enabled) {
            throw new Error("LoggerFactory is not enabled, please check your options passed in");
        }
        var logger = this._loggers.get(named);
        if (typeof logger !== "undefined") {
            return logger;
        }
        // Initialize logger with appropriate level
        logger = this.loadLogger(named);
        this._loggers.put(named, logger);
        return logger;
    };
    LoggerFactoryImpl.prototype.isEnabled = function () {
        return this._options.enabled;
    };
    LoggerFactoryImpl.prototype.closeLoggers = function () {
        this._loggers.forEachValue(function (logger) {
            // We can only close if AbstractLogger is used (our loggers, but user loggers may not extend it, even though unlikely).
            if (logger instanceof AbstractLogger_1.AbstractLogger) {
                logger.close();
            }
        });
        this._loggers.clear();
    };
    LoggerFactoryImpl.prototype.getName = function () {
        return this._name;
    };
    LoggerFactoryImpl.prototype.getLogGroupRuntimeSettingsByIndex = function (idx) {
        if (idx >= 0 && idx < this._logGroupRuntimeSettingsIndexed.length) {
            return this._logGroupRuntimeSettingsIndexed[idx];
        }
        return null;
    };
    LoggerFactoryImpl.prototype.getLogGroupRuntimeSettingsByLoggerName = function (nameLogger) {
        var result = this._loggerToLogGroupSettings.get(nameLogger);
        if (typeof result === "undefined") {
            return null;
        }
        return result;
    };
    LoggerFactoryImpl.prototype.getLogGroupRuntimeSettings = function () {
        return this._logGroupRuntimeSettingsIndexed.slice(0);
    };
    LoggerFactoryImpl.prototype.loadLogger = function (named) {
        var logGroupRules = this._options.logGroupRules;
        for (var i = 0; i < logGroupRules.length; i++) {
            var logGroupRule = logGroupRules[i];
            if (logGroupRule.regExp.test(named)) {
                var logGroupRuntimeSettings = this._logGroupRuntimeSettingsIndexed[i];
                var logger = void 0;
                switch (logGroupRule.loggerType) {
                    case LoggerOptions_1.LoggerType.Console:
                        logger = new ConsoleLoggerImpl_1.ConsoleLoggerImpl(named, logGroupRuntimeSettings);
                        break;
                    case LoggerOptions_1.LoggerType.MessageBuffer:
                        logger = new MessageBufferLoggerImpl_1.MessageBufferLoggerImpl(named, logGroupRuntimeSettings);
                        break;
                    case LoggerOptions_1.LoggerType.Custom:
                        if (logGroupRule.callBackLogger != null) {
                            logger = logGroupRule.callBackLogger(named, logGroupRuntimeSettings);
                        }
                        else {
                            throw new Error("Cannot create a custom logger, custom callback is null");
                        }
                        break;
                    default:
                        throw new Error("Cannot create a Logger for LoggerType: " + logGroupRule.loggerType);
                }
                // For a new logger map it by its name
                this._loggerToLogGroupSettings.put(named, logGroupRuntimeSettings);
                return logger;
            }
        }
        throw new Error("Failed to find a match to create a Logger for: " + named);
    };
    return LoggerFactoryImpl;
}());
exports.LoggerFactoryImpl = LoggerFactoryImpl;
//# sourceMappingURL=LoggerFactoryImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryOptions.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryOptions.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Options object you can use to configure the LoggerFactory you create at LFService.
 */
var LoggerFactoryOptions = (function () {
    function LoggerFactoryOptions() {
        this._logGroupRules = [];
        this._enabled = true;
    }
    /**
     * Add LogGroupRule, see {LogGroupRule) for details
     * @param rule Rule to add
     * @returns {LoggerFactoryOptions} returns itself
     */
    LoggerFactoryOptions.prototype.addLogGroupRule = function (rule) {
        this._logGroupRules.push(rule);
        return this;
    };
    /**
     * Enable or disable logging completely for the LoggerFactory.
     * @param enabled True for enabled (default)
     * @returns {LoggerFactoryOptions} returns itself
     */
    LoggerFactoryOptions.prototype.setEnabled = function (enabled) {
        this._enabled = enabled;
        return this;
    };
    Object.defineProperty(LoggerFactoryOptions.prototype, "logGroupRules", {
        get: function () {
            return this._logGroupRules;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoggerFactoryOptions.prototype, "enabled", {
        get: function () {
            return this._enabled;
        },
        enumerable: true,
        configurable: true
    });
    return LoggerFactoryOptions;
}());
exports.LoggerFactoryOptions = LoggerFactoryOptions;
//# sourceMappingURL=LoggerFactoryOptions.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/MessageBufferLoggerImpl.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/MessageBufferLoggerImpl.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var AbstractLogger_1 = __webpack_require__(/*! ./AbstractLogger */ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js");
/**
 * Logger which buffers all messages, use with care due to possible high memory footprint.
 * Can be convenient in some cases. Call toString() for full output, or cast to this class
 * and call getMessages() to do something with it yourself.
 */
var MessageBufferLoggerImpl = (function (_super) {
    __extends(MessageBufferLoggerImpl, _super);
    function MessageBufferLoggerImpl(name, logGroupRuntimeSettings) {
        var _this = _super.call(this, name, logGroupRuntimeSettings) || this;
        _this.messages = [];
        return _this;
    }
    MessageBufferLoggerImpl.prototype.close = function () {
        this.messages = [];
        _super.prototype.close.call(this);
    };
    MessageBufferLoggerImpl.prototype.getMessages = function () {
        return this.messages;
    };
    MessageBufferLoggerImpl.prototype.toString = function () {
        return this.messages.map(function (msg) {
            return msg;
        }).join("\n");
    };
    MessageBufferLoggerImpl.prototype.doLog = function (message) {
        var messageFormatter = this._getMessageFormatter();
        var fullMsg;
        if (messageFormatter === null) {
            fullMsg = this.createDefaultLogMessage(message);
        }
        else {
            fullMsg = messageFormatter(message);
        }
        this.messages.push(fullMsg);
    };
    return MessageBufferLoggerImpl;
}(AbstractLogger_1.AbstractLogger));
exports.MessageBufferLoggerImpl = MessageBufferLoggerImpl;
//# sourceMappingURL=MessageBufferLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/typescript-logging.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/typescript-logging.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
var LogGroupControl_1 = __webpack_require__(/*! ./control/LogGroupControl */ "./node_modules/typescript-logging/dist/commonjs/control/LogGroupControl.js");
var CategoryServiceControl_1 = __webpack_require__(/*! ./control/CategoryServiceControl */ "./node_modules/typescript-logging/dist/commonjs/control/CategoryServiceControl.js");
var ExtensionHelper_1 = __webpack_require__(/*! ./extension/ExtensionHelper */ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js");
exports.ExtensionHelper = ExtensionHelper_1.ExtensionHelper;
// Category related
var AbstractCategoryLogger_1 = __webpack_require__(/*! ./log/category/AbstractCategoryLogger */ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js");
exports.AbstractCategoryLogger = AbstractCategoryLogger_1.AbstractCategoryLogger;
var CategoryConsoleLoggerImpl_1 = __webpack_require__(/*! ./log/category/CategoryConsoleLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConsoleLoggerImpl.js");
exports.CategoryConsoleLoggerImpl = CategoryConsoleLoggerImpl_1.CategoryConsoleLoggerImpl;
var CategoryDelegateLoggerImpl_1 = __webpack_require__(/*! ./log/category/CategoryDelegateLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryDelegateLoggerImpl.js");
exports.CategoryDelegateLoggerImpl = CategoryDelegateLoggerImpl_1.CategoryDelegateLoggerImpl;
var Category_1 = __webpack_require__(/*! ./log/category/Category */ "./node_modules/typescript-logging/dist/commonjs/log/category/Category.js");
exports.Category = Category_1.Category;
var CategoryRuntimeSettings_1 = __webpack_require__(/*! ./log/category/CategoryRuntimeSettings */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryRuntimeSettings.js");
exports.CategoryRuntimeSettings = CategoryRuntimeSettings_1.CategoryRuntimeSettings;
var CategoryConfiguration_1 = __webpack_require__(/*! ./log/category/CategoryConfiguration */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConfiguration.js");
exports.CategoryConfiguration = CategoryConfiguration_1.CategoryConfiguration;
var CategoryMessageBufferImpl_1 = __webpack_require__(/*! ./log/category/CategoryMessageBufferImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryMessageBufferImpl.js");
exports.CategoryMessageBufferLoggerImpl = CategoryMessageBufferImpl_1.CategoryMessageBufferLoggerImpl;
var CategoryServiceFactory_1 = __webpack_require__(/*! ./log/category/CategoryServiceFactory */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryServiceFactory.js");
exports.CategoryServiceFactory = CategoryServiceFactory_1.CategoryServiceFactory;
var LoggerFactoryOptions_1 = __webpack_require__(/*! ./log/standard/LoggerFactoryOptions */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryOptions.js");
exports.LoggerFactoryOptions = LoggerFactoryOptions_1.LoggerFactoryOptions;
var LogGroupRule_1 = __webpack_require__(/*! ./log/standard/LogGroupRule */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRule.js");
exports.LogGroupRule = LogGroupRule_1.LogGroupRule;
var LFService_1 = __webpack_require__(/*! ./log/standard/LFService */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LFService.js");
exports.LFService = LFService_1.LFService;
var AbstractLogger_1 = __webpack_require__(/*! ./log/standard/AbstractLogger */ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js");
exports.AbstractLogger = AbstractLogger_1.AbstractLogger;
var ConsoleLoggerImpl_1 = __webpack_require__(/*! ./log/standard/ConsoleLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/ConsoleLoggerImpl.js");
exports.ConsoleLoggerImpl = ConsoleLoggerImpl_1.ConsoleLoggerImpl;
var MessageBufferLoggerImpl_1 = __webpack_require__(/*! ./log/standard/MessageBufferLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/MessageBufferLoggerImpl.js");
exports.MessageBufferLoggerImpl = MessageBufferLoggerImpl_1.MessageBufferLoggerImpl;
var LoggerOptions_1 = __webpack_require__(/*! ./log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
exports.CategoryLogFormat = LoggerOptions_1.CategoryLogFormat;
exports.DateFormat = LoggerOptions_1.DateFormat;
exports.DateFormatEnum = LoggerOptions_1.DateFormatEnum;
exports.LogFormat = LoggerOptions_1.LogFormat;
exports.LoggerType = LoggerOptions_1.LoggerType;
exports.LogLevel = LoggerOptions_1.LogLevel;
// Utilities
var DataStructures_1 = __webpack_require__(/*! ./utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
exports.SimpleMap = DataStructures_1.SimpleMap;
exports.LinkedList = DataStructures_1.LinkedList;
__export(__webpack_require__(/*! ./utils/JSONHelper */ "./node_modules/typescript-logging/dist/commonjs/utils/JSONHelper.js"));
var MessageUtils_1 = __webpack_require__(/*! ./utils/MessageUtils */ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js");
exports.MessageFormatUtils = MessageUtils_1.MessageFormatUtils;
/*
 Functions to export on TSL libarary var.
*/
// Export help function
function help() {
    /* tslint:disable:no-console */
    console.log("help()\n   ** Shows this help\n\n getLogControl(): LoggerControl\n   ** Returns LoggerControl Object, use to dynamically change loglevels for log4j logging.\n   ** Call .help() on LoggerControl object for available options.\n\n getCategoryControl(): CategoryServiceControl\n   ** Returns CategoryServiceControl Object, use to dynamically change loglevels for category logging.\n   ** Call .help() on CategoryServiceControl object for available options.\n");
    /* tslint:enable:no-console */
}
exports.help = help;
// Export LogControl function (log4j)
function getLogControl() {
    return new LogGroupControl_1.LoggerControlImpl();
}
exports.getLogControl = getLogControl;
// Export CategoryControl function
function getCategoryControl() {
    return new CategoryServiceControl_1.CategoryServiceControlImpl();
}
exports.getCategoryControl = getCategoryControl;
//# sourceMappingURL=typescript-logging.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LinkedNode = (function () {
    function LinkedNode(value) {
        this._previous = null;
        this._next = null;
        this._value = value;
    }
    Object.defineProperty(LinkedNode.prototype, "previous", {
        get: function () {
            return this._previous;
        },
        set: function (value) {
            this._previous = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinkedNode.prototype, "next", {
        get: function () {
            return this._next;
        },
        set: function (value) {
            this._next = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinkedNode.prototype, "value", {
        get: function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    return LinkedNode;
}());
/**
 * Double linkedlist implementation.
 */
var LinkedList = (function () {
    function LinkedList() {
        this.head = null;
        this.size = 0;
    }
    LinkedList.prototype.addHead = function (value) {
        if (!this.createHeadIfNeeded(value)) {
            if (this.head != null) {
                var nextNode = this.head.next;
                var newHeadNode = new LinkedNode(value);
                if (nextNode != null) {
                    nextNode.previous = newHeadNode;
                    newHeadNode.next = nextNode;
                }
                this.head = newHeadNode;
            }
            else {
                throw new Error("This should never happen, list implementation broken");
            }
        }
        this.size++;
    };
    LinkedList.prototype.addTail = function (value) {
        if (!this.createHeadIfNeeded(value)) {
            var oldTailNode = this.getTailNode();
            if (oldTailNode != null) {
                var newTailNode = new LinkedNode(value);
                oldTailNode.next = newTailNode;
                newTailNode.previous = oldTailNode;
            }
            else {
                throw new Error("List implementation broken");
            }
        }
        this.size++;
    };
    LinkedList.prototype.clear = function () {
        this.head = null;
        this.size = 0;
    };
    LinkedList.prototype.getHead = function () {
        if (this.head != null) {
            return this.head.value;
        }
        return null;
    };
    LinkedList.prototype.removeHead = function () {
        if (this.head != null) {
            var oldHead = this.head;
            var value = oldHead.value;
            this.head = oldHead.next;
            this.size--;
            return value;
        }
        return null;
    };
    LinkedList.prototype.getTail = function () {
        var node = this.getTailNode();
        if (node != null) {
            return node.value;
        }
        return null;
    };
    LinkedList.prototype.removeTail = function () {
        var node = this.getTailNode();
        if (node != null) {
            if (node === this.head) {
                this.head = null;
            }
            else {
                var previousNode = node.previous;
                if (previousNode != null) {
                    previousNode.next = null;
                }
                else {
                    throw new Error("List implementation is broken");
                }
            }
            this.size--;
            return node.value;
        }
        return null;
    };
    LinkedList.prototype.getSize = function () {
        return this.size;
    };
    LinkedList.prototype.filter = function (f) {
        var recurse = function (fn, node, values) {
            if (fn(node.value)) {
                values.push(node.value);
            }
            var nextNode = node.next;
            if (nextNode != null) {
                recurse(fn, nextNode, values);
            }
        };
        var result = [];
        var currentNode = this.head;
        if (currentNode != null) {
            recurse(f, currentNode, result);
        }
        return result;
    };
    LinkedList.prototype.createHeadIfNeeded = function (value) {
        if (this.head == null) {
            this.head = new LinkedNode(value);
            return true;
        }
        return false;
    };
    LinkedList.prototype.getTailNode = function () {
        if (this.head == null) {
            return null;
        }
        var node = this.head;
        while (node.next != null) {
            node = node.next;
        }
        return node;
    };
    return LinkedList;
}());
exports.LinkedList = LinkedList;
/**
 * Map implementation keyed by string (always).
 */
var SimpleMap = (function () {
    function SimpleMap() {
        this.array = {};
    }
    SimpleMap.prototype.put = function (key, value) {
        this.array[key] = value;
    };
    SimpleMap.prototype.get = function (key) {
        return this.array[key];
    };
    SimpleMap.prototype.exists = function (key) {
        var value = this.array[key];
        return (typeof value !== "undefined");
    };
    SimpleMap.prototype.remove = function (key) {
        var value = this.array[key];
        if (typeof value !== "undefined") {
            delete this.array[key];
        }
        return value;
    };
    SimpleMap.prototype.keys = function () {
        var keys = [];
        for (var key in this.array) {
            // To prevent random stuff to appear
            if (this.array.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys;
    };
    SimpleMap.prototype.values = function () {
        var values = [];
        for (var key in this.array) {
            // To prevent random stuff to appear
            if (this.array.hasOwnProperty(key)) {
                values.push(this.get(key));
            }
        }
        return values;
    };
    SimpleMap.prototype.size = function () {
        return this.keys().length;
    };
    SimpleMap.prototype.isEmpty = function () {
        return this.size() === 0;
    };
    SimpleMap.prototype.clear = function () {
        this.array = {};
    };
    SimpleMap.prototype.forEach = function (cbFunction) {
        var count = 0;
        for (var key in this.array) {
            // To prevent random stuff to appear
            if (this.array.hasOwnProperty(key)) {
                var value = this.array[key];
                cbFunction(key, value, count);
                count++;
            }
        }
    };
    SimpleMap.prototype.forEachValue = function (cbFunction) {
        var count = 0;
        for (var key in this.array) {
            // To prevent random stuff to appear
            if (this.array.hasOwnProperty(key)) {
                var value = this.array[key];
                cbFunction(value, count);
                count++;
            }
        }
    };
    return SimpleMap;
}());
exports.SimpleMap = SimpleMap;
/**
 * Tuple to hold two values.
 */
var TuplePair = (function () {
    function TuplePair(x, y) {
        this._x = x;
        this._y = y;
    }
    Object.defineProperty(TuplePair.prototype, "x", {
        get: function () {
            return this._x;
        },
        set: function (value) {
            this._x = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuplePair.prototype, "y", {
        get: function () {
            return this._y;
        },
        set: function (value) {
            this._y = value;
        },
        enumerable: true,
        configurable: true
    });
    return TuplePair;
}());
exports.TuplePair = TuplePair;
/**
 * Utility class to build up a string.
 */
var StringBuilder = (function () {
    function StringBuilder() {
        this.data = [];
    }
    StringBuilder.prototype.append = function (line) {
        if (line === undefined || line == null) {
            throw new Error("String must be set, cannot append null or undefined");
        }
        this.data.push(line);
        return this;
    };
    StringBuilder.prototype.appendLine = function (line) {
        this.data.push(line + "\n");
        return this;
    };
    StringBuilder.prototype.isEmpty = function () {
        return this.data.length === 0;
    };
    StringBuilder.prototype.clear = function () {
        this.data = [];
    };
    StringBuilder.prototype.toString = function (separator) {
        if (separator === void 0) { separator = ""; }
        return this.data.join(separator);
    };
    return StringBuilder;
}());
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=DataStructures.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/utils/JSONHelper.js":
/*!***************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/utils/JSONHelper.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Module containing bunch of JSON related stuff.
 */
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var DataStructures_1 = __webpack_require__(/*! ./DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var JSONTypeImpl = (function () {
    function JSONTypeImpl(value) {
        this._value = value;
    }
    JSONTypeImpl.prototype.getValue = function () {
        return this._value;
    };
    JSONTypeImpl.prototype.toString = function () {
        var value = this.getValue();
        if (value != null) {
            return value.toString();
        }
        return "null";
    };
    return JSONTypeImpl;
}());
var JSONBooleanType = (function (_super) {
    __extends(JSONBooleanType, _super);
    function JSONBooleanType(value) {
        return _super.call(this, value) || this;
    }
    return JSONBooleanType;
}(JSONTypeImpl));
var JSONNumberType = (function (_super) {
    __extends(JSONNumberType, _super);
    function JSONNumberType(value) {
        return _super.call(this, value) || this;
    }
    return JSONNumberType;
}(JSONTypeImpl));
var JSONStringType = (function (_super) {
    __extends(JSONStringType, _super);
    function JSONStringType(value) {
        return _super.call(this, value) || this;
    }
    JSONStringType.prototype.toString = function () {
        var value = this.getValue();
        if (value != null) {
            return JSON.stringify(value.toString());
        }
        return "null";
    };
    return JSONStringType;
}(JSONTypeImpl));
var JSONObjectType = (function (_super) {
    __extends(JSONObjectType, _super);
    function JSONObjectType(value) {
        return _super.call(this, value) || this;
    }
    return JSONObjectType;
}(JSONTypeImpl));
var JSONArrayType = (function (_super) {
    __extends(JSONArrayType, _super);
    function JSONArrayType(value) {
        return _super.call(this, value) || this;
    }
    JSONArrayType.prototype.toString = function () {
        var value = this.getValue();
        if (value != null) {
            return value.toString();
        }
        return "null";
    };
    return JSONArrayType;
}(JSONTypeImpl));
var JSONNullType = (function (_super) {
    __extends(JSONNullType, _super);
    function JSONNullType() {
        return _super.call(this, null) || this;
    }
    JSONNullType.prototype.toString = function () {
        return "null";
    };
    return JSONNullType;
}(JSONTypeImpl));
var JSONTypeConverter = (function () {
    function JSONTypeConverter() {
    }
    JSONTypeConverter.toJSONType = function (value) {
        if (value === null) {
            return new JSONNullType();
        }
        if (typeof value === "string") {
            return new JSONStringType(value);
        }
        if (typeof value === "number") {
            return new JSONNumberType(value);
        }
        if (typeof value === "boolean") {
            return new JSONBooleanType(value);
        }
        if (value instanceof JSONObject) {
            return new JSONObjectType(value);
        }
        throw new Error("Type not supported for value: " + value);
    };
    return JSONTypeConverter;
}());
var JSONObject = (function () {
    function JSONObject() {
        this.values = new DataStructures_1.SimpleMap();
    }
    JSONObject.prototype.addBoolean = function (name, value) {
        this.checkName(name);
        JSONObject.checkValue(value);
        this.values.put(name, new JSONBooleanType(value));
        return this;
    };
    JSONObject.prototype.addNumber = function (name, value) {
        this.checkName(name);
        JSONObject.checkValue(value);
        this.values.put(name, new JSONNumberType(value));
        return this;
    };
    JSONObject.prototype.addString = function (name, value) {
        this.checkName(name);
        JSONObject.checkValue(value);
        this.values.put(name, new JSONStringType(value));
        return this;
    };
    JSONObject.prototype.addNull = function (name) {
        this.checkName(name);
        this.values.put(name, new JSONNullType());
        return this;
    };
    JSONObject.prototype.addArray = function (name, array) {
        this.checkName(name);
        JSONObject.checkValue(array);
        if (array == null) {
            throw new Error("Cannot add array as null");
        }
        this.values.put(name, new JSONArrayType(array));
        return this;
    };
    JSONObject.prototype.addObject = function (name, object) {
        this.checkName(name);
        JSONObject.checkValue(object);
        if (object == null) {
            throw new Error("Cannot add object as null");
        }
        this.values.put(name, new JSONObjectType(object));
        return this;
    };
    JSONObject.prototype.toString = function (pretty) {
        var _this = this;
        if (pretty === void 0) { pretty = false; }
        var comma = false;
        var buffer = new DataStructures_1.StringBuilder();
        buffer.append("{");
        this.values.keys().forEach(function (key) {
            var value = _this.values.get(key);
            if (value != null) {
                if (comma) {
                    buffer.append(",");
                }
                buffer.append('"').append(key).append('":').append(value.toString());
                comma = true;
            }
        });
        buffer.append("}");
        return buffer.toString();
    };
    JSONObject.prototype.checkName = function (name) {
        if (name == null || name === undefined) {
            throw new Error("Name is null or undefined");
        }
        if (this.values.exists(name)) {
            throw new Error("Name " + name + " is already present for this object");
        }
    };
    JSONObject.checkValue = function (value) {
        if (value === undefined) {
            throw new Error("Value is undefined");
        }
    };
    return JSONObject;
}());
exports.JSONObject = JSONObject;
var JSONArray = (function () {
    function JSONArray() {
        this.objects = [];
    }
    JSONArray.prototype.add = function (object) {
        if (object === undefined) {
            throw new Error("Object is not allowed to be undefined");
        }
        this.objects.push(JSONTypeConverter.toJSONType(object));
        return this;
    };
    JSONArray.prototype.toString = function (pretty) {
        if (pretty === void 0) { pretty = false; }
        var buffer = new DataStructures_1.StringBuilder();
        buffer.append("[");
        this.objects.forEach(function (value, index) {
            if (index > 0) {
                buffer.append(",");
            }
            buffer.append(value.toString());
        });
        buffer.append("]");
        return buffer.toString();
    };
    return JSONArray;
}());
exports.JSONArray = JSONArray;
/**
 * Utility class that helps us convert things to and from json (not for normal usage).
 */
var JSONHelper = (function () {
    function JSONHelper() {
    }
    JSONHelper.categoryToJSON = function (cat, recursive) {
        /*
         {
         "categories":
         [
         { id=1,
         name: "x",
         parent: null,
         logLevel: "Error"
         },
         { id=2,
         name: "y",
         parent: 1,
         logLevel: "Error"
         }
         ]
         }
         */
        var arr = new JSONArray();
        JSONHelper._categoryToJSON(cat, arr, recursive);
        var object = new JSONObject();
        object.addArray("categories", arr);
        return object;
    };
    JSONHelper._categoryToJSON = function (cat, arr, recursive) {
        var object = new JSONObject();
        object.addNumber("id", cat.id);
        object.addString("name", cat.name);
        object.addString("logLevel", LoggerOptions_1.LogLevel[cat.logLevel].toString());
        if (cat.parent != null) {
            object.addNumber("parent", cat.parent.id);
        }
        else {
            object.addNull("parent");
        }
        arr.add(object);
        if (recursive) {
            cat.children.forEach(function (child) {
                JSONHelper._categoryToJSON(child, arr, recursive);
            });
        }
    };
    return JSONHelper;
}());
exports.JSONHelper = JSONHelper;
//# sourceMappingURL=JSONHelper.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ST = __webpack_require__(/*! stacktrace-js */ "./node_modules/stacktrace-js/stacktrace.js");
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Some utilities to format messages.
 */
var MessageFormatUtils = (function () {
    function MessageFormatUtils() {
    }
    /**
     * Render given date in given DateFormat and return as String.
     * @param date Date
     * @param dateFormat Format
     * @returns {string} Formatted date
     */
    MessageFormatUtils.renderDate = function (date, dateFormat) {
        var lpad = function (value, chars, padWith) {
            var howMany = chars - value.length;
            if (howMany > 0) {
                var res = "";
                for (var i = 0; i < howMany; i++) {
                    res += padWith;
                }
                res += value;
                return res;
            }
            return value;
        };
        var fullYear = function (d) {
            return lpad(d.getFullYear().toString(), 4, "0");
        };
        var month = function (d) {
            return lpad((d.getMonth() + 1).toString(), 2, "0");
        };
        var day = function (d) {
            return lpad(d.getDate().toString(), 2, "0");
        };
        var hours = function (d) {
            return lpad(d.getHours().toString(), 2, "0");
        };
        var minutes = function (d) {
            return lpad(d.getMinutes().toString(), 2, "0");
        };
        var seconds = function (d) {
            return lpad(d.getSeconds().toString(), 2, "0");
        };
        var millis = function (d) {
            return lpad(d.getMilliseconds().toString(), 3, "0");
        };
        var dateSeparator = dateFormat.dateSeparator;
        var ds = "";
        switch (dateFormat.formatEnum) {
            case LoggerOptions_1.DateFormatEnum.Default:
                // yyyy-mm-dd hh:mm:ss,m
                ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + " " +
                    hours(date) + ":" + minutes(date) + ":" + seconds(date) + "," + millis(date);
                break;
            case LoggerOptions_1.DateFormatEnum.YearMonthDayTime:
                ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + " " +
                    hours(date) + ":" + minutes(date) + ":" + seconds(date);
                break;
            case LoggerOptions_1.DateFormatEnum.YearDayMonthWithFullTime:
                ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + " " +
                    hours(date) + ":" + minutes(date) + ":" + seconds(date) + "," + millis(date);
                break;
            case LoggerOptions_1.DateFormatEnum.YearDayMonthTime:
                ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + " " +
                    hours(date) + ":" + minutes(date) + ":" + seconds(date);
                break;
            default:
                throw new Error("Unsupported date format enum: " + dateFormat.formatEnum);
        }
        return ds;
    };
    /**
     * Renders given category log message in default format.
     * @param msg Message to format
     * @param addStack If true adds the stack to the output, otherwise skips it
     * @returns {string} Formatted message
     */
    MessageFormatUtils.renderDefaultMessage = function (msg, addStack) {
        var result = "";
        var logFormat = msg.logFormat;
        if (logFormat.showTimeStamp) {
            result += MessageFormatUtils.renderDate(msg.date, logFormat.dateFormat) + " ";
        }
        result += LoggerOptions_1.LogLevel[msg.level].toUpperCase();
        if (msg.isResolvedErrorMessage) {
            result += " (resolved)";
        }
        result += " ";
        if (logFormat.showCategoryName) {
            result += "[";
            msg.categories.forEach(function (value, idx) {
                if (idx > 0) {
                    result += ", ";
                }
                result += value.name;
            });
            result += "]";
        }
        // Get the normal string message first
        var actualStringMsg = "";
        var dataString = "";
        var messageOrLogData = msg.message;
        if (typeof messageOrLogData === "string") {
            actualStringMsg = messageOrLogData;
        }
        else {
            var logData = messageOrLogData;
            actualStringMsg = logData.msg;
            // We do have data?
            if (logData.data) {
                dataString = " [data]: " + (logData.ds ? logData.ds(logData.data) : JSON.stringify(logData.data));
            }
        }
        result += " " + actualStringMsg + "" + dataString;
        if (addStack && msg.errorAsStack !== null) {
            result += "\n" + msg.errorAsStack;
        }
        return result;
    };
    /**
     * Renders given log4j log message in default format.
     * @param msg Message to format
     * @param addStack If true adds the stack to the output, otherwise skips it
     * @returns {string} Formatted message
     */
    MessageFormatUtils.renderDefaultLog4jMessage = function (msg, addStack) {
        var format = msg.logGroupRule.logFormat;
        var result = "";
        if (format.showTimeStamp) {
            result += MessageFormatUtils.renderDate(msg.date, format.dateFormat) + " ";
        }
        result += LoggerOptions_1.LogLevel[msg.level].toUpperCase() + " ";
        if (format.showLoggerName) {
            result += "[" + msg.loggerName + "]";
        }
        // Get the normal string message first
        var actualStringMsg = "";
        var dataString = "";
        if (typeof msg.message === "string") {
            actualStringMsg = msg.message;
        }
        else {
            var logData = msg.message;
            actualStringMsg = logData.msg;
            // We do have data?
            if (logData.data) {
                dataString = " [data]: " + (logData.ds ? logData.ds(logData.data) : JSON.stringify(logData.data));
            }
        }
        result += " " + actualStringMsg + "" + dataString;
        if (addStack && msg.errorAsStack !== null) {
            result += "\n" + msg.errorAsStack;
        }
        return result;
    };
    /**
     * Render error as stack
     * @param error Return error as Promise
     * @returns {Promise<string>|Promise} Promise for stack
     */
    MessageFormatUtils.renderError = function (error) {
        var result = error.name + ": " + error.message + "\n@";
        return new Promise(function (resolve) {
            // This one has a promise too
            ST.fromError(error, { offline: true }).then(function (frames) {
                var stackStr = (frames.map(function (frame) {
                    return frame.toString();
                })).join("\n  ");
                result += "\n" + stackStr;
                // This resolves our returned promise
                resolve(result);
            }).catch(function () {
                result = "Unexpected error object was passed in. ";
                try {
                    result += "Could not resolve it, stringified object: " + JSON.stringify(error);
                }
                catch (e) {
                    // Cannot stringify can only tell something was wrong.
                    result += "Could not resolve it or stringify it.";
                }
                resolve(result);
            });
        });
    };
    return MessageFormatUtils;
}());
exports.MessageFormatUtils = MessageFormatUtils;
//# sourceMappingURL=MessageUtils.js.map

/***/ }),

/***/ "./node_modules/css-selector-generator/build/index.js":
/*!************************************************************!*\
  !*** ./node_modules/css-selector-generator/build/index.js ***!
  \************************************************************/
/***/ ((module) => {

!function(t,e){ true?module.exports=e():0}(self,(function(){return(()=>{var t={426:(t,e,n)=>{var r=n(529);function o(t,e,n){Array.isArray(t)?t.push(e):t[n]=e}t.exports=function(t){var e,n,i,u=[];if(Array.isArray(t))n=[],e=t.length-1;else{if("object"!=typeof t||null===t)throw new TypeError("Expecting an Array or an Object, but `"+(null===t?"null":typeof t)+"` provided.");n={},i=Object.keys(t),e=i.length-1}return function n(c,s){var l,a,f,d;for(a=i?i[s]:s,Array.isArray(t[a])||(void 0===t[a]?t[a]=[]:t[a]=[t[a]]),l=0;l<t[a].length;l++)o((d=c,f=Array.isArray(d)?[].concat(d):r(d)),t[a][l],a),s>=e?u.push(f):n(f,s+1)}(n,0),u}},529:t=>{t.exports=function(){for(var t={},n=0;n<arguments.length;n++){var r=arguments[n];for(var o in r)e.call(r,o)&&(t[o]=r[o])}return t};var e=Object.prototype.hasOwnProperty}},e={};function n(r){var o=e[r];if(void 0!==o)return o.exports;var i=e[r]={exports:{}};return t[r](i,i.exports,n),i.exports}n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var r={};return(()=>{"use strict";n.r(r),n.d(r,{default:()=>U,getCssSelector:()=>H});var t,e,o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol?"symbol":typeof t};function i(t){return null!=t&&"object"===(void 0===t?"undefined":o(t))&&1===t.nodeType&&"object"===o(t.style)&&"object"===o(t.ownerDocument)}function u(t="unknown problem",...e){console.warn(`CssSelectorGenerator: ${t}`,...e)}!function(t){t.NONE="none",t.DESCENDANT="descendant",t.CHILD="child"}(t||(t={})),function(t){t.id="id",t.class="class",t.tag="tag",t.attribute="attribute",t.nthchild="nthchild",t.nthoftype="nthoftype"}(e||(e={}));const c={selectors:[e.id,e.class,e.tag,e.attribute],includeTag:!1,whitelist:[],blacklist:[],combineWithinSelector:!0,combineBetweenSelectors:!0,root:null,maxCombinations:Number.POSITIVE_INFINITY,maxCandidates:Number.POSITIVE_INFINITY};function s(t){return t instanceof RegExp}function l(t){return"string"==typeof t||s(t)}function a(t){return Array.isArray(t)?t.filter(l):[]}function f(t){const e=[Node.DOCUMENT_NODE,Node.DOCUMENT_FRAGMENT_NODE,Node.ELEMENT_NODE];return function(t){return t instanceof Node}(t)&&e.includes(t.nodeType)}function d(t,e){if(f(t))return t.contains(e)||u("element root mismatch","Provided root does not contain the element. This will most likely result in producing a fallback selector using element's real root node. If you plan to use the selector using provided root (e.g. `root.querySelector`), it will nto work as intended."),t;const n=e.getRootNode({composed:!1});return f(n)?(n!==document&&u("shadow root inferred","You did not provide a root and the element is a child of Shadow DOM. This will produce a selector using ShadowRoot as a root. If you plan to use the selector using document as a root (e.g. `document.querySelector`), it will not work as intended."),n):e.ownerDocument.querySelector(":root")}function p(t){return"number"==typeof t?t:Number.POSITIVE_INFINITY}function m(t=[]){const[e=[],...n]=t;return 0===n.length?e:n.reduce(((t,e)=>t.filter((t=>e.includes(t)))),e)}function y(t){return[].concat(...t)}function h(t){const e=t.map((t=>s(t)?t:new RegExp("^"+t.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".+")+"$")));return t=>e.some((e=>e.test(t)))}function g(t,e,n){const r=Array.from(d(n,t[0]).querySelectorAll(e));return r.length===t.length&&t.every((t=>r.includes(t)))}function b(t,e){return e=null!=e?e:t[0].ownerDocument.querySelector(":root"),m(t.map((t=>function(t,e){const n=[];let r=t;for(;i(r)&&r!==e;)n.push(r),r=r.parentElement;return n}(t,e))))}function S(t){const e=t.parentNode;if(e){const n=Array.from(e.childNodes).filter(i).indexOf(t);if(n>-1)return[`:nth-child(${n+1})`]}return[]}function N(t){return m(t.map(S))}const v=(t.NONE,t.NONE,t.DESCENDANT,t.DESCENDANT,t.CHILD,t.CHILD,new RegExp(["^$","\\s","^\\d"].join("|"))),w=new RegExp(["^$","^\\d"].join("|")),E=[e.nthoftype,e.tag,e.id,e.class,e.attribute,e.nthchild];function x(t){return[":root",...b([t]).map((t=>N([t])[0])).reverse()].join(" > ")}var A=n(426),C=n.n(A);const O=h(["class","id","ng-*"]);function T({nodeName:t}){return`[${t}]`}function j({nodeName:t,nodeValue:e}){return`[${t}='${V(e)}']`}function I({nodeName:t}){return!O(t)}function D(t){const e=Array.from(t.attributes).filter(I);return[...e.map(T),...e.map(j)]}function $(t){return(t.getAttribute("class")||"").trim().split(/\s+/).filter((t=>!w.test(t))).map((t=>`.${V(t)}`))}function _(t){return[V(t.tagName.toLowerCase())]}function k(t){const e=[...new Set(y(t.map(_)))];return 0===e.length||e.length>1?[]:[e[0]]}function R(t){const e=k([t])[0],n=t.parentElement;if(n){const r=Array.from(n.children).filter((t=>t.tagName.toLowerCase()===e)).indexOf(t);if(r>-1)return[`${e}:nth-of-type(${r+1})`]}return[]}function P(t=[],{maxResults:e=Number.POSITIVE_INFINITY}={}){const n=[];let r=0,o=L(1);for(;o.length<=t.length&&r<e;)r+=1,n.push(o.map((e=>t[e]))),o=M(o,t.length-1);return n}function M(t=[],e=0){const n=t.length;if(0===n)return[];const r=[...t];r[n-1]+=1;for(let t=n-1;t>=0;t--)if(r[t]>e){if(0===t)return L(n+1);r[t-1]++,r[t]=r[t-1]+1}return r[n-1]>e?L(n+1):r}function L(t=1){return Array.from(Array(t).keys())}const q=":".charCodeAt(0).toString(16).toUpperCase(),F=/[ !"#$%&'()\[\]{|}<>*+,./;=?@^`~\\]/;function V(t=""){var e,n;return null!==(n=null===(e=null===CSS||void 0===CSS?void 0:CSS.escape)||void 0===e?void 0:e.call(CSS,t))&&void 0!==n?n:function(t=""){return t.split("").map((t=>":"===t?`\\${q} `:F.test(t)?`\\${t}`:escape(t).replace(/%/g,"\\"))).join("")}(t)}const Y={tag:k,id:function(t){return 0===t.length||t.length>1?[]:function(t){const e=t.getAttribute("id")||"",n=`#${V(e)}`,r=t.getRootNode({composed:!1});return!v.test(e)&&g([t],n,r)?[n]:[]}(t[0])},class:function(t){return m(t.map($))},attribute:function(t){return m(t.map(D))},nthchild:N,nthoftype:function(t){return m(t.map(R))}};function B(t){return t.includes(e.tag)||t.includes(e.nthoftype)?[...t]:[...t,e.tag]}function G(t={}){const n=[...E];return t[e.tag]&&t[e.nthoftype]&&n.splice(n.indexOf(e.tag),1),n.map((e=>{return(r=t)[n=e]?r[n].join(""):"";var n,r})).join("")}function W(t,e,n="",r){const o=function(t,e){return""===e?t:function(t,e){return[...t.map((t=>e+" "+t)),...t.map((t=>e+" > "+t))]}(t,e)}(function(t,e,n){const r=y(function(t,e){return function(t){const{selectors:e,combineBetweenSelectors:n,includeTag:r,maxCandidates:o}=t,i=n?P(e,{maxResults:o}):e.map((t=>[t]));return r?i.map(B):i}(e).map((e=>function(t,e){const n={};return t.forEach((t=>{const r=e[t];r.length>0&&(n[t]=r)})),C()(n).map(G)}(e,t))).filter((t=>t.length>0))}(function(t,e){const{blacklist:n,whitelist:r,combineWithinSelector:o,maxCombinations:i}=e,u=h(n),c=h(r);return function(t){const{selectors:e,includeTag:n}=t,r=[].concat(e);return n&&!r.includes("tag")&&r.push("tag"),r}(e).reduce(((e,n)=>{const r=function(t=[],e){return t.sort(((t,n)=>{const r=e(t),o=e(n);return r&&!o?-1:!r&&o?1:0}))}(function(t=[],e,n){return t.filter((t=>n(t)||!e(t)))}(function(t,e){var n;return(null!==(n=Y[e])&&void 0!==n?n:()=>[])(t)}(t,n),u,c),c);return e[n]=o?P(r,{maxResults:i}):r.map((t=>[t])),e}),{})}(t,n),n));return[...new Set(r)]}(t,r.root,r),n);for(const e of o)if(g(t,e,r.root))return e;return null}function H(t,n={}){const r=function(t){const e=(Array.isArray(t)?t:[t]).filter(i);return[...new Set(e)]}(t),o=function(t,n={}){const r=Object.assign(Object.assign({},c),n);return{selectors:(o=r.selectors,Array.isArray(o)?o.filter((t=>{return n=e,r=t,Object.values(n).includes(r);var n,r})):[]),whitelist:a(r.whitelist),blacklist:a(r.blacklist),root:d(r.root,t),combineWithinSelector:!!r.combineWithinSelector,combineBetweenSelectors:!!r.combineBetweenSelectors,includeTag:!!r.includeTag,maxCombinations:p(r.maxCombinations),maxCandidates:p(r.maxCandidates)};var o}(r[0],n);let u="",s=o.root;function l(){return function(t,e,n="",r){if(0===t.length)return null;const o=[t.length>1?t:[],...b(t,e).map((t=>[t]))];for(const t of o){const e=W(t,0,n,r);if(e)return{foundElements:t,selector:e}}return null}(r,s,u,o)}let f=l();for(;f;){const{foundElements:t,selector:e}=f;if(g(r,e,o.root))return e;s=t[0],u=e,f=l()}return r.length>1?r.map((t=>H(t,o))).join(", "):function(t){return t.map(x).join(", ")}(r)}const U=H})(),r})()}));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQUlGRVhTY3JpcHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRCxRQUFRLGlDQUE2QixDQUFDLGdGQUFZLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUM3RCxNQUFNLEtBQUssRUFJTjtBQUNMLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2TkQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcktBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDZEQUFpQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVCxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVEQUF1RCxZQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdDQUF3QztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG9CQUFvQjtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0Msc0JBQXNCLCtDQUErQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7Ozs7Ozs7Ozs7QUN6akNoQyxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQWM7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLHFEQUFRO0FBQzNCLGVBQWUsK0ZBQStCO0FBQzlDLGtCQUFrQix3R0FBcUM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOzs7Ozs7Ozs7OztBQ25aMUIsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QiwrSEFBb0Q7QUFDN0UsV0FBVyxtQkFBTyxDQUFDLHFEQUFROztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxXQUFXO0FBQ1g7O0FBRUEsa0JBQWtCOzs7Ozs7Ozs7OztBQ3RabEIsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVosa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Q1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCO0FBQ3JCOzs7Ozs7Ozs7OztBQy9TYTtBQUNiO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLGtHQUFzQjtBQUNwRCx1QkFBdUIsbUJBQU8sQ0FBQyxpR0FBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNB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QUFNLElBQUk7Ozs7OztVQ0FsbFI7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1VFTkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXJyb3Itc3RhY2stcGFyc2VyL2Vycm9yLXN0YWNrLXBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnktc2VsZWN0b3Itc2hhZG93LWRvbS9zcmMvbm9ybWFsaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeS1zZWxlY3Rvci1zaGFkb3ctZG9tL3NyYy9xdWVyeVNlbGVjdG9yRGVlcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYXJyYXktc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQtdmxxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2JpbmFyeS1zZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL21hcHBpbmctbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1nZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1ub2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL3NvdXJjZS1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0YWNrLWdlbmVyYXRvci9ub2RlX21vZHVsZXMvc3RhY2tmcmFtZS9zdGFja2ZyYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdGFjay1nZW5lcmF0b3Ivc3RhY2stZ2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdGFja2ZyYW1lL3N0YWNrZnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0YWNrdHJhY2UtZ3BzL3N0YWNrdHJhY2UtZ3BzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdGFja3RyYWNlLWpzL3N0YWNrdHJhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL19pbmZyYS9BaWZleFNlcnZpY2VIVFRQLnRzIiwid2VicGFjazovLy8uL3NyYy9faW5mcmEvQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL0FjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL0FpZmV4UGx1Z2luSW5mby50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL0F0dHJpYnV0ZVZhbHVlUnVsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL0Jyb3dzZXJTY3JpcHQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9DU1NDb250ZXh0TWFwcGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vQ1NTU2VsZWN0b3JSdWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vQ1NTU2VsZWN0b3JXaXRoVmFsdWVSdWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vQ2xhc3NNdXRhdGlvbkhhbmRsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9Db250ZXh0TGVzc01hcHBlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL0NvbnRleHRNYXBwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9FdmVudExpc3RlbmVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vSW5kZXhSdWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vSW5uZXJUZXh0UnVsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL1BhZ2VNdXRhdGlvbkhhbmRsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9SdWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vUnVsZU1hcHBlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL1J1bGVTZXJ2aWNlLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vU2Vzc2lvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL1NpbXBsZVJ1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9VUkxDb250ZXh0TWFwcGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vVmFsdWVSdWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vV2Vic2l0ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL1hQYXRoQ29udGV4dE1hcHBlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL0xvZ2dlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2NvbnRyb2wvQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvY29udHJvbC9Mb2dHcm91cENvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2V4dGVuc2lvbi9FeHRlbnNpb25IZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9Mb2dnZXJPcHRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvY2F0ZWdvcnkvQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvY2F0ZWdvcnkvQ2F0ZWdvcnlDb25maWd1cmF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvY2F0ZWdvcnkvQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvY2F0ZWdvcnkvQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvY2F0ZWdvcnkvQ2F0ZWdvcnlNZXNzYWdlQnVmZmVySW1wbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5UnVudGltZVNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvY2F0ZWdvcnkvQ2F0ZWdvcnlTZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvY2F0ZWdvcnkvQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL3N0YW5kYXJkL0Fic3RyYWN0TG9nZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvc3RhbmRhcmQvQ29uc29sZUxvZ2dlckltcGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9zdGFuZGFyZC9MRlNlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9zdGFuZGFyZC9Mb2dHcm91cFJ1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9zdGFuZGFyZC9Mb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL3N0YW5kYXJkL0xvZ2dlckZhY3RvcnlJbXBsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvc3RhbmRhcmQvTG9nZ2VyRmFjdG9yeU9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9zdGFuZGFyZC9NZXNzYWdlQnVmZmVyTG9nZ2VySW1wbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvdHlwZXNjcmlwdC1sb2dnaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy91dGlscy9EYXRhU3RydWN0dXJlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvdXRpbHMvSlNPTkhlbHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvdXRpbHMvTWVzc2FnZVV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3Mtc2VsZWN0b3ItZ2VuZXJhdG9yL2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovLy93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovLy93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdlcnJvci1zdGFjay1wYXJzZXInLCBbJ3N0YWNrZnJhbWUnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3N0YWNrZnJhbWUnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5FcnJvclN0YWNrUGFyc2VyID0gZmFjdG9yeShyb290LlN0YWNrRnJhbWUpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlcihTdGFja0ZyYW1lKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIEZJUkVGT1hfU0FGQVJJX1NUQUNLX1JFR0VYUCA9IC8oXnxAKVxcUytcXDpcXGQrLztcbiAgICB2YXIgQ0hST01FX0lFX1NUQUNLX1JFR0VYUCA9IC9eXFxzKmF0IC4qKFxcUytcXDpcXGQrfFxcKG5hdGl2ZVxcKSkvbTtcbiAgICB2YXIgU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCA9IC9eKGV2YWxAKT8oXFxbbmF0aXZlIGNvZGVcXF0pPyQvO1xuXG4gICAgZnVuY3Rpb24gX21hcChhcnJheSwgZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBBcnJheS5wcm90b3R5cGUubWFwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXkubWFwKGZuLCB0aGlzQXJnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBuZXcgQXJyYXkoYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbaV0gPSBmbi5jYWxsKHRoaXNBcmcsIGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZmlsdGVyKGFycmF5LCBmbiwgdGhpc0FyZykge1xuICAgICAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZS5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5maWx0ZXIoZm4sIHRoaXNBcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChmbi5jYWxsKHRoaXNBcmcsIGFycmF5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChhcnJheVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pbmRleE9mKGFycmF5LCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlbaV0gPT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYW4gRXJyb3Igb2JqZWN0LCBleHRyYWN0IHRoZSBtb3N0IGluZm9ybWF0aW9uIGZyb20gaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gb2YgU3RhY2tGcmFtZXNcbiAgICAgICAgICovXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZShlcnJvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvci5zdGFja3RyYWNlICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZXJyb3JbJ29wZXJhI3NvdXJjZWxvYyddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmEoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjayAmJiBlcnJvci5zdGFjay5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVjhPcklFKGVycm9yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZGT3JTYWZhcmkoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBnaXZlbiBFcnJvciBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBTZXBhcmF0ZSBsaW5lIGFuZCBjb2x1bW4gbnVtYmVycyBmcm9tIGEgc3RyaW5nIG9mIHRoZSBmb3JtOiAoVVJJOkxpbmU6Q29sdW1uKVxuICAgICAgICBleHRyYWN0TG9jYXRpb246IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJGV4dHJhY3RMb2NhdGlvbih1cmxMaWtlKSB7XG4gICAgICAgICAgICAvLyBGYWlsLWZhc3QgYnV0IHJldHVybiBsb2NhdGlvbnMgbGlrZSBcIihuYXRpdmUpXCJcbiAgICAgICAgICAgIGlmICh1cmxMaWtlLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3VybExpa2VdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVnRXhwID0gLyguKz8pKD86XFw6KFxcZCspKT8oPzpcXDooXFxkKykpPyQvO1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gcmVnRXhwLmV4ZWModXJsTGlrZS5yZXBsYWNlKC9bXFwoXFwpXS9nLCAnJykpO1xuICAgICAgICAgICAgcmV0dXJuIFtwYXJ0c1sxXSwgcGFydHNbMl0gfHwgdW5kZWZpbmVkLCBwYXJ0c1szXSB8fCB1bmRlZmluZWRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlVjhPcklFOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZVY4T3JJRShlcnJvcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gX2ZpbHRlcihlcnJvci5zdGFjay5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFsaW5lLm1hdGNoKENIUk9NRV9JRV9TVEFDS19SRUdFWFApO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBfbWFwKGZpbHRlcmVkLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignKGV2YWwgJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL2V2YWwgY29kZS9nLCAnZXZhbCcpLnJlcGxhY2UoLyhcXChldmFsIGF0IFteXFwoKV0qKXwoXFwpXFwsLiokKS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xcKGV2YWwgY29kZS9nLCAnKCcpLnNwbGl0KC9cXHMrLykuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbih0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0b2tlbnMuam9pbignICcpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBfaW5kZXhPZihbJ2V2YWwnLCAnPGFub255bW91cz4nXSwgbG9jYXRpb25QYXJ0c1swXSkgPiAtMSA/IHVuZGVmaW5lZCA6IGxvY2F0aW9uUGFydHNbMF07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoZnVuY3Rpb25OYW1lLCB1bmRlZmluZWQsIGZpbGVOYW1lLCBsb2NhdGlvblBhcnRzWzFdLCBsb2NhdGlvblBhcnRzWzJdLCBsaW5lKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlRkZPclNhZmFyaTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VGRk9yU2FmYXJpKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBfZmlsdGVyKGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhbGluZS5tYXRjaChTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gX21hcChmaWx0ZXJlZCwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIC8vIFRocm93IGF3YXkgZXZhbCBpbmZvcm1hdGlvbiB1bnRpbCB3ZSBpbXBsZW1lbnQgc3RhY2t0cmFjZS5qcy9zdGFja2ZyYW1lIzhcbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCcgPiBldmFsJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC8gbGluZSAoXFxkKykoPzogPiBldmFsIGxpbmUgXFxkKykqID4gZXZhbFxcOlxcZCtcXDpcXGQrL2csICc6JDEnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCdAJykgPT09IC0xICYmIGxpbmUuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgZXZhbCBmcmFtZXMgb25seSBoYXZlIGZ1bmN0aW9uIG5hbWVzIGFuZCBub3RoaW5nIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKGxpbmUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KCdAJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24odG9rZW5zLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRva2Vucy5qb2luKCdAJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25QYXJ0c1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uUGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VPcGVyYTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYShlKSB7XG4gICAgICAgICAgICBpZiAoIWUuc3RhY2t0cmFjZSB8fCAoZS5tZXNzYWdlLmluZGV4T2YoJ1xcbicpID4gLTEgJiZcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCA+IGUuc3RhY2t0cmFjZS5zcGxpdCgnXFxuJykubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmE5KGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZS5zdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTExKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmE5OiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhOShlKSB7XG4gICAgICAgICAgICB2YXIgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykvaTtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IGUubWVzc2FnZS5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFN0YWNrRnJhbWUodW5kZWZpbmVkLCB1bmRlZmluZWQsIG1hdGNoWzJdLCBtYXRjaFsxXSwgdW5kZWZpbmVkLCBsaW5lc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZU9wZXJhMTA6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmExMChlKSB7XG4gICAgICAgICAgICB2YXIgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykoPzo6IEluIGZ1bmN0aW9uIChcXFMrKSk/JC9pO1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBTdGFja0ZyYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzNdIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE9wZXJhIDEwLjY1KyBFcnJvci5zdGFjayB2ZXJ5IHNpbWlsYXIgdG8gRkYvU2FmYXJpXG4gICAgICAgIHBhcnNlT3BlcmExMTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTExKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBfZmlsdGVyKGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQKSAmJiAhbGluZS5tYXRjaCgvXkVycm9yIGNyZWF0ZWQgYXQvKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gX21hcChmaWx0ZXJlZCwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KCdAJyk7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbih0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbkNhbGwgPSAodG9rZW5zLnNoaWZ0KCkgfHwgJycpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbkNhbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88YW5vbnltb3VzIGZ1bmN0aW9uKDogKFxcdyspKT8+LywgJyQyJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXChbXlxcKV0qXFwpL2csICcnKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3NSYXc7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbC5tYXRjaCgvXFwoKFteXFwpXSopXFwpLykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1JhdyA9IGZ1bmN0aW9uQ2FsbC5yZXBsYWNlKC9eW15cXChdK1xcKChbXlxcKV0qKVxcKSQvLCAnJDEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSAoYXJnc1JhdyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3NSYXcgPT09ICdbYXJndW1lbnRzIG5vdCBhdmFpbGFibGVdJykgP1xuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQgOiBhcmdzUmF3LnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uUGFydHNbMV0sXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgIGxpbmUpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xufSkpO1xuXG4iLCIvKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuXG5cbi8vIG5vcm1hbGl6ZS1zZWxlY3Rvci1yZXYtMDIuanNcbi8qXG4gIGF1dGhvcjoga3lsZSBzaW1wc29uIChAZ2V0aWZ5KVxuICBvcmlnaW5hbCBzb3VyY2U6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2dldGlmeS85Njc5MzgwXG5cbiAgbW9kaWZpZWQgZm9yIHRlc3RzIGJ5IGRhdmlkIGtheWUgKEBkZmtheWUpXG4gIDIxIG1hcmNoIDIwMTRcblxuICByZXYtMDIgaW5jb3Jwb3JhdGUga3lsZSdzIGNoYW5nZXMgMy8yLzQyMDE0XG4qL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplU2VsZWN0b3Ioc2VsKSB7XG4gIC8vIHNhdmUgdW5tYXRjaGVkIHRleHQsIGlmIGFueVxuICBmdW5jdGlvbiBzYXZlVW5tYXRjaGVkKCkge1xuICAgIGlmICh1bm1hdGNoZWQpIHtcbiAgICAgIC8vIHdoaXRlc3BhY2UgbmVlZGVkIGFmdGVyIGNvbWJpbmF0b3I/XG4gICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDAgJiYgL15bfis+XSQvLnRlc3QodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goXCIgXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBzYXZlIHVubWF0Y2hlZCB0ZXh0XG4gICAgICB0b2tlbnMucHVzaCh1bm1hdGNoZWQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0b2tlbnMgPSBbXSxcbiAgICBtYXRjaCxcbiAgICB1bm1hdGNoZWQsXG4gICAgcmVnZXgsXG4gICAgc3RhdGUgPSBbMF0sXG4gICAgbmV4dF9tYXRjaF9pZHggPSAwLFxuICAgIHByZXZfbWF0Y2hfaWR4LFxuICAgIG5vdF9lc2NhcGVkX3BhdHRlcm4gPSAvKD86W15cXFxcXXwoPzpefFteXFxcXF0pKD86XFxcXFxcXFwpKykkLyxcbiAgICB3aGl0ZXNwYWNlX3BhdHRlcm4gPSAvXlxccyskLyxcbiAgICBzdGF0ZV9wYXR0ZXJucyA9IFtcbiAgICAgIC9cXHMrfFxcL1xcKnxbXCInPn4rWyhdL2csIC8vIGdlbmVyYWxcbiAgICAgIC9cXHMrfFxcL1xcKnxbXCInW1xcXSgpXS9nLCAvLyBbLi5dIHNldFxuICAgICAgL1xccyt8XFwvXFwqfFtcIidbXFxdKCldL2csIC8vICguLikgc2V0XG4gICAgICBudWxsLCAvLyBzdHJpbmcgbGl0ZXJhbCAocGxhY2Vob2xkZXIpXG4gICAgICAvXFwqXFwvL2csIC8vIGNvbW1lbnRcbiAgICBdO1xuICBzZWwgPSBzZWwudHJpbSgpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB1bm1hdGNoZWQgPSBcIlwiO1xuXG4gICAgcmVnZXggPSBzdGF0ZV9wYXR0ZXJuc1tzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXV07XG5cbiAgICByZWdleC5sYXN0SW5kZXggPSBuZXh0X21hdGNoX2lkeDtcbiAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoc2VsKTtcblxuICAgIC8vIG1hdGNoZWQgdGV4dCB0byBwcm9jZXNzP1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgcHJldl9tYXRjaF9pZHggPSBuZXh0X21hdGNoX2lkeDtcbiAgICAgIG5leHRfbWF0Y2hfaWR4ID0gcmVnZXgubGFzdEluZGV4O1xuXG4gICAgICAvLyBjb2xsZWN0IHRoZSBwcmV2aW91cyBzdHJpbmcgY2h1bmsgbm90IG1hdGNoZWQgYmVmb3JlIHRoaXMgdG9rZW5cbiAgICAgIGlmIChwcmV2X21hdGNoX2lkeCA8IG5leHRfbWF0Y2hfaWR4IC0gbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIHVubWF0Y2hlZCA9IHNlbC5zdWJzdHJpbmcoXG4gICAgICAgICAgcHJldl9tYXRjaF9pZHgsXG4gICAgICAgICAgbmV4dF9tYXRjaF9pZHggLSBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2VuZXJhbCwgWyBdIHBhaXIsICggKSBwYWlyP1xuICAgICAgaWYgKHN0YXRlW3N0YXRlLmxlbmd0aCAtIDFdIDwgMykge1xuICAgICAgICBzYXZlVW5tYXRjaGVkKCk7XG5cbiAgICAgICAgLy8gc3RhcnRpbmcgYSBbIF0gcGFpcj9cbiAgICAgICAgaWYgKG1hdGNoWzBdID09PSBcIltcIikge1xuICAgICAgICAgIHN0YXRlLnB1c2goMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RhcnRpbmcgYSAoICkgcGFpcj9cbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT09IFwiKFwiKSB7XG4gICAgICAgICAgc3RhdGUucHVzaCgyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGFydGluZyBhIHN0cmluZyBsaXRlcmFsP1xuICAgICAgICBlbHNlIGlmICgvXltcIiddJC8udGVzdChtYXRjaFswXSkpIHtcbiAgICAgICAgICBzdGF0ZS5wdXNoKDMpO1xuICAgICAgICAgIHN0YXRlX3BhdHRlcm5zWzNdID0gbmV3IFJlZ0V4cChtYXRjaFswXSwgXCJnXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0YXJ0aW5nIGEgY29tbWVudD9cbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT09IFwiLypcIikge1xuICAgICAgICAgIHN0YXRlLnB1c2goNCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5kaW5nIGEgWyBdIG9yICggKSBwYWlyP1xuICAgICAgICBlbHNlIGlmICgvXltcXF0pXSQvLnRlc3QobWF0Y2hbMF0pICYmIHN0YXRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzdGF0ZS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGluZyB3aGl0ZXNwYWNlIG9yIGEgY29tYmluYXRvcj9cbiAgICAgICAgZWxzZSBpZiAoL14oPzpcXHMrfFt+Kz5dKSQvLnRlc3QobWF0Y2hbMF0pKSB7XG4gICAgICAgICAgLy8gbmVlZCB0byBpbnNlcnQgd2hpdGVzcGFjZSBiZWZvcmU/XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdG9rZW5zLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICF3aGl0ZXNwYWNlX3BhdHRlcm4udGVzdCh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKSAmJlxuICAgICAgICAgICAgc3RhdGVbc3RhdGUubGVuZ3RoIC0gMV0gPT09IDBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIGFkZCBub3JtYWxpemVkIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKFwiIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlIGF0dHJpYnV0ZSBzZWxlY3RvciBDU1MgTDRcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXSA9PT0gMSAmJlxuICAgICAgICAgICAgdG9rZW5zLmxlbmd0aCA9PT0gNSAmJlxuICAgICAgICAgICAgdG9rZW5zWzJdLmNoYXJBdCh0b2tlbnNbMl0ubGVuZ3RoIC0gMSkgPT09IFwiPVwiXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0b2tlbnNbNF0gPSBcIiBcIiArIHRva2Vuc1s0XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB3aGl0ZXNwYWNlIHRva2VuIHdlIGNhbiBza2lwP1xuICAgICAgICAgIGlmICh3aGl0ZXNwYWNlX3BhdHRlcm4udGVzdChtYXRjaFswXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNhdmUgbWF0Y2hlZCB0ZXh0XG4gICAgICAgIHRva2Vucy5wdXNoKG1hdGNoWzBdKTtcbiAgICAgIH1cbiAgICAgIC8vIG90aGVyd2lzZSwgc3RyaW5nIGxpdGVyYWwgb3IgY29tbWVudFxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHNhdmUgdW5tYXRjaGVkIHRleHRcbiAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSArPSB1bm1hdGNoZWQ7XG5cbiAgICAgICAgLy8gdW5lc2NhcGVkIHRlcm1pbmF0b3IgdG8gc3RyaW5nIGxpdGVyYWwgb3IgY29tbWVudD9cbiAgICAgICAgaWYgKG5vdF9lc2NhcGVkX3BhdHRlcm4udGVzdCh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgIC8vIGNvbW1lbnQgdGVybWluYXRvcj9cbiAgICAgICAgICBpZiAoc3RhdGVbc3RhdGUubGVuZ3RoIC0gMV0gPT09IDQpIHtcbiAgICAgICAgICAgIC8vIG9rIHRvIGRyb3AgY29tbWVudD9cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdG9rZW5zLmxlbmd0aCA8IDIgfHxcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZV9wYXR0ZXJuLnRlc3QodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAyXSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHR1cm4gY29tbWVudCBpbnRvIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdID0gXCIgXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZWQgYWxyZWFkeVxuICAgICAgICAgICAgbWF0Y2hbMF0gPSBcIlwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXRlLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwZW5kIG1hdGNoZWQgdGV4dCB0byBleGlzdGluZyB0b2tlblxuICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdICs9IG1hdGNoWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBvdGhlcndpc2UsIGVuZCBvZiBwcm9jZXNzaW5nIChubyBtb3JlIG1hdGNoZXMpXG4gICAgZWxzZSB7XG4gICAgICB1bm1hdGNoZWQgPSBzZWwuc3Vic3RyKG5leHRfbWF0Y2hfaWR4KTtcbiAgICAgIHNhdmVVbm1hdGNoZWQoKTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRva2Vucy5qb2luKFwiXCIpLnRyaW0oKTtcbn1cbiIsIi8qKlxuICogQGF1dGhvciBHZW9yZ2VncmlmZkAgKEdlb3JnZSBHcmlmZml0aHMpXG4gKiBMaWNlbnNlIEFwYWNoZS0yLjBcbiAqL1xuXG5pbXBvcnQgeyBub3JtYWxpemVTZWxlY3RvciB9IGZyb20gJy4vbm9ybWFsaXplJztcblxuLyoqXG4qIEZpbmRzIGZpcnN0IG1hdGNoaW5nIGVsZW1lbnRzIG9uIHRoZSBwYWdlIHRoYXQgbWF5IGJlIGluIGEgc2hhZG93IHJvb3QgdXNpbmcgYSBjb21wbGV4IHNlbGVjdG9yIG9mIG4tZGVwdGhcbipcbiogRG9uJ3QgaGF2ZSB0byBzcGVjaWZ5IGFsbCBzaGFkb3cgcm9vdHMgdG8gYnV0dG9uLCB0cmVlIGlzIHRyYXZlcmVkIHRvIGZpbmQgdGhlIGNvcnJlY3QgZWxlbWVudFxuKlxuKiBFeGFtcGxlIHF1ZXJ5U2VsZWN0b3JBbGxEZWVwKCdkb3dubG9hZHMtaXRlbTpudGgtY2hpbGQoNCkgI3JlbW92ZScpO1xuKlxuKiBFeGFtcGxlIHNob3VsZCB3b3JrIG9uIGNocm9tZTovL2Rvd25sb2FkcyBvdXRwdXR0aW5nIHRoZSByZW1vdmUgYnV0dG9uIGluc2lkZSBvZiBhIGRvd25sb2FkIGNhcmQgY29tcG9uZW50XG4qXG4qIEV4YW1wbGUgZmluZCBmaXJzdCBhY3RpdmUgZG93bmxvYWQgbGluayBlbGVtZW50IHF1ZXJ5U2VsZWN0b3JEZWVwKCcjZG93bmxvYWRzLWxpc3QgLmlzLWFjdGl2ZSBhW2hyZWZePVwiaHR0cHM6Ly9cIl0nKTtcbipcbiogQW5vdGhlciBleGFtcGxlIHF1ZXJ5U2VsZWN0b3JBbGxEZWVwKCcjZG93bmxvYWRzLWxpc3QgZGl2I3RpdGxlLWFyZWEgKyBhJyk7XG5lLmcuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGxEZWVwKHNlbGVjdG9yLCByb290ID0gZG9jdW1lbnQsIGFsbEVsZW1lbnRzID0gbnVsbCkge1xuICAgIHJldHVybiBfcXVlcnlTZWxlY3RvckRlZXAoc2VsZWN0b3IsIHRydWUsIHJvb3QsIGFsbEVsZW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JEZWVwKHNlbGVjdG9yLCByb290ID0gZG9jdW1lbnQsIGFsbEVsZW1lbnRzID0gbnVsbCkge1xuICAgIHJldHVybiBfcXVlcnlTZWxlY3RvckRlZXAoc2VsZWN0b3IsIGZhbHNlLCByb290LCBhbGxFbGVtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9xdWVyeVNlbGVjdG9yRGVlcChzZWxlY3RvciwgZmluZE1hbnksIHJvb3QsIGFsbEVsZW1lbnRzID0gbnVsbCkge1xuICAgIHNlbGVjdG9yID0gbm9ybWFsaXplU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGxldCBsaWdodEVsZW1lbnQgPSByb290LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuXG4gICAgaWYgKGRvY3VtZW50LmhlYWQuY3JlYXRlU2hhZG93Um9vdCB8fCBkb2N1bWVudC5oZWFkLmF0dGFjaFNoYWRvdykge1xuICAgICAgICAvLyBubyBuZWVkIHRvIGRvIGFueSBzcGVjaWFsIGlmIHNlbGVjdG9yIG1hdGNoZXMgc29tZXRoaW5nIHNwZWNpZmljIGluIGxpZ2h0LWRvbVxuICAgICAgICBpZiAoIWZpbmRNYW55ICYmIGxpZ2h0RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpZ2h0RWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNwbGl0IG9uIGNvbW1hcyBiZWNhdXNlIHRob3NlIGFyZSBhIGxvZ2ljYWwgZGl2aWRlIGluIHRoZSBvcGVyYXRpb25cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uc1RvTWFrZSA9IHNwbGl0QnlDaGFyYWN0ZXJVbmxlc3NRdW90ZWQoc2VsZWN0b3IsICcsJyk7XG5cbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbnNUb01ha2UucmVkdWNlKChhY2MsIG1pbmltYWxTZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgLy8gaWYgbm90IGZpbmRpbmcgbWFueSBqdXN0IHJlZHVjZSB0aGUgZmlyc3QgbWF0Y2hcbiAgICAgICAgICAgIGlmICghZmluZE1hbnkgJiYgYWNjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvIGJlc3QgdG8gc3VwcG9ydCBjb21wbGV4IHNlbGVjdG9ycyBhbmQgc3BsaXQgdGhlIHF1ZXJ5XG4gICAgICAgICAgICBjb25zdCBzcGxpdFNlbGVjdG9yID0gc3BsaXRCeUNoYXJhY3RlclVubGVzc1F1b3RlZChtaW5pbWFsU2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgd2hpdGUgc3BhY2UgYXQgc3RhcnQgb2Ygc2VsZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL15cXHMrL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxzKihbPit+XSspXFxzKi9nLCAnJDEnKSwgJyAnKVxuICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGVudHJ5IHdoaXRlIHNlbGVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4gISFlbnRyeSlcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBcImEgPiBiXCIgdG8gW1wiYVwiLCBcImJcIl1cbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoZW50cnkpID0+IHNwbGl0QnlDaGFyYWN0ZXJVbmxlc3NRdW90ZWQoZW50cnksICc+JykpO1xuXG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZUVsZW1lbnRzSW5kZXggPSBzcGxpdFNlbGVjdG9yLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjb25zdCBsYXN0U3BsaXRQYXJ0ID0gc3BsaXRTZWxlY3Rvcltwb3NzaWJsZUVsZW1lbnRzSW5kZXhdW3NwbGl0U2VsZWN0b3JbcG9zc2libGVFbGVtZW50c0luZGV4XS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlRWxlbWVudHMgPSBjb2xsZWN0QWxsRWxlbWVudHNEZWVwKGxhc3RTcGxpdFBhcnQsIHJvb3QsIGFsbEVsZW1lbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbmRFbGVtZW50cyA9IGZpbmRNYXRjaGluZ0VsZW1lbnQoc3BsaXRTZWxlY3RvciwgcG9zc2libGVFbGVtZW50c0luZGV4LCByb290KTtcbiAgICAgICAgICAgIGlmIChmaW5kTWFueSkge1xuICAgICAgICAgICAgICAgIGFjYyA9IGFjYy5jb25jYXQocG9zc2libGVFbGVtZW50cy5maWx0ZXIoZmluZEVsZW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWNjID0gcG9zc2libGVFbGVtZW50cy5maW5kKGZpbmRFbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmaW5kTWFueSA/IFtdIDogbnVsbCk7XG5cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZmluZE1hbnkpIHtcbiAgICAgICAgICAgIHJldHVybiBsaWdodEVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5mdW5jdGlvbiBmaW5kTWF0Y2hpbmdFbGVtZW50KHNwbGl0U2VsZWN0b3IsIHBvc3NpYmxlRWxlbWVudHNJbmRleCwgcm9vdCkge1xuICAgIHJldHVybiAoZWxlbWVudCkgPT4ge1xuICAgICAgICBsZXQgcG9zaXRpb24gPSBwb3NzaWJsZUVsZW1lbnRzSW5kZXg7XG4gICAgICAgIGxldCBwYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBsZXQgZm91bmRFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgIWlzRG9jdW1lbnROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZE1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzcGxpdFNlbGVjdG9yW3Bvc2l0aW9uXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmb3VuZE1hdGNoID0gcGFyZW50Lm1hdGNoZXMoc3BsaXRTZWxlY3Rvcltwb3NpdGlvbl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3RvciBpcyBpbiB0aGUgZm9ybWF0IFwiYSA+IGJcIlxuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBhIGZldyBwYXJlbnRzIG1hdGNoIGluIG9yZGVyXG4gICAgICAgICAgICAgICAgY29uc3QgcmV2ZXJzZWRQYXJ0cyA9IChbXSkuY29uY2F0KHNwbGl0U2VsZWN0b3JbcG9zaXRpb25dKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcmV2ZXJzZWRQYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1BhcmVudCB8fCAhbmV3UGFyZW50Lm1hdGNoZXMocGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcmVudCA9IGZpbmRQYXJlbnRPckhvc3QobmV3UGFyZW50LCByb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3VuZE1hdGNoICYmIHBvc2l0aW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm91bmRFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IGZpbmRQYXJlbnRPckhvc3QocGFyZW50LCByb290KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmRFbGVtZW50O1xuICAgIH07XG5cbn1cblxuZnVuY3Rpb24gc3BsaXRCeUNoYXJhY3RlclVubGVzc1F1b3RlZChzZWxlY3RvciwgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yLm1hdGNoKC9cXFxcPy58XiQvZykucmVkdWNlKChwLCBjKSA9PiB7XG4gICAgICAgIGlmIChjID09PSAnXCInICYmICFwLnNRdW90ZSkge1xuICAgICAgICAgICAgcC5xdW90ZSBePSAxO1xuICAgICAgICAgICAgcC5hW3AuYS5sZW5ndGggLSAxXSArPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICdcXCcnICYmICFwLnF1b3RlKSB7XG4gICAgICAgICAgICBwLnNRdW90ZSBePSAxO1xuICAgICAgICAgICAgcC5hW3AuYS5sZW5ndGggLSAxXSArPSBjO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIXAucXVvdGUgJiYgIXAuc1F1b3RlICYmIGMgPT09IGNoYXJhY3Rlcikge1xuICAgICAgICAgICAgcC5hLnB1c2goJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcC5hW3AuYS5sZW5ndGggLSAxXSArPSBjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH0sIHsgYTogWycnXSB9KS5hO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgbm9kZSBpcyBhIGRvY3VtZW50IG5vZGUgb3Igbm90LlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7bm9kZSBpcyBEb2N1bWVudCB8IERvY3VtZW50RnJhZ21lbnR9XG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERTtcbn1cblxuZnVuY3Rpb24gZmluZFBhcmVudE9ySG9zdChlbGVtZW50LCByb290KSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5ob3N0ICYmIHBhcmVudE5vZGUubm9kZVR5cGUgPT09IDExKSA/IHBhcmVudE5vZGUuaG9zdCA6IHBhcmVudE5vZGUgPT09IHJvb3QgPyBudWxsIDogcGFyZW50Tm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyBhbGwgZWxlbWVudHMgb24gdGhlIHBhZ2UsIGluY2x1c2l2ZSBvZiB0aG9zZSB3aXRoaW4gc2hhZG93IHJvb3RzLlxuICogQHBhcmFtIHtzdHJpbmc9fSBzZWxlY3RvciBTaW1wbGUgc2VsZWN0b3IgdG8gZmlsdGVyIHRoZSBlbGVtZW50cyBieS4gZS5nLiAnYScsICdkaXYubWFpbidcbiAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fSBMaXN0IG9mIGFuY2hvciBocmVmcy5cbiAqIEBhdXRob3IgZWJpZGVsQCAoRXJpYyBCaWRlbG1hbilcbiAqIExpY2Vuc2UgQXBhY2hlLTIuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdEFsbEVsZW1lbnRzRGVlcChzZWxlY3RvciA9IG51bGwsIHJvb3QsIGNhY2hlZEVsZW1lbnRzID0gbnVsbCkge1xuICAgIGxldCBhbGxFbGVtZW50cyA9IFtdO1xuXG4gICAgaWYgKGNhY2hlZEVsZW1lbnRzKSB7XG4gICAgICAgIGFsbEVsZW1lbnRzID0gY2FjaGVkRWxlbWVudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmluZEFsbEVsZW1lbnRzID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGFsbEVsZW1lbnRzLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIHNoYWRvdyByb290LCBkaWcgZGVlcGVyLlxuICAgICAgICAgICAgICAgIGlmIChlbC5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmRBbGxFbGVtZW50cyhlbC5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZihyb290LnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIGZpbmRBbGxFbGVtZW50cyhyb290LnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnKicpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5kQWxsRWxlbWVudHMocm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3RvciA/IGFsbEVsZW1lbnRzLmZpbHRlcihlbCA9PiBlbC5tYXRjaGVzKHNlbGVjdG9yKSkgOiBhbGxFbGVtZW50cztcdH1cblxuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB3aGljaCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFuIGFycmF5IGFuZCBhIHNldC4gQWRkaW5nIGEgbmV3XG4gKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAqIGVsZW1lbnQgaXMgTygxKS4gUmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHlcbiAqIHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgbWVtYmVyc2hpcC5cbiAqL1xuZnVuY3Rpb24gQXJyYXlTZXQoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gKi9cbkFycmF5U2V0LmZyb21BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X2Zyb21BcnJheShhQXJyYXksIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNldCA9IG5ldyBBcnJheVNldCgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICB9XG4gIHJldHVybiBzZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBob3cgbWFueSB1bmlxdWUgaXRlbXMgYXJlIGluIHRoaXMgQXJyYXlTZXQuIElmIGR1cGxpY2F0ZXMgaGF2ZSBiZWVuXG4gKiBhZGRlZCwgdGhhbiB0aG9zZSBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgc2l6ZS5cbiAqXG4gKiBAcmV0dXJucyBOdW1iZXJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBBcnJheVNldF9zaXplKCkge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fc2V0KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICB2YXIgaXNEdXBsaWNhdGUgPSBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICB9XG4gIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICB0aGlzLl9zZXRbc1N0cl0gPSBpZHg7XG4gIH1cbn07XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgcmV0dXJuIGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIGlmIChoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldFtzU3RyXTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbn07XG5cbmV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbi8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4vLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbi8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbi8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuLy9cbi8vICAgQ29udGludWF0aW9uXG4vLyAgIHwgICAgU2lnblxuLy8gICB8ICAgIHxcbi8vICAgViAgICBWXG4vLyAgIDEwMTAxMVxuXG52YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9CQVNFID0gMSA8PCBWTFFfQkFTRV9TSElGVDtcblxuLy8gYmluYXJ5OiAwMTExMTFcbnZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbi8qKlxuICogQ29udmVydHMgZnJvbSBhIHR3by1jb21wbGVtZW50IHZhbHVlIHRvIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICogICAyIGJlY29tZXMgNCAoMTAwIGJpbmFyeSksIC0yIGJlY29tZXMgNSAoMTAxIGJpbmFyeSlcbiAqL1xuZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHJldHVybiBhVmFsdWUgPCAwXG4gICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAqL1xuZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gIHJldHVybiBpc05lZ2F0aXZlXG4gICAgPyAtc2hpZnRlZFxuICAgIDogc2hpZnRlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gIHZhciBlbmNvZGVkID0gXCJcIjtcbiAgdmFyIGRpZ2l0O1xuXG4gIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gIGRvIHtcbiAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgaWYgKHZscSA+IDApIHtcbiAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgfVxuICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gIH0gd2hpbGUgKHZscSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFJbmRleCwgYU91dFBhcmFtKSB7XG4gIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IDA7XG4gIHZhciBzaGlmdCA9IDA7XG4gIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gIGRvIHtcbiAgICBpZiAoYUluZGV4ID49IHN0ckxlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgIH1cblxuICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJDb2RlQXQoYUluZGV4KyspKTtcbiAgICBpZiAoZGlnaXQgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBkaWdpdDogXCIgKyBhU3RyLmNoYXJBdChhSW5kZXggLSAxKSk7XG4gICAgfVxuXG4gICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuXG4gIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgYU91dFBhcmFtLnJlc3QgPSBhSW5kZXg7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gIH1cblxuICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICB9XG5cbiAgLy8gNjI6ICtcbiAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICByZXR1cm4gNjI7XG4gIH1cblxuICAvLyA2MzogL1xuICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICByZXR1cm4gNjM7XG4gIH1cblxuICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgcmV0dXJuIC0xO1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5leHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgLy9cbiAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgLy9cbiAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgLy9cbiAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAqXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICovXG5leHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLS1pbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICogcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG59XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG59XG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAqXG4gKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgfTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICpcbiAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICogY29weS5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXk7XG59O1xuXG5leHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8vIEl0IHR1cm5zIG91dCB0aGF0IHNvbWUgKG1vc3Q/KSBKYXZhU2NyaXB0IGVuZ2luZXMgZG9uJ3Qgc2VsZi1ob3N0XG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgLiBUaGlzIG1ha2VzIHNlbnNlIGJlY2F1c2UgQysrIHdpbGwgbGlrZWx5IHJlbWFpblxuLy8gZmFzdGVyIHRoYW4gSlMgd2hlbiBkb2luZyByYXcgQ1BVLWludGVuc2l2ZSBzb3J0aW5nLiBIb3dldmVyLCB3aGVuIHVzaW5nIGFcbi8vIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uLCBjYWxsaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIFZNJ3MgQysrIGFuZFxuLy8gSklUJ2QgSlMgaXMgcmF0aGVyIHNsb3cgKmFuZCogbG9zZXMgSklUIHR5cGUgaW5mb3JtYXRpb24sIHJlc3VsdGluZyBpblxuLy8gd29yc2UgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYW4gd291bGQgYmUgb3B0aW1hbC4gSW5cbi8vIGZhY3QsIHdoZW4gc29ydGluZyB3aXRoIGEgY29tcGFyYXRvciwgdGhlc2UgY29zdHMgb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIG9mXG4vLyBzb3J0aW5nIGluIEMrKy4gQnkgdXNpbmcgb3VyIG93biBKUy1pbXBsZW1lbnRlZCBRdWljayBTb3J0IChiZWxvdyksIHdlIGdldFxuLy8gYSB+MzUwMG1zIG1lYW4gc3BlZWQtdXAgaW4gYGJlbmNoL2JlbmNoLmh0bWxgLlxuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIFRoZSBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtLlxuICovXG5mdW5jdGlvbiBzd2FwKGFyeSwgeCwgeSkge1xuICB2YXIgdGVtcCA9IGFyeVt4XTtcbiAgYXJ5W3hdID0gYXJ5W3ldO1xuICBhcnlbeV0gPSB0ZW1wO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcbiAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKGxvdywgaGlnaCkge1xuICByZXR1cm4gTWF0aC5yb3VuZChsb3cgKyAoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkpO1xufVxuXG4vKipcbiAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gclxuICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCByKSB7XG4gIC8vIElmIG91ciBsb3dlciBib3VuZCBpcyBsZXNzIHRoYW4gb3VyIHVwcGVyIGJvdW5kLCB3ZSAoMSkgcGFydGl0aW9uIHRoZVxuICAvLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4gIC8vIHRoZSBlbXB0eSBhcnJheSBhbmQgb3VyIGJhc2UgY2FzZS5cblxuICBpZiAocCA8IHIpIHtcbiAgICAvLyAoMSkgUGFydGl0aW9uaW5nLlxuICAgIC8vXG4gICAgLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4gICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdCB0byB0aGUgYmVmb3JlIGl0LCBhbmRcbiAgICAvLyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBpdCBhZnRlciBpdC4gVGhlIGVmZmVjdCBpcyB0aGF0XG4gICAgLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbiAgICAvLyB0aGUgYXJyYXkgaXMgcHV0IGluIHNvcnRlZCBvcmRlciwgYW5kIGl0IHdpbGwgbm90IG5lZWQgdG8gYmUgbW92ZWRcbiAgICAvLyBhZ2Fpbi4gVGhpcyBydW5zIGluIE8obikgdGltZS5cblxuICAgIC8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4gICAgLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG4gICAgdmFyIHBpdm90SW5kZXggPSByYW5kb21JbnRJblJhbmdlKHAsIHIpO1xuICAgIHZhciBpID0gcCAtIDE7XG5cbiAgICBzd2FwKGFyeSwgcGl2b3RJbmRleCwgcik7XG4gICAgdmFyIHBpdm90ID0gYXJ5W3JdO1xuXG4gICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgYGpgIGlzIGluY3JlbWVudGVkIGluIHRoaXMgbG9vcCwgdGhlIGZvbGxvd2luZyBob2xkXG4gICAgLy8gdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbcCAuLiBpXWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdC5cbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbaSsxIC4uIGotMV1gIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGl2b3QuXG4gICAgZm9yICh2YXIgaiA9IHA7IGogPCByOyBqKyspIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFyeVtqXSwgcGl2b3QpIDw9IDApIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBzd2FwKGFyeSwgaSwgaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dhcChhcnksIGkgKyAxLCBqKTtcbiAgICB2YXIgcSA9IGkgKyAxO1xuXG4gICAgLy8gKDIpIFJlY3Vyc2Ugb24gZWFjaCBoYWxmLlxuXG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCBxIC0gMSk7XG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBxICsgMSwgcik7XG4gIH1cbn1cblxuLyoqXG4gKiBTb3J0IHRoZSBnaXZlbiBhcnJheSBpbi1wbGFjZSB3aXRoIHRoZSBnaXZlbiBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICovXG5leHBvcnRzLnF1aWNrU29ydCA9IGZ1bmN0aW9uIChhcnksIGNvbXBhcmF0b3IpIHtcbiAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCAwLCBhcnkubGVuZ3RoIC0gMSk7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbmZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZU1hcC5zZWN0aW9ucyAhPSBudWxsXG4gICAgPyBuZXcgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcClcbiAgICA6IG5ldyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCk7XG59XG5cblNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPSBmdW5jdGlvbihhU291cmNlTWFwKSB7XG4gIHJldHVybiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCk7XG59XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuLy8gcGFyc2VkIG1hcHBpbmcgY29vcmRpbmF0ZXMgZnJvbSB0aGUgc291cmNlIG1hcCdzIFwibWFwcGluZ3NcIiBhdHRyaWJ1dGUuIFRoZXlcbi8vIGFyZSBsYXppbHkgaW5zdGFudGlhdGVkLCBhY2Nlc3NlZCB2aWEgdGhlIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4vLyBhbmQgY3JlYXRlIHRoZXNlIGFycmF5cyBvbmNlIHF1ZXJpZWQgZm9yIGEgc291cmNlIGxvY2F0aW9uLiBXZSBqdW1wIHRocm91Z2hcbi8vIHRoZXNlIGhvb3BzIGJlY2F1c2UgdGhlcmUgY2FuIGJlIG1hbnkgdGhvdXNhbmRzIG9mIG1hcHBpbmdzLCBhbmQgcGFyc2luZ1xuLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuLy9cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheXMgaXMgb2YgdGhlIGZvcm06XG4vL1xuLy8gICAgIHtcbi8vICAgICAgIGdlbmVyYXRlZExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIHNvdXJjZTogVGhlIHBhdGggdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIHRoYXQgZ2VuZXJhdGVkIHRoaXNcbi8vICAgICAgICAgICAgICAgY2h1bmsgb2YgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgb3JpZ2luYWwgc3ltYm9sIHdoaWNoIGdlbmVyYXRlZCB0aGlzIGNodW5rIG9mXG4vLyAgICAgICAgICAgICBjb2RlLlxuLy8gICAgIH1cbi8vXG4vLyBBbGwgcHJvcGVydGllcyBleGNlcHQgZm9yIGBnZW5lcmF0ZWRMaW5lYCBhbmQgYGdlbmVyYXRlZENvbHVtbmAgY2FuIGJlXG4vLyBgbnVsbGAuXG4vL1xuLy8gYF9nZW5lcmF0ZWRNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucy5cbi8vXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy5cblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19nZW5lcmF0ZWRNYXBwaW5ncycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19vcmlnaW5hbE1hcHBpbmdzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fY2hhcklzTWFwcGluZ1NlcGFyYXRvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgaW5kZXgpIHtcbiAgICB2YXIgYyA9IGFTdHIuY2hhckF0KGluZGV4KTtcbiAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgfTtcblxuU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGFcbiAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKlxuICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFja1xuICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnlcbiAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICogQHBhcmFtIGFPcmRlclxuICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvclxuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG9cbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgIHZhciBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7XG5cbiAgICB2YXIgbWFwcGluZ3M7XG4gICAgc3dpdGNoIChvcmRlcikge1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmIHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4oc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWUgPT09IG51bGwgPyBudWxsIDogdGhpcy5fbmFtZXMuYXQobWFwcGluZy5uYW1lKVxuICAgICAgfTtcbiAgICB9LCB0aGlzKS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcHJvdmlkZWQuIElmIG5vIGNvbHVtbiBpcyBwcm92aWRlZCwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gYSBlaXRoZXIgdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3Igb3IgdGhlIG5leHRcbiAqIGNsb3Nlc3QgbGluZSB0aGF0IGhhcyBhbnkgbWFwcGluZ3MuIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgYW5kIGVpdGhlciB0aGUgY29sdW1uIHdlIGFyZSBzZWFyY2hpbmcgZm9yXG4gKiBvciB0aGUgbmV4dCBjbG9zZXN0IGNvbHVtbiB0aGF0IGhhcyBhbnkgb2Zmc2V0cy5cbiAqXG4gKiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBPcHRpb25hbC4gdGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqXG4gKiBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpcyByZXR1cm5lZCwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nLCAwKVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIG5lZWRsZS5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgbmVlZGxlLnNvdXJjZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMobmVlZGxlLnNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbmVlZGxlLnNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihuZWVkbGUuc291cmNlKTtcblxuICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAoYUFyZ3MuY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAvLyBTaW5jZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdzO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIHRoZSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yXG4gKiBhbHJlYWR5IHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNvdXJjZSBtYXBzIGhhdmUgdGhlXG4gKiBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBzb3VyY2VzOiBBbiBhcnJheSBvZiBVUkxzIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbmFtZXM6IEFuIGFycmF5IG9mIGlkZW50aWZpZXJzIHdoaWNoIGNhbiBiZSByZWZlcnJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICogICAtIHNvdXJjZVJvb3Q6IE9wdGlvbmFsLiBUaGUgVVJMIHJvb3QgZnJvbSB3aGljaCBhbGwgc291cmNlcyBhcmUgcmVsYXRpdmUuXG4gKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gKlxuICogICAgIHtcbiAqICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAqICAgICB9XG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gKi9cbmZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNvdXJjZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzJyk7XG4gIC8vIFNhc3MgMy4zIGxlYXZlcyBvdXQgdGhlICduYW1lcycgYXJyYXksIHNvIHdlIGRldmlhdGUgZnJvbSB0aGUgc3BlYyAod2hpY2hcbiAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgdmFyIG5hbWVzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbmFtZXMnLCBbXSk7XG4gIHZhciBzb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB2YXIgc291cmNlc0NvbnRlbnQgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzQ29udGVudCcsIG51bGwpO1xuICB2YXIgbWFwcGluZ3MgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdtYXBwaW5ncycpO1xuICB2YXIgZmlsZSA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ2ZpbGUnLCBudWxsKTtcblxuICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgLy8gc3RyaW5nIHJhdGhlciB0aGFuIGEgbnVtYmVyLCBzbyB3ZSB1c2UgbG9vc2UgZXF1YWxpdHkgY2hlY2tpbmcgaGVyZS5cbiAgaWYgKHZlcnNpb24gIT0gdGhpcy5fdmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgc291cmNlcyA9IHNvdXJjZXNcbiAgICAubWFwKFN0cmluZylcbiAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgLm1hcCh1dGlsLm5vcm1hbGl6ZSlcbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgc291cmNlIHJvb3QsIGlmIHRoZSBzb3VyY2Ugcm9vdCBpcyBhYnNvbHV0ZS4gTm90IGRvaW5nIHRoaXMgd291bGRcbiAgICAvLyBiZSBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMgd2hlbiB0aGUgc291cmNlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlXG4gICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2VSb290ICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2VSb290KSAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlKVxuICAgICAgICA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKVxuICAgICAgICA6IHNvdXJjZTtcbiAgICB9KTtcblxuICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSwgdHJ1ZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICB0aGlzLmZpbGUgPSBmaWxlO1xufVxuXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQ3JlYXRlIGEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICpcbiAqIEBwYXJhbSBTb3VyY2VNYXBHZW5lcmF0b3IgYVNvdXJjZU1hcFxuICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAqIEByZXR1cm5zIEJhc2ljU291cmNlTWFwQ29uc3VtZXJcbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKSB7XG4gICAgdmFyIHNtYyA9IE9iamVjdC5jcmVhdGUoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuXG4gICAgdmFyIG5hbWVzID0gc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgIHZhciBzb3VyY2VzID0gc21jLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX3NvdXJjZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICBzbWMuc291cmNlUm9vdCA9IGFTb3VyY2VNYXAuX3NvdXJjZVJvb3Q7XG4gICAgc21jLnNvdXJjZXNDb250ZW50ID0gYVNvdXJjZU1hcC5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChzbWMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc21jLnNvdXJjZVJvb3QpO1xuICAgIHNtYy5maWxlID0gYVNvdXJjZU1hcC5fZmlsZTtcblxuICAgIC8vIEJlY2F1c2Ugd2UgYXJlIG1vZGlmeWluZyB0aGUgZW50cmllcyAoYnkgY29udmVydGluZyBzdHJpbmcgc291cmNlcyBhbmRcbiAgICAvLyBuYW1lcyB0byBpbmRpY2VzIGludG8gdGhlIHNvdXJjZXMgYW5kIG5hbWVzIEFycmF5U2V0cyksIHdlIGhhdmUgdG8gbWFrZVxuICAgIC8vIGEgY29weSBvZiB0aGUgZW50cnkgb3IgZWxzZSBiYWQgdGhpbmdzIGhhcHBlbi4gU2hhcmVkIG11dGFibGUgc3RhdGVcbiAgICAvLyBzdHJpa2VzIGFnYWluISBTZWUgZ2l0aHViIGlzc3VlICMxOTEuXG5cbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTtcbiAgICB2YXIgZGVzdEdlbmVyYXRlZE1hcHBpbmdzID0gc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZGVzdE9yaWdpbmFsTWFwcGluZ3MgPSBzbWMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzcmNNYXBwaW5nID0gZ2VuZXJhdGVkTWFwcGluZ3NbaV07XG4gICAgICB2YXIgZGVzdE1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBzcmNNYXBwaW5nLmdlbmVyYXRlZExpbmU7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBzcmNNYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKHNyY01hcHBpbmcuc291cmNlKSB7XG4gICAgICAgIGRlc3RNYXBwaW5nLnNvdXJjZSA9IHNvdXJjZXMuaW5kZXhPZihzcmNNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsTGluZSA9IHNyY01hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHNyY01hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKHNyY01hcHBpbmcubmFtZSkge1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm5hbWUgPSBuYW1lcy5pbmRleE9mKHNyY01hcHBpbmcubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0T3JpZ2luYWxNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgZGVzdEdlbmVyYXRlZE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgIH1cblxuICAgIHF1aWNrU29ydChzbWMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgIHJldHVybiBzbWM7XG4gIH07XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlUm9vdCAhPSBudWxsID8gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgcykgOiBzO1xuICAgIH0sIHRoaXMpO1xuICB9XG59KTtcblxuLyoqXG4gKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gIHRoaXMuZ2VuZXJhdGVkTGluZSA9IDA7XG4gIHRoaXMuZ2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB0aGlzLm5hbWUgPSBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY2FjaGVkU2VnbWVudHMgPSB7fTtcbiAgICB2YXIgdGVtcCA9IHt9O1xuICAgIHZhciBvcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIG1hcHBpbmcsIHN0ciwgc2VnbWVudCwgZW5kLCB2YWx1ZTtcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJzsnKSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnLCcpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXBwaW5nID0gbmV3IE1hcHBpbmcoKTtcbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gZ2VuZXJhdGVkTGluZTtcblxuICAgICAgICAvLyBCZWNhdXNlIGVhY2ggb2Zmc2V0IGlzIGVuY29kZWQgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgLy8gbWFueSBzZWdtZW50cyBvZnRlbiBoYXZlIHRoZSBzYW1lIGVuY29kaW5nLiBXZSBjYW4gZXhwbG9pdCB0aGlzXG4gICAgICAgIC8vIGZhY3QgYnkgY2FjaGluZyB0aGUgcGFyc2VkIHZhcmlhYmxlIGxlbmd0aCBmaWVsZHMgb2YgZWFjaCBzZWdtZW50LFxuICAgICAgICAvLyBhbGxvd2luZyB1cyB0byBhdm9pZCBhIHNlY29uZCBwYXJzZSBpZiB3ZSBlbmNvdW50ZXIgdGhlIHNhbWVcbiAgICAgICAgLy8gc2VnbWVudCBhZ2Fpbi5cbiAgICAgICAgZm9yIChlbmQgPSBpbmRleDsgZW5kIDwgbGVuZ3RoOyBlbmQrKykge1xuICAgICAgICAgIGlmICh0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGVuZCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBhU3RyLnNsaWNlKGluZGV4LCBlbmQpO1xuXG4gICAgICAgIHNlZ21lbnQgPSBjYWNoZWRTZWdtZW50c1tzdHJdO1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgIGluZGV4ICs9IHN0ci5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShhU3RyLCBpbmRleCwgdGVtcCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICBpbmRleCA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIHNlZ21lbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FjaGVkU2VnbWVudHNbc3RyXSA9IHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgc2VnbWVudFswXTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gcHJldmlvdXNTb3VyY2UgKyBzZWdtZW50WzFdO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHNlZ21lbnRbMV07XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyBzZWdtZW50WzJdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHNlZ21lbnRbM107XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gcHJldmlvdXNOYW1lICsgc2VnbWVudFs0XTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSBzZWdtZW50WzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KGdlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBnZW5lcmF0ZWRNYXBwaW5ncztcblxuICAgIHF1aWNrU29ydChvcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG9yaWdpbmFsTWFwcGluZ3M7XG4gIH07XG5cbi8qKlxuICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yLCBhQmlhcykge1xuICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICB9XG4gICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgfTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gKiBpbmNsdXNpdmUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgIC8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4gICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRNYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXggKyAxXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbGFzdCBtYXBwaW5nIGZvciBlYWNoIGxpbmUgc3BhbnMgdGhlIGVudGlyZSBsaW5lLlxuICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLFxuICAgICAgXCJnZW5lcmF0ZWRMaW5lXCIsXG4gICAgICBcImdlbmVyYXRlZENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnc291cmNlJywgbnVsbCk7XG4gICAgICAgIGlmIChzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmF0KHNvdXJjZSk7XG4gICAgICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbCk7XG4gICAgICAgIGlmIChuYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmF0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbmFtZTogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudC5sZW5ndGggPj0gdGhpcy5fc291cmNlcy5zaXplKCkgJiZcbiAgICAgICF0aGlzLnNvdXJjZXNDb250ZW50LnNvbWUoZnVuY3Rpb24gKHNjKSB7IHJldHVybiBzYyA9PSBudWxsOyB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBhU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIGFTb3VyY2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb3VyY2VzLmhhcyhhU291cmNlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGFTb3VyY2UpXTtcbiAgICB9XG5cbiAgICB2YXIgdXJsO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IGFTb3VyY2UucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgXCJcIik7XG4gICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKGZpbGVVcmlBYnNQYXRoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZmlsZVVyaUFic1BhdGgpXVxuICAgICAgfVxuXG4gICAgICBpZiAoKCF1cmwucGF0aCB8fCB1cmwucGF0aCA9PSBcIi9cIilcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhcIi9cIiArIGFTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIGFTb3VyY2UpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgZnJvbVxuICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuICAgIC8vIGRvbid0IHdhbnQgdG8gdGhyb3cgaWYgd2UgY2FuJ3QgZmluZCB0aGUgc291cmNlIC0gd2UganVzdCB3YW50IHRvXG4gICAgLy8gcmV0dXJuIG51bGwsIHNvIHdlIHByb3ZpZGUgYSBmbGFnIHRvIGV4aXQgZ3JhY2VmdWxseS5cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyk7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgb3JpZ2luYWxMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IG5lZWRsZS5zb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIGxhc3RDb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG5leHBvcnRzLkJhc2ljU291cmNlTWFwQ29uc3VtZXIgPSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEFuIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2hcbiAqIHdlIGNhbiBxdWVyeSBmb3IgaW5mb3JtYXRpb24uIEl0IGRpZmZlcnMgZnJvbSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluXG4gKiB0aGF0IGl0IHRha2VzIFwiaW5kZXhlZFwiIHNvdXJjZSBtYXBzIChpLmUuIG9uZXMgd2l0aCBhIFwic2VjdGlvbnNcIiBmaWVsZCkgYXNcbiAqIGlucHV0LlxuICpcbiAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAqXG4gKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gKiAgICAgICBmaWVsZC5cbiAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAqXG4gKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gKiB1bnN1cHBvcnRlZC5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAqXG4gKiAge1xuICogICAgdmVyc2lvbiA6IDMsXG4gKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICogICAgc2VjdGlvbnM6IFt7XG4gKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICogICAgICBtYXA6IHtcbiAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICogICAgICB9XG4gKiAgICB9XSxcbiAqICB9XG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICovXG5mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNlY3Rpb25zID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc2VjdGlvbnMnKTtcblxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgdmFyIGxhc3RPZmZzZXQgPSB7XG4gICAgbGluZTogLTEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHRoaXMuX3NlY3Rpb25zID0gc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMudXJsKSB7XG4gICAgICAvLyBUaGUgdXJsIGZpZWxkIHdpbGwgcmVxdWlyZSBzdXBwb3J0IGZvciBhc3luY2hyb25pY2l0eS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8xNlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdXRpbC5nZXRBcmcocywgJ29mZnNldCcpO1xuICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgIHZhciBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICdjb2x1bW4nKTtcblxuICAgIGlmIChvZmZzZXRMaW5lIDwgbGFzdE9mZnNldC5saW5lIHx8XG4gICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4nKTtcbiAgICB9XG4gICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICBnZW5lcmF0ZWRPZmZzZXQ6IHtcbiAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG9mZnNldExpbmUgKyAxLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgIH0sXG4gICAgICBjb25zdW1lcjogbmV3IFNvdXJjZU1hcENvbnN1bWVyKHV0aWwuZ2V0QXJnKHMsICdtYXAnKSlcbiAgICB9XG4gIH0pO1xufVxuXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5vcmlnaW5hbFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgLy8gRmluZCB0aGUgc2VjdGlvbiBjb250YWluaW5nIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24gd2UncmUgdHJ5aW5nIHRvIG1hcFxuICAgIC8vIHRvIGFuIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgIHZhciBzZWN0aW9uSW5kZXggPSBiaW5hcnlTZWFyY2guc2VhcmNoKG5lZWRsZSwgdGhpcy5fc2VjdGlvbnMsXG4gICAgICBmdW5jdGlvbihuZWVkbGUsIHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNtcCA9IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC0gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZTtcbiAgICAgICAgaWYgKGNtcCkge1xuICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbik7XG4gICAgICB9KTtcbiAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW3NlY3Rpb25JbmRleF07XG5cbiAgICBpZiAoIXNlY3Rpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBuYW1lOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBzZWN0aW9uLmNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgbGluZTogbmVlZGxlLmdlbmVyYXRlZExpbmUgLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgY29sdW1uOiBuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgIDogMCksXG4gICAgICBiaWFzOiBhQXJncy5iaWFzXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiBzLmNvbnN1bWVyLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCk7XG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICB2YXIgY29udGVudCA9IHNlY3Rpb24uY29uc3VtZXIuc291cmNlQ29udGVudEZvcihhU291cmNlLCB0cnVlKTtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoXG4gKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgLy8gT25seSBjb25zaWRlciB0aGlzIHNlY3Rpb24gaWYgdGhlIHJlcXVlc3RlZCBzb3VyY2UgaXMgaW4gdGhlIGxpc3Qgb2ZcbiAgICAgIC8vIHNvdXJjZXMgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuc291cmNlcy5pbmRleE9mKHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJykpID09PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBnZW5lcmF0ZWRQb3NpdGlvbiA9IHNlY3Rpb24uY29uc3VtZXIuZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpO1xuICAgICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uKSB7XG4gICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkUG9zaXRpb24ubGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkUG9zaXRpb24uY29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lXG4gICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgOiAwKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcbiAgICAgIHZhciBzZWN0aW9uTWFwcGluZ3MgPSBzZWN0aW9uLmNvbnN1bWVyLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VjdGlvbk1hcHBpbmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gc2VjdGlvbk1hcHBpbmdzW2pdO1xuXG4gICAgICAgIHZhciBzb3VyY2UgPSBzZWN0aW9uLmNvbnN1bWVyLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBzZWN0aW9uLmNvbnN1bWVyLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpO1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuXG4gICAgICAgIC8vIFRoZSBtYXBwaW5ncyBjb21pbmcgZnJvbSB0aGUgY29uc3VtZXIgZm9yIHRoZSBzZWN0aW9uIGhhdmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4gICAgICAgIC8vIG5lZWQgdG8gb2Zmc2V0IHRoZW0gdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb25jYXRlbmF0ZWRcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGZpbGUuXG4gICAgICAgIHZhciBhZGp1c3RlZE1hcHBpbmcgPSB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHF1aWNrU29ydCh0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gIH07XG5cbmV4cG9ydHMuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyID0gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBNYXBwaW5nTGlzdCA9IHJlcXVpcmUoJy4vbWFwcGluZy1saXN0JykuTWFwcGluZ0xpc3Q7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gWW91IG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAqL1xuZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKSB7XG4gIGlmICghYUFyZ3MpIHtcbiAgICBhQXJncyA9IHt9O1xuICB9XG4gIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB0aGlzLl9za2lwVmFsaWRhdGlvbiA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc2tpcFZhbGlkYXRpb24nLCBmYWxzZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbWFwcGluZ3MgPSBuZXcgTWFwcGluZ0xpc3QoKTtcbiAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbn1cblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIGZvciB0aGlzIHNvdXJjZSBtYXAgYmVpbmcgY3JlYXRlZC4gVGhlIG1hcHBpbmdcbiAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGdlbmVyYXRlZDogQW4gb2JqZWN0IHdpdGggdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICogICAtIG5hbWU6IEFuIG9wdGlvbmFsIG9yaWdpbmFsIHRva2VuIG5hbWUgZm9yIHRoaXMgbWFwcGluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJywgbnVsbCk7XG4gICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gU3RyaW5nKHNvdXJjZSk7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgaWYgKCF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIElmIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcCBpcyBlbXB0eSwgc2V0IHRoZSBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gKiBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZC4gRWFjaCBtYXBwaW5nIHRvIHRoZSBzdXBwbGllZCBzb3VyY2UgZmlsZSBpc1xuICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAqICAgICAgICBJZiBvbWl0dGVkLCBTb3VyY2VNYXBDb25zdW1lcidzIGZpbGUgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gKiAgICAgICAgVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHdoZW4gdGhlIHR3byBzb3VyY2UgbWFwcyBhcmVuJ3QgaW4gdGhlIHNhbWVcbiAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gKiAgICAgICAgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlLCBhU291cmNlTWFwUGF0aCkge1xuICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgIGlmIChhU291cmNlRmlsZSA9PSBudWxsKSB7XG4gICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgcmVxdWlyZXMgZWl0aGVyIGFuIGV4cGxpY2l0IHNvdXJjZSBmaWxlLCAnICtcbiAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgfVxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgfVxuICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbiAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb3B5IG1hcHBpbmdcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAqXG4gKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAqICAgICAgdG9rZW4uXG4gKlxuICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgLy8gQ2FzZSAxLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsOiBhT3JpZ2luYWwsXG4gICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gdG8gdGhlIHN0cmVhbSBvZiBiYXNlIDY0IFZMUXNcbiAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIG5leHQ7XG4gICAgdmFyIG1hcHBpbmc7XG4gICAgdmFyIG5hbWVJZHg7XG4gICAgdmFyIHNvdXJjZUlkeDtcblxuICAgIHZhciBtYXBwaW5ncyA9IHRoaXMuX21hcHBpbmdzLnRvQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcbiAgICAgIG5leHQgPSAnJ1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBuZXh0ICs9ICc7JztcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nLCBtYXBwaW5nc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dCArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUlkeCA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShzb3VyY2VJZHggLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgIHByZXZpb3VzU291cmNlID0gc291cmNlSWR4O1xuXG4gICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDE7XG5cbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmFtZUlkeCA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobmFtZUlkeCAtIHByZXZpb3VzTmFtZSk7XG4gICAgICAgICAgcHJldmlvdXNOYW1lID0gbmFtZUlkeDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhU291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsIGtleSlcbiAgICAgICAgPyB0aGlzLl9zb3VyY2VzQ29udGVudHNba2V5XVxuICAgICAgICA6IG51bGw7XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogRXh0ZXJuYWxpemUgdGhlIHNvdXJjZSBtYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTigpIHtcbiAgICB2YXIgbWFwID0ge1xuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgbmFtZXM6IHRoaXMuX25hbWVzLnRvQXJyYXkoKSxcbiAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgfTtcbiAgICBpZiAodGhpcy5fZmlsZSAhPSBudWxsKSB7XG4gICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH07XG5cbi8qKlxuICogUmVuZGVyIHRoZSBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZCB0byBhIHN0cmluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSk7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gU291cmNlTWFwR2VuZXJhdG9yO1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIE1hdGNoZXMgYSBXaW5kb3dzLXN0eWxlIGBcXHJcXG5gIG5ld2xpbmUgb3IgYSBgXFxuYCBuZXdsaW5lIHVzZWQgYnkgYWxsIG90aGVyXG4vLyBvcGVyYXRpbmcgc3lzdGVtcyB0aGVzZSBkYXlzIChjYXB0dXJpbmcgdGhlIHJlc3VsdCkuXG52YXIgUkVHRVhfTkVXTElORSA9IC8oXFxyP1xcbikvO1xuXG4vLyBOZXdsaW5lIGNoYXJhY3RlciBjb2RlIGZvciBjaGFyQ29kZUF0KCkgY29tcGFyaXNvbnNcbnZhciBORVdMSU5FX0NPREUgPSAxMDtcblxuLy8gUHJpdmF0ZSBzeW1ib2wgZm9yIGlkZW50aWZ5aW5nIGBTb3VyY2VOb2RlYHMgd2hlbiBtdWx0aXBsZSB2ZXJzaW9ucyBvZlxuLy8gdGhlIHNvdXJjZS1tYXAgbGlicmFyeSBhcmUgbG9hZGVkLiBUaGlzIE1VU1QgTk9UIENIQU5HRSBhY3Jvc3Ncbi8vIHZlcnNpb25zIVxudmFyIGlzU291cmNlTm9kZSA9IFwiJCQkaXNTb3VyY2VOb2RlJCQkXCI7XG5cbi8qKlxuICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICogc25pcHBldHMgb2YgZ2VuZXJhdGVkIEphdmFTY3JpcHQgc291cmNlIGNvZGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGxpbmUgYW5kXG4gKiBjb2x1bW4gaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcGFyYW0gYUxpbmUgVGhlIG9yaWdpbmFsIGxpbmUgbnVtYmVyLlxuICogQHBhcmFtIGFDb2x1bW4gVGhlIG9yaWdpbmFsIGNvbHVtbiBudW1iZXIuXG4gKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gKiBAcGFyYW0gYUNodW5rcyBPcHRpb25hbC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCBhcmUgc25pcHBldHMgb2ZcbiAqICAgICAgICBnZW5lcmF0ZWQgSlMsIG9yIG90aGVyIFNvdXJjZU5vZGVzLlxuICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICovXG5mdW5jdGlvbiBTb3VyY2VOb2RlKGFMaW5lLCBhQ29sdW1uLCBhU291cmNlLCBhQ2h1bmtzLCBhTmFtZSkge1xuICB0aGlzLmNoaWxkcmVuID0gW107XG4gIHRoaXMuc291cmNlQ29udGVudHMgPSB7fTtcbiAgdGhpcy5saW5lID0gYUxpbmUgPT0gbnVsbCA/IG51bGwgOiBhTGluZTtcbiAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09IG51bGwgPyBudWxsIDogYUNvbHVtbjtcbiAgdGhpcy5zb3VyY2UgPSBhU291cmNlID09IG51bGwgPyBudWxsIDogYVNvdXJjZTtcbiAgdGhpcy5uYW1lID0gYU5hbWUgPT0gbnVsbCA/IG51bGwgOiBhTmFtZTtcbiAgdGhpc1tpc1NvdXJjZU5vZGVdID0gdHJ1ZTtcbiAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAqXG4gKiBAcGFyYW0gYUdlbmVyYXRlZENvZGUgVGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFSZWxhdGl2ZVBhdGggT3B0aW9uYWwuIFRoZSBwYXRoIHRoYXQgcmVsYXRpdmUgc291cmNlcyBpbiB0aGVcbiAqICAgICAgICBTb3VyY2VNYXBDb25zdW1lciBzaG91bGQgYmUgcmVsYXRpdmUgdG8uXG4gKi9cblNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLCBhU291cmNlTWFwQ29uc3VtZXIsIGFSZWxhdGl2ZVBhdGgpIHtcbiAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAvLyBhbmQgdGhlIFNvdXJjZU1hcFxuICAgIHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgIC8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAgIC8vIHdoaWxlIGFsbCBvZGQgaW5kaWNlcyBhcmUgdGhlIG5ld2xpbmVzIGJldHdlZW4gdHdvIGFkamFjZW50IGxpbmVzXG4gICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIHJlbW92ZWQgZnJvbSB0aGlzIGFycmF5LCBieSBjYWxsaW5nIGBzaGlmdE5leHRMaW5lYC5cbiAgICB2YXIgcmVtYWluaW5nTGluZXMgPSBhR2VuZXJhdGVkQ29kZS5zcGxpdChSRUdFWF9ORVdMSU5FKTtcbiAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVDb250ZW50cyA9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCk7XG4gICAgICAvLyBUaGUgbGFzdCBsaW5lIG9mIGEgZmlsZSBtaWdodCBub3QgaGF2ZSBhIG5ld2xpbmUuXG4gICAgICB2YXIgbmV3TGluZSA9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCkgfHwgXCJcIjtcbiAgICAgIHJldHVybiBsaW5lQ29udGVudHMgKyBuZXdMaW5lO1xuICAgIH07XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICB2YXIgbGFzdEdlbmVyYXRlZExpbmUgPSAxLCBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgIC8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbiAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBjb2RlIGZyb20gXCJsYXN0TWFwcGluZ1wiIHRvIFwibWFwcGluZ1wiOlxuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSBmaXJzdCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAvLyBFYWNoIGxpbmUgaXMgYWRkZWQgYXMgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICB9XG4gICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICBub2RlLmFkZChuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pKTtcbiAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICB9XG4gICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgfSwgdGhpcyk7XG4gICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgIGlmIChyZW1haW5pbmdMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcpIHtcbiAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgIH1cbiAgICAgIC8vIGFuZCBhZGQgdGhlIHJlbWFpbmluZyBsaW5lcyB3aXRob3V0IGFueSBtYXBwaW5nXG4gICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5qb2luKFwiXCIpKTtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50IGludG8gU291cmNlTm9kZVxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlO1xuXG4gICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZS5hZGQoY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc291cmNlID0gYVJlbGF0aXZlUGF0aFxuICAgICAgICAgID8gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIDogbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIG5vZGUuYWRkKG5ldyBTb3VyY2VOb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcubmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2FkZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGFDaHVuay5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoYUNodW5rKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3ByZXBlbmQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGFDaHVua1tpc1NvdXJjZU5vZGVdIHx8IHR5cGVvZiBhQ2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gKiB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIHNuaXBwZXQgb2YgSlMgYW5kIGlzIHBhc3NlZCB0aGF0XG4gKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICB2YXIgY2h1bms7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgIGlmIChjaHVua1tpc1NvdXJjZU5vZGVdKSB7XG4gICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKGNodW5rICE9PSAnJykge1xuICAgICAgICBhRm4oY2h1bmssIHsgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIExpa2UgYFN0cmluZy5wcm90b3R5cGUuam9pbmAgZXhjZXB0IGZvciBTb3VyY2VOb2Rlcy4gSW5zZXJ0cyBgYVN0cmAgYmV0d2VlblxuICogZWFjaCBvZiBgdGhpcy5jaGlsZHJlbmAuXG4gKlxuICogQHBhcmFtIGFTZXAgVGhlIHNlcGFyYXRvci5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfam9pbihhU2VwKSB7XG4gIHZhciBuZXdDaGlsZHJlbjtcbiAgdmFyIGk7XG4gIHZhciBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKGxlbiA+IDApIHtcbiAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4tMTsgaSsrKSB7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaChhU2VwKTtcbiAgICB9XG4gICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gbmV3Q2hpbGRyZW47XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIG9uIHRoZSB2ZXJ5IHJpZ2h0LW1vc3Qgc291cmNlIHNuaXBwZXQuIFVzZWZ1bFxuICogZm9yIHRyaW1taW5nIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGEgc291cmNlIG5vZGUsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gYVBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAqIEBwYXJhbSBhUmVwbGFjZW1lbnQgVGhlIHRoaW5nIHRvIHJlcGxhY2UgdGhlIHBhdHRlcm4gd2l0aC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucmVwbGFjZVJpZ2h0ID0gZnVuY3Rpb24gU291cmNlTm9kZV9yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkge1xuICB2YXIgbGFzdENoaWxkID0gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICBpZiAobGFzdENoaWxkW2lzU291cmNlTm9kZV0pIHtcbiAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBsYXN0Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvclxuICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICpcbiAqIEBwYXJhbSBhU291cmNlRmlsZSBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdGhpcy5zb3VyY2VDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKGFTb3VyY2VGaWxlKV0gPSBhU291cmNlQ29udGVudDtcbiAgfTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgU291cmNlTm9kZXMuIFRoZSB3YWxraW5nIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgZWFjaFxuICogc291cmNlIGZpbGUgY29udGVudCBhbmQgaXMgcGFzc2VkIHRoZSBmaWxlbmFtZSBhbmQgc291cmNlIGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIGFGbiBUaGUgdHJhdmVyc2FsIGZ1bmN0aW9uLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGtTb3VyY2VDb250ZW50cyhhRm4pIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV1baXNTb3VyY2VOb2RlXSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLndhbGtTb3VyY2VDb250ZW50cyhhRm4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzb3VyY2VzID0gT2JqZWN0LmtleXModGhpcy5zb3VyY2VDb250ZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlLiBXYWxrcyBvdmVyIHRoZSB0cmVlXG4gKiBhbmQgY29uY2F0ZW5hdGVzIGFsbCB0aGUgdmFyaW91cyBzbmlwcGV0cyB0b2dldGhlciB0byBvbmUgc3RyaW5nLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmcoKSB7XG4gIHZhciBzdHIgPSBcIlwiO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgc3RyICs9IGNodW5rO1xuICB9KTtcbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICogbWFwLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICB2YXIgZ2VuZXJhdGVkID0ge1xuICAgIGNvZGU6IFwiXCIsXG4gICAgbGluZTogMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICB2YXIgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICB2YXIgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbE5hbWUgPSBudWxsO1xuICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgIGdlbmVyYXRlZC5jb2RlICs9IGNodW5rO1xuICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5jb2x1bW4gIT09IG51bGwpIHtcbiAgICAgIGlmKGxhc3RPcmlnaW5hbFNvdXJjZSAhPT0gb3JpZ2luYWwuc291cmNlXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxDb2x1bW4gIT09IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTmFtZSAhPT0gb3JpZ2luYWwubmFtZSkge1xuICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgIGxhc3RPcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgbGFzdE9yaWdpbmFsTmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gY2h1bmsubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG4gICAgICBpZiAoY2h1bmsuY2hhckNvZGVBdChpZHgpID09PSBORVdMSU5FX0NPREUpIHtcbiAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbiA9IDA7XG4gICAgICAgIC8vIE1hcHBpbmdzIGVuZCBhdCBlb2xcbiAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB0aGlzLndhbGtTb3VyY2VDb250ZW50cyhmdW5jdGlvbiAoc291cmNlRmlsZSwgc291cmNlQ29udGVudCkge1xuICAgIG1hcC5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpO1xuICB9KTtcblxuICByZXR1cm4geyBjb2RlOiBnZW5lcmF0ZWQuY29kZSwgbWFwOiBtYXAgfTtcbn07XG5cbmV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgcmV0dXJuIGFBcmdzW2FOYW1lXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICB9XG59XG5leHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxudmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuXSopKD86OihcXGQrKSk/KFxcUyopJC87XG52YXIgZGF0YVVybFJlZ2V4cCA9IC9eZGF0YTouK1xcLC4rJC87XG5cbmZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgIGhvc3Q6IG1hdGNoWzNdLFxuICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgIHBhdGg6IG1hdGNoWzVdXG4gIH07XG59XG5leHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbmZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgdmFyIHVybCA9ICcnO1xuICBpZiAoYVBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5zY2hlbWUgKyAnOic7XG4gIH1cbiAgdXJsICs9ICcvLyc7XG4gIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLmhvc3QpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBvcnQpIHtcbiAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICpcbiAqIC0gUmVwbGFjZXMgY29uc2VjdXRpdmUgc2xhc2hlcyB3aXRoIG9uZSBzbGFzaC5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAqXG4gKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgdXJsIHRvIG5vcm1hbGl6ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGFQYXRoKSB7XG4gIHZhciBwYXRoID0gYVBhdGg7XG4gIHZhciB1cmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIGlmICh1cmwpIHtcbiAgICBpZiAoIXVybC5wYXRoKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuICAgIHBhdGggPSB1cmwucGF0aDtcbiAgfVxuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKTtcblxuICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KC9cXC8rLyk7XG4gIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4gICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgdXAgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICB1cC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoID0gcGFydHMuam9pbignLycpO1xuXG4gIGlmIChwYXRoID09PSAnJykge1xuICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICB9XG5cbiAgaWYgKHVybCkge1xuICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuXG4vKipcbiAqIEpvaW5zIHR3byBwYXRocy9VUkxzLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgam9pbmVkIHdpdGggdGhlIHJvb3QuXG4gKlxuICogLSBJZiBhUGF0aCBpcyBhIFVSTCBvciBhIGRhdGEgVVJJLCBhUGF0aCBpcyByZXR1cm5lZCwgdW5sZXNzIGFQYXRoIGlzIGFcbiAqICAgc2NoZW1lLXJlbGF0aXZlIFVSTDogVGhlbiB0aGUgc2NoZW1lIG9mIGFSb290LCBpZiBhbnksIGlzIHByZXBlbmRlZFxuICogICBmaXJzdC5cbiAqIC0gT3RoZXJ3aXNlIGFQYXRoIGlzIGEgcGF0aC4gSWYgYVJvb3QgaXMgYSBVUkwsIHRoZW4gaXRzIHBhdGggcG9ydGlvblxuICogICBpcyB1cGRhdGVkIHdpdGggdGhlIHJlc3VsdCBhbmQgYVJvb3QgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGUgcmVzdWx0XG4gKiAgIGlzIHJldHVybmVkLlxuICogICAtIElmIGFQYXRoIGlzIGFic29sdXRlLCB0aGUgcmVzdWx0IGlzIGFQYXRoLlxuICogICAtIE90aGVyd2lzZSB0aGUgdHdvIHBhdGhzIGFyZSBqb2luZWQgd2l0aCBhIHNsYXNoLlxuICogLSBKb2luaW5nIGZvciBleGFtcGxlICdodHRwOi8vJyBhbmQgJ3d3dy5leGFtcGxlLmNvbScgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIGpvaW4oYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cbiAgaWYgKGFQYXRoID09PSBcIlwiKSB7XG4gICAgYVBhdGggPSBcIi5cIjtcbiAgfVxuICB2YXIgYVBhdGhVcmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIHZhciBhUm9vdFVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3QgPSBhUm9vdFVybC5wYXRoIHx8ICcvJztcbiAgfVxuXG4gIC8vIGBqb2luKGZvbywgJy8vd3d3LmV4YW1wbGUub3JnJylgXG4gIGlmIChhUGF0aFVybCAmJiAhYVBhdGhVcmwuc2NoZW1lKSB7XG4gICAgaWYgKGFSb290VXJsKSB7XG4gICAgICBhUGF0aFVybC5zY2hlbWUgPSBhUm9vdFVybC5zY2hlbWU7XG4gICAgfVxuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7XG4gIH1cblxuICBpZiAoYVBhdGhVcmwgfHwgYVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpIHtcbiAgICByZXR1cm4gYVBhdGg7XG4gIH1cblxuICAvLyBgam9pbignaHR0cDovLycsICd3d3cuZXhhbXBsZS5jb20nKWBcbiAgaWYgKGFSb290VXJsICYmICFhUm9vdFVybC5ob3N0ICYmICFhUm9vdFVybC5wYXRoKSB7XG4gICAgYVJvb3RVcmwuaG9zdCA9IGFQYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cblxuICB2YXIgam9pbmVkID0gYVBhdGguY2hhckF0KDApID09PSAnLydcbiAgICA/IGFQYXRoXG4gICAgOiBub3JtYWxpemUoYVJvb3QucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyBhUGF0aCk7XG5cbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3RVcmwucGF0aCA9IGpvaW5lZDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG4gIHJldHVybiBqb2luZWQ7XG59XG5leHBvcnRzLmpvaW4gPSBqb2luO1xuXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbiAoYVBhdGgpIHtcbiAgcmV0dXJuIGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nIHx8ICEhYVBhdGgubWF0Y2godXJsUmVnZXhwKTtcbn07XG5cbi8qKlxuICogTWFrZSBhIHBhdGggcmVsYXRpdmUgdG8gYSBVUkwgb3IgYW5vdGhlciBwYXRoLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgbWFkZSByZWxhdGl2ZSB0byBhUm9vdC5cbiAqL1xuZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cblxuICBhUm9vdCA9IGFSb290LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgZm9yIHRoZSBwYXRoIHRvIGJlIGFib3ZlIHRoZSByb290LiBJbiB0aGlzIGNhc2UsIHNpbXBseVxuICAvLyBjaGVja2luZyB3aGV0aGVyIHRoZSByb290IGlzIGEgcHJlZml4IG9mIHRoZSBwYXRoIHdvbid0IHdvcmsuIEluc3RlYWQsIHdlXG4gIC8vIG5lZWQgdG8gcmVtb3ZlIGNvbXBvbmVudHMgZnJvbSB0aGUgcm9vdCBvbmUgYnkgb25lLCB1bnRpbCBlaXRoZXIgd2UgZmluZFxuICAvLyBhIHByZWZpeCB0aGF0IGZpdHMsIG9yIHdlIHJ1biBvdXQgb2YgY29tcG9uZW50cyB0byByZW1vdmUuXG4gIHZhciBsZXZlbCA9IDA7XG4gIHdoaWxlIChhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSAhPT0gMCkge1xuICAgIHZhciBpbmRleCA9IGFSb290Lmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9ubHkgcGFydCBvZiB0aGUgcm9vdCB0aGF0IGlzIGxlZnQgaXMgdGhlIHNjaGVtZSAoaS5lLiBodHRwOi8vLFxuICAgIC8vIGZpbGU6Ly8vLCBldGMuKSwgb25lIG9yIG1vcmUgc2xhc2hlcyAoLyksIG9yIHNpbXBseSBub3RoaW5nIGF0IGFsbCwgd2VcbiAgICAvLyBoYXZlIGV4aGF1c3RlZCBhbGwgY29tcG9uZW50cywgc28gdGhlIHBhdGggaXMgbm90IHJlbGF0aXZlIHRvIHRoZSByb290LlxuICAgIGFSb290ID0gYVJvb3Quc2xpY2UoMCwgaW5kZXgpO1xuICAgIGlmIChhUm9vdC5tYXRjaCgvXihbXlxcL10rOlxcLyk/XFwvKiQvKSkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgICsrbGV2ZWw7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgYWRkIGEgXCIuLi9cIiBmb3IgZWFjaCBjb21wb25lbnQgd2UgcmVtb3ZlZCBmcm9tIHRoZSByb290LlxuICByZXR1cm4gQXJyYXkobGV2ZWwgKyAxKS5qb2luKFwiLi4vXCIpICsgYVBhdGguc3Vic3RyKGFSb290Lmxlbmd0aCArIDEpO1xufVxuZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG52YXIgc3VwcG9ydHNOdWxsUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuICEoJ19fcHJvdG9fXycgaW4gb2JqKTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGlkZW50aXR5IChzKSB7XG4gIHJldHVybiBzO1xufVxuXG4vKipcbiAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuZnVuY3Rpb24gdG9TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiAnJCcgKyBhU3RyO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLnRvU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IHRvU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBmcm9tU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gYVN0ci5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy5mcm9tU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IGZyb21TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzUHJvdG9TdHJpbmcocykge1xuICBpZiAoIXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDkgLyogXCJfX3Byb3RvX19cIi5sZW5ndGggKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocy5jaGFyQ29kZUF0KGxlbmd0aCAtIDEpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMikgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAzKSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDQpICE9PSAxMTYgLyogJ3QnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNSkgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA2KSAhPT0gMTE0IC8qICdyJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDcpICE9PSAxMTIgLyogJ3AnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOCkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA5KSAhPT0gOTUgIC8qICdfJyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBsZW5ndGggLSAxMDsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAocy5jaGFyQ29kZUF0KGkpICE9PSAzNiAvKiAnJCcgKi8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICogbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGEgbWFwcGluZyB3aXRoIGFcbiAqIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICB2YXIgY21wID0gbWFwcGluZ0Euc291cmNlIC0gbWFwcGluZ0Iuc291cmNlO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBtYXBwaW5nQS5uYW1lIC0gbWFwcGluZ0IubmFtZTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggZGVmbGF0ZWQgc291cmNlIGFuZCBuYW1lIGluZGljZXMgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4sIGJ1dCBkaWZmZXJlbnRcbiAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gKiBtYXBwaW5nIHdpdGggYSBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Euc291cmNlIC0gbWFwcGluZ0Iuc291cmNlO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBtYXBwaW5nQS5uYW1lIC0gbWFwcGluZ0IubmFtZTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZDtcblxuZnVuY3Rpb24gc3RyY21wKGFTdHIxLCBhU3RyMikge1xuICBpZiAoYVN0cjEgPT09IGFTdHIyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYVN0cjEgPiBhU3RyMikge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBpbmZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgc3RyaW5ncyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQ7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcbiIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ3N0YWNrZnJhbWUnLCBbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5TdGFja0ZyYW1lID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGZ1bmN0aW9uIF9pc051bWJlcihuKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NhcGl0YWxpemUoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9nZXR0ZXIocCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1twXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYm9vbGVhblByb3BzID0gWydpc0NvbnN0cnVjdG9yJywgJ2lzRXZhbCcsICdpc05hdGl2ZScsICdpc1RvcGxldmVsJ107XG4gICAgdmFyIG51bWVyaWNQcm9wcyA9IFsnY29sdW1uTnVtYmVyJywgJ2xpbmVOdW1iZXInXTtcbiAgICB2YXIgc3RyaW5nUHJvcHMgPSBbJ2ZpbGVOYW1lJywgJ2Z1bmN0aW9uTmFtZScsICdzb3VyY2UnXTtcbiAgICB2YXIgYXJyYXlQcm9wcyA9IFsnYXJncyddO1xuICAgIHZhciBvYmplY3RQcm9wcyA9IFsnZXZhbE9yaWdpbiddO1xuXG4gICAgdmFyIHByb3BzID0gYm9vbGVhblByb3BzLmNvbmNhdChudW1lcmljUHJvcHMsIHN0cmluZ1Byb3BzLCBhcnJheVByb3BzLCBvYmplY3RQcm9wcyk7XG5cbiAgICBmdW5jdGlvbiBTdGFja0ZyYW1lKG9iaikge1xuICAgICAgICBpZiAoIW9iaikgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAob2JqW3Byb3BzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpc1snc2V0JyArIF9jYXBpdGFsaXplKHByb3BzW2ldKV0ob2JqW3Byb3BzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZ2V0QXJnczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcmdzO1xuICAgICAgICB9LFxuICAgICAgICBzZXRBcmdzOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJncyBtdXN0IGJlIGFuIEFycmF5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSB2O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEV2YWxPcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZhbE9yaWdpbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RXZhbE9yaWdpbjogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBTdGFja0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmFsT3JpZ2luID0gdjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZhbE9yaWdpbiA9IG5ldyBTdGFja0ZyYW1lKHYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFdmFsIE9yaWdpbiBtdXN0IGJlIGFuIE9iamVjdCBvciBTdGFja0ZyYW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZSgpIHx8ICcnO1xuICAgICAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSB0aGlzLmdldExpbmVOdW1iZXIoKSB8fCAnJztcbiAgICAgICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSB0aGlzLmdldENvbHVtbk51bWJlcigpIHx8ICcnO1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRoaXMuZ2V0RnVuY3Rpb25OYW1lKCkgfHwgJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRJc0V2YWwoKSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1tldmFsXSAoJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlciArICcpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbZXZhbF06JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uTmFtZSArICcgKCcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXIgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFN0YWNrRnJhbWUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIFN0YWNrRnJhbWUkJGZyb21TdHJpbmcoc3RyKSB7XG4gICAgICAgIHZhciBhcmdzU3RhcnRJbmRleCA9IHN0ci5pbmRleE9mKCcoJyk7XG4gICAgICAgIHZhciBhcmdzRW5kSW5kZXggPSBzdHIubGFzdEluZGV4T2YoJyknKTtcblxuICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gc3RyLnN1YnN0cmluZygwLCBhcmdzU3RhcnRJbmRleCk7XG4gICAgICAgIHZhciBhcmdzID0gc3RyLnN1YnN0cmluZyhhcmdzU3RhcnRJbmRleCArIDEsIGFyZ3NFbmRJbmRleCkuc3BsaXQoJywnKTtcbiAgICAgICAgdmFyIGxvY2F0aW9uU3RyaW5nID0gc3RyLnN1YnN0cmluZyhhcmdzRW5kSW5kZXggKyAxKTtcblxuICAgICAgICBpZiAobG9jYXRpb25TdHJpbmcuaW5kZXhPZignQCcpID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgcGFydHMgPSAvQCguKz8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/JC8uZXhlYyhsb2NhdGlvblN0cmluZywgJycpO1xuICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHBhcnRzWzJdO1xuICAgICAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHBhcnRzWzNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgYXJnczogYXJncyB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBmaWxlTmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbHVtbk51bWJlcjogY29sdW1uTnVtYmVyIHx8IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29sZWFuUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShib29sZWFuUHJvcHNbaV0pXSA9IF9nZXR0ZXIoYm9vbGVhblByb3BzW2ldKTtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShib29sZWFuUHJvcHNbaV0pXSA9IChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIHRoaXNbcF0gPSBCb29sZWFuKHYpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoYm9vbGVhblByb3BzW2ldKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bWVyaWNQcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKG51bWVyaWNQcm9wc1tqXSldID0gX2dldHRlcihudW1lcmljUHJvcHNbal0pO1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKG51bWVyaWNQcm9wc1tqXSldID0gKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXNOdW1iZXIodikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihwICsgJyBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXNbcF0gPSBOdW1iZXIodik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShudW1lcmljUHJvcHNbal0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc3RyaW5nUHJvcHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShzdHJpbmdQcm9wc1trXSldID0gX2dldHRlcihzdHJpbmdQcm9wc1trXSk7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUoc3RyaW5nUHJvcHNba10pXSA9IChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIHRoaXNbcF0gPSBTdHJpbmcodik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShzdHJpbmdQcm9wc1trXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0YWNrRnJhbWU7XG59KSk7XG4iLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3RhY2stZ2VuZXJhdG9yJywgWydzdGFja2ZyYW1lJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdzdGFja2ZyYW1lJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuU3RhY2tHZW5lcmF0b3IgPSBmYWN0b3J5KHJvb3QuU3RhY2tGcmFtZSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoU3RhY2tGcmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhY2t0cmFjZTogZnVuY3Rpb24gU3RhY2tHZW5lcmF0b3IkJGJhY2t0cmFjZShvcHRzKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICAgICAgICAgIHZhciBtYXhTdGFja1NpemUgPSAxMDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3B0cy5tYXhTdGFja1NpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgbWF4U3RhY2tTaXplID0gb3B0cy5tYXhTdGFja1NpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJyID0gYXJndW1lbnRzLmNhbGxlZTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyICYmIHN0YWNrLmxlbmd0aCA8IG1heFN0YWNrU2l6ZSkge1xuICAgICAgICAgICAgICAgIC8vIEFsbG93IFY4IG9wdGltaXphdGlvbnNcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShjdXJyWydhcmd1bWVudHMnXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBjdXJyWydhcmd1bWVudHMnXVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9mdW5jdGlvbig/OlxccysoW1xcdyRdKykpK1xccypcXCgvLnRlc3QoY3Vyci50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5ldyBTdGFja0ZyYW1lKHtmdW5jdGlvbk5hbWU6IFJlZ0V4cC4kMSB8fCB1bmRlZmluZWQsIGFyZ3M6IGFyZ3N9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChuZXcgU3RhY2tGcmFtZSh7YXJnczogYXJnc30pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3Vyci5jYWxsZXI7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgIH1cbiAgICB9O1xufSkpO1xuIiwiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ3N0YWNrZnJhbWUnLCBbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5TdGFja0ZyYW1lID0gZmFjdG9yeSgpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBmdW5jdGlvbiBfaXNOdW1iZXIobikge1xuICAgICAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFN0YWNrRnJhbWUoZnVuY3Rpb25OYW1lLCBhcmdzLCBmaWxlTmFtZSwgbGluZU51bWJlciwgY29sdW1uTnVtYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTmFtZShmdW5jdGlvbk5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXJncyhhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsZU5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRGaWxlTmFtZShmaWxlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVOdW1iZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRMaW5lTnVtYmVyKGxpbmVOdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2x1bW5OdW1iZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb2x1bW5OdW1iZXIoY29sdW1uTnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZSA9IHtcbiAgICAgICAgZ2V0RnVuY3Rpb25OYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbk5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEZ1bmN0aW9uTmFtZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25OYW1lID0gU3RyaW5nKHYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEFyZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEFyZ3M6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJncyBtdXN0IGJlIGFuIEFycmF5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSB2O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE5PVEU6IFByb3BlcnR5IG5hbWUgbWF5IGJlIG1pc2xlYWRpbmcgYXMgaXQgaW5jbHVkZXMgdGhlIHBhdGgsXG4gICAgICAgIC8vIGJ1dCBpdCBzb21ld2hhdCBtaXJyb3JzIFY4J3MgSmF2YVNjcmlwdFN0YWNrVHJhY2VBcGlcbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC93aWtpL0phdmFTY3JpcHRTdGFja1RyYWNlQXBpIGFuZCBHZWNrbydzXG4gICAgICAgIC8vIGh0dHA6Ly9teHIubW96aWxsYS5vcmcvbW96aWxsYS1jZW50cmFsL3NvdXJjZS94cGNvbS9iYXNlL25zSUV4Y2VwdGlvbi5pZGwjMTRcbiAgICAgICAgZ2V0RmlsZU5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXRGaWxlTmFtZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZU5hbWUgPSBTdHJpbmcodik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGluZU51bWJlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluZU51bWJlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TGluZU51bWJlcjogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICghX2lzTnVtYmVyKHYpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTGluZSBOdW1iZXIgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saW5lTnVtYmVyID0gTnVtYmVyKHYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldENvbHVtbk51bWJlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uTnVtYmVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXRDb2x1bW5OdW1iZXI6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAoIV9pc051bWJlcih2KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbHVtbiBOdW1iZXIgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb2x1bW5OdW1iZXIgPSBOdW1iZXIodik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U291cmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFNvdXJjZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gU3RyaW5nKHYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSB0aGlzLmdldEZ1bmN0aW9uTmFtZSgpIHx8ICd7YW5vbnltb3VzfSc7XG4gICAgICAgICAgICB2YXIgYXJncyA9ICcoJyArICh0aGlzLmdldEFyZ3MoKSB8fCBbXSkuam9pbignLCcpICsgJyknO1xuICAgICAgICAgICAgdmFyIGZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZSgpID8gKCdAJyArIHRoaXMuZ2V0RmlsZU5hbWUoKSkgOiAnJztcbiAgICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gX2lzTnVtYmVyKHRoaXMuZ2V0TGluZU51bWJlcigpKSA/ICgnOicgKyB0aGlzLmdldExpbmVOdW1iZXIoKSkgOiAnJztcbiAgICAgICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBfaXNOdW1iZXIodGhpcy5nZXRDb2x1bW5OdW1iZXIoKSkgPyAoJzonICsgdGhpcy5nZXRDb2x1bW5OdW1iZXIoKSkgOiAnJztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbk5hbWUgKyBhcmdzICsgZmlsZU5hbWUgKyBsaW5lTnVtYmVyICsgY29sdW1uTnVtYmVyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBTdGFja0ZyYW1lO1xufSkpO1xuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3RhY2t0cmFjZS1ncHMnLCBbJ3NvdXJjZS1tYXAnLCAnc3RhY2tmcmFtZSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLCByZXF1aXJlKCdzdGFja2ZyYW1lJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuU3RhY2tUcmFjZUdQUyA9IGZhY3Rvcnkocm9vdC5Tb3VyY2VNYXAgfHwgcm9vdC5zb3VyY2VNYXAsIHJvb3QuU3RhY2tGcmFtZSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbihTb3VyY2VNYXAsIFN0YWNrRnJhbWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGEgWC1Eb21haW4gcmVxdWVzdCB0byB1cmwgYW5kIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSB3aXRoIHJlc3BvbnNlIHRleHQgaWYgZnVsZmlsbGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3hkcih1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgcmVxLm9wZW4oJ2dldCcsIHVybCk7XG4gICAgICAgICAgICByZXEub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBvbnJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID49IDIwMCAmJiByZXEuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignSFRUUCBzdGF0dXM6ICcgKyByZXEuc3RhdHVzICsgJyByZXRyaWV2aW5nICcgKyB1cmwpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXEuc2VuZCgpO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBCYXNlNjQtZW5jb2RlZCBzdHJpbmcgaW50byBpdHMgb3JpZ2luYWwgcmVwcmVzZW50YXRpb24uXG4gICAgICogVXNlZCBmb3IgaW5saW5lIHNvdXJjZW1hcHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYjY0c3RyIEJhc2UtNjQgZW5jb2RlZCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBvcmlnaW5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9hdG9iKGI2NHN0cikge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmF0b2IpIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuYXRvYihiNjRzdHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzdXBwbHkgYSBwb2x5ZmlsbCBmb3Igd2luZG93LmF0b2IgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3BhcnNlSnNvbihzdHJpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJyAmJiBKU09OLnBhcnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzdXBwbHkgYSBwb2x5ZmlsbCBmb3IgSlNPTi5wYXJzZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZmluZEZ1bmN0aW9uTmFtZShzb3VyY2UsIGxpbmVOdW1iZXIvKiwgY29sdW1uTnVtYmVyKi8pIHtcbiAgICAgICAgLy8gZnVuY3Rpb24ge25hbWV9KHthcmdzfSkgbVsxXT1uYW1lIG1bMl09YXJnc1xuICAgICAgICB2YXIgcmVGdW5jdGlvbkRlY2xhcmF0aW9uID0gL2Z1bmN0aW9uXFxzKyhbXihdKj8pXFxzKlxcKChbXildKilcXCkvO1xuICAgICAgICAvLyB7bmFtZX0gPSBmdW5jdGlvbiAoe2FyZ3N9KSBUT0RPIGFyZ3MgY2FwdHVyZVxuICAgICAgICB2YXIgcmVGdW5jdGlvbkV4cHJlc3Npb24gPSAvWydcIl0/KFskX0EtWmEtel1bJF9BLVphLXowLTldKilbJ1wiXT9cXHMqWzo9XVxccypmdW5jdGlvblxcYi87XG4gICAgICAgIC8vIHtuYW1lfSA9IGV2YWwoKVxuICAgICAgICB2YXIgcmVGdW5jdGlvbkV2YWx1YXRpb24gPSAvWydcIl0/KFskX0EtWmEtel1bJF9BLVphLXowLTldKilbJ1wiXT9cXHMqWzo9XVxccyooPzpldmFsfG5ldyBGdW5jdGlvbilcXGIvO1xuICAgICAgICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIC8vIFdhbGsgYmFja3dhcmRzIGluIHRoZSBzb3VyY2UgbGluZXMgdW50aWwgd2UgZmluZCB0aGUgbGluZSB3aGljaCBtYXRjaGVzIG9uZSBvZiB0aGUgcGF0dGVybnMgYWJvdmVcbiAgICAgICAgdmFyIGNvZGUgPSAnJztcbiAgICAgICAgdmFyIG1heExpbmVzID0gTWF0aC5taW4obGluZU51bWJlciwgMjApO1xuICAgICAgICB2YXIgbTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhMaW5lczsgKytpKSB7XG4gICAgICAgICAgICAvLyBsaW5lTm8gaXMgMS1iYXNlZCwgc291cmNlW10gaXMgMC1iYXNlZFxuICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsaW5lTnVtYmVyIC0gaSAtIDFdO1xuICAgICAgICAgICAgdmFyIGNvbW1lbnRQb3MgPSBsaW5lLmluZGV4T2YoJy8vJyk7XG4gICAgICAgICAgICBpZiAoY29tbWVudFBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGNvbW1lbnRQb3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBsaW5lICsgY29kZTtcbiAgICAgICAgICAgICAgICBtID0gcmVGdW5jdGlvbkV4cHJlc3Npb24uZXhlYyhjb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtID0gcmVGdW5jdGlvbkRlY2xhcmF0aW9uLmV4ZWMoY29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG0gJiYgbVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbSA9IHJlRnVuY3Rpb25FdmFsdWF0aW9uLmV4ZWMoY29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG0gJiYgbVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZW5zdXJlU3VwcG9ydGVkRW52aXJvbm1lbnQoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjb25zdW1lIHNvdXJjZSBtYXBzIGluIG9sZGVyIGJyb3dzZXJzJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZW5zdXJlU3RhY2tGcmFtZUlzTGVnaXQoc3RhY2tmcmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0YWNrZnJhbWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHaXZlbiBTdGFja0ZyYW1lIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhY2tmcmFtZS5maWxlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dpdmVuIGZpbGUgbmFtZSBpcyBub3QgYSBTdHJpbmcnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhY2tmcmFtZS5saW5lTnVtYmVyICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgc3RhY2tmcmFtZS5saW5lTnVtYmVyICUgMSAhPT0gMCB8fFxuICAgICAgICAgICAgc3RhY2tmcmFtZS5saW5lTnVtYmVyIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR2l2ZW4gbGluZSBudW1iZXIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RhY2tmcmFtZS5jb2x1bW5OdW1iZXIgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBzdGFja2ZyYW1lLmNvbHVtbk51bWJlciAlIDEgIT09IDAgfHxcbiAgICAgICAgICAgIHN0YWNrZnJhbWUuY29sdW1uTnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR2l2ZW4gY29sdW1uIG51bWJlciBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZmluZFNvdXJjZU1hcHBpbmdVUkwoc291cmNlKSB7XG4gICAgICAgIHZhciBtID0gL1xcL1xcL1sjQF0gP3NvdXJjZU1hcHBpbmdVUkw9KFteXFxzJ1wiXSspXFxzKiQvLmV4ZWMoc291cmNlKTtcbiAgICAgICAgaWYgKG0gJiYgbVsxXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1bMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZU1hcHBpbmdVUkwgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZXh0cmFjdExvY2F0aW9uSW5mb0Zyb21Tb3VyY2VNYXAoc3RhY2tmcmFtZSwgcmF3U291cmNlTWFwLCBzb3VyY2VDYWNoZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgbWFwQ29uc3VtZXIgPSBuZXcgU291cmNlTWFwLlNvdXJjZU1hcENvbnN1bWVyKHJhd1NvdXJjZU1hcCk7XG5cbiAgICAgICAgICAgIHZhciBsb2MgPSBtYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICAgICAgICBsaW5lOiBzdGFja2ZyYW1lLmxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGFja2ZyYW1lLmNvbHVtbk51bWJlclxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChsb2Muc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcHBlZFNvdXJjZSA9IG1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IobG9jLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZFNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VDYWNoZVtsb2Muc291cmNlXSA9IG1hcHBlZFNvdXJjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgICAgICAgICAgbmV3IFN0YWNrRnJhbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MubmFtZSB8fCBzdGFja2ZyYW1lLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrZnJhbWUuYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5jb2x1bW4pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ291bGQgbm90IGdldCBvcmlnaW5hbCBzb3VyY2UgZm9yIGdpdmVuIHN0YWNrZnJhbWUgYW5kIHNvdXJjZSBtYXAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogICAgICBvcHRzLnNvdXJjZUNhY2hlID0ge3VybDogXCJTb3VyY2UgU3RyaW5nXCJ9ID0+IHByZWxvYWQgc291cmNlIGNhY2hlXG4gICAgICogICAgICBvcHRzLm9mZmxpbmUgPSBUcnVlIHRvIHByZXZlbnQgbmV0d29yayByZXF1ZXN0cy5cbiAgICAgKiAgICAgICAgICAgICAgQmVzdCBlZmZvcnQgd2l0aG91dCBzb3VyY2VzIG9yIHNvdXJjZSBtYXBzLlxuICAgICAqICAgICAgb3B0cy5hamF4ID0gUHJvbWlzZSByZXR1cm5pbmcgZnVuY3Rpb24gdG8gbWFrZSBYLURvbWFpbiByZXF1ZXN0c1xuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBTdGFja1RyYWNlR1BTKG9wdHMpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0YWNrVHJhY2VHUFMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrVHJhY2VHUFMob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAgICAgdGhpcy5zb3VyY2VDYWNoZSA9IG9wdHMuc291cmNlQ2FjaGUgfHwge307XG5cbiAgICAgICAgdGhpcy5hamF4ID0gb3B0cy5hamF4IHx8IF94ZHI7XG5cbiAgICAgICAgdGhpcy5fYXRvYiA9IG9wdHMuYXRvYiB8fCBfYXRvYjtcblxuICAgICAgICB0aGlzLl9nZXQgPSBmdW5jdGlvbiBfZ2V0KGxvY2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRGF0YVVybCA9IGxvY2F0aW9uLnN1YnN0cigwLCA1KSA9PT0gJ2RhdGE6JztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VDYWNoZVtsb2NhdGlvbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnNvdXJjZUNhY2hlW2xvY2F0aW9uXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRzLm9mZmxpbmUgJiYgIWlzRGF0YVVybCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDYW5ub3QgbWFrZSBuZXR3b3JrIHJlcXVlc3RzIGluIG9mZmxpbmUgbW9kZScpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEYXRhVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhIFVSTHMgY2FuIGhhdmUgcGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMzk3XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VwcG9ydGVkRW5jb2RpbmdSZWdleHAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247KFtcXHc9OlwiLV0rOykqYmFzZTY0LC87XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsb2NhdGlvbi5tYXRjaChzdXBwb3J0ZWRFbmNvZGluZ1JlZ2V4cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlTWFwU3RhcnQgPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuY29kZWRTb3VyY2UgPSBsb2NhdGlvbi5zdWJzdHIoc291cmNlTWFwU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLl9hdG9iKGVuY29kZWRTb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlQ2FjaGVbbG9jYXRpb25dID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGhlIGVuY29kaW5nIG9mIHRoZSBpbmxpbmUgc291cmNlbWFwIGlzIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeGhyUHJvbWlzZSA9IHRoaXMuYWpheChsb2NhdGlvbiwge21ldGhvZDogJ2dldCd9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSBQcm9taXNlIHRvIHByZXZlbnQgZHVwbGljYXRlIGluLWZsaWdodCByZXF1ZXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VDYWNoZVtsb2NhdGlvbl0gPSB4aHJQcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIFN0YWNrRnJhbWUsIGVuaGFuY2UgZnVuY3Rpb24gbmFtZSBhbmQgdXNlIHNvdXJjZSBtYXBzIGZvciBhXG4gICAgICAgICAqIGJldHRlciBTdGFja0ZyYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0YWNrRnJhbWV9IHN0YWNrZnJhbWUgb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHJlc29sdmVzIHdpdGggd2l0aCBzb3VyY2UtbWFwcGVkIFN0YWNrRnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGlucG9pbnQgPSBmdW5jdGlvbiBTdGFja1RyYWNlR1BTJCRwaW5wb2ludChzdGFja2ZyYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRNYXBwZWRMb2NhdGlvbihzdGFja2ZyYW1lKS50aGVuKGZ1bmN0aW9uKG1hcHBlZFN0YWNrRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZU1hcHBlZFN0YWNrRnJhbWUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1hcHBlZFN0YWNrRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kRnVuY3Rpb25OYW1lKG1hcHBlZFN0YWNrRnJhbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlLCByZXNvbHZlTWFwcGVkU3RhY2tGcmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIFsnY2F0Y2gnXShyZXNvbHZlTWFwcGVkU3RhY2tGcmFtZSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCByZWplY3QpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBTdGFja0ZyYW1lLCBndWVzcyBmdW5jdGlvbiBuYW1lIGZyb20gbG9jYXRpb24gaW5mb3JtYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RhY2tGcmFtZX0gc3RhY2tmcmFtZVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyB3aXRoIGVuaGFuY2VkIFN0YWNrRnJhbWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbmRGdW5jdGlvbk5hbWUgPSBmdW5jdGlvbiBTdGFja1RyYWNlR1BTJCRmaW5kRnVuY3Rpb25OYW1lKHN0YWNrZnJhbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBfZW5zdXJlU3RhY2tGcmFtZUlzTGVnaXQoc3RhY2tmcmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0KHN0YWNrZnJhbWUuZmlsZU5hbWUpLnRoZW4oZnVuY3Rpb24gZ2V0U291cmNlQ2FsbGJhY2soc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gc3RhY2tmcmFtZS5saW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sdW1uTnVtYmVyID0gc3RhY2tmcmFtZS5jb2x1bW5OdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBndWVzc2VkRnVuY3Rpb25OYW1lID0gX2ZpbmRGdW5jdGlvbk5hbWUoc291cmNlLCBsaW5lTnVtYmVyLCBjb2x1bW5OdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJlcGxhY2UgZnVuY3Rpb25OYW1lIGlmIHdlIGZvdW5kIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3Vlc3NlZEZ1bmN0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgU3RhY2tGcmFtZShndWVzc2VkRnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrZnJhbWUuYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFja2ZyYW1lLmZpbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0YWNrZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KVsnY2F0Y2gnXShyZWplY3QpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBTdGFja0ZyYW1lLCBzZWVrIHNvdXJjZS1tYXBwZWQgbG9jYXRpb24gYW5kIHJldHVybiBuZXcgZW5oYW5jZWQgU3RhY2tGcmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdGFja0ZyYW1lfSBzdGFja2ZyYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHJlc29sdmVzIHdpdGggZW5oYW5jZWQgU3RhY2tGcmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0TWFwcGVkTG9jYXRpb24gPSBmdW5jdGlvbiBTdGFja1RyYWNlR1BTJCRnZXRNYXBwZWRMb2NhdGlvbihzdGFja2ZyYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgX2Vuc3VyZVN1cHBvcnRlZEVudmlyb25tZW50KCk7XG4gICAgICAgICAgICAgICAgX2Vuc3VyZVN0YWNrRnJhbWVJc0xlZ2l0KHN0YWNrZnJhbWUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZUNhY2hlID0gdGhpcy5zb3VyY2VDYWNoZTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBzdGFja2ZyYW1lLmZpbGVOYW1lO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldChmaWxlTmFtZSkudGhlbihmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmdVUkwgPSBfZmluZFNvdXJjZU1hcHBpbmdVUkwoc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzRGF0YVVybCA9IHNvdXJjZU1hcHBpbmdVUkwuc3Vic3RyKDAsIDUpID09PSAnZGF0YTonO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IGZpbGVOYW1lLnN1YnN0cmluZygwLCBmaWxlTmFtZS5sYXN0SW5kZXhPZignLycpICsgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZU1hcHBpbmdVUkxbMF0gIT09ICcvJyAmJiAhaXNEYXRhVXJsICYmICEoL15odHRwcz86XFwvXFwvfF5cXC9cXC8vaSkudGVzdChzb3VyY2VNYXBwaW5nVVJMKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwcGluZ1VSTCA9IGJhc2UgKyBzb3VyY2VNYXBwaW5nVVJMO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0KHNvdXJjZU1hcHBpbmdVUkwpLnRoZW4oZnVuY3Rpb24oc291cmNlTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXAgPSBfcGFyc2VKc29uKHNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZU1hcC5zb3VyY2VSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU1hcC5zb3VyY2VSb290ID0gYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgX2V4dHJhY3RMb2NhdGlvbkluZm9Gcm9tU291cmNlTWFwKHN0YWNrZnJhbWUsIHNvdXJjZU1hcCwgc291cmNlQ2FjaGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlbJ2NhdGNoJ10oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGFja2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCByZWplY3QpWydjYXRjaCddKHJlamVjdCk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCByZWplY3QpWydjYXRjaCddKHJlamVjdCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9O1xuICAgIH07XG59KSk7XG4iLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdzdGFja3RyYWNlJywgWydlcnJvci1zdGFjay1wYXJzZXInLCAnc3RhY2stZ2VuZXJhdG9yJywgJ3N0YWNrdHJhY2UtZ3BzJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdlcnJvci1zdGFjay1wYXJzZXInKSwgcmVxdWlyZSgnc3RhY2stZ2VuZXJhdG9yJyksIHJlcXVpcmUoJ3N0YWNrdHJhY2UtZ3BzJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuU3RhY2tUcmFjZSA9IGZhY3Rvcnkocm9vdC5FcnJvclN0YWNrUGFyc2VyLCByb290LlN0YWNrR2VuZXJhdG9yLCByb290LlN0YWNrVHJhY2VHUFMpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gU3RhY2tUcmFjZShFcnJvclN0YWNrUGFyc2VyLCBTdGFja0dlbmVyYXRvciwgU3RhY2tUcmFjZUdQUykge1xuICAgIHZhciBfb3B0aW9ucyA9IHtcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbihzdGFja2ZyYW1lKSB7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IHN0YWNrZnJhbWVzIGZvciB0aGlzIGxpYnJhcnkgYnkgZGVmYXVsdFxuICAgICAgICAgICAgcmV0dXJuIChzdGFja2ZyYW1lLmZ1bmN0aW9uTmFtZSB8fCAnJykuaW5kZXhPZignU3RhY2tUcmFjZSQkJykgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgKHN0YWNrZnJhbWUuZnVuY3Rpb25OYW1lIHx8ICcnKS5pbmRleE9mKCdFcnJvclN0YWNrUGFyc2VyJCQnKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAoc3RhY2tmcmFtZS5mdW5jdGlvbk5hbWUgfHwgJycpLmluZGV4T2YoJ1N0YWNrVHJhY2VHUFMkJCcpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIChzdGFja2ZyYW1lLmZ1bmN0aW9uTmFtZSB8fCAnJykuaW5kZXhPZignU3RhY2tHZW5lcmF0b3IkJCcpID09PSAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlQ2FjaGU6IHt9XG4gICAgfTtcblxuICAgIHZhciBfZ2VuZXJhdGVFcnJvciA9IGZ1bmN0aW9uIFN0YWNrVHJhY2UkJEdlbmVyYXRlRXJyb3IoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBFcnJvciBtdXN0IGJlIHRocm93biB0byBnZXQgc3RhY2sgaW4gSUVcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWVyZ2UgMiBnaXZlbiBPYmplY3RzLiBJZiBhIGNvbmZsaWN0IG9jY3VycyB0aGUgc2Vjb25kIG9iamVjdCB3aW5zLlxuICAgICAqIERvZXMgbm90IGRvIGRlZXAgbWVyZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpcnN0IGJhc2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNlY29uZCBvdmVycmlkZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBtZXJnZWQgZmlyc3QgYW5kIHNlY29uZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gX21lcmdlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHt9O1xuXG4gICAgICAgIFtmaXJzdCwgc2Vjb25kXS5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9pc1NoYXBlZExpa2VQYXJzYWJsZUVycm9yKGVycikge1xuICAgICAgICByZXR1cm4gZXJyLnN0YWNrIHx8IGVyclsnb3BlcmEjc291cmNlbG9jJ107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ZpbHRlcmVkKHN0YWNrZnJhbWVzLCBmaWx0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2ZyYW1lcy5maWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhY2tmcmFtZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIGJhY2t0cmFjZSBmcm9tIGludm9jYXRpb24gcG9pbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gb2YgU3RhY2tGcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBTdGFja1RyYWNlJCRnZXQob3B0cykge1xuICAgICAgICAgICAgdmFyIGVyciA9IF9nZW5lcmF0ZUVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm4gX2lzU2hhcGVkTGlrZVBhcnNhYmxlRXJyb3IoZXJyKSA/IHRoaXMuZnJvbUVycm9yKGVyciwgb3B0cykgOiB0aGlzLmdlbmVyYXRlQXJ0aWZpY2lhbGx5KG9wdHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBiYWNrdHJhY2UgZnJvbSBpbnZvY2F0aW9uIHBvaW50LlxuICAgICAgICAgKiBJTVBPUlRBTlQ6IERvZXMgbm90IGhhbmRsZSBzb3VyY2UgbWFwcyBvciBndWVzcyBmdW5jdGlvbiBuYW1lcyFcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSBvZiBTdGFja0ZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTeW5jOiBmdW5jdGlvbiBTdGFja1RyYWNlJCRnZXRTeW5jKG9wdHMpIHtcbiAgICAgICAgICAgIG9wdHMgPSBfbWVyZ2UoX29wdGlvbnMsIG9wdHMpO1xuICAgICAgICAgICAgdmFyIGVyciA9IF9nZW5lcmF0ZUVycm9yKCk7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBfaXNTaGFwZWRMaWtlUGFyc2FibGVFcnJvcihlcnIpID8gRXJyb3JTdGFja1BhcnNlci5wYXJzZShlcnIpIDogU3RhY2tHZW5lcmF0b3IuYmFja3RyYWNlKG9wdHMpO1xuICAgICAgICAgICAgcmV0dXJuIF9maWx0ZXJlZChzdGFjaywgb3B0cy5maWx0ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhbiBlcnJvciBvYmplY3QsIHBhcnNlIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IGZvciBBcnJheVtTdGFja0ZyYW1lfVxuICAgICAgICAgKi9cbiAgICAgICAgZnJvbUVycm9yOiBmdW5jdGlvbiBTdGFja1RyYWNlJCRmcm9tRXJyb3IoZXJyb3IsIG9wdHMpIHtcbiAgICAgICAgICAgIG9wdHMgPSBfbWVyZ2UoX29wdGlvbnMsIG9wdHMpO1xuICAgICAgICAgICAgdmFyIGdwcyA9IG5ldyBTdGFja1RyYWNlR1BTKG9wdHMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tmcmFtZXMgPSBfZmlsdGVyZWQoRXJyb3JTdGFja1BhcnNlci5wYXJzZShlcnJvciksIG9wdHMuZmlsdGVyKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFByb21pc2UuYWxsKHN0YWNrZnJhbWVzLm1hcChmdW5jdGlvbihzZikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZU9yaWdpbmFsKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBncHMucGlucG9pbnQoc2YpLnRoZW4ocmVzb2x2ZSwgcmVzb2x2ZU9yaWdpbmFsKVsnY2F0Y2gnXShyZXNvbHZlT3JpZ2luYWwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIFN0YWNrR2VuZXJhdG9yIHRvIGdlbmVyYXRlIGEgYmFja3RyYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gb2YgQXJyYXlbU3RhY2tGcmFtZV1cbiAgICAgICAgICovXG4gICAgICAgIGdlbmVyYXRlQXJ0aWZpY2lhbGx5OiBmdW5jdGlvbiBTdGFja1RyYWNlJCRnZW5lcmF0ZUFydGlmaWNpYWxseShvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gX21lcmdlKF9vcHRpb25zLCBvcHRzKTtcbiAgICAgICAgICAgIHZhciBzdGFja0ZyYW1lcyA9IFN0YWNrR2VuZXJhdG9yLmJhY2t0cmFjZShvcHRzKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5maWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzdGFja0ZyYW1lcyA9IHN0YWNrRnJhbWVzLmZpbHRlcihvcHRzLmZpbHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN0YWNrRnJhbWVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBmdW5jdGlvbiwgd3JhcCBpdCBzdWNoIHRoYXQgaW52b2NhdGlvbnMgdHJpZ2dlciBhIGNhbGxiYWNrIHRoYXRcbiAgICAgICAgICogaXMgY2FsbGVkIHdpdGggYSBzdGFjayB0cmFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdG8gYmUgaW5zdHJ1bWVudGVkXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBhIHN0YWNrIHRyYWNlIG9uIGludm9jYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyYmFjayBvcHRpb25hbCBmdW5jdGlvbiB0byBjYWxsIHdpdGggZXJyb3IgaWYgdW5hYmxlIHRvIGdldCBzdGFjayB0cmFjZS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgb3B0aW9uYWwgY29udGV4dCBvYmplY3QgKGUuZy4gd2luZG93KVxuICAgICAgICAgKi9cbiAgICAgICAgaW5zdHJ1bWVudDogZnVuY3Rpb24gU3RhY2tUcmFjZSQkaW5zdHJ1bWVudChmbiwgY2FsbGJhY2ssIGVycmJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbnN0cnVtZW50IG5vbi1mdW5jdGlvbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZuLl9fc3RhY2t0cmFjZU9yaWdpbmFsRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGluc3RydW1lbnRlZCwgcmV0dXJuIGdpdmVuIEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5zdHJ1bWVudGVkID0gZnVuY3Rpb24gU3RhY2tUcmFjZSQkaW5zdHJ1bWVudGVkKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0KCkudGhlbihjYWxsYmFjaywgZXJyYmFjaylbJ2NhdGNoJ10oZXJyYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnIHx8IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzU2hhcGVkTGlrZVBhcnNhYmxlRXJyb3IoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbUVycm9yKGUpLnRoZW4oY2FsbGJhY2ssIGVycmJhY2spWydjYXRjaCddKGVycmJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgaW5zdHJ1bWVudGVkLl9fc3RhY2t0cmFjZU9yaWdpbmFsRm4gPSBmbjtcblxuICAgICAgICAgICAgcmV0dXJuIGluc3RydW1lbnRlZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBmdW5jdGlvbiB0aGF0IGhhcyBiZWVuIGluc3RydW1lbnRlZCxcbiAgICAgICAgICogcmV2ZXJ0IHRoZSBmdW5jdGlvbiB0byBpdCdzIG9yaWdpbmFsIChub24taW5zdHJ1bWVudGVkKSBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gdG8gZGUtaW5zdHJ1bWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZGVpbnN0cnVtZW50OiBmdW5jdGlvbiBTdGFja1RyYWNlJCRkZWluc3RydW1lbnQoZm4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZS1pbnN0cnVtZW50IG5vbi1mdW5jdGlvbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZuLl9fc3RhY2t0cmFjZU9yaWdpbmFsRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uX19zdGFja3RyYWNlT3JpZ2luYWxGbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gbm90IGluc3RydW1lbnRlZCwgcmV0dXJuIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhbiBlcnJvciBtZXNzYWdlIGFuZCBBcnJheSBvZiBTdGFja0ZyYW1lcywgc2VyaWFsaXplIGFuZCBQT1NUIHRvIGdpdmVuIFVSTC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gc3RhY2tmcmFtZXNcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXJyb3JNc2dcbiAgICAgICAgICovXG4gICAgICAgIHJlcG9ydDogZnVuY3Rpb24gU3RhY2tUcmFjZSQkcmVwb3J0KHN0YWNrZnJhbWVzLCB1cmwsIGVycm9yTXNnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBvbnJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPj0gMjAwICYmIHJlcS5zdGF0dXMgPCA0MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdQT1NUIHRvICcgKyB1cmwgKyAnIGZhaWxlZCB3aXRoIHN0YXR1czogJyArIHJlcS5zdGF0dXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxLm9wZW4oJ3Bvc3QnLCB1cmwpO1xuICAgICAgICAgICAgICAgIHJlcS5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlcG9ydFBheWxvYWQgPSB7c3RhY2s6IHN0YWNrZnJhbWVzfTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JNc2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXBvcnRQYXlsb2FkLm1lc3NhZ2UgPSBlcnJvck1zZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXEuc2VuZChKU09OLnN0cmluZ2lmeShyZXBvcnRQYXlsb2FkKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KSk7XG4iLCJpbXBvcnQgQWN0aW9uIGZyb20gXCIuLi9kb21haW4vQWN0aW9uXCI7XG5pbXBvcnQgQWlmZXhTZXJ2aWNlIGZyb20gXCIuLi9kb21haW4vQWlmZXhTZXJ2aWNlXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2RvbWFpbi9Ub2tlblwiO1xuaW1wb3J0IFdlYlNpdGUgZnJvbSBcIi4uL2RvbWFpbi9XZWJzaXRlXCI7XG5pbXBvcnQgU2Vzc2lvbiBmcm9tIFwiLi4vZG9tYWluL1Nlc3Npb25cIjtcbmltcG9ydCBBaWZleFBsdWdpbkluZm8gZnJvbSBcIi4uL2RvbWFpbi9BaWZleFBsdWdpbkluZm9cIjtcbmNvbnN0IE9LX1NUQVRVUyA9IDIwMDtcbmNvbnN0IElOVkFMSURfUEFSQU1FVEVSU19TVEFUVVMgPSA0MDA7XG5jb25zdCBGT1JCSURERU5fU1RBVFVTID0gNDAzO1xuY29uc3QgTk9UX0ZPVU5EX1NUQVRVUyA9IDQwNDtcbmNvbnN0IElOVEVSTkFMX1NFUlZFUl9FUlJPUl9TVEFUVVMgPSA1MDA7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBaWZleFNlcnZpY2VIVFRQIGltcGxlbWVudHMgQWlmZXhTZXJ2aWNlIHtcblxuXHRwaW5nKHNlcnZlclVSTDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0cmV0dXJuIGZldGNoKGAke3NlcnZlclVSTH0vYXBpL3BpbmdgLCB7XG5cdFx0XHRtZXRob2Q6IFwiR0VUXCIsXG5cdFx0XHRoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG5cdFx0fSlcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblx0XHRcdFx0Y29uc29sZS5sb2cocmVzcG9uc2UpO1xuXHRcdFx0XHRpZiAocmVzcG9uc2Uub2spIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnb2snKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ2Vycm9yJyk7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHR9XG5cblx0Z2V0UGx1Z2luSW5mbyhzZXJ2ZXJVUkw6IHN0cmluZyk6IFByb21pc2U8QWlmZXhQbHVnaW5JbmZvPiB7XG5cdFx0Y29uc3Qgb3B0aW9uID0ge1xuXHRcdFx0bWV0aG9kOiBcIkdFVFwiLFxuXHRcdFx0aGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuXHRcdH07XG5cdFx0cmV0dXJuIGZldGNoKGAke3NlcnZlclVSTH0vYXBpL3BsdWdpbi1pbmZvYCwgb3B0aW9uKVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4ge1xuXHRcdFx0XHRpZiAoIXJlc3BvbnNlLm9rKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXNwb25zZS5qc29uKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oZGV0YWlscyA9PiB7XG5cdFx0XHRcdGRldGFpbHMudXJsID0gYCR7c2VydmVyVVJMfS9kb3dubG9hZGBcblx0XHRcdFx0cmV0dXJuIG5ldyBBaWZleFBsdWdpbkluZm8oZGV0YWlscy52ZXJzaW9uLCBkZXRhaWxzLm5hbWUsIGRldGFpbHMuZGVzY3JpcHRpb24sIGRldGFpbHMudXJsKTtcblx0XHRcdH0pXG5cdH1cblxuXHRnZXRTZXNzaW9uKHNlcnZlclVSTDogc3RyaW5nLCBzZXNzaW9uSWQ6IHN0cmluZywgdG9rZW46IFRva2VuIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxTZXNzaW9uIHwgdW5kZWZpbmVkIHwgXCJVbmF1dGhvcml6ZWRcIj4ge1xuXHRcdGNvbnN0IFNFU1NJT05fVVJMID0gc2VydmVyVVJMICsgJy9hcGkvc2Vzc2lvbnMvJyArIHNlc3Npb25JZDtcblx0XHRyZXR1cm4gZmV0Y2goU0VTU0lPTl9VUkwsIHtcblx0XHRcdG1ldGhvZDogJ0dFVCcsXG5cdFx0XHRoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7dG9rZW4/LnRva2VufWAgfSxcblx0XHR9KVxuXHRcdFx0LnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IE9LX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiByZXNwb25zZVxuXHRcdFx0XHRcdFx0Lmpzb24oKVxuXHRcdFx0XHRcdFx0LnRoZW4oKHNlc3Npb246IHtcblx0XHRcdFx0XHRcdFx0aWQ6IHN0cmluZyxcblx0XHRcdFx0XHRcdFx0d2ViU2l0ZTogeyBpZDogc3RyaW5nIH0sXG5cdFx0XHRcdFx0XHRcdGJhc2VVUkw6IHN0cmluZyxcblx0XHRcdFx0XHRcdFx0bmFtZTogc3RyaW5nLFxuXHRcdFx0XHRcdFx0XHRkZXNjcmlwdGlvbjogc3RyaW5nLFxuXHRcdFx0XHRcdFx0XHRvdmVybGF5VHlwZTogXCJyYWluYm93XCIgfCBcImJsdWVza3lcIiB8IFwic2hhZG93XCIsXG5cdFx0XHRcdFx0XHRcdHJlY29yZGluZ01vZGU6IFwiYnlleHBsb3JhdGlvblwiIHwgXCJieWludGVyYWN0aW9uXCJcblxuXHRcdFx0XHRcdFx0fSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFNlc3Npb24oc2Vzc2lvbi5pZCwgc2Vzc2lvbi53ZWJTaXRlLmlkLCBzZXNzaW9uLmJhc2VVUkwsIHNlc3Npb24ubmFtZSwgc2Vzc2lvbi5kZXNjcmlwdGlvbiwgc2Vzc2lvbi5vdmVybGF5VHlwZSwgc2Vzc2lvbi5yZWNvcmRpbmdNb2RlKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IElOVkFMSURfUEFSQU1FVEVSU19TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IE5PVF9GT1VORF9TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IEZPUkJJRERFTl9TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gXCJVbmF1dGhvcml6ZWRcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBJTlRFUk5BTF9TRVJWRVJfRVJST1JfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGBzZXJ2ZXIgZXJyb3JgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0fVxuXG5cdGdldFdlYlNpdGUoc2VydmVyVVJMOiBzdHJpbmcsIHdlYlNpdGVJZDogc3RyaW5nLCB0b2tlbjogVG9rZW4gfCB1bmRlZmluZWQpOiBQcm9taXNlPFdlYlNpdGUgfCB1bmRlZmluZWQgfCBcIlVuYXV0aG9yaXplZFwiPiB7XG5cdFx0cmV0dXJuIGZldGNoKGAke3NlcnZlclVSTH0vYXBpL3dlYnNpdGVzLyR7d2ViU2l0ZUlkfWAsIHtcblx0XHRcdG1ldGhvZDogJ0dFVCcsXG5cdFx0XHRoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsIFwiQXV0aG9yaXphdGlvblwiOiBgQmVhcmVyICR7dG9rZW4/LnRva2VufWAgfSxcblx0XHR9KVxuXHRcdFx0LnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IE9LX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiByZXNwb25zZVxuXHRcdFx0XHRcdFx0Lmpzb24oKVxuXHRcdFx0XHRcdFx0LnRoZW4od2Vic2l0ZURhdGEgPT4ge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV3IFdlYlNpdGUod2Vic2l0ZURhdGEuaWQsIHdlYnNpdGVEYXRhLm5hbWUsIHdlYnNpdGVEYXRhLm1hcHBpbmdMaXN0KTtcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gSU5WQUxJRF9QQVJBTUVURVJTX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChgc2Vzc2lvbklkIGlzIG1hbGZvcm1lZGApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IE5PVF9GT1VORF9TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gSU5URVJOQUxfU0VSVkVSX0VSUk9SX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChgc2VydmVyIGVycm9yYCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cblx0fVxuXG5cdGNyZWF0ZUVtcHR5RXhwbG9yYXRpb24odGVzdGVyTmFtZTogc3RyaW5nLCBzZXJ2ZXJVUkw6IHN0cmluZywgc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xuXHRcdGNvbnN0IGJvZHkgPSB7XG5cdFx0XHR0ZXN0ZXJOYW1lLFxuXHRcdFx0aW50ZXJhY3Rpb25MaXN0OiBbXSxcblx0XHR9O1xuXHRcdGNvbnN0IG9wdGlvbiA9IHtcblx0XHRcdG1ldGhvZDogXCJQT1NUXCIsXG5cdFx0XHRib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcblx0XHRcdGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcblx0XHR9O1xuXHRcdHJldHVybiBmZXRjaChcblx0XHRcdGAke3NlcnZlclVSTH0vYXBpL3Nlc3Npb25zLyR7c2Vzc2lvbklkfS9leHBsb3JhdGlvbnNgLFxuXHRcdFx0b3B0aW9uXG5cdFx0KVxuXHRcdFx0LnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IE9LX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5qc29uKCkudGhlbihkYXRhID0+IHtcblx0XHRcdFx0XHRcdHJldHVybiBkYXRhLmV4cGxvcmF0aW9uTnVtYmVyXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBOT1RfRk9VTkRfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgbm8gc2Vzc2lvbiBub3QgZm91bmQgZm9yIElkYCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IElOVkFMSURfUEFSQU1FVEVSU19TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBzZXNzaW9uSWQgYW5kL29yIGV4cGxvcmF0aW9uIGlzIG1hbGZvcm1lZGApKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBJTlRFUk5BTF9TRVJWRVJfRVJST1JfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgc2VydmVyIGVycm9yYCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXG5cdH1cblxuXHRzZW5kQWN0aW9uKGV4cGxvcmF0aW9uTnVtYmVyOiBudW1iZXIsIGFjdGlvbjogQWN0aW9uLCBzZXJ2ZXJVUkw6IHN0cmluZywgc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcblxuXHRcdGNvbnN0IGJvZHkgPSB7XG5cdFx0XHRpbnRlcmFjdGlvbkxpc3Q6IFt7XG5cdFx0XHRcdGNvbmNyZXRlVHlwZTogYWN0aW9uLmdldENvbmNyZXRlVHlwZSgpLFxuXHRcdFx0XHRraW5kOiBhY3Rpb24ucHJlZml4LFxuXHRcdFx0XHR2YWx1ZTogYWN0aW9uLnN1ZmZpeCxcblx0XHRcdFx0ZGF0ZTogYWN0aW9uLmRhdGVcblx0XHRcdH1dXG5cdFx0fVxuXHRcdGNvbnN0IG9wdGlvbiA9IHtcblx0XHRcdG1ldGhvZDogXCJQT1NUXCIsXG5cdFx0XHRib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcblx0XHRcdGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcblx0XHR9O1xuXHRcdHJldHVybiBmZXRjaChcblx0XHRcdGAke3NlcnZlclVSTH0vYXBpL3Nlc3Npb25zLyR7c2Vzc2lvbklkfS9leHBsb3JhdGlvbnMvJHtleHBsb3JhdGlvbk51bWJlcn0vaW50ZXJhY3Rpb25zYCxcblx0XHRcdG9wdGlvbilcblx0XHRcdC50aGVuKChyZXNwb25zZSkgPT4ge1xuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBPS19TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gTk9UX0ZPVU5EX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYHNlc3Npb25JZCBub3QgZm91bmRgKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gSU5WQUxJRF9QQVJBTUVURVJTX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYHNlc3Npb25JZCBhbmQvb3IgZXhwbG9yYXRpb24gaXMgbWFsZm9ybWVkYCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IElOVEVSTkFMX1NFUlZFUl9FUlJPUl9TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBzZXJ2ZXIgZXJyb3JgKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pLmNhdGNoKGVycm9yID0+IHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihlcnJvcik7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlNlcnZpY2UgRmFpbGVkIHRvIHB1c2ggbmV3IGFjdGlvblwiKTtcblx0XHRcdH0pXG5cblx0fVxufVxuIiwiaW1wb3J0IEJyb3dzZXJTZXJ2aWNlIGZyb20gXCIuLi9kb21haW4vQnJvd3NlclNlcnZpY2VcIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCIuLi9mcmFtZXdvcmsvTG9nZ2VyXCI7XG5cbmNvbnN0IEVYUExPUkFUSU9OX05VTUJFUl9LRVkgPSAnRVhQTE9SQVRJT05fTlVNQkVSX0tFWSc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcm93c2VyU2VydmljZVNlc3Npb25TdG9yYWdlIGltcGxlbWVudHMgQnJvd3NlclNlcnZpY2Uge1xuXHRnZXRFeHBsb3JhdGlvbk51bWJlcigpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJCcm93c2VyU2VydmljZVNlc3Npb25TdG9yYWdlLmdldEV4cGxvcmF0aW9uTnVtYmVyXCIpO1xuICAgICAgICBjb25zdCBleHBsb3JhdGlvbk51bWJlckl0ZW0gPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKEVYUExPUkFUSU9OX05VTUJFUl9LRVkpO1xuICAgICAgICBpZiAoZXhwbG9yYXRpb25OdW1iZXJJdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWROdW1iZXIgPSBwYXJzZUludChleHBsb3JhdGlvbk51bWJlckl0ZW0pO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlZE51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJCcm93c2VyU2VydmljZVNlc3Npb25TdG9yYWdlLmdldEV4cGxvcmF0aW9uTnVtYmVyOiBOYU5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZS5nZXRFeHBsb3JhdGlvbk51bWJlcjogXCIgKyBwYXJzZWROdW1iZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWROdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZS5nZXRFeHBsb3JhdGlvbk51bWJlcjogdW5kZWZpbmVkXCIpO1xuICAgIH1cblxuXHRzYXZlRXhwbG9yYXRpb25OdW1iZXIoZXhwbG9yYXRpb25OdW1iZXI6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJCcm93c2VyU2VydmljZVNlc3Npb25TdG9yYWdlLnNhdmVFeHBsb3JhdGlvbk51bWJlcjogXCIgKyBleHBsb3JhdGlvbk51bWJlcik7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oRVhQTE9SQVRJT05fTlVNQkVSX0tFWSwgZXhwbG9yYXRpb25OdW1iZXIudG9TdHJpbmcoKSk7XG4gICAgfVxufSIsImltcG9ydCBSdWxlIGZyb20gXCIuL1J1bGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWN0aW9uIHtcblxuICAgIHB1YmxpYyBwcmVmaXg6IHN0cmluZztcbiAgICBwdWJsaWMgc3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgcHVibGljIHJ1bGVMaXN0OiBSdWxlW107XG4gICAgcHVibGljIGh0bWxFbGVtZW50TGlzdDogKEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpW107XG4gICAgcHVibGljIGRhdGU6IERhdGU7XG5cbiAgICBjb25zdHJ1Y3RvcihwcmVmaXg6IHN0cmluZywgc3VmZml4Pzogc3RyaW5nLCBydWxlTGlzdDogUnVsZVtdID0gW10sIGh0bWxFbGVtZW50TGlzdDogSFRNTEVsZW1lbnRbXT0gW10pIHtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLnJ1bGVMaXN0ID0gcnVsZUxpc3Q7XG4gICAgICAgIHRoaXMuaHRtbEVsZW1lbnRMaXN0ID0gaHRtbEVsZW1lbnRMaXN0O1xuICAgICAgICB0aGlzLmRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRSdWxlTGlzdChydWxlTGlzdDogUnVsZVtdKTogdm9pZCB7XG4gICAgICAgIHRoaXMucnVsZUxpc3QgPSBydWxlTGlzdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0Q29uY3JldGVUeXBlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBcIkFjdGlvblwiO1xuICAgIH1cblxuICAgIHB1YmxpYyB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgICAgICBpZiAodGhpcy5zdWZmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLnByZWZpeH0kJHt0aGlzLnN1ZmZpeH1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGVxdWFscyhhY3Rpb246IEFjdGlvbik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKCh0aGlzLnByZWZpeCA9PT0gYWN0aW9uLnByZWZpeCkgJiYgKHRoaXMuc3VmZml4ID09PSBhY3Rpb24uc3VmZml4KSlcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2VBY3Rpb24oYWN0aW9uVGV4dDogc3RyaW5nKTogQWN0aW9uIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBhY3Rpb25UZXh0LnNwbGl0KFwiJFwiKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24ocGFydHNbMF0pXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1tYWdpYy1udW1iZXJzXG4gICAgICAgIH0gZWxzZSBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGlvbihwYXJ0c1swXSwgcGFydHNbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIGFjdGlvbiA6IFwiICsgYWN0aW9uVGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufSIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIEFpZmV4UGx1Z2luSW5mbyB7XG4gICAgcmVhZG9ubHkgdmVyc2lvbjogc3RyaW5nO1xuICAgIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgICByZWFkb25seSBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHVybDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IodmVyc2lvbjogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmcsIHVybDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgfVxufSIsImltcG9ydCBBY3Rpb24gZnJvbSAnLi9BY3Rpb24nO1xuaW1wb3J0IFNpbXBsZVJ1bGUgZnJvbSAnLi9TaW1wbGVSdWxlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXR0cmlidXRlVmFsdWVSdWxlIGV4dGVuZHMgU2ltcGxlUnVsZSB7XG5cbiAgICBwdWJsaWMgYXR0cmlidXRlTmFtZTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHJlZml4OiBzdHJpbmcsIFxuICAgICAgICBzdWZmaXg6IHN0cmluZyB8IHVuZGVmaW5lZCwgXG4gICAgICAgIGV2ZW50OiBzdHJpbmcsIGNzczogc3RyaW5nIHwgdW5kZWZpbmVkLCBcbiAgICAgICAgeHBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICAgICAgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBcbiAgICAgICAga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQsIFxuICAgICAgICBjb250ZXh0VVJMOiBzdHJpbmcgfCB1bmRlZmluZWQsIFxuICAgICAgICBjb250ZXh0Q1NTOiBzdHJpbmcgfCB1bmRlZmluZWQsIFxuICAgICAgICBjb250ZXh0WFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCwgXG4gICAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmcsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IHN0cmluZyxcbiAgICAgICAgKSB7XG4gICAgICAgIHN1cGVyKHByZWZpeCwgc3VmZml4LCBldmVudCwgY3NzLCB4cGF0aCwgY29kZSwga2V5LCBjb250ZXh0VVJMLCBjb250ZXh0Q1NTLCBjb250ZXh0WFBhdGgsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZVxuICAgIH1cblxuICAgIG1ha2VBY3Rpb24oZXZlbnQgOiBFdmVudCk6IEFjdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmZpbmRBY3Rpb25NYXBwZWRUYXJnZXQoZXZlbnQpO1xuXG4gICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBhdHRyaWJ1dGVWYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKHRoaXMuYXR0cmlidXRlTmFtZSlcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uKHRoaXMucHJlZml4LCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24odGhpcy5wcmVmaXgpO1xuICAgIH1cblxuXG4gICAgYWN0aW9uVG9FbGVtZW50cyhhY3Rpb246IEFjdGlvbik6IChIVE1MRWxlbWVudHwgU1ZHRWxlbWVudClbXSB7XG4gICAgICAgIGlmIChhY3Rpb24ucHJlZml4ICE9PSB0aGlzLnByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb24uc3VmZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5hY3Rpb25Ub0VsZW1lbnRzKGFjdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc3VmZml4ID0gYWN0aW9uLnN1ZmZpeDtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5maW5kTWF0Y2hlZEVsZW1lbnRzKCk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHMuZmlsdGVyKGRvbUVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkb21FbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKHRoaXMuYXR0cmlidXRlTmFtZSkgPT09IHN1ZmZpeDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwiLi4vZnJhbWV3b3JrL0xvZ2dlclwiO1xuaW1wb3J0IEFjdGlvbiBmcm9tIFwiLi9BY3Rpb25cIjtcbmltcG9ydCBBaWZleFNlcnZpY2UgZnJvbSBcIi4vQWlmZXhTZXJ2aWNlXCI7XG5pbXBvcnQgQnJvd3NlclNlcnZpY2UgZnJvbSBcIi4vQnJvd3NlclNlcnZpY2VcIjtcbmltcG9ydCBDbGFzc011dGF0aW9uSGFuZGxlciBmcm9tIFwiLi9DbGFzc011dGF0aW9uSGFuZGxlclwiO1xuaW1wb3J0IEV2ZW50TGlzdGVuZXIgZnJvbSBcIi4vRXZlbnRMaXN0ZW5lclwiO1xuaW1wb3J0IFBhZ2VNdXRhdGlvbkhhbmRsZXIgZnJvbSBcIi4vUGFnZU11dGF0aW9uSGFuZGxlclwiO1xuaW1wb3J0IFJ1bGVTZXJ2aWNlIGZyb20gXCIuL1J1bGVTZXJ2aWNlXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4vVG9rZW5cIjtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcm93c2VyU2NyaXB0IHtcblxuICAgIHByaXZhdGUgX3NlcnZlclVSTDogc3RyaW5nO1xuXHRwcml2YXRlIF9zZXNzaW9uSWQ6IHN0cmluZztcblx0cHJpdmF0ZSBfd2ViU2l0ZUlkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cdHByaXZhdGUgX3Rva2VuOiBUb2tlbiB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9ydWxlU2VydmljZSA6IFJ1bGVTZXJ2aWNlO1xuICAgIHByaXZhdGUgX2V2ZW50TGlzdGVuZXIgOiBFdmVudExpc3RlbmVyO1xuICAgIHByaXZhdGUgX2FpZmV4U2VydmljZSA6IEFpZmV4U2VydmljZTtcbiAgICBwcml2YXRlIF9icm93c2VyU2VydmljZSA6IEJyb3dzZXJTZXJ2aWNlO1xuICAgIHByaXZhdGUgX3BhZ2VNdXRhdGlvbkhhbmRsZXIgOiBQYWdlTXV0YXRpb25IYW5kbGVyO1xuICAgIHByaXZhdGUgX2V4cGxvcmF0aW9uTnVtYmVyOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgICBcbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXJVUkw6IHN0cmluZywgc2Vzc2lvbklkOiBzdHJpbmcsIHRva2VuOiBUb2tlbiB8IHVuZGVmaW5lZCwgYWlmZXhTZXJ2aWNlOiBBaWZleFNlcnZpY2UsIGJyb3dzZXJTZXJ2aWNlOiBCcm93c2VyU2VydmljZSkge1xuICAgICAgICB0aGlzLl9zZXJ2ZXJVUkwgPSBzZXJ2ZXJVUkw7XG4gICAgICAgIHRoaXMuX3Nlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICAgICAgdGhpcy5fdG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5fYWlmZXhTZXJ2aWNlID0gYWlmZXhTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9icm93c2VyU2VydmljZSA9IGJyb3dzZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9ydWxlU2VydmljZSA9IG5ldyBSdWxlU2VydmljZSgpO1xuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVyID0gbmV3IEV2ZW50TGlzdGVuZXIodGhpcy5fcnVsZVNlcnZpY2UpO1xuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVyLmFkZE9ic2VydmVyKHRoaXMucHJvY2Vzc05ld0FjdGlvbi5iaW5kKHRoaXMpKTtcblxuICAgICAgICBuZXcgQ2xhc3NNdXRhdGlvbkhhbmRsZXIoKTtcblxuICAgICAgICB0aGlzLl9wYWdlTXV0YXRpb25IYW5kbGVyID0gbmV3IFBhZ2VNdXRhdGlvbkhhbmRsZXIodGhpcy5vbk11dGF0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9wYWdlTXV0YXRpb25IYW5kbGVyLmluaXQoKTtcbiAgICB9XG5cbiAgICBzdGFydCgpIDogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9haWZleFNlcnZpY2UuZ2V0U2Vzc2lvbih0aGlzLl9zZXJ2ZXJVUkwsIHRoaXMuX3Nlc3Npb25JZCwgdW5kZWZpbmVkKVxuICAgICAgICAgICAgLnRoZW4oKHNlc3Npb25SZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvblJlc3VsdCAmJiBzZXNzaW9uUmVzdWx0ICE9PSBcIlVuYXV0aG9yaXplZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dlYlNpdGVJZCA9IHNlc3Npb25SZXN1bHQud2ViU2l0ZUlkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9haWZleFNlcnZpY2UuZ2V0V2ViU2l0ZSh0aGlzLl9zZXJ2ZXJVUkwsIHRoaXMuX3dlYlNpdGVJZCwgdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHdlYlNpdGVSZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2ViU2l0ZVJlc3VsdCAmJiB3ZWJTaXRlUmVzdWx0ICE9PSAnVW5hdXRob3JpemVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBydWxlcyA9IHdlYlNpdGVSZXN1bHQubWFwcGluZ0xpc3QubWFwKChydSA6IGFueSkgPT4gdGhpcy5fcnVsZVNlcnZpY2UuY3JlYXRlUnVsZShydSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ydWxlU2VydmljZS5sb2FkUnVsZXMocnVsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ydWxlU2VydmljZS5tYXBSdWxlc1RvRWxlbWVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBSdWxlcyBsb2FkZWQgOiAke3J1bGVzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lci5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEV4cGxvcmF0aW9uTnVtYmVyID0gdGhpcy5fYnJvd3NlclNlcnZpY2UuZ2V0RXhwbG9yYXRpb25OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEV4cGxvcmF0aW9uTnVtYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwbG9yYXRpb25OdW1iZXIgPSBjdXJyZW50RXhwbG9yYXRpb25OdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWlmZXhTZXJ2aWNlLmNyZWF0ZUVtcHR5RXhwbG9yYXRpb24oXCJCUk9XU0VSX1NDUklQVFwiLCB0aGlzLl9zZXJ2ZXJVUkwsIHRoaXMuX3Nlc3Npb25JZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGV4cGxvcmF0aW9uTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHBsb3JhdGlvbk51bWJlciA9IGV4cGxvcmF0aW9uTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnJvd3NlclNlcnZpY2Uuc2F2ZUV4cGxvcmF0aW9uTnVtYmVyKHRoaXMuX2V4cGxvcmF0aW9uTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTmV3QWN0aW9uKG5ldyBBY3Rpb24oXCJzdGFydFwiLCB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgfVxuXG4gICAgcHJvY2Vzc05ld0FjdGlvbihhY3Rpb246IEFjdGlvbik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fZXhwbG9yYXRpb25OdW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGV4cGxvcmF0aW9uIGhhcyBub3QgYmVlbiBjb3JyZWN0bHkgc3RhcnRlZFwiKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FpZmV4U2VydmljZS5zZW5kQWN0aW9uKHRoaXMuX2V4cGxvcmF0aW9uTnVtYmVyLCBhY3Rpb24sIHRoaXMuX3NlcnZlclVSTCwgdGhpcy5fc2Vzc2lvbklkKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uTXV0YXRpb24oKSA6dm9pZHtcbiAgICAgICAgdGhpcy5fcnVsZVNlcnZpY2UubWFwUnVsZXNUb0VsZW1lbnRzKCk7XG4gICAgfVxuXG59IiwiaW1wb3J0IENvbnRleHRNYXBwZXIgZnJvbSBcIi4vQ29udGV4dE1hcHBlclwiO1xuaW1wb3J0IFJ1bGUgZnJvbSBcIi4vUnVsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDU1NDb250ZXh0TWFwcGVyIGV4dGVuZHMgQ29udGV4dE1hcHBlciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0IDogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgIH1cblxuICAgIGJ1aWxkRWxlbWVudFRvUnVsZU1hcCgpIDogTWFwPEhUTUxFbGVtZW50fFNWR0VsZW1lbnQsIFJ1bGVbXT4ge1xuICAgICAgICBpZiAodGhpcy5fY29udGV4dCkge1xuICAgICAgICAgICAgY29uc3QgY3NzUXVlcnlSZXN1bHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuX2NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGNzc1F1ZXJ5UmVzdWx0ICYmIGNzc1F1ZXJ5UmVzdWx0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEVsZW1lbnRUb1J1bGVNYXBGb3JTZWxlY3RvcnMoY3NzUXVlcnlSZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cbn0iLCJpbXBvcnQgQWN0aW9uIGZyb20gJy4vQWN0aW9uJztcbmltcG9ydCBSdWxlIGZyb20gJy4vUnVsZSc7XG5pbXBvcnQgZ2V0Q3NzU2VsZWN0b3IgZnJvbSAnY3NzLXNlbGVjdG9yLWdlbmVyYXRvcic7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSBcIi4uL2ZyYW1ld29yay9Mb2dnZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1NTU2VsZWN0b3JSdWxlIGV4dGVuZHMgUnVsZSB7XG4gICAgY29uc3RydWN0b3IocHJlZml4OiBzdHJpbmcsIHN1ZmZpeDogc3RyaW5nIHwgdW5kZWZpbmVkLCBldmVudDogc3RyaW5nLCBjc3M6IHN0cmluZyB8IHVuZGVmaW5lZCwgeHBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICAgICAgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBrZXk6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dFVSTDogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0Q1NTOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRYUGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkLCBkZXNjcmlwdGlvbjogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKHByZWZpeCwgc3VmZml4LCBldmVudCwgY3NzLCB4cGF0aCwgY29kZSwga2V5LCBjb250ZXh0VVJMLCBjb250ZXh0Q1NTLCBjb250ZXh0WFBhdGgsIGRlc2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICBtYWtlQWN0aW9uKGV2ZW50IDogRXZlbnQpOiBBY3Rpb24gfCB1bmRlZmluZWQge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkgeyBcbiAgICAgICAgICAgICAgICBsZXQgc3VmZml4O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IGdldENzc1NlbGVjdG9yKGV2ZW50LnRhcmdldCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFnXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYXR0cmlidXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgYmxhY2tsaXN0OiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qZGF0YS4qL2ksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKmFpZmV4LiovaSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qb3Zlci4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qYXV0by4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qdmFsdWUuKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKmNoZWNrZWQuKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdbcGxhY2Vob2xkZXJdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipocmVmLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipzcmMuKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKm9uY2xpY2suKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKm9ubG9hZC4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qb25rZXl1cC4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qd2lkdGguKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKmhlaWdodC4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qc3R5bGUuKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKnNpemUuKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKm1heGxlbmd0aC4qL2lcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21iaW5lQmV0d2VlblNlbGVjdG9yczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heENhbmRpZGF0ZXM6IDEwMFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgZXhjZXB0aW9uYCxuZXcgRXJyb3IoJ2NzcyBleGNlcHRpb24nKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uKHRoaXMucHJlZml4LCBzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWN0aW9uVG9FbGVtZW50cyhhY3Rpb246IEFjdGlvbik6IChIVE1MRWxlbWVudHxTVkdFbGVtZW50KVtdIHtcbiAgICAgICAgaWYgKGFjdGlvbi5wcmVmaXggIT09IHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uLnN1ZmZpeCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgOiAoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudClbXSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudHMgPSB0aGlzLmZpbmRNYXRjaGVkRWxlbWVudHMoKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYWN0aW9uLnN1ZmZpeCkuZm9yRWFjaCggKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50RWxlbWVudHMuc29tZSgocGFyZW50KSA9PiBwYXJlbnQuY29udGFpbnMoZWxlbWVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBBY3Rpb24gZnJvbSAnLi9BY3Rpb24nO1xuaW1wb3J0IFJ1bGUgZnJvbSAnLi9SdWxlJztcbmltcG9ydCBnZXRDc3NTZWxlY3RvciBmcm9tICdjc3Mtc2VsZWN0b3ItZ2VuZXJhdG9yJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tIFwiLi4vZnJhbWV3b3JrL0xvZ2dlclwiO1xuaW1wb3J0IHsgQ3NzU2VsZWN0b3JUeXBlIH0gZnJvbSAnY3NzLXNlbGVjdG9yLWdlbmVyYXRvci90eXBlcy90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENTU1NlbGVjdG9yV2l0aFZhbHVlUnVsZSBleHRlbmRzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeDogc3RyaW5nLCBzdWZmaXg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IHN0cmluZywgY3NzOiBzdHJpbmcgfCB1bmRlZmluZWQsIHhwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCwga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRVUkw6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dENTUzogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0WFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgICAgICBzdXBlcihwcmVmaXgsIHN1ZmZpeCwgZXZlbnQsIGNzcywgeHBhdGgsIGNvZGUsIGtleSwgY29udGV4dFVSTCwgY29udGV4dENTUywgY29udGV4dFhQYXRoLCBkZXNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgbWFrZUFjdGlvbihldmVudCA6IEV2ZW50KTogQWN0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHsgXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZShldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGxldCBzdWZmaXg7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gZ2V0Q3NzU2VsZWN0b3IoZXZlbnQudGFyZ2V0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCIsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0YWdcIiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhdHRyaWJ1dGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBibGFja2xpc3Q6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipkYXRhLiovaSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qYWlmZXguKi9pLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipvdmVyLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLiphdXRvLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLip2YWx1ZS4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qY2hlY2tlZC4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1twbGFjZWhvbGRlcl0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKmhyZWYuKi9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8uKnNyYy4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qb25jbGljay4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qb25sb2FkLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipvbmtleXVwLiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLip3aWR0aC4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qaGVpZ2h0LiovaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLipzdHlsZS4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qc2l6ZS4qL2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy4qbWF4bGVuZ3RoLiovaVxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbWJpbmVCZXR3ZWVuU2VsZWN0b3JzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4Q2FuZGlkYXRlczogMTAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBleGNlcHRpb25gLG5ldyBFcnJvcignY3NzIGV4Y2VwdGlvbicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ICs9IGA/JHt2YWx1ZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGlvbih0aGlzLnByZWZpeCwgc3VmZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFjdGlvblRvRWxlbWVudHMoYWN0aW9uOiBBY3Rpb24pOiAoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudClbXSB7XG4gICAgICAgIGlmIChhY3Rpb24ucHJlZml4ICE9PSB0aGlzLnByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbi5zdWZmaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzIDogKEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpW10gPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnRzID0gdGhpcy5maW5kTWF0Y2hlZEVsZW1lbnRzKCk7XG4gICAgICAgICAgICBsZXQgc2hhcnBDaGFySW5kZXggPSBhY3Rpb24uc3VmZml4LmluZGV4T2YoJz8nKTtcbiAgICAgICAgICAgIGxldCBjc3NTZWxlY3RvciA9IHNoYXJwQ2hhckluZGV4ID09PSAtMSA/IGFjdGlvbi5zdWZmaXggOiBhY3Rpb24uc3VmZml4LnN1YnN0cmluZygwLCBzaGFycENoYXJJbmRleCk7XG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGNzc1NlbGVjdG9yKS5mb3JFYWNoKCAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRFbGVtZW50cy5zb21lKChwYXJlbnQpID0+IHBhcmVudC5jb250YWlucyhlbGVtZW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBlbGVtZW50IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VmFsdWUoZWxlbWVudDogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgfSBcblxuICAgICAgICBjb25zdCB2YWx1ZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICBpZiAodmFsdWVBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZUF0dHJpYnV0ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCIuLi9mcmFtZXdvcmsvTG9nZ2VyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsYXNzTXV0YXRpb25IYW5kbGVyIHtcblxuICAgIHByaXZhdGUgX29ic2VydmVyOiBNdXRhdGlvbk9ic2VydmVyO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKHJlY29yZHMpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbGFzcyBtdXRhdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQudGFyZ2V0Lm1hdGNoZXMoJzpob3ZlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q2xhc3MgPSByZWNvcmQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNyZWF0ZUV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQub2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2xhc3MgJiYgY3VycmVudENsYXNzLmluY2x1ZGVzKHJlY29yZC5vbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFdmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGVFdmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnY3JlYXRlIGV2ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSBuZXcgRXZlbnQoJ2Nzcy1jbGFzcy1hZGRlZCcse2J1YmJsZXM6dHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLnRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUsIHN1YnRyZWU6IHRydWUsIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlfTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCBjb25maWcpO1xuICAgICAgICBsb2dnZXIuaW5mbygnY2xhc3MgbXV0YXRpb24gaGFuZGxlciBpbml0aWFsaXplZCcpO1xuICAgIH1cblxufSIsImltcG9ydCBDb250ZXh0TWFwcGVyIGZyb20gXCIuL0NvbnRleHRNYXBwZXJcIjtcbmltcG9ydCBSdWxlIGZyb20gXCIuL1J1bGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGV4dExlc3NNYXBwZXIgZXh0ZW5kcyBDb250ZXh0TWFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIodW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBidWlsZEVsZW1lbnRUb1J1bGVNYXAoKSA6IE1hcDxIVE1MRWxlbWVudHxTVkdFbGVtZW50LCBSdWxlW10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRFbGVtZW50VG9SdWxlTWFwRm9yU2VsZWN0b3JzKCk7XG4gICAgfVxufSIsImltcG9ydCBSdWxlIGZyb20gXCIuL1J1bGVcIjtcbmltcG9ydCB7bG9nZ2VyfSBmcm9tIFwiLi4vZnJhbWV3b3JrL0xvZ2dlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBDb250ZXh0TWFwcGVyIHtcbiAgICBwcm90ZWN0ZWQgX2NvbnRleHQgOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgcHJvdGVjdGVkIF9jc3NTZWxlY3RvcjJSdWxlcyA6IE1hcDxzdHJpbmcsIFJ1bGVbXT47XG4gICAgcHJvdGVjdGVkIF94cGF0aFNlbGVjdG9yMlJ1bGVzIDogTWFwPHN0cmluZywgUnVsZVtdPjtcblxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQgOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX2Nzc1NlbGVjdG9yMlJ1bGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl94cGF0aFNlbGVjdG9yMlJ1bGVzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIGFkZChydWxlIDogUnVsZSk6IHZvaWQge1xuICAgICAgICBpZiAocnVsZS5jb250ZXh0Q1NTICE9PSB0aGlzLl9jb250ZXh0ICYmIHJ1bGUuY29udGV4dFVSTCAhPT0gdGhpcy5fY29udGV4dCAmJiBydWxlLmNvbnRleHRYUGF0aCAhPT0gdGhpcy5fY29udGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgYWRkIHJ1bGUgd2l0aCBhIGRpZmZlcmVudCBjb250ZXh0ICcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydWxlLmNzcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jc3NTZWxlY3RvcjJSdWxlcy5oYXMocnVsZS5jc3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3NzU2VsZWN0b3IyUnVsZXMuc2V0KHJ1bGUuY3NzLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcnVsZXM0U2VsZWN0b3IgPSB0aGlzLl9jc3NTZWxlY3RvcjJSdWxlcy5nZXQocnVsZS5jc3MpO1xuICAgICAgICAgICAgaWYgKHJ1bGVzNFNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcnVsZXM0U2VsZWN0b3IucHVzaChydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocnVsZS54cGF0aCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl94cGF0aFNlbGVjdG9yMlJ1bGVzLmhhcyhydWxlLnhwYXRoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3hwYXRoU2VsZWN0b3IyUnVsZXMuc2V0KHJ1bGUueHBhdGgsIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBydWxlczRTZWxlY3RvciA9IHRoaXMuX3hwYXRoU2VsZWN0b3IyUnVsZXMuZ2V0KHJ1bGUueHBhdGgpO1xuICAgICAgICAgICAgaWYgKHJ1bGVzNFNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcnVsZXM0U2VsZWN0b3IucHVzaChydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFic3RyYWN0IGJ1aWxkRWxlbWVudFRvUnVsZU1hcCgpIDogTWFwPEhUTUxFbGVtZW50fFNWR0VsZW1lbnQsIFJ1bGVbXT47XG5cbiAgICBwcm90ZWN0ZWQgYnVpbGRFbGVtZW50VG9SdWxlTWFwRm9yU2VsZWN0b3JzKGNvbnRleHQ/IDogSFRNTEVsZW1lbnR8U1ZHRWxlbWVudCkgOiBNYXA8SFRNTEVsZW1lbnR8U1ZHRWxlbWVudCwgUnVsZVtdPiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRUb1J1bGVzIDogTWFwPEhUTUxFbGVtZW50fFNWR0VsZW1lbnQsIFJ1bGVbXT4gPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW3NlbGVjdG9yLCBydWxlc10gb2YgdGhpcy5fY3NzU2VsZWN0b3IyUnVsZXMpIHtcbiAgICAgICAgICAgIGxldCBxdWVyeVNlbGVjdG9yIDogTm9kZUxpc3RPZjxIVE1MRWxlbWVudHxTVkdFbGVtZW50PjtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlTZWxlY3RvciA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXJ5U2VsZWN0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXJ5U2VsZWN0b3IuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXM0RWxlbWVudCA9IGVsZW1lbnRUb1J1bGVzLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGVzNEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM0RWxlbWVudCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50VG9SdWxlcy5zZXQoZWxlbWVudCwgcnVsZXM0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bGVzNEVsZW1lbnQucHVzaCguLi5ydWxlcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3NlbGVjdG9yLCBydWxlc10gb2YgdGhpcy5feHBhdGhTZWxlY3RvcjJSdWxlcykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5WHBhdGg7XG4gICAgICAgICAgICBsZXQgcXVlcnlYcGF0aFJlc3VsdDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVhwYXRoID0gZG9jdW1lbnQuZXZhbHVhdGUoc2VsZWN0b3IsIGNvbnRleHQsIG51bGwsIFhQYXRoUmVzdWx0LkFOWV9UWVBFLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVhwYXRoID0gZG9jdW1lbnQuZXZhbHVhdGUoc2VsZWN0b3IsIGRvY3VtZW50LCBudWxsLCBYUGF0aFJlc3VsdC5BTllfVFlQRSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignWFBhdGggRXJyb3I6JyxuZXcgRXJyb3IoXCJlXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHF1ZXJ5WHBhdGgpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVhwYXRoUmVzdWx0ID0gcXVlcnlYcGF0aC5pdGVyYXRlTmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHF1ZXJ5WHBhdGhSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5WHBhdGhSZXN1bHQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBxdWVyeVhwYXRoUmVzdWx0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vQ29udGV4dCA9ICEgY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRJbkNvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQuY29udGFpbnMocXVlcnlYcGF0aFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9Db250ZXh0IHx8IHJlc3VsdEluQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBydWxlczRFbGVtZW50ID0gZWxlbWVudFRvUnVsZXMuZ2V0KHF1ZXJ5WHBhdGhSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnVsZXM0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlczRFbGVtZW50ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRUb1J1bGVzLnNldChxdWVyeVhwYXRoUmVzdWx0LCBydWxlczRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXM0RWxlbWVudC5wdXNoKC4uLnJ1bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBxdWVyeVhwYXRoUmVzdWx0ID0gcXVlcnlYcGF0aC5pdGVyYXRlTmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudFRvUnVsZXM7XG4gICAgfVxufSIsImltcG9ydCBSdWxlU2VydmljZSBmcm9tIFwiLi9SdWxlU2VydmljZVwiO1xuaW1wb3J0IEFjdGlvbiBmcm9tIFwiLi9BY3Rpb25cIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCIuLi9mcmFtZXdvcmsvTG9nZ2VyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50TGlzdGVuZXIge1xuICAgIHByaXZhdGUgX3J1bGVTZXJ2aWNlOiBSdWxlU2VydmljZTtcbiAgICBwcml2YXRlIF9oYW5kbGVkRXZlbnRzOiBzdHJpbmdbXTtcbiAgICBwcml2YXRlIF9vYnNlcnZlcnM6ICgoYWN0aW9uOiBBY3Rpb24pID0+IHZvaWQpW107XG5cbiAgICBjb25zdHJ1Y3RvcihydWxlU2VydmljZTogUnVsZVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fcnVsZVNlcnZpY2UgPSBydWxlU2VydmljZVxuICAgICAgICB0aGlzLl9oYW5kbGVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuX29ic2VydmVycyA9IFtdO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVkRXZlbnRzID0gdGhpcy5fcnVsZVNlcnZpY2UuZ2V0RXZlbnRzVG9IYW5kbGUoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBFdmVudExpc3RlbmVyOiB0aGVyZSBhcmUgJHt0aGlzLl9oYW5kbGVkRXZlbnRzLmxlbmd0aH0gZXZlbnRzIHRvIGhhbmRsZWApO1xuICAgICAgICB0aGlzLl9oYW5kbGVkRXZlbnRzLmZvckVhY2goKGhhbmRsZWRFdmVudCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihoYW5kbGVkRXZlbnQsIHRoaXMuZXhwbG9yYXRvcnlMaXN0ZW5lci5iaW5kKHRoaXMpLCB0cnVlKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRPYnNlcnZlcihvYnNlcnZlckZ1bmN0aW9uIDogKGFjdGlvbjogQWN0aW9uKSA9PiB2b2lkKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVycy5wdXNoKG9ic2VydmVyRnVuY3Rpb24pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZXhwbG9yYXRvcnlMaXN0ZW5lcihldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgbGV0IHVuc2FmZUV2ZW50OiBhbnkgPSBldmVudDtcbiAgICAgICAgaWYgKHVuc2FmZUV2ZW50LmlzVHJ1c3RlZCkge1xuICAgICAgICAgICAgaWYgKCF1bnNhZmVFdmVudC5leHBsb3JlZCkge1xuICAgICAgICAgICAgICAgIHVuc2FmZUV2ZW50LmV4cGxvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYEV2ZW50TGlzdGVuZXI6IGV2ZW50ICR7dW5zYWZlRXZlbnQudHlwZX0gaXMgYmVpbmcgaGFuZGxlZGApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLl9ydWxlU2VydmljZS5nZXRNYXRjaGluZ1J1bGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChydWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHJ1bGUubWFrZUFjdGlvbihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBhY3Rpb24gOiAke2FjdGlvbi50b1N0cmluZygpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmZvckVhY2goKG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdubyBhY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiaW1wb3J0IEFjdGlvbiBmcm9tICcuL0FjdGlvbic7XG5pbXBvcnQgU2ltcGxlUnVsZSBmcm9tICcuL1NpbXBsZVJ1bGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbmRleFJ1bGUgZXh0ZW5kcyBTaW1wbGVSdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXg6IHN0cmluZywgc3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQsIGV2ZW50OiBzdHJpbmcsIGNzczogc3RyaW5nIHwgdW5kZWZpbmVkLCB4cGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgICAgICBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGtleTogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0VVJMOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRDU1M6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dFhQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIocHJlZml4LCBzdWZmaXgsIGV2ZW50LCBjc3MsIHhwYXRoLCBjb2RlLCBrZXksIGNvbnRleHRVUkwsIGNvbnRleHRDU1MsIGNvbnRleHRYUGF0aCwgZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIG1ha2VBY3Rpb24oZXZlbnQgOiBFdmVudCk6IEFjdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nRWxlbWVudHMgPSB0aGlzLmZpbmRNYXRjaGVkRWxlbWVudHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGluZ0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0RWxlbWVudHMgPSBldmVudC5jb21wb3NlZFBhdGgoKS5maWx0ZXIoKHRhcmdldCk6dGFyZ2V0IGlzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCA9PiB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50cy5sZW5ndGggPiAwICYmIG1hdGNoaW5nRWxlbWVudHNbaV0uY29udGFpbnModGFyZ2V0RWxlbWVudHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24odGhpcy5wcmVmaXgsIGkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3Rpb25Ub0VsZW1lbnRzKGFjdGlvbjogQWN0aW9uKTogKEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudClbXSB7XG4gICAgICAgIGlmIChhY3Rpb24ucHJlZml4ICE9PSB0aGlzLnByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGFjdGlvbi5zdWZmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmFjdGlvblRvRWxlbWVudHMoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KGFjdGlvbi5zdWZmaXgsIDEwKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmZpbmRNYXRjaGVkRWxlbWVudHMoKTtcbiAgICAgICAgLy8gSGFwcGVucyBpZiBhIHByZXZpb3VzIHJ1bGVzIHdhcyBub3QgdXNpbmcgdGhlIGluZGV4IHN1ZmZpeFxuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCB8fMKgbnVsbCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtZW50c1tpbmRleF1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgQWN0aW9uIGZyb20gJy4vQWN0aW9uJztcbmltcG9ydCBTaW1wbGVSdWxlIGZyb20gJy4vU2ltcGxlUnVsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElubmVyVGV4dFJ1bGUgZXh0ZW5kcyBTaW1wbGVSdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXg6IHN0cmluZywgc3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQsIGV2ZW50OiBzdHJpbmcsIGNzczogc3RyaW5nIHwgdW5kZWZpbmVkLCB4cGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgICAgICBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGtleTogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0VVJMOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRDU1M6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dFhQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIocHJlZml4LCBzdWZmaXgsIGV2ZW50LCBjc3MsIHhwYXRoLCBjb2RlLCBrZXksIGNvbnRleHRVUkwsIGNvbnRleHRDU1MsIGNvbnRleHRYUGF0aCwgZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIG1ha2VBY3Rpb24oZXZlbnQ6IGFueSk6IEFjdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmZpbmRBY3Rpb25NYXBwZWRUYXJnZXQoZXZlbnQpO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uKHRoaXMucHJlZml4LCBlbGVtZW50LmlubmVyVGV4dC50cmltKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGlvbih0aGlzLnByZWZpeCwgXCJzdmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3Rpb25Ub0VsZW1lbnRzKGFjdGlvbjogQWN0aW9uKTogKEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpW10ge1xuICAgICAgICBpZiAoYWN0aW9uLnByZWZpeCAhPT0gdGhpcy5wcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uLnN1ZmZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuYWN0aW9uVG9FbGVtZW50cyhhY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IGFjdGlvbi5zdWZmaXg7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZmluZE1hdGNoZWRFbGVtZW50cygpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcihkb21FbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb21FbGVtZW50LmlubmVyVGV4dC50cmltKCkgPT09IHN1ZmZpeC50cmltKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb21FbGVtZW50IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdmdcIiA9PT0gc3VmZml4LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiY29uc3QgTVVUQVRJT05fUkVGUkVTSF9DSEVDSyA9IDEwMDA7XG5jb25zdCBET01fSURTID0gW1wiQUlGRVhfcHJvYmFiaWxpdHlQb3B1cFwiLCBcIkFJRkVYX3RhYlwiXTtcbmltcG9ydCB7bG9nZ2VyfSBmcm9tIFwiLi4vZnJhbWV3b3JrL0xvZ2dlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdlTXV0YXRpb25IYW5kbGVyIHtcblxuICAgIGxhc3RNdXRhdGlvbjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIG9ic2VydmVyOiBNdXRhdGlvbk9ic2VydmVyIHwgdW5kZWZpbmVkO1xuICAgIG11dGF0aW9uSGFzT2NjdXJlZDogYm9vbGVhbjtcbiAgICBiZVJlZnJlc2hpbmcgOiBib29sZWFuO1xuICAgIHdpbGxSZWZyZXNoIDogYm9vbGVhbjtcblxuICAgIG9uUGFnZU11dGF0aW9uOiAoKSA9PiB2b2lkO1xuXG4gICAgY29uc3RydWN0b3Iob25QYWdlTXV0YXRpb246ICgpID0+IHZvaWQpIHtcbiAgICAgICAgdGhpcy5vblBhZ2VNdXRhdGlvbiA9IG9uUGFnZU11dGF0aW9uXG4gICAgICAgIHRoaXMuYmVSZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubXV0YXRpb25IYXNPY2N1cmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2lsbFJlZnJlc2ggPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxhc3RNdXRhdGlvbiA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigocmVjb3JkcykgPT4ge1xuICAgICAgICAgICAgbGV0IHdhdGNoZWRQYWdlSGFzTXV0YXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1dhdGNoZWROb2RlTGlzdChyZWNvcmQuYWRkZWROb2RlcykgJiYgISB0aGlzLmlzSW5jbHVkZWRJbkFJRkVYRWxlbWVudChyZWNvcmQuYWRkZWROb2RlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoZWRQYWdlSGFzTXV0YXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2F0Y2hlZFBhZ2VIYXNNdXRhdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEgdGhpcy5iZVJlZnJlc2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iZVJlZnJlc2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUGFnZU11dGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZVJlZnJlc2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgTVVUQVRJT05fUkVGUkVTSF9DSEVDSyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLndpbGxSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndpbGxSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFRJTUVfQ0hFQ0tfTVVMVElQTElFUiA9IDI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmVSZWZyZXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUGFnZU11dGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmVSZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2lsbFJlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBNVVRBVElPTl9SRUZSRVNIX0NIRUNLKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFRJTUVfQ0hFQ0tfTVVMVElQTElFUiAqIE1VVEFUSU9OX1JFRlJFU0hfQ0hFQ0spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7IGF0dHJpYnV0ZXM6IGZhbHNlLCBjaGlsZExpc3Q6IHRydWUsIGNoYXJhY3RlckRhdGE6IGZhbHNlLCBzdWJ0cmVlOiB0cnVlfTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmJvZHksIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc1dhdGNoZWROb2RlTGlzdChub2RlTGlzdCA6IE5vZGVMaXN0KSA6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgaXNXYXRjaGVkIDogYm9vbGVhbiA9IGZhbHNlO1xuICAgICAgICBub2RlTGlzdC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgIT09IFwiU0NSSVBUXCIgJiYgbm9kZS50YWdOYW1lICE9PSBcIklGUkFNRVwiICYmIG5vZGUudGFnTmFtZSAhPT0gXCJJTUdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzV2F0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnN0eWxlLmRpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzV2F0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3R5bGUuZGlzcGxheSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzV2F0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBpc1dhdGNoZWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0luY2x1ZGVkSW5BSUZFWEVsZW1lbnQobm9kZUxpc3QgOiBOb2RlTGlzdCkgOiBib29sZWFuIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiB2YXJpYWJsZS1uYW1lXG4gICAgICAgIGNvbnN0IEFJRkVYRWxlbWVudExpc3QgPSBET01fSURTLm1hcChpZCA9PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpLmZpbHRlcigoZWxlbWVudCk6IGVsZW1lbnQgaXMgSFRNTEVsZW1lbnQgPT4gZWxlbWVudCAhPT0gbnVsbCk7XG4gICAgICAgIGxldCBpc0luY2x1ZGVkIDogYm9vbGVhbiA9IHRydWU7XG4gICAgICAgIG5vZGVMaXN0LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBSUZFWEVsZW1lbnRMaXN0LnNvbWUoKGFpZmV4Tm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWlmZXhOb2RlLmNvbnRhaW5zKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzSW5jbHVkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBpc0luY2x1ZGVkO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBxdWVyeVNlbGVjdG9yQWxsRGVlcCB9IGZyb20gJ3F1ZXJ5LXNlbGVjdG9yLXNoYWRvdy1kb20nO1xuaW1wb3J0IEFjdGlvbiBmcm9tIFwiLi9BY3Rpb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUnVsZSB7XG5cbiAgICBldmVudDogc3RyaW5nO1xuICAgIGNzczogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHhwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgcHJlZml4OiBzdHJpbmc7XG4gICAgc3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGNvbnRleHRVUkw6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBjb250ZXh0Q1NTOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgY29udGV4dFhQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHByZWZpeDogc3RyaW5nLCBzdWZmaXg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IHN0cmluZywgY3NzOiBzdHJpbmcgfCB1bmRlZmluZWQsIHhwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCwga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRVUkw6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dENTUzogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0WFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246IHN0cmluZykge1xuXG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5jc3MgPSBjc3M7XG4gICAgICAgIHRoaXMueHBhdGggPSB4cGF0aDtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5jb250ZXh0VVJMID0gY29udGV4dFVSTDtcbiAgICAgICAgdGhpcy5jb250ZXh0Q1NTID0gY29udGV4dENTUztcbiAgICAgICAgdGhpcy5jb250ZXh0WFBhdGggPSBjb250ZXh0WFBhdGg7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICBtYXRjaChldmVudCA6IEV2ZW50KSA6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoZXZlbnQudHlwZSAhPT0gdGhpcy5ldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnQgPT09IFwia2V5dXBcIiB8fCB0aGlzLmV2ZW50ID09PSBcImtleWRvd25cIiB8fCB0aGlzLmV2ZW50ID09PSBcImtleXByZXNzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2RlICYmIGV2ZW50LmNvZGUgIT09IHRoaXMuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMua2V5ICYmIGV2ZW50LmtleSAhPT0gdGhpcy5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cblxuICAgIGFic3RyYWN0IG1ha2VBY3Rpb24oZXZlbnQgOiBFdmVudCk6IEFjdGlvbiB8IHVuZGVmaW5lZDtcblxuICAgIGFic3RyYWN0IGFjdGlvblRvRWxlbWVudHMoYWN0aW9uOiBBY3Rpb24pOiAoSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50KVtdIDtcblxuICAgIGZpbmRBY3Rpb25NYXBwZWRUYXJnZXQoZXZlbnQ6IEV2ZW50KTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImFpZmV4X3N0eWxlXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNsb3Nlc3QgPSB0YXJnZXQuY2xvc2VzdChcIlthaWZleF9zdHlsZV1cIik7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3QgJiYgKGNsb3Nlc3QgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBjbG9zZXN0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmluZE1hdGNoZWRFbGVtZW50cygpIDogKEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpW117XG4gICAgICAgIGxldCBjb250ZXh0O1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRYUGF0aCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkb2N1bWVudC5ldmFsdWF0ZSh0aGlzLmNvbnRleHRYUGF0aCwgZG9jdW1lbnQsIG51bGwsIFhQYXRoUmVzdWx0LkFOWV9UWVBFLCBudWxsKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gcmVzdWx0Lml0ZXJhdGVOZXh0KCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb250ZXh0Q1NTKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmNvbnRleHRDU1MpO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVsZW1lbnRzID0gW107XG4gICAgICAgIGlmICh0aGlzLnhwYXRoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZG9jdW1lbnQuZXZhbHVhdGUodGhpcy54cGF0aCwgY29udGV4dCwgbnVsbCwgWFBhdGhSZXN1bHQuQU5ZX1RZUEUsIG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRvY3VtZW50LmV2YWx1YXRlKHRoaXMueHBhdGgsIGRvY3VtZW50LCBudWxsLCBYUGF0aFJlc3VsdC5BTllfVFlQRSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBub2RlID0gcmVzdWx0Lml0ZXJhdGVOZXh0KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHJlc3VsdC5pdGVyYXRlTmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICBpZiAodGhpcy5jc3MpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSBxdWVyeVNlbGVjdG9yQWxsRGVlcCh0aGlzLmNzcywgY29udGV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gcXVlcnlTZWxlY3RvckFsbERlZXAodGhpcy5jc3MpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcigoZWxlbWVudCA6IE5vZGUpOiBlbGVtZW50IGlzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCA9PiBlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xuICAgIH1cblxufSIsImltcG9ydCBDb250ZXh0TWFwcGVyIGZyb20gXCIuL0NvbnRleHRNYXBwZXJcIjtcbmltcG9ydCBSdWxlIGZyb20gXCIuL1J1bGVcIjtcbmltcG9ydCBVUkxDb250ZXh0TWFwcGVyIGZyb20gXCIuL1VSTENvbnRleHRNYXBwZXJcIjtcbmltcG9ydCBYUGF0aENvbnRleHRNYXBwZXIgZnJvbSBcIi4vWFBhdGhDb250ZXh0TWFwcGVyXCI7XG5pbXBvcnQgQ29udGV4dExlc3NNYXBwZXIgZnJvbSBcIi4vQ29udGV4dExlc3NNYXBwZXJcIjtcbmltcG9ydCBDU1NDb250ZXh0TWFwcGVyIGZyb20gXCIuL0NTU0NvbnRleHRNYXBwZXJcIjtcbmltcG9ydCB7bG9nZ2VyfSBmcm9tIFwiLi4vZnJhbWV3b3JrL0xvZ2dlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTWFwcGVyIHtcbiAgICBwcml2YXRlIF9jc3NDb250ZXh0MkNvbnRleHRNYXBwZXIgOiBNYXA8c3RyaW5nLCBDb250ZXh0TWFwcGVyPjtcbiAgICBwcml2YXRlIF94cGF0aENvbnRleHQyQ29udGV4dE1hcHBlciA6IE1hcDxzdHJpbmcsIENvbnRleHRNYXBwZXI+O1xuICAgIHByaXZhdGUgX3VybENvbnRleHQyQ29udGV4dE1hcHBlciA6IE1hcDxzdHJpbmcsIENvbnRleHRNYXBwZXI+O1xuICAgIHByaXZhdGUgX2NvbnRleHRMZXNzTWFwcGVyIDogQ29udGV4dExlc3NNYXBwZXI7XG4gICAgcHJpdmF0ZSBfcHJlZml4MlJ1bGVzIDogTWFwPHN0cmluZywgUnVsZVtdPjtcbiAgICBwcml2YXRlIF9ldmVudEluUnVsZXMgOiBzdHJpbmdbXTtcbiAgICBwdWJsaWMgcnVsZXM6IFJ1bGVbXTtcblxuICAgIGNvbnN0cnVjdG9yKHJ1bGVzIDogUnVsZVtdKSB7XG4gICAgICAgIHRoaXMuX2Nzc0NvbnRleHQyQ29udGV4dE1hcHBlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5feHBhdGhDb250ZXh0MkNvbnRleHRNYXBwZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3VybENvbnRleHQyQ29udGV4dE1hcHBlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY29udGV4dExlc3NNYXBwZXIgPSBuZXcgQ29udGV4dExlc3NNYXBwZXIoKTtcbiAgICAgICAgdGhpcy5fcHJlZml4MlJ1bGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ldmVudEluUnVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuXG4gICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICBsZXQgcnVsZXM0UHJlZml4ID0gdGhpcy5fcHJlZml4MlJ1bGVzLmdldChydWxlLnByZWZpeCk7XG4gICAgICAgICAgICBpZiAoISBydWxlczRQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBydWxlczRQcmVmaXggPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVmaXgyUnVsZXMuc2V0KHJ1bGUucHJlZml4LHJ1bGVzNFByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydWxlczRQcmVmaXgucHVzaChydWxlKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ldmVudEluUnVsZXMuaW5jbHVkZXMocnVsZS5ldmVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEluUnVsZXMucHVzaChydWxlLmV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJ1bGUuY29udGV4dENTUykge1xuICAgICAgICAgICAgICAgIGxldCBjb250ZXh0TWFwcGVyNENzc0NvbnRleHQgPSB0aGlzLl9jc3NDb250ZXh0MkNvbnRleHRNYXBwZXIuZ2V0KHJ1bGUuY29udGV4dENTUyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0TWFwcGVyNENzc0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dE1hcHBlcjRDc3NDb250ZXh0ID0gbmV3IENTU0NvbnRleHRNYXBwZXIocnVsZS5jb250ZXh0Q1NTKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jc3NDb250ZXh0MkNvbnRleHRNYXBwZXIuc2V0KHJ1bGUuY29udGV4dENTUywgY29udGV4dE1hcHBlcjRDc3NDb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dE1hcHBlcjRDc3NDb250ZXh0LmFkZChydWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocnVsZS5jb250ZXh0WFBhdGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29udGV4dE1hcHBlcjRYcGF0aENvbnRleHQgPSB0aGlzLl94cGF0aENvbnRleHQyQ29udGV4dE1hcHBlci5nZXQocnVsZS5jb250ZXh0WFBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICghY29udGV4dE1hcHBlcjRYcGF0aENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dE1hcHBlcjRYcGF0aENvbnRleHQgPSBuZXcgWFBhdGhDb250ZXh0TWFwcGVyKHJ1bGUuY29udGV4dFhQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feHBhdGhDb250ZXh0MkNvbnRleHRNYXBwZXIuc2V0KHJ1bGUuY29udGV4dFhQYXRoLCBjb250ZXh0TWFwcGVyNFhwYXRoQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHRNYXBwZXI0WHBhdGhDb250ZXh0LmFkZChydWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocnVsZS5jb250ZXh0VVJMKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRleE1hcHBlcjRVUkxDb250ZXh0ID0gdGhpcy5fdXJsQ29udGV4dDJDb250ZXh0TWFwcGVyLmdldChydWxlLmNvbnRleHRVUkwpO1xuICAgICAgICAgICAgICAgIGlmICghY29udGV4TWFwcGVyNFVSTENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4TWFwcGVyNFVSTENvbnRleHQgPSBuZXcgVVJMQ29udGV4dE1hcHBlcihydWxlLmNvbnRleHRVUkwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cmxDb250ZXh0MkNvbnRleHRNYXBwZXIuc2V0KHJ1bGUuY29udGV4dFVSTCwgY29udGV4TWFwcGVyNFVSTENvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXhNYXBwZXI0VVJMQ29udGV4dC5hZGQocnVsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRMZXNzTWFwcGVyLmFkZChydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBnZXRJc0xvYWRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWZpeDJSdWxlcy5zaXplID4gMDtcbiAgICB9XG5cbiAgICBnZXRSdWxlTGlzdEJ5UHJlZml4KHByZWZpeCA6IHN0cmluZykgOiBSdWxlW10ge1xuICAgICAgICBsZXQgcnVsZXM0cHJlZmlzID0gdGhpcy5fcHJlZml4MlJ1bGVzLmdldChwcmVmaXgpO1xuICAgICAgICBpZiAocnVsZXM0cHJlZmlzKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVsZXM0cHJlZmlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGV2ZW50SW5SdWxlcygpOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudEluUnVsZXM7XG4gICAgfVxuXG4gICAgYnVpbGRFbGVtZW50VG9SdWxlTWFwKCk6IE1hcDxIVE1MRWxlbWVudHxTVkdFbGVtZW50LCBSdWxlW10+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0IDogTWFwPEhUTUxFbGVtZW50fFNWR0VsZW1lbnQsIFJ1bGVbXT4gPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgbWFwcGVyIG9mIHRoaXMuX3VybENvbnRleHQyQ29udGV4dE1hcHBlci52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZWxlbWVudCwgcnVsZXNdIG9mIG1hcHBlci5idWlsZEVsZW1lbnRUb1J1bGVNYXAoKSkge1xuICAgICAgICAgICAgICAgIGxldCBydWxlczRlbGVtZW50ID0gcmVzdWx0LmdldChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGVzNGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM0ZWxlbWVudCA9IFtdXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoZWxlbWVudCxydWxlczRlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVsZXM0ZWxlbWVudC5wdXNoKC4uLnJ1bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1hcHBlciBvZiB0aGlzLl9jc3NDb250ZXh0MkNvbnRleHRNYXBwZXIudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2VsZW1lbnQsIHJ1bGVzXSBvZiBtYXBwZXIuYnVpbGRFbGVtZW50VG9SdWxlTWFwKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXM0ZWxlbWVudCA9IHJlc3VsdC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFydWxlczRlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzNGVsZW1lbnQgPSBbXVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGVsZW1lbnQscnVsZXM0ZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bGVzNGVsZW1lbnQucHVzaCguLi5ydWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtYXBwZXIgb2YgdGhpcy5feHBhdGhDb250ZXh0MkNvbnRleHRNYXBwZXIudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2VsZW1lbnQsIHJ1bGVzXSBvZiBtYXBwZXIuYnVpbGRFbGVtZW50VG9SdWxlTWFwKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXM0ZWxlbWVudCA9IHJlc3VsdC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFydWxlczRlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzNGVsZW1lbnQgPSBbXVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGVsZW1lbnQscnVsZXM0ZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bGVzNGVsZW1lbnQucHVzaCguLi5ydWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbZWxlbWVudCwgcnVsZXNdIG9mIHRoaXMuX2NvbnRleHRMZXNzTWFwcGVyLmJ1aWxkRWxlbWVudFRvUnVsZU1hcCgpKSB7XG4gICAgICAgICAgICBsZXQgcnVsZXM0ZWxlbWVudCA9IHJlc3VsdC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoIXJ1bGVzNGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBydWxlczRlbGVtZW50ID0gW11cbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGVsZW1lbnQscnVsZXM0ZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydWxlczRlbGVtZW50LnB1c2goLi4ucnVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG59IiwiaW1wb3J0IFJ1bGUgZnJvbSBcIi4vUnVsZVwiO1xuaW1wb3J0IEFjdGlvbiBmcm9tIFwiLi9BY3Rpb25cIjtcbmltcG9ydCBSdWxlTWFwcGVyIGZyb20gXCIuL1J1bGVNYXBwZXJcIjtcbmltcG9ydCBJbmRleFJ1bGUgZnJvbSBcIi4vSW5kZXhSdWxlXCI7XG5pbXBvcnQgSW5uZXJUZXh0UnVsZSBmcm9tIFwiLi9Jbm5lclRleHRSdWxlXCI7XG5pbXBvcnQgVmFsdWVSdWxlIGZyb20gXCIuL1ZhbHVlUnVsZVwiO1xuaW1wb3J0IFNpbXBsZVJ1bGUgZnJvbSBcIi4vU2ltcGxlUnVsZVwiO1xuaW1wb3J0IENTU1NlbGVjdG9yUnVsZSBmcm9tIFwiLi9DU1NTZWxlY3RvclJ1bGVcIjtcbmltcG9ydCBBdHRyaWJ1dGVWYWx1ZVJ1bGUgZnJvbSBcIi4vQXR0cmlidXRlVmFsdWVSdWxlXCI7XG5pbXBvcnQgQ1NTU2VsZWN0b3JXaXRoVmFsdWVSdWxlIGZyb20gXCIuL0NTU1NlbGVjdG9yV2l0aFZhbHVlUnVsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlU2VydmljZSB7XG4gICAgZWxlbWVudFJ1bGVzOiBNYXA8SFRNTEVsZW1lbnR8U1ZHRWxlbWVudCwgUnVsZVtdPjtcbiAgICBwcml2YXRlIF9ydWxlTWFwcGVyIDogUnVsZU1hcHBlcjtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRSdWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcnVsZU1hcHBlciA9IG5ldyBSdWxlTWFwcGVyKFtdKTtcbiAgICB9XG5cbiAgICBnZXQgZWxlbWVudExpc3RNYXRjaGVkQnlSdWxlKCk6IChIVE1MRWxlbWVudHxTVkdFbGVtZW50KVtdIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbGVtZW50UnVsZXMua2V5cygpKVxuICAgIH1cblxuICAgIGdldEV2ZW50c1RvSGFuZGxlKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVNYXBwZXIuZXZlbnRJblJ1bGVzO1xuICAgIH1cblxuICAgIGxvYWRSdWxlcyhydWxlcyA6IFJ1bGVbXSk6dm9pZCB7XG4gICAgICAgIHRoaXMuX3J1bGVNYXBwZXIgPSBuZXcgUnVsZU1hcHBlcihydWxlcyk7XG4gICAgfVxuXG4gICAgbWFwUnVsZXNUb0VsZW1lbnRzKCk6dm9pZCB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJ1bGVzID0gdGhpcy5fcnVsZU1hcHBlci5idWlsZEVsZW1lbnRUb1J1bGVNYXAoKTtcbiAgICB9XG5cbiAgICBnZXRNYXRjaGluZ1J1bGUoZXZlbnQgOiBFdmVudCApOiBSdWxlIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gZXZlbnQuY29tcG9zZWRQYXRoKCkuZmlsdGVyKCh0YXJnZXQpOiB0YXJnZXQgaXMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50ID0+IHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gdGhpcy5lbGVtZW50UnVsZXMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHJ1bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ1J1bGUgPSBydWxlcy5maW5kKChydWxlKSA9PiBydWxlLm1hdGNoKGV2ZW50KSlcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdSdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1J1bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UnVsZUxpc3RCeUFjdGlvbihhY3Rpb246IEFjdGlvbik6IFJ1bGVbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydWxlTWFwcGVyLmdldFJ1bGVMaXN0QnlQcmVmaXgoYWN0aW9uLnByZWZpeCk7XG4gICAgfVxuXG4gICAgZ2V0SFRNTEVsZW1lbnRzTWF0Y2hlZEJ5QWN0aW9uKGFjdGlvbjogQWN0aW9uKTogKEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpW10ge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA6IFNldDxIVE1MRWxlbWVudHxTVkdFbGVtZW50PiA9IG5ldyBTZXQoKTtcbiAgICAgICAgYWN0aW9uLnJ1bGVMaXN0LmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50TGlzdEZvclJ1bGUgPSBydWxlLmFjdGlvblRvRWxlbWVudHMoYWN0aW9uKTtcbiAgICAgICAgICAgIGVsZW1lbnRMaXN0Rm9yUnVsZS5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudHMuYWRkKGVsZW1lbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbLi4uZWxlbWVudHMudmFsdWVzKCldO1xuICAgIH1cblxuICAgIGNyZWF0ZVJ1bGUoZGF0YSA6IHtcbiAgICAgICAgb3V0cHV0IDoge1xuICAgICAgICAgICAgcHJlZml4IDogc3RyaW5nLFxuICAgICAgICAgICAgc3VmZml4PyA6IHN0cmluZyxcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2ggOiB7XG4gICAgICAgICAgICBldmVudCA6IHN0cmluZyxcbiAgICAgICAgICAgIGNzcz8gOiBzdHJpbmcsXG4gICAgICAgICAgICB4cGF0aD8gOiBzdHJpbmcsXG4gICAgICAgICAgICBjb2RlPyA6IHN0cmluZyxcbiAgICAgICAgICAgIGtleT8gOiBzdHJpbmcsXG4gICAgICAgICAgICBhdHRyaWJ1dGVOYW1lPzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRleHQ/IDoge1xuICAgICAgICAgICAgdXJsPyA6IHN0cmluZyxcbiAgICAgICAgICAgIGNzcz8gOiBzdHJpbmcsXG4gICAgICAgICAgICB4cGF0aD8gOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgZGVzY3JpcHRpb24gOiBzdHJpbmdcbiAgICB9KSA6IFJ1bGUge1xuICAgICAgICBzd2l0Y2ggKGRhdGEub3V0cHV0LnN1ZmZpeCkge1xuICAgICAgICAgICAgY2FzZSBcImlubmVyVGV4dFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW5uZXJUZXh0UnVsZShkYXRhLm91dHB1dC5wcmVmaXgsZGF0YS5vdXRwdXQ/LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgY2FzZSBcImluZGV4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmRleFJ1bGUoZGF0YS5vdXRwdXQucHJlZml4LGRhdGEub3V0cHV0LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZVJ1bGUoZGF0YS5vdXRwdXQucHJlZml4LGRhdGEub3V0cHV0LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgY2FzZSBcImNzc1NlbGVjdG9yXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDU1NTZWxlY3RvclJ1bGUoZGF0YS5vdXRwdXQucHJlZml4LGRhdGEub3V0cHV0LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgY2FzZSBcImNzc1NlbGVjdG9yV2l0aFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDU1NTZWxlY3RvcldpdGhWYWx1ZVJ1bGUoZGF0YS5vdXRwdXQucHJlZml4LGRhdGEub3V0cHV0LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgY2FzZSBcImF0dHJpYnV0ZVZhbHVlXCI6XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubWF0Y2guYXR0cmlidXRlTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2ltcGxlUnVsZShkYXRhLm91dHB1dC5wcmVmaXgsZGF0YS5vdXRwdXQuc3VmZml4LCBkYXRhLm1hdGNoLmV2ZW50LCBkYXRhLm1hdGNoPy5jc3MsIGRhdGEubWF0Y2g/LnhwYXRoLCBkYXRhLm1hdGNoPy5jb2RlLCBkYXRhLm1hdGNoPy5rZXksIGRhdGE/LmNvbnRleHQ/LnVybCwgZGF0YT8uY29udGV4dD8uY3NzLCBkYXRhPy5jb250ZXh0Py54cGF0aCwgZGF0YS5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVWYWx1ZVJ1bGUoZGF0YS5vdXRwdXQucHJlZml4LGRhdGEub3V0cHV0LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24sIGRhdGEubWF0Y2guYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVJ1bGUoZGF0YS5vdXRwdXQucHJlZml4LGRhdGEub3V0cHV0LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG5cbiAgICB9XG5cblxufSIsIlxuZXhwb3J0IHR5cGUgT3ZlcmxheVR5cGUgPSBcInJhaW5ib3dcIiB8IFwiYmx1ZXNreVwiIHwgXCJzaGFkb3dcIjtcbmV4cG9ydCB0eXBlIFJlY29yZGluZ01vZGUgPSBcImJ5ZXhwbG9yYXRpb25cIiB8IFwiYnlpbnRlcmFjdGlvblwiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Vzc2lvbiB7XG4gICAgcmVhZG9ubHkgaWQgOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgd2ViU2l0ZUlkIDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IGJhc2VVUkw6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBuYW1lIDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IGRlc2NyaXB0aW9uIDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHJlYWRvbmx5IG92ZXJsYXlUeXBlOiBPdmVybGF5VHlwZTtcbiAgICByZWFkb25seSByZWNvcmRpbmdNb2RlOiBSZWNvcmRpbmdNb2RlO1xuXG4gICAgY29uc3RydWN0b3IoaWQ6IHN0cmluZywgd2ViU2l0ZUlkOiBzdHJpbmcsIGJhc2VVUkw6c3RyaW5nIHwgdW5kZWZpbmVkLCBuYW1lIDogc3RyaW5nLCBkZXNjcmlwdGlvbiA6IHN0cmluZywgb3ZlcmxheVR5cGU6IE92ZXJsYXlUeXBlLCByZWNvcmRpbmdNb2RlOiBSZWNvcmRpbmdNb2RlKSB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCB8fCBpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjcmVhdGUgU2Vzc2lvbiB3aXRob3V0IGlkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlYlNpdGVJZCA9PT0gbnVsbCB8fCB3ZWJTaXRlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY3JlYXRlIFNlc3Npb24gd2l0aG91dCB3ZWJTaXRlSWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMud2ViU2l0ZUlkID0gd2ViU2l0ZUlkO1xuICAgICAgICB0aGlzLmJhc2VVUkwgPSBiYXNlVVJMO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMub3ZlcmxheVR5cGUgPSBvdmVybGF5VHlwZTsgICAgICAgIFxuICAgICAgICB0aGlzLnJlY29yZGluZ01vZGUgPSByZWNvcmRpbmdNb2RlO1xuICAgIH1cblxufSIsImltcG9ydCBBY3Rpb24gZnJvbSAnLi9BY3Rpb24nO1xuaW1wb3J0IFJ1bGUgZnJvbSAnLi9SdWxlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2ltcGxlUnVsZSBleHRlbmRzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeDogc3RyaW5nLCBzdWZmaXg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IHN0cmluZywgY3NzOiBzdHJpbmcgfCB1bmRlZmluZWQsIHhwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCwga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRVUkw6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dENTUzogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0WFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgICAgICBzdXBlcihwcmVmaXgsIHN1ZmZpeCwgZXZlbnQsIGNzcywgeHBhdGgsIGNvZGUsIGtleSwgY29udGV4dFVSTCwgY29udGV4dENTUywgY29udGV4dFhQYXRoLCBkZXNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgbWFrZUFjdGlvbihldmVudCA6IEV2ZW50KTogQWN0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24odGhpcy5wcmVmaXgpO1xuICAgIH1cblxuICAgIGFjdGlvblRvRWxlbWVudHMoYWN0aW9uOiBBY3Rpb24pOiAoSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50KVtdIHtcbiAgICAgICAgaWYgKGFjdGlvbi5wcmVmaXggIT09IHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmZpbmRNYXRjaGVkRWxlbWVudHMoKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cbn1cbiIsImltcG9ydCBDb250ZXh0TWFwcGVyIGZyb20gXCIuL0NvbnRleHRNYXBwZXJcIjtcbmltcG9ydCBSdWxlIGZyb20gXCIuL1J1bGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVVJMQ29udGV4dE1hcHBlciBleHRlbmRzIENvbnRleHRNYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQgOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgfVxuXG4gICAgYnVpbGRFbGVtZW50VG9SdWxlTWFwKCkgOiBNYXA8SFRNTEVsZW1lbnR8U1ZHRWxlbWVudCwgUnVsZVtdPiB7XG4gICAgICAgIGlmICh0aGlzLl9jb250ZXh0ICYmIGRvY3VtZW50LlVSTC5zdGFydHNXaXRoKHRoaXMuX2NvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEVsZW1lbnRUb1J1bGVNYXBGb3JTZWxlY3RvcnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IEFjdGlvbiBmcm9tICcuL0FjdGlvbic7XG5pbXBvcnQgU2ltcGxlUnVsZSBmcm9tICcuL1NpbXBsZVJ1bGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWYWx1ZVJ1bGUgZXh0ZW5kcyBTaW1wbGVSdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXg6IHN0cmluZywgc3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQsIGV2ZW50OiBzdHJpbmcsIGNzczogc3RyaW5nIHwgdW5kZWZpbmVkLCB4cGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgICAgICBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGtleTogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0VVJMOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRDU1M6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dFhQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIocHJlZml4LCBzdWZmaXgsIGV2ZW50LCBjc3MsIHhwYXRoLCBjb2RlLCBrZXksIGNvbnRleHRVUkwsIGNvbnRleHRDU1MsIGNvbnRleHRYUGF0aCwgZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIG1ha2VBY3Rpb24oZXZlbnQgOiBFdmVudCk6IEFjdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24odGhpcy5wcmVmaXgsIHRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24odGhpcy5wcmVmaXgsIFwic3ZnXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWN0aW9uVG9FbGVtZW50cyhhY3Rpb246IEFjdGlvbik6IChIVE1MRWxlbWVudHxTVkdFbGVtZW50KVtdIHtcbiAgICAgICAgaWYgKGFjdGlvbi5wcmVmaXggIT09IHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbi5zdWZmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmFjdGlvblRvRWxlbWVudHMoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZmluZE1hdGNoZWRFbGVtZW50cygpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViU2l0ZSB7XG4gICAgcHVibGljIGlkOiBzdHJpbmc7XG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcbiAgICBwdWJsaWMgbWFwcGluZ0xpc3Q6IHttYXRjaDogYW55LCBvdXRwdXQ6IGFueSwgZGVzY3JpcHRpb246IHN0cmluZ31bXTtcblxuICAgIGNvbnN0cnVjdG9yKGlkOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgbWFwcGluZ0xpc3Q6IHttYXRjaDogYW55LCBvdXRwdXQ6IGFueSwgZGVzY3JpcHRpb246IHN0cmluZ31bXSkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubWFwcGluZ0xpc3QgPSBtYXBwaW5nTGlzdDtcbiAgICB9XG59IiwiaW1wb3J0IENvbnRleHRNYXBwZXIgZnJvbSBcIi4vQ29udGV4dE1hcHBlclwiO1xuaW1wb3J0IFJ1bGUgZnJvbSBcIi4vUnVsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBYUGF0aENvbnRleHRNYXBwZXIgZXh0ZW5kcyBDb250ZXh0TWFwcGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0IDogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgIH1cblxuICAgIGJ1aWxkRWxlbWVudFRvUnVsZU1hcCgpIDogTWFwPEhUTUxFbGVtZW50fFNWR0VsZW1lbnQsIFJ1bGVbXT4ge1xuICAgICAgICBpZiAodGhpcy5fY29udGV4dCkge1xuXG4gICAgICAgICAgICBjb25zdCB4cGF0aFF1ZXJ5UmVzdWx0ID0gZG9jdW1lbnQuZXZhbHVhdGUodGhpcy5fY29udGV4dCwgZG9jdW1lbnQsIG51bGwsIFhQYXRoUmVzdWx0LkFOWV9UWVBFLCBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB4cGF0aFF1ZXJ5UmVzdWx0Lml0ZXJhdGVOZXh0KCk7XG4gICAgICAgICAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IGNvbnRleHQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRFbGVtZW50VG9SdWxlTWFwRm9yU2VsZWN0b3JzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgICB9ICAgXG4gICAgfVxufSIsImltcG9ydCB7Q2F0ZWdvcnksQ2F0ZWdvcnlMb2dnZXIsQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeSxDYXRlZ29yeUNvbmZpZ3VyYXRpb24sTG9nTGV2ZWx9IGZyb20gXCJ0eXBlc2NyaXB0LWxvZ2dpbmdcIjtcbiBcbi8vIE9wdGlvbmFsbHkgY2hhbmdlIGRlZmF1bHQgc2V0dGluZ3MsIGluIHRoaXMgZXhhbXBsZSBzZXQgZGVmYXVsdCBsb2dnaW5nIHRvIEluZm8uXG4vLyBXaXRob3V0IGNoYW5naW5nIGNvbmZpZ3VyYXRpb24sIGNhdGVnb3JpZXMgd2lsbCBsb2cgdG8gRXJyb3IuXG5cbmxldCBsb2dMZXZlbDtcblxuc3dpdGNoKHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgY2FzZSAncHJvZHVjdGlvbic6XG4gICAgICAgIGxvZ0xldmVsID0gTG9nTGV2ZWwuRXJyb3I7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldmVsb3BtZW50JzogXG4gICAgICAgIGxvZ0xldmVsID0gTG9nTGV2ZWwuRGVidWc7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2dpdGh1Yic6XG4gICAgICAgIGxvZ0xldmVsID0gTG9nTGV2ZWwuRXJyb3I7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IFxuICAgICAgICBsb2dMZXZlbCA9IExvZ0xldmVsLkVycm9yXG59XG5cbkNhdGVnb3J5U2VydmljZUZhY3Rvcnkuc2V0RGVmYXVsdENvbmZpZ3VyYXRpb24obmV3IENhdGVnb3J5Q29uZmlndXJhdGlvbihsb2dMZXZlbCkpO1xuIFxuLy8gQ3JlYXRlIGNhdGVnb3JpZXMsIHRoZXkgd2lsbCBhdXRvcmVnaXN0ZXIgdGhlbXNlbHZlcywgb25lIGNhdGVnb3J5IHdpdGhvdXQgcGFyZW50IChyb290KSBhbmQgYSBjaGlsZCBjYXRlZ29yeS5cbmV4cG9ydCBjb25zdCBsb2dnZXIgPSBuZXcgQ2F0ZWdvcnkoXCJUYWJTY3JpcHRcIik7XG4iLCJpbXBvcnQgQnJvd3NlclNjcmlwdCBmcm9tIFwiLi9kb21haW4vQnJvd3NlclNjcmlwdFwiO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gXCIuL2ZyYW1ld29yay9Mb2dnZXJcIjtcbmltcG9ydCBBaWZleFNlcnZpY2VIVFRQIGZyb20gXCIuL19pbmZyYS9BaWZleFNlcnZpY2VIVFRQXCI7XG5pbXBvcnQgQnJvd3NlclNlcnZpY2VMb2NhbFN0b3JhZ2UgZnJvbSBcIi4vX2luZnJhL0Jyb3dzZXJTZXJ2aWNlTG9jYWxTdG9yYWdlXCI7XG5pbXBvcnQgQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZSBmcm9tIFwiLi9faW5mcmEvQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZVwiO1xuXG5sb2dnZXIuaW5mbyhcIkFJRkVYIHNjcmlwdCBpcyBydW5uaW5nLlwiKTtcblxuY29uc3QgQUlGRVhfU0NSSVBUID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJBSUZFWFwiKTtcbmlmIChBSUZFWF9TQ1JJUFQpIHtcbiAgICBsb2dnZXIuaW5mbyhcIkFJRkVYIFNDUklQVCBFbGVtZW50IGlzIGZvdW5kLlwiKTtcbiAgICBjb25zdCBDT05ORVhJT05fVVJMID0gQUlGRVhfU0NSSVBULmdldEF0dHJpYnV0ZShcImNvbm5leGlvbi11cmxcIik7XG4gICAgaWYgKENPTk5FWElPTl9VUkwpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCJBSUZFWCBjb25uZXhpb24tdXJsIEVsZW1lbnQgaXMgZm91bmQuXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgQUlGRVhfVVJMID0gbmV3IFVSTChDT05ORVhJT05fVVJMKTtcblx0XHRcdGxldCBzZXNzaW9uSWQgPSBBSUZFWF9VUkwuc2VhcmNoUGFyYW1zLmdldCgnc2Vzc2lvbklkJyk7XG5cdFx0XHRpZiAoc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJBSUZFWCBzZXNzaW9uSWQgaXMgZm91bmQuXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEFJRkVYX1NFUlZJQ0UgPSBuZXcgQWlmZXhTZXJ2aWNlSFRUUCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEJST1dTRVJfU0VSVklDRSA9IG5ldyBCcm93c2VyU2VydmljZVNlc3Npb25TdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgQlJPV1NFUl9TQ1JJUFQgPSBuZXcgQnJvd3NlclNjcmlwdChBSUZFWF9VUkwub3JpZ2luLCBzZXNzaW9uSWQsIHVuZGVmaW5lZCwgQUlGRVhfU0VSVklDRSwgQlJPV1NFUl9TRVJWSUNFKTtcbiAgICAgICAgICAgICAgICBCUk9XU0VSX1NDUklQVC5zdGFydCgpO1x0XG5cdFx0XHR9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgY29ubmV4aW9uIFVSTFwiLCBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbm5leGlvbiBVUkxcIikpO1xuICAgICAgICB9XG4gICAgfVxufSBlbHNlIHtcbiAgICBsb2dnZXIuZXJyb3IoXCJBSUZFWCBTQ1JJUFQgRWxlbWVudCBpcyBub3QgZm91bmQuXCIsIG5ldyBFcnJvcihcIkFJRkVYIFNDUklQVCBFbGVtZW50IGlzIG5vdCBmb3VuZC5cIikpO1xufVxuXG4vLyA8c2NyaXB0IGlkPVwiQUlGRVhcIiBjb25uZXhpb24tdXJsPVwiaHR0cHM6Ly9haWZleC5jb20vYWlmZXgvY29ubmV4aW9uP3Nlc3Npb25JZD1hMWIyYzNkNGU1ZjZnN2g4aTlqMFwiIHNyYz1cImh0dHBzOi8vYWlmZXguY29tL2FpZmV4L3NjcmlwdC9haWZleC5qc1wiPjwvc2NyaXB0PiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENhdGVnb3J5U2VydmljZV8xID0gcmVxdWlyZShcIi4uL2xvZy9jYXRlZ29yeS9DYXRlZ29yeVNlcnZpY2VcIik7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL2xvZy9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIERhdGFTdHJ1Y3R1cmVzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvRGF0YVN0cnVjdHVyZXNcIik7XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIGNsYXNzIGZvciBDYXRlZ29yeVNlcnZpY2VDb250cm9sLlxuICovXG52YXIgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsKCkge1xuICAgIH1cbiAgICBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5wcm90b3R5cGUuaGVscCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmxvZyhDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5faGVscCk7XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwucHJvdG90eXBlLmV4YW1wbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2coQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2V4YW1wbGUpO1xuICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLnByb3RvdHlwZS5zaG93U2V0dGluZ3MgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSB2b2lkIDApIHsgaWQgPSBcImFsbFwiOyB9XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIHZhciBzZXJ2aWNlID0gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2dldENhdGVnb3J5U2VydmljZSgpO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9nZXRDYXRlZ29yaWVzKGlkKTtcbiAgICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICAgICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX3Byb2Nlc3NDYXRlZ29yeShzZXJ2aWNlLCBjYXRlZ29yeSwgcmVzdWx0LCAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0LnRvU3RyaW5nKCkpO1xuICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLnByb3RvdHlwZS5jaGFuZ2UgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIHNlcnZpY2UgPSBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fZ2V0Q2F0ZWdvcnlTZXJ2aWNlKCk7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2dldENhdGVnb3JpZXMoc2V0dGluZ3MuY2F0ZWdvcnkpO1xuICAgICAgICB2YXIgbG9nTGV2ZWwgPSBudWxsO1xuICAgICAgICB2YXIgZm9ybWF0RW51bSA9IG51bGw7XG4gICAgICAgIHZhciBzaG93Q2F0ZWdvcnlOYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIHNob3dUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdmFyIGFkZFJlc3VsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiwgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFkZFJlc3VsdChcInJlY3Vyc2l2ZT1cIiArIHNldHRpbmdzLnJlY3Vyc2l2ZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MubG9nTGV2ZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxvZ0xldmVsID0gTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLmZyb21TdHJpbmcoc2V0dGluZ3MubG9nTGV2ZWwpO1xuICAgICAgICAgICAgYWRkUmVzdWx0KFwibG9nTGV2ZWw9XCIgKyBzZXR0aW5ncy5sb2dMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5sb2dGb3JtYXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdEVudW0gPSBMb2dnZXJPcHRpb25zXzEuRGF0ZUZvcm1hdEVudW0uZnJvbVN0cmluZyhzZXR0aW5ncy5sb2dGb3JtYXQpO1xuICAgICAgICAgICAgYWRkUmVzdWx0KFwibG9nRm9ybWF0PVwiICsgc2V0dGluZ3MubG9nRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnNob3dDYXRlZ29yeU5hbWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBzaG93Q2F0ZWdvcnlOYW1lID0gc2V0dGluZ3Muc2hvd0NhdGVnb3J5TmFtZTtcbiAgICAgICAgICAgIGFkZFJlc3VsdChcInNob3dDYXRlZ29yeU5hbWU9XCIgKyBzZXR0aW5ncy5zaG93Q2F0ZWdvcnlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnNob3dUaW1lc3RhbXAgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBzaG93VGltZXN0YW1wID0gc2V0dGluZ3Muc2hvd1RpbWVzdGFtcDtcbiAgICAgICAgICAgIGFkZFJlc3VsdChcInNob3dUaW1lc3RhbXA9XCIgKyBzZXR0aW5ncy5zaG93VGltZXN0YW1wKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXBwbHlDaGFuZ2VzID0gZnVuY3Rpb24gKGNhdCkge1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5U2V0dGluZ3MgPSBzZXJ2aWNlLmdldENhdGVnb3J5U2V0dGluZ3MoY2F0KTtcbiAgICAgICAgICAgIC8vIFNob3VsZCBub3QgaGFwcGVuIGJ1dCBtYWtlIHRzbGludCBoYXBweVxuICAgICAgICAgICAgaWYgKGNhdGVnb3J5U2V0dGluZ3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nTGV2ZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlTZXR0aW5ncy5sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0RW51bSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeVNldHRpbmdzLmxvZ0Zvcm1hdC5kYXRlRm9ybWF0LmZvcm1hdEVudW0gPSBmb3JtYXRFbnVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvd1RpbWVzdGFtcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeVNldHRpbmdzLmxvZ0Zvcm1hdC5zaG93VGltZVN0YW1wID0gc2hvd1RpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNob3dDYXRlZ29yeU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlTZXR0aW5ncy5sb2dGb3JtYXQuc2hvd0NhdGVnb3J5TmFtZSA9IHNob3dDYXRlZ29yeU5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjYXRlZ29yaWVzLmZvckVhY2goZnVuY3Rpb24gKGNhdCkgeyByZXR1cm4gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2FwcGx5VG9DYXRlZ29yeShjYXQsIHNldHRpbmdzLnJlY3Vyc2l2ZSwgYXBwbHlDaGFuZ2VzKTsgfSk7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2coXCJBcHBsaWVkIGNoYW5nZXM6IFwiICsgcmVzdWx0ICsgXCIgdG8gY2F0ZWdvcmllcyAnXCIgKyBzZXR0aW5ncy5jYXRlZ29yeSArIFwiJy5cIik7XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gdm9pZCAwKSB7IGlkID0gXCJhbGxcIjsgfVxuICAgICAgICB2YXIgc2VydmljZSA9IENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9nZXRDYXRlZ29yeVNlcnZpY2UoKTtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fZ2V0Q2F0ZWdvcmllcyhpZCk7XG4gICAgICAgIHZhciBhcHBseUNoYW5nZXMgPSBmdW5jdGlvbiAoY2F0KSB7XG4gICAgICAgICAgICB2YXIgY2F0ZWdvcnlTZXR0aW5ncyA9IHNlcnZpY2UuZ2V0Q2F0ZWdvcnlTZXR0aW5ncyhjYXQpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gc2VydmljZS5nZXRPcmlnaW5hbENhdGVnb3J5U2V0dGluZ3MoY2F0KTtcbiAgICAgICAgICAgIC8vIFNob3VsZCBub3QgaGFwcGVuIGJ1dCBtYWtlIHRzbGludCBoYXBweVxuICAgICAgICAgICAgaWYgKGNhdGVnb3J5U2V0dGluZ3MgIT09IG51bGwgJiYgb3JpZ2luYWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeVNldHRpbmdzLmxvZ0xldmVsID0gb3JpZ2luYWwubG9nTGV2ZWw7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlTZXR0aW5ncy5sb2dGb3JtYXQuZGF0ZUZvcm1hdC5mb3JtYXRFbnVtID0gb3JpZ2luYWwubG9nRm9ybWF0LmRhdGVGb3JtYXQuZm9ybWF0RW51bTtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeVNldHRpbmdzLmxvZ0Zvcm1hdC5zaG93VGltZVN0YW1wID0gb3JpZ2luYWwubG9nRm9ybWF0LnNob3dUaW1lU3RhbXA7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlTZXR0aW5ncy5sb2dGb3JtYXQuc2hvd0NhdGVnb3J5TmFtZSA9IG9yaWdpbmFsLmxvZ0Zvcm1hdC5zaG93Q2F0ZWdvcnlOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjYXRlZ29yaWVzLmZvckVhY2goZnVuY3Rpb24gKGNhdCkgeyByZXR1cm4gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2FwcGx5VG9DYXRlZ29yeShjYXQsIHRydWUsIGFwcGx5Q2hhbmdlcyk7IH0pO1xuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXBwbGllZCByZXNldCB0byBjYXRlZ29yeTogXCIgKyBpZCArIFwiLlwiKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fcHJvY2Vzc0NhdGVnb3J5ID0gZnVuY3Rpb24gKHNlcnZpY2UsIGNhdGVnb3J5LCByZXN1bHQsIGluZGVudCkge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBzZXJ2aWNlLmdldENhdGVnb3J5U2V0dGluZ3MoY2F0ZWdvcnkpO1xuICAgICAgICBpZiAoc2V0dGluZ3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoXCIgIFwiICsgY2F0ZWdvcnkuaWQgKyBcIjogXCIpO1xuICAgICAgICAgICAgaWYgKGluZGVudCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGVudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoXCIgIFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKGNhdGVnb3J5Lm5hbWUgKyBcIiAoXCIgKyBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWxbc2V0dGluZ3MubG9nTGV2ZWxdLnRvU3RyaW5nKCkgKyBcIkBcIiArIExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlW3NldHRpbmdzLmxvZ2dlclR5cGVdLnRvU3RyaW5nKCkgKyBcIilcXG5cIik7XG4gICAgICAgICAgICBpZiAoY2F0ZWdvcnkuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9wcm9jZXNzQ2F0ZWdvcnkoc2VydmljZSwgY2hpbGQsIHJlc3VsdCwgaW5kZW50ICsgMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9hcHBseVRvQ2F0ZWdvcnkgPSBmdW5jdGlvbiAoY2F0ZWdvcnksIHJlY3Vyc2l2ZSwgYXBwbHkpIHtcbiAgICAgICAgYXBwbHkoY2F0ZWdvcnkpO1xuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICBjYXRlZ29yeS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9hcHBseVRvQ2F0ZWdvcnkoY2hpbGQsIHJlY3Vyc2l2ZSwgYXBwbHkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9nZXRDYXRlZ29yeVNlcnZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBDYXRlZ29yeVNlcnZpY2VfMS5DYXRlZ29yeVNlcnZpY2VJbXBsLmdldEluc3RhbmNlKCk7XG4gICAgfTtcbiAgICBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fZ2V0Q2F0ZWdvcmllcyA9IGZ1bmN0aW9uIChpZENhdGVnb3J5KSB7XG4gICAgICAgIHZhciBzZXJ2aWNlID0gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2dldENhdGVnb3J5U2VydmljZSgpO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBpZiAoaWRDYXRlZ29yeSA9PT0gXCJhbGxcIikge1xuICAgICAgICAgICAgY2F0ZWdvcmllcyA9IHNlcnZpY2UuZ2V0Um9vdENhdGVnb3JpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYXRlZ29yeSA9IHNlcnZpY2UuZ2V0Q2F0ZWdvcnlCeUlkKGlkQ2F0ZWdvcnkpO1xuICAgICAgICAgICAgaWYgKGNhdGVnb3J5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZpbmQgY2F0ZWdvcnkgd2l0aCBpZCBcIiArIGlkQ2F0ZWdvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0ZWdvcmllcy5wdXNoKGNhdGVnb3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2F0ZWdvcmllcztcbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9oZWxwID0gXCJcXG4gIGhlbHAoKTogdm9pZFxcbiAgICAqKiBTaG93cyB0aGlzIGhlbHAuXFxuXFxuICBleGFtcGxlKCk6IHZvaWRcXG4gICAgKiogU2hvd3MgYW4gZXhhbXBsZSBvbiBob3cgdG8gdXNlIHRoaXMuXFxuXFxuICBzaG93U2V0dGluZ3MoaWQ6IG51bWJlciB8IFxcXCJhbGxcXFwiID0gXFxcImFsbFxcXCIpOiB2b2lkXFxuICAgICoqIFNob3dzIHNldHRpbmdzIGZvciBhIHNwZWNpZmljIGNhdGVnb3J5LCBvciBmb3IgYWxsLiBUaGUgaWQgb2YgY2F0ZWdvcmllcyBjYW4gYmUgZm91bmQgYnkgY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRob3V0IHBhcmFtZXRlci5cXG5cXG4gIGNoYW5nZShzZXR0aW5nczogQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbFNldHRpbmdzKTogdm9pZFxcbiAgICAqKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHNldHRpbmdzIGZvciBvbmUgb3IgYWxsIGNhdGVnb3JpZXMuXFxuICAgICoqXFxuICAgICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xTZXR0aW5ncywgcHJvcGVydGllcyBvZiBvYmplY3Q6XFxuICAgICAgICAgY2F0ZWdvcnk6IG51bWJlciB8IFxcXCJhbGxcXFwiXFxuICAgICAgICAgICAqKiBBcHBseSB0byBzcGVjaWZpYyBjYXRlZ29yeSwgb3IgXFxcImFsbFxcXCIuXFxuICAgICAgICAgICAqKiBSZXF1aXJlZFxcblxcbiAgICAgICAgIHJlY3Vyc2l2ZTogYm9vbGVhblxcbiAgICAgICAgICAgKiogQXBwbHkgdG8gY2hpbGQgY2F0ZWdvcmllcyAodHJ1ZSkgb3Igbm90LlxcbiAgICAgICAgICAgKiogUmVxdWlyZWRcXG5cXG4gICAgICAgICBsb2dMZXZlbDogXFxcIkZhdGFsXFxcIiB8IFxcXCJFcnJvclxcXCIgfCBcXFwiV2FyblxcXCIgfCBcXFwiSW5mb1xcXCIgfCBcXFwiRGVidWdcXFwiIHwgXFxcIlRyYWNlXFxcIiB8IHVuZGVmaW5lZFxcbiAgICAgICAgICAgKiogU2V0IGxvZyBsZXZlbCwgdW5kZWZpbmVkIHdpbGwgbm90IGNoYW5nZSB0aGUgc2V0dGluZy5cXG4gICAgICAgICAgICoqIE9wdGlvbmFsXFxuXFxuICAgICAgICAgbG9nRm9ybWF0OiBcXFwiRGVmYXVsdFxcXCIgfCBcXFwiWWVhck1vbnRoRGF5VGltZVxcXCIgfCBcXFwiWWVhckRheU1vbnRoV2l0aEZ1bGxUaW1lXFxcIiB8IFxcXCJZZWFyRGF5TW9udGhUaW1lXFxcIiB8IHVuZGVmaW5lZFxcbiAgICAgICAgICAgKiogU2V0IHRoZSBsb2cgZm9ybWF0LCB1bmRlZmluZWQgd2lsbCBub3QgY2hhbmdlIHRoZSBzZXR0aW5nLlxcbiAgICAgICAgICAgKiogT3B0aW9uYWxcXG5cXG4gICAgICAgICBzaG93VGltZXN0YW1wOiBib29sZWFuIHwgdW5kZWZpbmVkXFxuICAgICAgICAgICAqKiBXaGV0aGVyIHRvIHNob3cgdGltZXN0YW1wLCB1bmRlZmluZWQgd2lsbCBub3QgY2hhbmdlIHRoZSBzZXR0aW5nLlxcbiAgICAgICAgICAgKiogT3B0aW9uYWxcXG5cXG4gICAgICAgICBzaG93Q2F0ZWdvcnlOYW1lOiBib29sZWFuIHwgdW5kZWZpbmVkXFxuICAgICAgICAgICAqKiBXaGV0aGVyIHRvIHNob3cgdGhlIGNhdGVnb3J5IG5hbWUsIHVuZGVmaW5lZCB3aWxsIG5vdCBjaGFuZ2UgdGhlIHNldHRpbmcuXFxuICAgICAgICAgICAqKiBPcHRpb25hbFxcblxcbiAgIHJlc2V0KGlkOiBudW1iZXIgfCBcXFwiYWxsXFxcIik6IHZvaWRcXG4gICAgICoqIFJlc2V0cyBldmVyeXRoaW5nIHRvIG9yaWdpbmFsIHZhbHVlcywgZm9yIG9uZSBzcGVjaWZpYyBvciBmb3IgYWxsIGNhdGVnb3JpZXMuXFxuXCI7XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2V4YW1wbGUgPSBcIlxcbiAgRXhhbXBsZXM6XFxuICAgIGNoYW5nZSh7Y2F0ZWdvcnk6IFxcXCJhbGxcXFwiLCByZWN1cnNpdmU6dHJ1ZSwgbG9nTGV2ZWw6IFxcXCJJbmZvXFxcIn0pXFxuICAgICAgKiogQ2hhbmdlIGxvZ2xldmVsIHRvIEluZm8gZm9yIGFsbCBjYXRlZ29yaWVzLCBhcHBseSB0byBjaGlsZCBjYXRlZ29yaWVzIGFzIHdlbGwuXFxuXFxuICAgIGNoYW5nZSh7Y2F0ZWdvcnk6IDEsIHJlY3Vyc2l2ZTpmYWxzZSwgbG9nTGV2ZWw6IFxcXCJXYXJuXFxcIn0pXFxuICAgICAgKiogQ2hhbmdlIGxvZ0xldmVsIGZvciBjYXRlZ29yeSAxLCBkbyBub3QgcmVjdXJzZS5cXG5cXG4gICAgY2hhbmdlKHtjYXRlZ29yeTogXFxcImFsbFxcXCIsIHJlY3Vyc2l2ZTp0cnVlLCBsb2dMZXZlbDogXFxcIkRlYnVnXFxcIiwgbG9nRm9ybWF0OiBcXFwiWWVhckRheU1vbnRoVGltZVxcXCIsIHNob3dUaW1lc3RhbXA6ZmFsc2UsIHNob3dDYXRlZ29yeU5hbWU6ZmFsc2V9KVxcbiAgICAgICoqIENoYW5nZSBsb2dsZXZlbCB0byBEZWJ1ZyBmb3IgYWxsIGNhdGVnb3JpZXMsIGFwcGx5IGZvcm1hdCwgZG8gbm90IHNob3cgdGltZXN0YW1wIGFuZCBjYXRlZ29yeSBuYW1lcyAtIHJlY3Vyc2l2ZWx5IHRvIGNoaWxkIGNhdGVnb3JpZXMuXFxuXFxuXCI7XG4gICAgcmV0dXJuIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsO1xufSgpKTtcbmV4cG9ydHMuQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwgPSBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhdGVnb3J5U2VydmljZUNvbnRyb2wuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL2xvZy9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIExGU2VydmljZV8xID0gcmVxdWlyZShcIi4uL2xvZy9zdGFuZGFyZC9MRlNlcnZpY2VcIik7XG52YXIgRGF0YVN0cnVjdHVyZXNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9EYXRhU3RydWN0dXJlc1wiKTtcbnZhciBMb2dnZXJDb250cm9sSW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9nZ2VyQ29udHJvbEltcGwoKSB7XG4gICAgfVxuICAgIExvZ2dlckNvbnRyb2xJbXBsLnByb3RvdHlwZS5oZWxwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgIGNvbnNvbGUubG9nKExvZ2dlckNvbnRyb2xJbXBsLl9oZWxwKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBMb2dnZXJDb250cm9sSW1wbC5wcm90b3R5cGUubGlzdEZhY3RvcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJ0U2V0dGluZ3NGYWN0b3JpZXMgPSBMb2dnZXJDb250cm9sSW1wbC5fZ2V0UnVudGltZVNldHRpbmdzTG9nZ2VyRmFjdG9yaWVzKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIHJlc3VsdC5hcHBlbmRMaW5lKFwiUmVnaXN0ZXJlZCBMb2dnZXJGYWN0b3JpZXMgKGluZGV4IC8gbmFtZSlcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnRTZXR0aW5nc0ZhY3Rvcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJ0U2V0dGluZ3NGYWN0b3J5ID0gcnRTZXR0aW5nc0ZhY3Rvcmllc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoXCIgIFwiICsgaSkuYXBwZW5kKFwiOiBcIiArIHJ0U2V0dGluZ3NGYWN0b3J5LmdldE5hbWUoKSArIFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0LnRvU3RyaW5nKCkpO1xuICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICB9O1xuICAgIExvZ2dlckNvbnRyb2xJbXBsLnByb3RvdHlwZS5zaG93U2V0dGluZ3MgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSB2b2lkIDApIHsgaWQgPSBcImFsbFwiOyB9XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGlkID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgICB2YXIgaWR4XzEgPSAwO1xuICAgICAgICAgICAgTG9nZ2VyQ29udHJvbEltcGwuX2dldFJ1bnRpbWVTZXR0aW5nc0xvZ2dlckZhY3RvcmllcygpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRGF0YVN0cnVjdHVyZXNfMS5UdXBsZVBhaXIoaWR4XzErKywgaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBMb2dnZXJDb250cm9sSW1wbC5fZ2V0UnVudGltZVNldHRpbmdzTG9nZ2VyRmFjdG9yaWVzKCk7XG4gICAgICAgICAgICBpZiAoaWQgPj0gMCAmJiBpZCA8IHNldHRpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEYXRhU3RydWN0dXJlc18xLlR1cGxlUGFpcihpZCwgc2V0dGluZ3NbaWRdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgbnVtYmVyOiBcIiArIGlkICsgXCIgd2FzIG5vdCBmb3VuZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByZXN1bHRfMSA9IHJlc3VsdDsgX2kgPCByZXN1bHRfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZXR0aW5nID0gcmVzdWx0XzFbX2ldO1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCIgIExvZ2dlckZhY3Rvcnk6IFwiICsgc2V0dGluZy55LmdldE5hbWUoKSArIFwiIChpZD1cIiArIHNldHRpbmcueCArIFwiKVwiKTtcbiAgICAgICAgICAgIHZhciBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyA9IHNldHRpbmcueS5nZXRMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncygpO1xuICAgICAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sZW5ndGg7IGcrKykge1xuICAgICAgICAgICAgICAgIHZhciBncm91cFNldHRpbmcgPSBsb2dHcm91cFJ1bnRpbWVTZXR0aW5nc1tnXTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiAgICAgTG9nR3JvdXA6IChpZD1cIiArIGcgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIgICAgICAgUmVnRXhwOiBcIiArIGdyb3VwU2V0dGluZy5sb2dHcm91cFJ1bGUucmVnRXhwLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIgICAgICAgTGV2ZWw6IFwiICsgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsW2dyb3VwU2V0dGluZy5sZXZlbF0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIgICAgICAgTG9nZ2VyVHlwZTogXCIgKyBMb2dnZXJPcHRpb25zXzEuTG9nZ2VyVHlwZVtncm91cFNldHRpbmcubG9nZ2VyVHlwZV0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nZ2VyQ29udHJvbEltcGwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGlkRmFjdG9yeSkge1xuICAgICAgICBpZiAoaWRGYWN0b3J5ID09PSB2b2lkIDApIHsgaWRGYWN0b3J5ID0gXCJhbGxcIjsgfVxuICAgICAgICB2YXIgbG9nZ2VyRmFjdG9yaWVzU2V0dGluZ3MgPSBMb2dnZXJDb250cm9sSW1wbC5fZ2V0UnVudGltZVNldHRpbmdzTG9nZ2VyRmFjdG9yaWVzKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGlkRmFjdG9yeSA9PT0gXCJhbGxcIikge1xuICAgICAgICAgICAgcmVzdWx0ID0gbG9nZ2VyRmFjdG9yaWVzU2V0dGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaWRGYWN0b3J5ID49IDAgJiYgaWRGYWN0b3J5IDwgbG9nZ2VyRmFjdG9yaWVzU2V0dGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobG9nZ2VyRmFjdG9yaWVzU2V0dGluZ3NbaWRGYWN0b3J5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHNldHRpbmcpIHtcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVzZXQgYWxsIHNldHRpbmdzIGZvciBmYWN0b3J5IFwiICsgaWRGYWN0b3J5KTtcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSBuZXcgTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsKHNldHRpbmcpO1xuICAgICAgICAgICAgY29udHJvbC5yZXNldCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExvZ2dlckNvbnRyb2xJbXBsLnByb3RvdHlwZS5nZXRMb2dnZXJGYWN0b3J5Q29udHJvbCA9IGZ1bmN0aW9uIChpZEZhY3RvcnkpIHtcbiAgICAgICAgdmFyIGxvZ2dlckZhY3Rvcmllc1NldHRpbmdzID0gTG9nZ2VyQ29udHJvbEltcGwuX2dldFJ1bnRpbWVTZXR0aW5nc0xvZ2dlckZhY3RvcmllcygpO1xuICAgICAgICBpZiAoaWRGYWN0b3J5ID49IDAgJiYgaWRGYWN0b3J5IDwgbG9nZ2VyRmFjdG9yaWVzU2V0dGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZ2dlckZhY3RvcnlDb250cm9sSW1wbChsb2dnZXJGYWN0b3JpZXNTZXR0aW5nc1tpZEZhY3RvcnldKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZEZhY3RvcnkgaXMgaW52YWxpZCAobGVzcyB0aGFuIDApIG9yIG5vbiBleGlzdGluZyBpZC5cIik7XG4gICAgfTtcbiAgICBMb2dnZXJDb250cm9sSW1wbC5fZ2V0UnVudGltZVNldHRpbmdzTG9nZ2VyRmFjdG9yaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTG9nZ2VyQ29udHJvbEltcGwuX2dldFNldHRpbmdzKCkuZ2V0UnVudGltZVNldHRpbmdzRm9yTG9nZ2VyRmFjdG9yaWVzKCk7XG4gICAgfTtcbiAgICBMb2dnZXJDb250cm9sSW1wbC5fZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMRlNlcnZpY2VfMS5MRlNlcnZpY2UuZ2V0UnVudGltZVNldHRpbmdzKCk7XG4gICAgfTtcbiAgICBMb2dnZXJDb250cm9sSW1wbC5faGVscCA9IFwiXFxuICBoZWxwKCk6IHZvaWRcXG4gICAgKiogU2hvd3MgdGhpcyBoZWxwLlxcblxcbiAgbGlzdEZhY3RvcmllcygpOiB2b2lkXFxuICAgICoqIExpc3QgYWxsIHJlZ2lzdGVyZWQgTG9nZ2VyRmFjdG9yaWVzIHdpdGggYXNzb2NpYXRlZCBsb2cgZ3JvdXBzIHdpdGggcmVzcGVjdGl2ZSBpZHMgKGlkcyBjYW4gYmUgdXNlZCB0byB0YXJnZXQgYSBmYWN0b3J5IGFuZC9vciBncm91cCkuXFxuXFxuICBzaG93U2V0dGluZ3MoaWRGYWN0b3J5OiBudW1iZXIgfCBcXFwiYWxsXFxcIik6IHZvaWRcXG4gICAgKiogU2hvdyBsb2cgZ3JvdXAgc2V0dGluZ3MgZm9yIGlkRmFjdG9yeSAodXNlIGxpc3RGYWN0b3JpZXMgdG8gZmluZCBpZCBmb3IgYSBMb2dnZXJGYWN0b3J5KS4gSWYgaWRGYWN0b3J5IGlzIFxcXCJhbGxcXFwiIHNob3dzIGFsbCBmYWN0b3JpZXMuXFxuXFxuICBnZXRMb2dnZXJGYWN0b3J5Q29udHJvbChpZEZhY3Rvcnk6IG51bWJlcik6IExvZ2dlckZhY3RvcnlDb250cm9sXFxuICAgICoqIFJldHVybiBMb2dnZXJGYWN0b3J5Q29udHJvbCB3aGVuIGZvdW5kIGZvciBnaXZlbiBpZEZhY3Rvcnkgb3IgdGhyb3dzIEVycm9yIGlmIGludmFsaWQgb3IgbnVsbCwgZ2V0IHRoZSBpZCBieSB1c2luZyBsaXN0RmFjdG9yaWVzKClcXG5cXG4gIHJlc2V0KGlkRmFjdG9yeTogbnVtYmVyIHwgXFxcImFsbFxcXCIpOiB2b2lkXFxuICAgICoqIFJlc2V0cyBnaXZlbiBmYWN0b3J5IG9yIGFsbCBmYWN0b3JpZXMgYmFjayB0byBvcmlnaW5hbCB2YWx1ZXMuXFxuXCI7XG4gICAgcmV0dXJuIExvZ2dlckNvbnRyb2xJbXBsO1xufSgpKTtcbmV4cG9ydHMuTG9nZ2VyQ29udHJvbEltcGwgPSBMb2dnZXJDb250cm9sSW1wbDtcbnZhciBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlckZhY3RvcnlDb250cm9sSW1wbChzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIH1cbiAgICBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwucHJvdG90eXBlLmhlbHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2coTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLl9oZWxwKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwucHJvdG90eXBlLmV4YW1wbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2coTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLl9leGFtcGxlKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwucHJvdG90eXBlLnNob3dTZXR0aW5ncyA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoaWQgPT09IHZvaWQgMCkgeyBpZCA9IFwiYWxsXCI7IH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRhU3RydWN0dXJlc18xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgdmFyIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzID0gdGhpcy5fc2V0dGluZ3MuZ2V0TG9nR3JvdXBSdW50aW1lU2V0dGluZ3MoKTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZExpbmUoXCJSZWdpc3RlcmVkIExvZ0dyb3VwcyAoaW5kZXggLyBleHByZXNzaW9uKVwiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvZ0dyb3VwUnVudGltZVNldHRpbmcgPSBsb2dHcm91cFJ1bnRpbWVTZXR0aW5nc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRMaW5lKFwiICBcIiArIGkgKyBcIjogXCIgKyBsb2dHcm91cFJ1bnRpbWVTZXR0aW5nLmxvZ0dyb3VwUnVsZS5yZWdFeHAuc291cmNlICsgXCIsIGxvZ0xldmVsPVwiICtcbiAgICAgICAgICAgICAgICBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWxbbG9nR3JvdXBSdW50aW1lU2V0dGluZy5sZXZlbF0udG9TdHJpbmcoKSArIFwiLCBzaG93VGltZXN0YW1wPVwiICsgbG9nR3JvdXBSdW50aW1lU2V0dGluZy5sb2dGb3JtYXQuc2hvd1RpbWVTdGFtcCArXG4gICAgICAgICAgICAgICAgXCIsIHNob3dMb2dnZXJOYW1lPVwiICsgbG9nR3JvdXBSdW50aW1lU2V0dGluZy5sb2dGb3JtYXQuc2hvd0xvZ2dlck5hbWUgK1xuICAgICAgICAgICAgICAgIFwiLCBmb3JtYXQ9XCIgKyBMb2dnZXJPcHRpb25zXzEuRGF0ZUZvcm1hdEVudW1bbG9nR3JvdXBSdW50aW1lU2V0dGluZy5sb2dGb3JtYXQuZGF0ZUZvcm1hdC5mb3JtYXRFbnVtXS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdC50b1N0cmluZygpKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwucHJvdG90eXBlLmNoYW5nZSA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICB2YXIgbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MgPSB0aGlzLl9nZXRMb2dHcm91cFJ1blRpbWVTZXR0aW5nc0ZvcihzZXR0aW5ncy5ncm91cCk7XG4gICAgICAgIHZhciBsb2dMZXZlbCA9IG51bGw7XG4gICAgICAgIHZhciBmb3JtYXRFbnVtID0gbnVsbDtcbiAgICAgICAgdmFyIHNob3dMb2dnZXJOYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIHNob3dUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdmFyIGFkZFJlc3VsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiwgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MubG9nTGV2ZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxvZ0xldmVsID0gTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLmZyb21TdHJpbmcoc2V0dGluZ3MubG9nTGV2ZWwpO1xuICAgICAgICAgICAgYWRkUmVzdWx0KFwibG9nTGV2ZWw9XCIgKyBzZXR0aW5ncy5sb2dMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5sb2dGb3JtYXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdEVudW0gPSBMb2dnZXJPcHRpb25zXzEuRGF0ZUZvcm1hdEVudW0uZnJvbVN0cmluZyhzZXR0aW5ncy5sb2dGb3JtYXQpO1xuICAgICAgICAgICAgYWRkUmVzdWx0KFwibG9nRm9ybWF0PVwiICsgc2V0dGluZ3MubG9nRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnNob3dMb2dnZXJOYW1lID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgc2hvd0xvZ2dlck5hbWUgPSBzZXR0aW5ncy5zaG93TG9nZ2VyTmFtZTtcbiAgICAgICAgICAgIGFkZFJlc3VsdChcInNob3dMb2dnZXJOYW1lPVwiICsgc2V0dGluZ3Muc2hvd0xvZ2dlck5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Muc2hvd1RpbWVzdGFtcCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHNob3dUaW1lc3RhbXAgPSBzZXR0aW5ncy5zaG93VGltZXN0YW1wO1xuICAgICAgICAgICAgYWRkUmVzdWx0KFwic2hvd1RpbWVzdGFtcD1cIiArIHNldHRpbmdzLnNob3dUaW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIGlmIChsb2dMZXZlbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHMubGV2ZWwgPSBsb2dMZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXRFbnVtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcy5sb2dGb3JtYXQuZGF0ZUZvcm1hdC5mb3JtYXRFbnVtID0gZm9ybWF0RW51bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG93VGltZXN0YW1wICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcy5sb2dGb3JtYXQuc2hvd1RpbWVTdGFtcCA9IHNob3dUaW1lc3RhbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvd0xvZ2dlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzLmxvZ0Zvcm1hdC5zaG93TG9nZ2VyTmFtZSA9IHNob3dMb2dnZXJOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFwcGxpZWQgY2hhbmdlczogXCIgKyByZXN1bHQgKyBcIiB0byBsb2cgZ3JvdXBzICdcIiArIHNldHRpbmdzLmdyb3VwICsgXCInLlwiKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGlkR3JvdXApIHtcbiAgICAgICAgaWYgKGlkR3JvdXAgPT09IHZvaWQgMCkgeyBpZEdyb3VwID0gXCJhbGxcIjsgfVxuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLl9nZXRMb2dHcm91cFJ1blRpbWVTZXR0aW5nc0ZvcihpZEdyb3VwKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZXR0aW5nc18xID0gc2V0dGluZ3M7IF9pIDwgc2V0dGluZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZXR0aW5nID0gc2V0dGluZ3NfMVtfaV07XG4gICAgICAgICAgICBzZXR0aW5nLmxldmVsID0gc2V0dGluZy5sb2dHcm91cFJ1bGUubGV2ZWw7XG4gICAgICAgICAgICBzZXR0aW5nLmxvZ0Zvcm1hdC5zaG93VGltZVN0YW1wID0gc2V0dGluZy5sb2dHcm91cFJ1bGUubG9nRm9ybWF0LnNob3dUaW1lU3RhbXA7XG4gICAgICAgICAgICBzZXR0aW5nLmxvZ0Zvcm1hdC5zaG93TG9nZ2VyTmFtZSA9IHNldHRpbmcubG9nR3JvdXBSdWxlLmxvZ0Zvcm1hdC5zaG93TG9nZ2VyTmFtZTtcbiAgICAgICAgICAgIHNldHRpbmcubG9nRm9ybWF0LmRhdGVGb3JtYXQuZm9ybWF0RW51bSA9IHNldHRpbmcubG9nR3JvdXBSdWxlLmxvZ0Zvcm1hdC5kYXRlRm9ybWF0LmZvcm1hdEVudW07XG4gICAgICAgIH1cbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJlc2V0IGFsbCBzZXR0aW5ncyBmb3IgZ3JvdXAgXCIgKyBpZEdyb3VwKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwucHJvdG90eXBlLl9nZXRMb2dHcm91cFJ1blRpbWVTZXR0aW5nc0ZvciA9IGZ1bmN0aW9uIChpZEdyb3VwKSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IFtdO1xuICAgICAgICBpZiAoaWRHcm91cCA9PT0gXCJhbGxcIikge1xuICAgICAgICAgICAgc2V0dGluZ3MgPSB0aGlzLl9zZXR0aW5ncy5nZXRMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tJbmRleChpZEdyb3VwKTtcbiAgICAgICAgICAgIHNldHRpbmdzLnB1c2godGhpcy5fc2V0dGluZ3MuZ2V0TG9nR3JvdXBSdW50aW1lU2V0dGluZ3MoKVtpZEdyb3VwXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLnByb3RvdHlwZS5fY2hlY2tJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuX3NldHRpbmdzLmdldExvZ0dyb3VwUnVudGltZVNldHRpbmdzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGV4LCB1c2UgbGlzdExvZ0dyb3VwcyB0byBmaW5kIG91dCBhIHZhbGlkIG9uZS5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnlDb250cm9sSW1wbC5faGVscCA9IFwiXFxuICBoZWxwKCk6IHZvaWRcXG4gICAgKiogU2hvd3MgdGhpcyBoZWxwLlxcblxcbiAgZXhhbXBsZSgpOiB2b2lkXFxuICAgICoqIFNob3dzIGFuIGV4YW1wbGUgb2YgdXNhZ2UuXFxuXFxuICBzaG93U2V0dGluZ3MoaWQ6IG51bWJlciB8IFxcXCJhbGxcXFwiKTogdm9pZFxcbiAgICAqKiBQcmludHMgc2V0dGluZ3MgZm9yIGdpdmVuIGdyb3VwIGlkLCBcXFwiYWxsXFxcIiBmb3IgYWxsIGdyb3VwLlxcblxcbiAgY2hhbmdlKHNldHRpbmdzOiBMb2dHcm91cENvbnRyb2xTZXR0aW5ncyk6IHZvaWRcXG4gICAgKiogQ2hhbmdlcyB0aGUgY3VycmVudCBzZXR0aW5ncyBmb3Igb25lIG9yIGFsbCBsb2cgZ3JvdXBzLlxcbiAgICAqKlxcbiAgICAgICBMb2dHcm91cENvbnRyb2xTZXR0aW5ncywgcHJvcGVydGllcyBvZiBvYmplY3Q6XFxuICAgICAgICAgZ3JvdXA6IG51bWJlciB8IFxcXCJhbGxcXFwiXFxuICAgICAgICAgICAqKiBBcHBseSB0byBzcGVjaWZpYyBncm91cCwgb3IgXFxcImFsbFxcXCIuXFxuICAgICAgICAgICAqKiBSZXF1aXJlZFxcblxcbiAgICAgICAgIGxvZ0xldmVsOiBcXFwiRmF0YWxcXFwiIHwgXFxcIkVycm9yXFxcIiB8IFxcXCJXYXJuXFxcIiB8IFxcXCJJbmZvXFxcIiB8IFxcXCJEZWJ1Z1xcXCIgfCBcXFwiVHJhY2VcXFwiIHwgdW5kZWZpbmVkXFxuICAgICAgICAgICAqKiBTZXQgbG9nIGxldmVsLCB1bmRlZmluZWQgd2lsbCBub3QgY2hhbmdlIHRoZSBzZXR0aW5nLlxcbiAgICAgICAgICAgKiogT3B0aW9uYWxcXG5cXG4gICAgICAgICBsb2dGb3JtYXQ6IFxcXCJEZWZhdWx0XFxcIiB8IFxcXCJZZWFyTW9udGhEYXlUaW1lXFxcIiB8IFxcXCJZZWFyRGF5TW9udGhXaXRoRnVsbFRpbWVcXFwiIHwgXFxcIlllYXJEYXlNb250aFRpbWVcXFwiIHwgdW5kZWZpbmVkXFxuICAgICAgICAgICAqKiBTZXQgdGhlIGxvZyBmb3JtYXQsIHVuZGVmaW5lZCB3aWxsIG5vdCBjaGFuZ2UgdGhlIHNldHRpbmcuXFxuICAgICAgICAgICAqKiBPcHRpb25hbFxcblxcbiAgICAgICAgIHNob3dUaW1lc3RhbXA6IGJvb2xlYW4gfCB1bmRlZmluZWRcXG4gICAgICAgICAgICoqIFdoZXRoZXIgdG8gc2hvdyB0aW1lc3RhbXAsIHVuZGVmaW5lZCB3aWxsIG5vdCBjaGFuZ2UgdGhlIHNldHRpbmcuXFxuICAgICAgICAgICAqKiBPcHRpb25hbFxcblxcbiAgICAgICAgIHNob3dMb2dnZXJOYW1lOiBib29sZWFuIHwgdW5kZWZpbmVkXFxuICAgICAgICAgICAqKiBXaGV0aGVyIHRvIHNob3cgdGhlIGxvZ2dlciBuYW1lLCB1bmRlZmluZWQgd2lsbCBub3QgY2hhbmdlIHRoZSBzZXR0aW5nLlxcbiAgICAgICAgICAgKiogT3B0aW9uYWxcXG5cXG4gIHJlc2V0KGlkOiBudW1iZXIgfCBcXFwiYWxsXFxcIik6IHZvaWRcXG4gICAgKiogUmVzZXRzIGV2ZXJ5dGhpbmcgdG8gb3JpZ2luYWwgdmFsdWVzLCBmb3Igb25lIHNwZWNpZmljIG9yIGZvciBhbGwgZ3JvdXBzLlxcblxcbiAgaGVscCgpOlxcbiAgICAqKiBTaG93cyB0aGlzIGhlbHAuXFxuXCI7XG4gICAgTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLl9leGFtcGxlID0gXCJcXG4gIEV4YW1wbGVzOlxcbiAgICBjaGFuZ2Uoe2dyb3VwOiBcXFwiYWxsXFxcIiwgbG9nTGV2ZWw6IFxcXCJJbmZvXFxcIn0pXFxuICAgICAgKiogQ2hhbmdlIGxvZ2xldmVsIHRvIEluZm8gZm9yIGFsbCBncm91cHMuXFxuXFxuICAgIGNoYW5nZSh7Z3JvdXA6IDEsIHJlY3Vyc2l2ZTpmYWxzZSwgbG9nTGV2ZWw6IFxcXCJXYXJuXFxcIn0pXFxuICAgICAgKiogQ2hhbmdlIGxvZ0xldmVsIGZvciBncm91cCAxIHRvIFdhcm4uXFxuXFxuICAgIGNoYW5nZSh7Z3JvdXA6IFxcXCJhbGxcXFwiLCBsb2dMZXZlbDogXFxcIkRlYnVnXFxcIiwgbG9nRm9ybWF0OiBcXFwiWWVhckRheU1vbnRoVGltZVxcXCIsIHNob3dUaW1lc3RhbXA6ZmFsc2UsIHNob3dMb2dnZXJOYW1lOmZhbHNlfSlcXG4gICAgICAqKiBDaGFuZ2UgbG9nbGV2ZWwgdG8gRGVidWcgZm9yIGFsbCBncm91cHMsIGFwcGx5IGZvcm1hdCwgZG8gbm90IHNob3cgdGltZXN0YW1wIGFuZCBsb2dnZXIgbmFtZXMuXFxuXCI7XG4gICAgcmV0dXJuIExvZ2dlckZhY3RvcnlDb250cm9sSW1wbDtcbn0oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2dHcm91cENvbnRyb2wuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2F0ZWdvcnlTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbG9nL2NhdGVnb3J5L0NhdGVnb3J5U2VydmljZVwiKTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vbG9nL0xvZ2dlck9wdGlvbnNcIik7XG52YXIgTWVzc2FnZVV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvTWVzc2FnZVV0aWxzXCIpO1xudmFyIEV4dGVuc2lvbkhlbHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uSGVscGVyKCkge1xuICAgICAgICAvLyBQcml2YXRlIGNvbnN0cnVjdG9yXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHdpbmRvdyBldmVudCBsaXN0ZW5lciB0byBsaXN0ZW4gdG8gbWVzc2FnZXMgKGZyb20gZXh0ZW5zaW9ucykuXG4gICAgICogQ2FuIGJlIHJlZ2lzdGVyZWQvZW5hYmxlZCBvbmx5IG9uY2UuXG4gICAgICovXG4gICAgRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIUV4dGVuc2lvbkhlbHBlci5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IGV2dC5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChtc2cgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgRXh0ZW5zaW9uSGVscGVyLnByb2Nlc3NNZXNzYWdlRnJvbUV4dGVuc2lvbihtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIEV4dGVuc2lvbkhlbHBlci5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXh0ZW5zaW9uSGVscGVyLnByb2Nlc3NNZXNzYWdlRnJvbUV4dGVuc2lvbiA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKCFFeHRlbnNpb25IZWxwZXIucmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgaWYgKG1zZy5mcm9tID09PSBcInRzbC1leHRlbnNpb25cIikge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBtc2cuZGF0YTtcbiAgICAgICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlZ2lzdGVyXCI6XG4gICAgICAgICAgICAgICAgICAgIEV4dGVuc2lvbkhlbHBlci5lbmFibGVFeHRlbnNpb25JbnRlZ3JhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVxdWVzdC1jaGFuZ2UtbG9nbGV2ZWxcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlUmVxdWVzdCA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXRzQXBwbGllZCA9IEV4dGVuc2lvbkhlbHBlci5hcHBseUxvZ0xldmVsKHZhbHVlUmVxdWVzdC5jYXRlZ29yeUlkLCB2YWx1ZVJlcXVlc3QubG9nTGV2ZWwsIHZhbHVlUmVxdWVzdC5yZWN1cnNpdmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2F0c0FwcGxpZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VuZCBjaGFuZ2VzIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIEV4dGVuc2lvbkhlbHBlci5zZW5kQ2F0ZWdvcmllc1J1bnRpbWVVcGRhdGVNZXNzYWdlKGNhdHNBcHBsaWVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gY29tbWFuZCB0byBwcm9jZXNzIG1lc3NhZ2UgZnJvbSBleHRlbnNpb24sIGNvbW1hbmQgd2FzOiBcIiArIGRhdGEudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSGVscGVyLnNlbmRDYXRlZ29yeUxvZ01lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmICghRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2F0ZWdvcnlJZHMgPSBtc2cuY2F0ZWdvcmllcy5tYXAoZnVuY3Rpb24gKGNhdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhdC5pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb250ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJsb2ctbWVzc2FnZVwiLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzOiBjYXRlZ29yeUlkcyxcbiAgICAgICAgICAgICAgICBlcnJvckFzU3RhY2s6IG1zZy5lcnJvckFzU3RhY2ssXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkTWVzc2FnZTogTWVzc2FnZVV0aWxzXzEuTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckRlZmF1bHRNZXNzYWdlKG1zZywgZmFsc2UpLFxuICAgICAgICAgICAgICAgIGxvZ0xldmVsOiBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWxbbXNnLmxldmVsXS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZy5tZXNzYWdlQXNTdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRFcnJvck1lc3NhZ2U6IG1zZy5pc1Jlc29sdmVkRXJyb3JNZXNzYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtZXNzYWdlID0ge1xuICAgICAgICAgICAgZGF0YTogY29udGVudCxcbiAgICAgICAgICAgIGZyb206IFwidHNsLWxvZ2dpbmdcIixcbiAgICAgICAgfTtcbiAgICAgICAgRXh0ZW5zaW9uSGVscGVyLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSGVscGVyLnNlbmRDYXRlZ29yaWVzUnVudGltZVVwZGF0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAoY2F0ZWdvcmllcykge1xuICAgICAgICBpZiAoIUV4dGVuc2lvbkhlbHBlci5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlcnZpY2UgPSBDYXRlZ29yeVNlcnZpY2VfMS5DYXRlZ29yeVNlcnZpY2VJbXBsLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHZhciBjYXRMZXZlbHMgPSB7IGNhdGVnb3JpZXM6IEFycmF5KCkgfTtcbiAgICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjYXQpIHtcbiAgICAgICAgICAgIHZhciBjYXRTZXR0aW5ncyA9IHNlcnZpY2UuZ2V0Q2F0ZWdvcnlTZXR0aW5ncyhjYXQpO1xuICAgICAgICAgICAgaWYgKGNhdFNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYXRMZXZlbHMuY2F0ZWdvcmllcy5wdXNoKHsgaWQ6IGNhdC5pZCwgbG9nTGV2ZWw6IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbFtjYXRTZXR0aW5ncy5sb2dMZXZlbF0udG9TdHJpbmcoKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb250ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJjYXRlZ29yaWVzLXJ0LXVwZGF0ZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGNhdExldmVscyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBkYXRhOiBjb250ZW50LFxuICAgICAgICAgICAgZnJvbTogXCJ0c2wtbG9nZ2luZ1wiXG4gICAgICAgIH07XG4gICAgICAgIEV4dGVuc2lvbkhlbHBlci5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkhlbHBlci5zZW5kUm9vdENhdGVnb3JpZXNUb0V4dGVuc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFFeHRlbnNpb25IZWxwZXIucmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLmdldFJvb3RDYXRlZ29yaWVzKCkubWFwKGZ1bmN0aW9uIChjYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBFeHRlbnNpb25IZWxwZXIuZ2V0Q2F0ZWdvcnlBc0pTT04oY2F0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb250ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJyb290LWNhdGVnb3JpZXMtdHJlZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGNhdGVnb3JpZXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBkYXRhOiBjb250ZW50LFxuICAgICAgICAgICAgZnJvbTogXCJ0c2wtbG9nZ2luZ1wiXG4gICAgICAgIH07XG4gICAgICAgIEV4dGVuc2lvbkhlbHBlci5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIGV4dGVuc2lvbiBpbnRlZ3JhdGlvbiBpcyBlbmFibGVkLCB3aWxsIHNlbmQgdGhlIHJvb3QgY2F0ZWdvcmllcyBvdmVyIHRvIHRoZSBleHRlbnNpb24uXG4gICAgICogT3RoZXJ3aXNlIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBFeHRlbnNpb25IZWxwZXIuZ2V0Q2F0ZWdvcnlBc0pTT04gPSBmdW5jdGlvbiAoY2F0KSB7XG4gICAgICAgIHZhciBjaGlsZENhdGVnb3JpZXMgPSBjYXQuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIEV4dGVuc2lvbkhlbHBlci5nZXRDYXRlZ29yeUFzSlNPTihjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkQ2F0ZWdvcmllcyxcbiAgICAgICAgICAgIGlkOiBjYXQuaWQsXG4gICAgICAgICAgICBsb2dMZXZlbDogTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsW2NhdC5sb2dMZXZlbF0udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG5hbWU6IGNhdC5uYW1lLFxuICAgICAgICAgICAgcGFyZW50SWQ6IChjYXQucGFyZW50ICE9IG51bGwgPyBjYXQucGFyZW50LmlkIDogbnVsbCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBFeHRlbnNpb25IZWxwZXIuYXBwbHlMb2dMZXZlbCA9IGZ1bmN0aW9uIChjYXRlZ29yeUlkLCBsb2dMZXZlbCwgcmVjdXJzaXZlKSB7XG4gICAgICAgIHZhciBjYXRzID0gW107XG4gICAgICAgIHZhciBjYXRlZ29yeSA9IENhdGVnb3J5U2VydmljZV8xLkNhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKS5nZXRDYXRlZ29yeUJ5SWQoY2F0ZWdvcnlJZCk7XG4gICAgICAgIGlmIChjYXRlZ29yeSAhPSBudWxsKSB7XG4gICAgICAgICAgICBFeHRlbnNpb25IZWxwZXIuX2FwcGx5TG9nTGV2ZWxSZWN1cnNpdmUoY2F0ZWdvcnksIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5mcm9tU3RyaW5nKGxvZ0xldmVsKSwgcmVjdXJzaXZlLCBjYXRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IGNoYW5nZSBsb2cgbGV2ZWwsIGZhaWxlZCB0byBmaW5kIGNhdGVnb3J5IHdpdGggaWQ6IFwiICsgY2F0ZWdvcnlJZCk7XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2F0cztcbiAgICB9O1xuICAgIEV4dGVuc2lvbkhlbHBlci5fYXBwbHlMb2dMZXZlbFJlY3Vyc2l2ZSA9IGZ1bmN0aW9uIChjYXRlZ29yeSwgbG9nTGV2ZWwsIHJlY3Vyc2l2ZSwgY2F0cykge1xuICAgICAgICB2YXIgY2F0ZWdvcnlTZXR0aW5ncyA9IENhdGVnb3J5U2VydmljZV8xLkNhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKS5nZXRDYXRlZ29yeVNldHRpbmdzKGNhdGVnb3J5KTtcbiAgICAgICAgaWYgKGNhdGVnb3J5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2F0ZWdvcnlTZXR0aW5ncy5sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgICAgICAgICAgY2F0cy5wdXNoKGNhdGVnb3J5KTtcbiAgICAgICAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBFeHRlbnNpb25IZWxwZXIuX2FwcGx5TG9nTGV2ZWxSZWN1cnNpdmUoY2hpbGQsIGxvZ0xldmVsLCByZWN1cnNpdmUsIGNhdHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFeHRlbnNpb25IZWxwZXIuZ2V0QWxsQ2F0ZWdvcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhdHMgPSBbXTtcbiAgICAgICAgdmFyIGFkZENhdHMgPSBmdW5jdGlvbiAoY2F0LCBhbGxDYXRzKSB7XG4gICAgICAgICAgICBhbGxDYXRzLnB1c2goY2F0KTtcbiAgICAgICAgICAgIGNhdC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjYXRDaGlsZCkge1xuICAgICAgICAgICAgICAgIGFkZENhdHMoY2F0Q2hpbGQsIGFsbENhdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENhdGVnb3J5U2VydmljZV8xLkNhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKS5nZXRSb290Q2F0ZWdvcmllcygpLmZvckVhY2goZnVuY3Rpb24gKGNhdCkge1xuICAgICAgICAgICAgYWRkQ2F0cyhjYXQsIGNhdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhdHM7XG4gICAgfTtcbiAgICBFeHRlbnNpb25IZWxwZXIuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmICghRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LnBvc3RNZXNzYWdlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UobXNnLCBcIipcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqICBFeHRlbnNpb24gZnJhbWV3b3JrIHdpbGwgY2FsbCB0aGlzIHRvIGVuYWJsZSB0aGUgaW50ZWdyYXRpb24gYmV0d2VlbiB0d28sXG4gICAgICogIGFmdGVyIHRoaXMgY2FsbCB0aGUgZnJhbWV3b3JrIHdpbGwgcmVzcG9uZCB3aXRoIHBvc3RNZXNzYWdlKCkgbWVzc2FnZXMuXG4gICAgICovXG4gICAgRXh0ZW5zaW9uSGVscGVyLmVuYWJsZUV4dGVuc2lvbkludGVncmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIUV4dGVuc2lvbkhlbHBlci5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluc3RhbmNlID0gQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpO1xuICAgICAgICBpbnN0YW5jZS5lbmFibGVFeHRlbnNpb25JbnRlZ3JhdGlvbigpO1xuICAgICAgICAvLyBTZW5kIG92ZXIgYWxsIGNhdGVnb3JpZXNcbiAgICAgICAgRXh0ZW5zaW9uSGVscGVyLnNlbmRSb290Q2F0ZWdvcmllc1RvRXh0ZW5zaW9uKCk7XG4gICAgICAgIC8vIFNlbmQgb3ZlciB0aGUgY3VycmVudCBydW50aW1lIGxldmVsc1xuICAgICAgICB2YXIgY2F0cyA9IEV4dGVuc2lvbkhlbHBlci5nZXRBbGxDYXRlZ29yaWVzKCk7XG4gICAgICAgIEV4dGVuc2lvbkhlbHBlci5zZW5kQ2F0ZWdvcmllc1J1bnRpbWVVcGRhdGVNZXNzYWdlKGNhdHMpO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uSGVscGVyO1xufSgpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uSGVscGVyID0gRXh0ZW5zaW9uSGVscGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXh0ZW5zaW9uSGVscGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBMb2cgbGV2ZWwgZm9yIGEgbG9nZ2VyLlxuICovXG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJUcmFjZVwiXSA9IDBdID0gXCJUcmFjZVwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRGVidWdcIl0gPSAxXSA9IFwiRGVidWdcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkluZm9cIl0gPSAyXSA9IFwiSW5mb1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV2FyblwiXSA9IDNdID0gXCJXYXJuXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFcnJvclwiXSA9IDRdID0gXCJFcnJvclwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRmF0YWxcIl0gPSA1XSA9IFwiRmF0YWxcIjtcbn0pKExvZ0xldmVsID0gZXhwb3J0cy5Mb2dMZXZlbCB8fCAoZXhwb3J0cy5Mb2dMZXZlbCA9IHt9KSk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1uYW1lc3BhY2UgKi9cbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIExvZ0xldmVsIGJhc2VkIG9uIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSB2YWwgVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TG9nTGV2ZWx9LCBFcnJvciBpcyB0aHJvd24gaWYgaW52YWxpZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0cmFjZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBMb2dMZXZlbC5UcmFjZTtcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBMb2dMZXZlbC5EZWJ1ZztcbiAgICAgICAgICAgIGNhc2UgXCJpbmZvXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvZ0xldmVsLkluZm87XG4gICAgICAgICAgICBjYXNlIFwid2FyblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBMb2dMZXZlbC5XYXJuO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvZ0xldmVsLkVycm9yO1xuICAgICAgICAgICAgY2FzZSBcImZhdGFsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvZ0xldmVsLkZhdGFsO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB2YWx1ZSBmb3IgY29udmVyc2lvbjogXCIgKyB2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIExvZ0xldmVsLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xufSkoTG9nTGV2ZWwgPSBleHBvcnRzLkxvZ0xldmVsIHx8IChleHBvcnRzLkxvZ0xldmVsID0ge30pKTtcbi8qIHRzbGludDpkaXNhYmxlOmVuYWJsZS1uYW1lc3BhY2UgKi9cbi8qKlxuICogV2hlcmUgdG8gbG9nIHRvPyBQaWNrIG9uZSBvZiB0aGUgY29uc3RhbnRzLiBDdXN0b20gcmVxdWlyZXMgYSBjYWxsYmFjayB0byBiZSBwcmVzZW50LCBzZWUgTEZTZXJ2aWNlLmNyZWF0ZUxvZ2dlckZhY3RvcnkoLi4uKVxuICogd2hlcmUgdGhpcyBjb21lcyBpbnRvIHBsYXkuXG4gKi9cbnZhciBMb2dnZXJUeXBlO1xuKGZ1bmN0aW9uIChMb2dnZXJUeXBlKSB7XG4gICAgTG9nZ2VyVHlwZVtMb2dnZXJUeXBlW1wiQ29uc29sZVwiXSA9IDBdID0gXCJDb25zb2xlXCI7XG4gICAgTG9nZ2VyVHlwZVtMb2dnZXJUeXBlW1wiTWVzc2FnZUJ1ZmZlclwiXSA9IDFdID0gXCJNZXNzYWdlQnVmZmVyXCI7XG4gICAgTG9nZ2VyVHlwZVtMb2dnZXJUeXBlW1wiQ3VzdG9tXCJdID0gMl0gPSBcIkN1c3RvbVwiO1xufSkoTG9nZ2VyVHlwZSA9IGV4cG9ydHMuTG9nZ2VyVHlwZSB8fCAoZXhwb3J0cy5Mb2dnZXJUeXBlID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyBzZXZlcmFsIGRhdGUgZW51bXMgdXNlZCBmb3IgZm9ybWF0dGluZyBhIGRhdGUuXG4gKi9cbnZhciBEYXRlRm9ybWF0RW51bTtcbihmdW5jdGlvbiAoRGF0ZUZvcm1hdEVudW0pIHtcbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBhczogeWVhci1tb250aC1kYXkgaG91cjptaW51dGU6c2Vjb25kLG1pbGxpcyAtPiAxOTk5LTAyLTEyIDIzOjU5OjU5LDEyM1xuICAgICAqIE5vdGUgdGhlIGRhdGUgc2VwYXJhdG9yIGNhbiBiZSBzZXQgc2VwYXJhdGVseS5cbiAgICAgKi9cbiAgICBEYXRlRm9ybWF0RW51bVtEYXRlRm9ybWF0RW51bVtcIkRlZmF1bHRcIl0gPSAwXSA9IFwiRGVmYXVsdFwiO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIGFzOiB5ZWFyLW1vbnRoLWRheSBob3VyOm1pbnV0ZTpzZWNvbmQgLT4gMTk5OS0wMi0xMiAyMzo1OTo1OVxuICAgICAqIE5vdGUgdGhlIGRhdGUgc2VwYXJhdG9yIGNhbiBiZSBzZXQgc2VwYXJhdGVseS5cbiAgICAgKi9cbiAgICBEYXRlRm9ybWF0RW51bVtEYXRlRm9ybWF0RW51bVtcIlllYXJNb250aERheVRpbWVcIl0gPSAxXSA9IFwiWWVhck1vbnRoRGF5VGltZVwiO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIGFzOiB5ZWFyLWRheS1tb250aCBob3VyOm1pbnV0ZTpzZWNvbmQsbWlsbGlzIC0+IDE5OTktMTItMDIgMjM6NTk6NTksMTIzXG4gICAgICogTm90ZSB0aGUgZGF0ZSBzZXBhcmF0b3IgY2FuIGJlIHNldCBzZXBhcmF0ZWx5LlxuICAgICAqL1xuICAgIERhdGVGb3JtYXRFbnVtW0RhdGVGb3JtYXRFbnVtW1wiWWVhckRheU1vbnRoV2l0aEZ1bGxUaW1lXCJdID0gMl0gPSBcIlllYXJEYXlNb250aFdpdGhGdWxsVGltZVwiO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIGFzOiB5ZWFyLWRheS1tb250aCBob3VyOm1pbnV0ZTpzZWNvbmQgLT4gMTk5OS0xMi0wMiAyMzo1OTo1OVxuICAgICAqIE5vdGUgdGhlIGRhdGUgc2VwYXJhdG9yIGNhbiBiZSBzZXQgc2VwYXJhdGVseS5cbiAgICAgKi9cbiAgICBEYXRlRm9ybWF0RW51bVtEYXRlRm9ybWF0RW51bVtcIlllYXJEYXlNb250aFRpbWVcIl0gPSAzXSA9IFwiWWVhckRheU1vbnRoVGltZVwiO1xufSkoRGF0ZUZvcm1hdEVudW0gPSBleHBvcnRzLkRhdGVGb3JtYXRFbnVtIHx8IChleHBvcnRzLkRhdGVGb3JtYXRFbnVtID0ge30pKTtcbi8qIHRzbGludDpkaXNhYmxlOm5vLW5hbWVzcGFjZSAqL1xuKGZ1bmN0aW9uIChEYXRlRm9ybWF0RW51bSkge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgTG9nTGV2ZWwgYmFzZWQgb24gc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHBhcmFtIHZhbCBWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtMb2dMZXZlbH0sIEVycm9yIGlzIHRocm93biBpZiBpbnZhbGlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWwudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZUZvcm1hdEVudW0uRGVmYXVsdDtcbiAgICAgICAgICAgIGNhc2UgXCJ5ZWFybW9udGhkYXlUaW1lXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVGb3JtYXRFbnVtLlllYXJNb250aERheVRpbWU7XG4gICAgICAgICAgICBjYXNlIFwieWVhcmRheW1vbnRod2l0aGZ1bGx0aW1lXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVGb3JtYXRFbnVtLlllYXJEYXlNb250aFdpdGhGdWxsVGltZTtcbiAgICAgICAgICAgIGNhc2UgXCJ5ZWFyZGF5bW9udGh0aW1lXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVGb3JtYXRFbnVtLlllYXJEYXlNb250aFRpbWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHZhbHVlIGZvciBjb252ZXJzaW9uOiBcIiArIHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGF0ZUZvcm1hdEVudW0uZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG59KShEYXRlRm9ybWF0RW51bSA9IGV4cG9ydHMuRGF0ZUZvcm1hdEVudW0gfHwgKGV4cG9ydHMuRGF0ZUZvcm1hdEVudW0gPSB7fSkpO1xuLyogdHNsaW50OmRpc2FibGU6ZW5hYmxlLW5hbWVzcGFjZSAqL1xuLyoqXG4gKiBEYXRlRm9ybWF0IGNsYXNzLCBzdG9yZXMgZGF0YSBvbiBob3cgdG8gZm9ybWF0IGEgZGF0ZS5cbiAqL1xudmFyIERhdGVGb3JtYXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIHRvIGRlZmluZSB0aGUgZGF0ZWZvcm1hdCB1c2VkIGZvciBsb2dnaW5nLCBjYW4gYmUgY2FsbGVkIGVtcHR5IGFzIGl0IHVzZXMgZGVmYXVsdHMuXG4gICAgICogQHBhcmFtIGZvcm1hdEVudW0gRGF0ZUZvcm1hdEVudW0sIHVzZSBvbmUgb2YgdGhlIGNvbnN0YW50cyBmcm9tIHRoZSBlbnVtLiBEZWZhdWx0cyB0byBEYXRlRm9ybWF0RW51bS5EZWZhdWx0XG4gICAgICogQHBhcmFtIGRhdGVTZXBhcmF0b3IgU2VwYXJhdG9yIHVzZWQgYmV0d2VlbiBkYXRlcywgZGVmYXVsdHMgdG8gLVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGVGb3JtYXQoZm9ybWF0RW51bSwgZGF0ZVNlcGFyYXRvcikge1xuICAgICAgICBpZiAoZm9ybWF0RW51bSA9PT0gdm9pZCAwKSB7IGZvcm1hdEVudW0gPSBEYXRlRm9ybWF0RW51bS5EZWZhdWx0OyB9XG4gICAgICAgIGlmIChkYXRlU2VwYXJhdG9yID09PSB2b2lkIDApIHsgZGF0ZVNlcGFyYXRvciA9IFwiLVwiOyB9XG4gICAgICAgIHRoaXMuX2Zvcm1hdEVudW0gPSBmb3JtYXRFbnVtO1xuICAgICAgICB0aGlzLl9kYXRlU2VwYXJhdG9yID0gZGF0ZVNlcGFyYXRvcjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGVGb3JtYXQucHJvdG90eXBlLCBcImZvcm1hdEVudW1cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXRFbnVtO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9ybWF0RW51bSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0ZUZvcm1hdC5wcm90b3R5cGUsIFwiZGF0ZVNlcGFyYXRvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVTZXBhcmF0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRlU2VwYXJhdG9yID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIERhdGVGb3JtYXQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZUZvcm1hdCh0aGlzLl9mb3JtYXRFbnVtLCB0aGlzLl9kYXRlU2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlRm9ybWF0O1xufSgpKTtcbmV4cG9ydHMuRGF0ZUZvcm1hdCA9IERhdGVGb3JtYXQ7XG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBsb2cgZm9ybWF0LCB3aGF0IHdpbGwgYSBsb2cgbGluZSBsb29rIGxpa2U/XG4gKi9cbnZhciBMb2dGb3JtYXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIExvZ0Zvcm1hdC4gQ2FuIGJlIGNyZWF0ZWQgd2l0aG91dCBwYXJhbWV0ZXJzIHdoZXJlIGl0IHdpbGwgdXNlIHNhbmUgZGVmYXVsdHMuXG4gICAgICogQHBhcmFtIGRhdGVGb3JtYXQgRGF0ZUZvcm1hdCAod2hhdCBuZWVkcyB0aGUgZGF0ZSBsb29rIGxpa2UgaW4gdGhlIGxvZyBsaW5lKVxuICAgICAqIEBwYXJhbSBzaG93VGltZVN0YW1wIFNob3cgZGF0ZSB0aW1lc3RhbXAgYXQgYWxsP1xuICAgICAqIEBwYXJhbSBzaG93TG9nZ2VyTmFtZSBTaG93IHRoZSBsb2dnZXIgbmFtZT9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2dGb3JtYXQoZGF0ZUZvcm1hdCwgc2hvd1RpbWVTdGFtcCwgc2hvd0xvZ2dlck5hbWUpIHtcbiAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT09IHZvaWQgMCkgeyBkYXRlRm9ybWF0ID0gbmV3IERhdGVGb3JtYXQoKTsgfVxuICAgICAgICBpZiAoc2hvd1RpbWVTdGFtcCA9PT0gdm9pZCAwKSB7IHNob3dUaW1lU3RhbXAgPSB0cnVlOyB9XG4gICAgICAgIGlmIChzaG93TG9nZ2VyTmFtZSA9PT0gdm9pZCAwKSB7IHNob3dMb2dnZXJOYW1lID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLl9zaG93VGltZVN0YW1wID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2hvd0xvZ2dlck5hbWUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kYXRlRm9ybWF0ID0gZGF0ZUZvcm1hdDtcbiAgICAgICAgdGhpcy5fc2hvd1RpbWVTdGFtcCA9IHNob3dUaW1lU3RhbXA7XG4gICAgICAgIHRoaXMuX3Nob3dMb2dnZXJOYW1lID0gc2hvd0xvZ2dlck5hbWU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dGb3JtYXQucHJvdG90eXBlLCBcImRhdGVGb3JtYXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlRm9ybWF0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nRm9ybWF0LnByb3RvdHlwZSwgXCJzaG93VGltZVN0YW1wXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hvd1RpbWVTdGFtcDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dUaW1lU3RhbXAgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0Zvcm1hdC5wcm90b3R5cGUsIFwic2hvd0xvZ2dlck5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaG93TG9nZ2VyTmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dMb2dnZXJOYW1lID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBMb2dGb3JtYXQ7XG59KCkpO1xuZXhwb3J0cy5Mb2dGb3JtYXQgPSBMb2dGb3JtYXQ7XG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBsb2cgZm9ybWF0LCB3aGF0IHdpbGwgYSBsb2cgbGluZSBsb29rIGxpa2U/XG4gKi9cbnZhciBDYXRlZ29yeUxvZ0Zvcm1hdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIGRlZmluaW5nIHRoZSBjYXRlZ29yeSBsb2cgZm9ybWF0IHVzZWQuXG4gICAgICogQHBhcmFtIGRhdGVGb3JtYXQgRGF0ZSBmb3JtYXQgKHVzZXMgZGVmYXVsdCksIGZvciBkZXRhaWxzIHNlZSBEYXRlRm9ybWF0IGNsYXNzLlxuICAgICAqIEBwYXJhbSBzaG93VGltZVN0YW1wIFRydWUgdG8gc2hvdyB0aW1lc3RhbXAgaW4gdGhlIGxvZ2dpbmcsIGRlZmF1bHRzIHRvIHRydWUuXG4gICAgICogQHBhcmFtIHNob3dDYXRlZ29yeU5hbWUgVHJ1ZSB0byBzaG93IGNhdGVnb3J5IG5hbWUgaW4gdGhlIGxvZ2dpbmcsIGRlZmF1bHRzIHRvIHRydWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlMb2dGb3JtYXQoZGF0ZUZvcm1hdCwgc2hvd1RpbWVTdGFtcCwgc2hvd0NhdGVnb3J5TmFtZSkge1xuICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PT0gdm9pZCAwKSB7IGRhdGVGb3JtYXQgPSBuZXcgRGF0ZUZvcm1hdCgpOyB9XG4gICAgICAgIGlmIChzaG93VGltZVN0YW1wID09PSB2b2lkIDApIHsgc2hvd1RpbWVTdGFtcCA9IHRydWU7IH1cbiAgICAgICAgaWYgKHNob3dDYXRlZ29yeU5hbWUgPT09IHZvaWQgMCkgeyBzaG93Q2F0ZWdvcnlOYW1lID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLl9kYXRlRm9ybWF0ID0gZGF0ZUZvcm1hdDtcbiAgICAgICAgdGhpcy5fc2hvd1RpbWVTdGFtcCA9IHNob3dUaW1lU3RhbXA7XG4gICAgICAgIHRoaXMuX3Nob3dDYXRlZ29yeU5hbWUgPSBzaG93Q2F0ZWdvcnlOYW1lO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dGb3JtYXQucHJvdG90eXBlLCBcImRhdGVGb3JtYXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlRm9ybWF0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGF0ZUZvcm1hdCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dGb3JtYXQucHJvdG90eXBlLCBcInNob3dUaW1lU3RhbXBcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaG93VGltZVN0YW1wO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2hvd1RpbWVTdGFtcCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dGb3JtYXQucHJvdG90eXBlLCBcInNob3dDYXRlZ29yeU5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaG93Q2F0ZWdvcnlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2hvd0NhdGVnb3J5TmFtZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDYXRlZ29yeUxvZ0Zvcm1hdC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXRlZ29yeUxvZ0Zvcm1hdCh0aGlzLl9kYXRlRm9ybWF0LmNvcHkoKSwgdGhpcy5fc2hvd1RpbWVTdGFtcCwgdGhpcy5fc2hvd0NhdGVnb3J5TmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcnlMb2dGb3JtYXQ7XG59KCkpO1xuZXhwb3J0cy5DYXRlZ29yeUxvZ0Zvcm1hdCA9IENhdGVnb3J5TG9nRm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nZ2VyT3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEYXRhU3RydWN0dXJlc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL0RhdGFTdHJ1Y3R1cmVzXCIpO1xudmFyIE1lc3NhZ2VVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL01lc3NhZ2VVdGlsc1wiKTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbnZhciBDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsKG1lc3NhZ2UsIGVycm9yLCBjYXRlZ29yaWVzLCBkYXRlLCBsZXZlbCwgbG9nRm9ybWF0LCByZWFkeSkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlZEVycm9yTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lcnJvckFzU3RhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5fY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXM7XG4gICAgICAgIHRoaXMuX2RhdGUgPSBkYXRlO1xuICAgICAgICB0aGlzLl9sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLl9sb2dGb3JtYXQgPSBsb2dGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3JlYWR5ID0gcmVhZHk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5TG9nTWVzc2FnZUltcGwucHJvdG90eXBlLCBcImVycm9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJjYXRlZ29yaWVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2F0ZWdvcmllcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5TG9nTWVzc2FnZUltcGwucHJvdG90eXBlLCBcImRhdGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUsIFwibGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5TG9nTWVzc2FnZUltcGwucHJvdG90eXBlLCBcImxvZ0Zvcm1hdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0Zvcm1hdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5TG9nTWVzc2FnZUltcGwucHJvdG90eXBlLCBcImlzTWVzc2FnZUxvZ0RhdGFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgKHRoaXMuX21lc3NhZ2UpICE9PSBcInN0cmluZ1wiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUsIFwibWVzc2FnZUFzU3RyaW5nXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLl9tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2UubXNnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUsIFwibG9nRGF0YVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLl9tZXNzYWdlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJpc1Jlc29sdmVkRXJyb3JNZXNzYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWRFcnJvck1lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJlcnJvckFzU3RhY2tcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvckFzU3RhY2s7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvckFzU3RhY2sgPSBzdGFjaztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUuaXNSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5O1xuICAgIH07XG4gICAgQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUuc2V0UmVhZHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSB2YWx1ZTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJyZXNvbHZlZEVycm9yTWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkRXJyb3JNZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRFcnJvck1lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIENhdGVnb3J5TG9nTWVzc2FnZUltcGw7XG59KCkpO1xuLyoqXG4gKiBBYnN0cmFjdCBjYXRlZ29yeSBsb2dnZXIsIHVzZSBhcyB5b3VyIGJhc2UgY2xhc3MgZm9yIG5ldyB0eXBlIG9mIGxvZ2dlcnMgKGl0XG4gKiBzYXZlcyB5b3UgYSBsb3Qgb2Ygd29yaykgYW5kIG92ZXJyaWRlIGRvTG9nKENhdGVnb3J5TG9nTWVzc2FnZSkuIFRoZSBtZXNzYWdlIGFyZ3VtZW50XG4gKiBwcm92aWRlcyBmdWxsIGFjY2VzcyB0byBhbnl0aGluZyByZWxhdGVkIHRvIHRoZSBsb2dnaW5nIGV2ZW50LlxuICogSWYgeW91IGp1c3Qgd2FudCB0aGUgc3RhbmRhcmQgbGluZSBvZiBsb2dnaW5nLCBjYWxsOiB0aGlzLmNyZWF0ZURlZmF1bHRMb2dNZXNzYWdlKG1zZykgb25cbiAqIHRoaXMgY2xhc3Mgd2hpY2ggd2lsbCByZXR1cm4geW91IHRoZSBmb3JtYXR0ZWQgbG9nIG1lc3NhZ2UgYXMgc3RyaW5nIChlLmcuIHRoZVxuICogZGVmYXVsdCBsb2dnZXJzIGFsbCB1c2UgdGhpcykuXG4gKi9cbnZhciBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyKHJvb3RDYXRlZ29yeSwgcnVudGltZVNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuYWxsTWVzc2FnZXMgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5MaW5rZWRMaXN0KCk7XG4gICAgICAgIHRoaXMucm9vdENhdGVnb3J5ID0gcm9vdENhdGVnb3J5O1xuICAgICAgICB0aGlzLnJ1bnRpbWVTZXR0aW5ncyA9IHJ1bnRpbWVTZXR0aW5ncztcbiAgICB9XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUudHJhY2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5hcHBseSh0aGlzLCBbTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLlRyYWNlLCBtc2csIG51bGwsIGZhbHNlXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5hcHBseSh0aGlzLCBbTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkRlYnVnLCBtc2csIG51bGwsIGZhbHNlXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nLmFwcGx5KHRoaXMsIFtMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuSW5mbywgbXNnLCBudWxsLCBmYWxzZV0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5hcHBseSh0aGlzLCBbTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLldhcm4sIG1zZywgbnVsbCwgZmFsc2VdLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgfTtcbiAgICBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5hcHBseSh0aGlzLCBbTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yLCBtc2csIGVycm9yLCBmYWxzZV0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLmZhdGFsID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nLmFwcGx5KHRoaXMsIFtMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRmF0YWwsIG1zZywgZXJyb3IsIGZhbHNlXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUucmVzb2x2ZWQgPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cuYXBwbHkodGhpcywgW0xvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5FcnJvciwgbXNnLCBlcnJvciwgdHJ1ZV0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgbXNnLCBlcnJvcikge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cuYXBwbHkodGhpcywgW2xldmVsLCBtc2csIGVycm9yLCBmYWxzZV0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLmdldFJvb3RDYXRlZ29yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdENhdGVnb3J5O1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUuY3JlYXRlRGVmYXVsdExvZ01lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHJldHVybiBNZXNzYWdlVXRpbHNfMS5NZXNzYWdlRm9ybWF0VXRpbHMucmVuZGVyRGVmYXVsdE1lc3NhZ2UobXNnLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBvcHRpb25hbCBtZXNzYWdlIGZvcm1hdHRlci4gQWxsIExvZ2dlclR5cGVzIChleGNlcHQgY3VzdG9tKSB3aWxsIHNlZSBpZlxuICAgICAqIHRoZXkgaGF2ZSB0aGlzLCBhbmQgaWYgc28gdXNlIGl0IHRvIGxvZy5cbiAgICAgKiBAcmV0dXJucyB7KChtZXNzYWdlOkNhdGVnb3J5TG9nTWVzc2FnZSk9PnN0cmluZyl8bnVsbH1cbiAgICAgKi9cbiAgICBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyLnByb3RvdHlwZS5fZ2V0TWVzc2FnZUZvcm1hdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhdGVnb3J5U2V0dGluZ3MgPSB0aGlzLnJ1bnRpbWVTZXR0aW5ncy5nZXRDYXRlZ29yeVNldHRpbmdzKHRoaXMucm9vdENhdGVnb3J5KTtcbiAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXBwZW4gYnV0IG1ha2UgdHMgaGFwcHlcbiAgICAgICAgaWYgKGNhdGVnb3J5U2V0dGluZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpZCBub3QgZmluZCBDYXRlZ29yeVNldHRpbmdzIGZvciByb290Q2F0ZWdvcnk6IFwiICsgdGhpcy5yb290Q2F0ZWdvcnkubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhdGVnb3J5U2V0dGluZ3MuZm9ybWF0dGVyTG9nTWVzc2FnZTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLl9sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIG1zZywgZXJyb3IsIHJlc29sdmVkKSB7XG4gICAgICAgIGlmIChlcnJvciA9PT0gdm9pZCAwKSB7IGVycm9yID0gbnVsbDsgfVxuICAgICAgICBpZiAocmVzb2x2ZWQgPT09IHZvaWQgMCkgeyByZXNvbHZlZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gNF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMuX2xvZ0ludGVybmFsKGxldmVsLCAoKSA9PiBtc2csICgpID0+IGVycm9yLCByZXNvbHZlZCwgLi4uY2F0ZWdvcmllcyk7XG4gICAgICAgIHZhciBmdW5jdGlvbk1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1zZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZ1bmN0aW9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbG9nSW50ZXJuYWwuYXBwbHkodGhpcywgW2xldmVsLCBmdW5jdGlvbk1lc3NhZ2UsIGZ1bmN0aW9uRXJyb3IsIHJlc29sdmVkXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUuX2xvZ0ludGVybmFsID0gZnVuY3Rpb24gKGxldmVsLCBtc2csIGVycm9yLCByZXNvbHZlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDQ7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9nQ2F0ZWdvcmllcyA9IFt0aGlzLnJvb3RDYXRlZ29yeV07XG4gICAgICAgIC8vIExvZyByb290IGNhdGVnb3J5IGJ5IGRlZmF1bHQgaWYgbm9uZSBwcmVzZW50XG4gICAgICAgIGlmICh0eXBlb2YgY2F0ZWdvcmllcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYXRlZ29yaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvZ0NhdGVnb3JpZXMgPSBsb2dDYXRlZ29yaWVzLmNvbmNhdChjYXRlZ29yaWVzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAhPT0gX3RoaXMucm9vdENhdGVnb3J5OyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5ID0gbG9nQ2F0ZWdvcmllc1tpXTtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYXZlIGEgbnVsbCBlbGVtZW50IHdpdGhpbiBjYXRlZ29yaWVzLCBhdCBpbmRleD1cIiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpc18xLnJ1bnRpbWVTZXR0aW5ncy5nZXRDYXRlZ29yeVNldHRpbmdzKGNhdGVnb3J5KTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhdGVnb3J5IHdpdGggcGF0aDogXCIgKyBjYXRlZ29yeS5nZXRDYXRlZ29yeVBhdGgoKSArIFwiIGlzIG5vdCByZWdpc3RlcmVkIHdpdGggdGhpcyBsb2dnZXIsIG1heWJlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ5b3UgcmVnaXN0ZXJlZCBpdCB3aXRoIGEgZGlmZmVyZW50IHJvb3QgbG9nZ2VyP1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5sb2dMZXZlbCA8PSBsZXZlbCkge1xuICAgICAgICAgICAgICAgIHZhciBhY3R1YWxFcnJvciA9IGVycm9yICE9PSBudWxsID8gZXJyb3IoKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGFjdHVhbEVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2dNZXNzYWdlID0gbmV3IENhdGVnb3J5TG9nTWVzc2FnZUltcGwobXNnKCksIGFjdHVhbEVycm9yLCBsb2dDYXRlZ29yaWVzLCBuZXcgRGF0ZSgpLCBsZXZlbCwgc2V0dGluZ3MubG9nRm9ybWF0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nTWVzc2FnZS5yZXNvbHZlZEVycm9yTWVzc2FnZSA9IHJlc29sdmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYWxsTWVzc2FnZXMuYWRkVGFpbChsb2dNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLnByb2Nlc3NNZXNzYWdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ01lc3NhZ2VfMSA9IG5ldyBDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsKG1zZygpLCBhY3R1YWxFcnJvciwgbG9nQ2F0ZWdvcmllcywgbmV3IERhdGUoKSwgbGV2ZWwsIHNldHRpbmdzLmxvZ0Zvcm1hdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBsb2dNZXNzYWdlXzEucmVzb2x2ZWRFcnJvck1lc3NhZ2UgPSByZXNvbHZlZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmFsbE1lc3NhZ2VzLmFkZFRhaWwobG9nTWVzc2FnZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZVV0aWxzXzEuTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckVycm9yKGFjdHVhbEVycm9yKS50aGVuKGZ1bmN0aW9uIChzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nTWVzc2FnZV8xLmVycm9yQXNTdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nTWVzc2FnZV8xLnNldFJlYWR5KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc01lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ01lc3NhZ2VfMS5lcnJvckFzU3RhY2sgPSBcIjxVTktOT1dOPiB1bmFibGUgdG8gZ2V0IHN0YWNrLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nTWVzc2FnZV8xLnNldFJlYWR5KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc01lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgLy8gR2V0IHRoZSBydW50aW1lIGxldmVscyBmb3IgZ2l2ZW4gY2F0ZWdvcmllcy4gSWYgdGhlaXIgbGV2ZWwgaXMgbG93ZXIgdGhhbiBnaXZlbiBsZXZlbCwgd2UgbG9nLlxuICAgICAgICAvLyBJbiBhZGRpdGlvbiB3ZSBwYXNzIGFsb25nIHdoaWNoIGNhdGVnb3J5L2NhdGVnb3JpZXMgd2UgbG9nIHRoaXMgc3RhdGVtZW50IGZvci5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dDYXRlZ29yaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEoaSk7XG4gICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyLnByb3RvdHlwZS5wcm9jZXNzTWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJhc2ljYWxseSB3ZSB3YWl0IHVudGlsIGVycm9ycyBhcmUgcmVzb2x2ZWQgKHRob3NlIG1lc3NhZ2VzXG4gICAgICAgIC8vIG1heSBub3QgYmUgcmVhZHkpLlxuICAgICAgICB2YXIgbXNncyA9IHRoaXMuYWxsTWVzc2FnZXM7XG4gICAgICAgIGlmIChtc2dzLmdldFNpemUoKSA+IDApIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gbXNncy5nZXRIZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1zZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbXNnLmlzUmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXNncy5yZW1vdmVIZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9Mb2cobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChtc2dzLmdldFNpemUoKSA+IDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcjtcbn0oKSk7XG5leHBvcnRzLkFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIgPSBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbnZhciBDYXRlZ29yeVNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL0NhdGVnb3J5U2VydmljZVwiKTtcbi8qKlxuICogQ2F0ZWdvcnkgZm9yIHVzZSB3aXRoIGNhdGVnb3JpemVkIGxvZ2dpbmcuXG4gKiBBdCBtaW5pbXVtIHlvdSBuZWVkIG9uZSBjYXRlZ29yeSwgd2hpY2ggd2lsbCBzZXJ2ZSBhcyB0aGUgcm9vdCBjYXRlZ29yeS5cbiAqIFlvdSBjYW4gY3JlYXRlIGNoaWxkIGNhdGVnb3JpZXMgKGxpa2UgYSB0cmVlKS4gWW91IGNhbiBoYXZlIG11bHRpcGxlIHJvb3RcbiAqIGNhdGVnb3JpZXMuXG4gKi9cbnZhciBDYXRlZ29yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnkobmFtZSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yO1xuICAgICAgICBpZiAobmFtZS5pbmRleE9mKFwiI1wiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgIyBpbiBhIG5hbWUgb2YgYSBDYXRlZ29yeVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pZCA9IENhdGVnb3J5Lm5leHRJZCgpO1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLnJlZ2lzdGVyQ2F0ZWdvcnkodGhpcyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeS5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnkucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeS5wcm90b3R5cGUsIFwibG9nTGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2F0ZWdvcnkucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRDYXRlZ29yeUxvZ2dlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLl9sb2dnZXIpLnRyYWNlLmFwcGx5KF9hLCBbbXNnXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBDYXRlZ29yeS5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZENhdGVnb3J5TG9nZ2VyKCk7XG4gICAgICAgIChfYSA9IHRoaXMuX2xvZ2dlcikuZGVidWcuYXBwbHkoX2EsIFttc2ddLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIENhdGVnb3J5LnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRDYXRlZ29yeUxvZ2dlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLl9sb2dnZXIpLmluZm8uYXBwbHkoX2EsIFttc2ddLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIENhdGVnb3J5LnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRDYXRlZ29yeUxvZ2dlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLl9sb2dnZXIpLndhcm4uYXBwbHkoX2EsIFttc2ddLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIENhdGVnb3J5LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZENhdGVnb3J5TG9nZ2VyKCk7XG4gICAgICAgIChfYSA9IHRoaXMuX2xvZ2dlcikuZXJyb3IuYXBwbHkoX2EsIFttc2csIGVycm9yXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBDYXRlZ29yeS5wcm90b3R5cGUuZmF0YWwgPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRDYXRlZ29yeUxvZ2dlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLl9sb2dnZXIpLmZhdGFsLmFwcGx5KF9hLCBbbXNnLCBlcnJvcl0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgQ2F0ZWdvcnkucHJvdG90eXBlLnJlc29sdmVkID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkQ2F0ZWdvcnlMb2dnZXIoKTtcbiAgICAgICAgKF9hID0gdGhpcy5fbG9nZ2VyKS5yZXNvbHZlZC5hcHBseShfYSwgW21zZywgZXJyb3JdLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIENhdGVnb3J5LnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAzXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkQ2F0ZWdvcnlMb2dnZXIoKTtcbiAgICAgICAgKF9hID0gdGhpcy5fbG9nZ2VyKS5sb2cuYXBwbHkoX2EsIFtsZXZlbCwgbXNnLCBlcnJvcl0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgQ2F0ZWdvcnkucHJvdG90eXBlLmdldENhdGVnb3J5UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubmFtZTtcbiAgICAgICAgdmFyIGNhdCA9IHRoaXMucGFyZW50O1xuICAgICAgICB3aGlsZSAoY2F0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhdC5uYW1lICsgXCIjXCIgKyByZXN1bHQ7XG4gICAgICAgICAgICBjYXQgPSBjYXQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnkucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGlkIGZvciB0aGlzIGNhdGVnb3J5ICh0aGlzXG4gICAgICAgICAqIGlzIGZvciBpbnRlcm5hbCBwdXJwb3NlcyBvbmx5KS5cbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gSWRcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDYXRlZ29yeS5wcm90b3R5cGUubG9hZENhdGVnb3J5TG9nZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvZ2dlcikge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyID0gQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLmdldExvZ2dlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2xvZ2dlciA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0aGlzLl9sb2dnZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIGEgbG9nZ2VyIGZvciBjYXRlZ29yeSAoc2hvdWxkIG5vdCBoYXBwZW4pOiBcIiArIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhdGVnb3J5Lm5leHRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIENhdGVnb3J5LmN1cnJlbnRJZCsrO1xuICAgIH07XG4gICAgQ2F0ZWdvcnkuY3VycmVudElkID0gMTtcbiAgICByZXR1cm4gQ2F0ZWdvcnk7XG59KCkpO1xuZXhwb3J0cy5DYXRlZ29yeSA9IENhdGVnb3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2F0ZWdvcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL0xvZ2dlck9wdGlvbnNcIik7XG4vKipcbiAqIERlZmF1bHQgY29uZmlndXJhdGlvbiwgY2FuIGJlIHVzZWQgdG8gaW5pdGlhbGx5IHNldCBhIGRpZmZlcmVudCBkZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAqIG9uIHRoZSBDYXRlZ29yeVNlcnZpY2VGYWN0b3J5LiBUaGlzIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgY2F0ZWdvcmllcyBhbHJlYWR5IHJlZ2lzdGVyZWQgKG9yXG4gKiByZWdpc3RlcmVkIGluIHRoZSBmdXR1cmUpLiBDYW4gYWxzbyBiZSBhcHBsaWVkIHRvIG9uZSBDYXRlZ29yeSAoYW5kIGNoaWxkcykuXG4gKi9cbnZhciBDYXRlZ29yeUNvbmZpZ3VyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBsb2dMZXZlbCBMb2cgbGV2ZWwgZm9yIGFsbCBsb2dnZXJzLCBkZWZhdWx0IGlzIExvZ0xldmVsLkVycm9yXG4gICAgICogQHBhcmFtIGxvZ2dlclR5cGUgV2hlcmUgdG8gbG9nLCBkZWZhdWx0IGlzIExvZ2dlclR5cGUuQ29uc29sZVxuICAgICAqIEBwYXJhbSBsb2dGb3JtYXQgV2hhdCBsb2dnaW5nIGZvcm1hdCB0byB1c2UsIHVzZSBkZWZhdWx0IGluc3RhbmNlLCBmb3IgZGVmYXVsdCB2YWx1ZXMgc2VlIENhdGVnb3J5TG9nRm9ybWF0LlxuICAgICAqIEBwYXJhbSBjYWxsQmFja0xvZ2dlciBPcHRpb25hbCBjYWxsYmFjaywgaWYgTG9nZ2VyVHlwZS5DdXN0b20gaXMgdXNlZCBhcyBsb2dnZXJUeXBlLiBJbiB0aGF0IGNhc2UgbXVzdCByZXR1cm4gYSBuZXcgTG9nZ2VyIGluc3RhbmNlLlxuICAgICAqICAgICAgICAgICAgSXQgaXMgcmVjb21tZW5kZWQgdG8gZXh0ZW5kIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIgdG8gbWFrZSB5b3VyIGN1c3RvbSBsb2dnZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlDb25maWd1cmF0aW9uKGxvZ0xldmVsLCBsb2dnZXJUeXBlLCBsb2dGb3JtYXQsIGNhbGxCYWNrTG9nZ2VyKSB7XG4gICAgICAgIGlmIChsb2dMZXZlbCA9PT0gdm9pZCAwKSB7IGxvZ0xldmVsID0gTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yOyB9XG4gICAgICAgIGlmIChsb2dnZXJUeXBlID09PSB2b2lkIDApIHsgbG9nZ2VyVHlwZSA9IExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkNvbnNvbGU7IH1cbiAgICAgICAgaWYgKGxvZ0Zvcm1hdCA9PT0gdm9pZCAwKSB7IGxvZ0Zvcm1hdCA9IG5ldyBMb2dnZXJPcHRpb25zXzEuQ2F0ZWdvcnlMb2dGb3JtYXQoKTsgfVxuICAgICAgICBpZiAoY2FsbEJhY2tMb2dnZXIgPT09IHZvaWQgMCkgeyBjYWxsQmFja0xvZ2dlciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fZm9ybWF0dGVyTG9nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gbG9nTGV2ZWw7XG4gICAgICAgIHRoaXMuX2xvZ2dlclR5cGUgPSBsb2dnZXJUeXBlO1xuICAgICAgICB0aGlzLl9sb2dGb3JtYXQgPSBsb2dGb3JtYXQ7XG4gICAgICAgIHRoaXMuX2NhbGxCYWNrTG9nZ2VyID0gY2FsbEJhY2tMb2dnZXI7XG4gICAgICAgIGlmICh0aGlzLl9sb2dnZXJUeXBlID09PSBMb2dnZXJPcHRpb25zXzEuTG9nZ2VyVHlwZS5DdXN0b20gJiYgdGhpcy5jYWxsQmFja0xvZ2dlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWYgeW91IHNwZWNpZnkgbG9nZ2VyVHlwZSB0byBiZSBDdXN0b20sIHlvdSBtdXN0IHByb3ZpZGUgdGhlIGNhbGxCYWNrTG9nZ2VyIGFyZ3VtZW50XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLCBcImxvZ0xldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLCBcImxvZ2dlclR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dnZXJUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlDb25maWd1cmF0aW9uLnByb3RvdHlwZSwgXCJsb2dGb3JtYXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dGb3JtYXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLCBcImNhbGxCYWNrTG9nZ2VyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbEJhY2tMb2dnZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLCBcImZvcm1hdHRlckxvZ01lc3NhZ2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmb3JtYXR0ZXJMb2dNZXNzYWdlIGZ1bmN0aW9uLCBzZWUgY29tbWVudCBvbiB0aGUgc2V0dGVyLlxuICAgICAgICAgKiBAcmV0dXJucyB7KChtZXNzYWdlOkNhdGVnb3J5TG9nTWVzc2FnZSk9PnN0cmluZyl8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGRlZmF1bHQgZm9ybWF0dGVyTG9nTWVzc2FnZSBmdW5jdGlvbiwgaWYgc2V0IGl0IGlzIGFwcGxpZWQgdG8gYWxsIHR5cGUgb2YgbG9nZ2VycyBleGNlcHQgZm9yIGEgY3VzdG9tIGxvZ2dlci5cbiAgICAgICAgICogQnkgZGVmYXVsdCB0aGlzIGlzIG51bGwgKG5vdCBzZXQpLiBZb3UgY2FuIGFzc2lnbiBhIGZ1bmN0aW9uIHRvIGFsbG93IGN1c3RvbSBmb3JtYXR0aW5nIG9mIGEgbG9nIG1lc3NhZ2UuXG4gICAgICAgICAqIEVhY2ggbG9nIG1lc3NhZ2Ugd2lsbCBjYWxsIHRoaXMgZnVuY3Rpb24gdGhlbiBhbmQgZXhwZWN0cyB5b3VyIGZ1bmN0aW9uIHRvIGZvcm1hdCB0aGUgbWVzc2FnZSBhbmQgcmV0dXJuIGEgc3RyaW5nLlxuICAgICAgICAgKiBXaWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSBhdHRlbXB0IHRvIHNldCBhIGZvcm1hdHRlckxvZ01lc3NhZ2UgaWYgdGhlIExvZ2dlclR5cGUgaXMgY3VzdG9tLlxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGZvcm1hdHRlciBmdW5jdGlvbiwgb3IgbnVsbCB0byByZXNldCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdGhpcy5fbG9nZ2VyVHlwZSA9PT0gTG9nZ2VyT3B0aW9uc18xLkxvZ2dlclR5cGUuQ3VzdG9tKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBzcGVjaWZ5IGEgZm9ybWF0dGVyIGZvciBsb2cgbWVzc2FnZXMgaWYgeW91ciBsb2dnZXJUeXBlIGlzIEN1c3RvbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2F0ZWdvcnlDb25maWd1cmF0aW9uLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0gbmV3IENhdGVnb3J5Q29uZmlndXJhdGlvbih0aGlzLmxvZ0xldmVsLCB0aGlzLmxvZ2dlclR5cGUsIHRoaXMubG9nRm9ybWF0LmNvcHkoKSwgdGhpcy5jYWxsQmFja0xvZ2dlcik7XG4gICAgICAgIGNvbmZpZy5mb3JtYXR0ZXJMb2dNZXNzYWdlID0gdGhpcy5mb3JtYXR0ZXJMb2dNZXNzYWdlO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgcmV0dXJuIENhdGVnb3J5Q29uZmlndXJhdGlvbjtcbn0oKSk7XG5leHBvcnRzLkNhdGVnb3J5Q29uZmlndXJhdGlvbiA9IENhdGVnb3J5Q29uZmlndXJhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhdGVnb3J5Q29uZmlndXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0Q2F0ZWdvcnlMb2dnZXJcIik7XG4vKipcbiAqIFNpbXBsZSBsb2dnZXIsIHRoYXQgbG9ncyB0byB0aGUgY29uc29sZS4gSWYgdGhlIGNvbnNvbGUgaXMgdW5hdmFpbGFibGUgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gKi9cbnZhciBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsKHJvb3RDYXRlZ29yeSwgcnVudGltZVNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCByb290Q2F0ZWdvcnksIHJ1bnRpbWVTZXR0aW5ncykgfHwgdGhpcztcbiAgICB9XG4gICAgQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbC5wcm90b3R5cGUuZG9Mb2cgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmIChjb25zb2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRm9ybWF0dGVyID0gdGhpcy5fZ2V0TWVzc2FnZUZvcm1hdHRlcigpO1xuICAgICAgICAgICAgdmFyIGZ1bGxNc2cgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAobWVzc2FnZUZvcm1hdHRlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZ1bGxNc2cgPSB0aGlzLmNyZWF0ZURlZmF1bHRMb2dNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmdWxsTXNnID0gbWVzc2FnZUZvcm1hdHRlcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICAgICAgc3dpdGNoIChtc2cubGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5UcmFjZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgdHJ5IHRyYWNlIHdlIGRvbid0IHdhbnQgc3RhY2tzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkRlYnVnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCB0cnksIHRvbyBtdWNoIGRpZmZlcmVuY2VzIG9mIGNvbnNvbGVzLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5JbmZvOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5pbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oZnVsbE1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLldhcm46XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihmdWxsTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRXJyb3I6XG4gICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRmF0YWw6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGZ1bGxNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBsZXZlbDogXCIgKyBtc2cubGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsb2dnZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmdWxsTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uc29sZSBpcyBub3QgZGVmaW5lZCwgY2Fubm90IGxvZyBtc2c6IFwiICsgbXNnLm1lc3NhZ2VBc1N0cmluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsO1xufShBYnN0cmFjdENhdGVnb3J5TG9nZ2VyXzEuQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcikpO1xuZXhwb3J0cy5DYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsID0gQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhdGVnb3J5Q29uc29sZUxvZ2dlckltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIERlbGVnYXRlIGxvZ2dlciwgZGVsZWdhdGVzIGxvZ2dpbmcgdG8gZ2l2ZW4gbG9nZ2VyIChjb25zdHJ1Y3RvcikuXG4gKi9cbnZhciBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwoZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsLnByb3RvdHlwZSwgXCJkZWxlZ2F0ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9kZWxlZ2F0ZSkudHJhY2UuYXBwbHkoX2EsIFttc2ddLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLmRlYnVnLmFwcGx5KF9hLCBbbXNnXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbC5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLmluZm8uYXBwbHkoX2EsIFttc2ddLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9kZWxlZ2F0ZSkud2Fybi5hcHBseShfYSwgW21zZ10uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLmVycm9yLmFwcGx5KF9hLCBbbXNnLCBlcnJvcl0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwucHJvdG90eXBlLmZhdGFsID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLmZhdGFsLmFwcGx5KF9hLCBbbXNnLCBlcnJvcl0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwucHJvdG90eXBlLnJlc29sdmVkID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLnJlc29sdmVkLmFwcGx5KF9hLCBbbXNnLCBlcnJvcl0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgbXNnLCBlcnJvcikge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9kZWxlZ2F0ZSkubG9nLmFwcGx5KF9hLCBbbGV2ZWwsIG1zZywgZXJyb3JdLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIHJldHVybiBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbDtcbn0oKSk7XG5leHBvcnRzLkNhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsID0gQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEV4dGVuc2lvbkhlbHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL2V4dGVuc2lvbi9FeHRlbnNpb25IZWxwZXJcIik7XG52YXIgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RDYXRlZ29yeUxvZ2dlclwiKTtcbi8qKlxuICogVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHksIGl0IGlzIHVzZWQgZm9yIGNvbW11bmljYXRpb24gd2l0aCB0aGUgZXh0ZW5zaW9uIG9ubHkuXG4gKi9cbnZhciBDYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsKHJvb3RDYXRlZ29yeSwgcnVudGltZVNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCByb290Q2F0ZWdvcnksIHJ1bnRpbWVTZXR0aW5ncykgfHwgdGhpcztcbiAgICB9XG4gICAgQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsLnByb3RvdHlwZS5kb0xvZyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIEV4dGVuc2lvbkhlbHBlcl8xLkV4dGVuc2lvbkhlbHBlci5zZW5kQ2F0ZWdvcnlMb2dNZXNzYWdlKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIndpbmRvdyBpcyBub3QgYXZhaWxhYmxlLCB5b3UgbXVzdCBiZSBydW5uaW5nIGluIGEgYnJvd3NlciBmb3IgdGhpcy4gRHJvcHBlZCBtZXNzYWdlLlwiKTtcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsO1xufShBYnN0cmFjdENhdGVnb3J5TG9nZ2VyXzEuQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcikpO1xuZXhwb3J0cy5DYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGwgPSBDYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdENhdGVnb3J5TG9nZ2VyXCIpO1xuLyoqXG4gKiBMb2dnZXIgd2hpY2ggYnVmZmVycyBhbGwgbWVzc2FnZXMsIHVzZSB3aXRoIGNhcmUgZHVlIHRvIHBvc3NpYmxlIGhpZ2ggbWVtb3J5IGZvb3RwcmludC5cbiAqIENhbiBiZSBjb252ZW5pZW50IGluIHNvbWUgY2FzZXMuIENhbGwgdG9TdHJpbmcoKSBmb3IgZnVsbCBvdXRwdXQsIG9yIGNhc3QgdG8gdGhpcyBjbGFzc1xuICogYW5kIGNhbGwgZ2V0TWVzc2FnZXMoKSB0byBkbyBzb21ldGhpbmcgd2l0aCBpdCB5b3Vyc2VsZi5cbiAqL1xudmFyIENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYXRlZ29yeU1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwucHJvdG90eXBlLmdldE1lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcztcbiAgICB9O1xuICAgIENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5tYXAoZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICB9O1xuICAgIENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwucHJvdG90eXBlLmRvTG9nID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgbWVzc2FnZUZvcm1hdHRlciA9IHRoaXMuX2dldE1lc3NhZ2VGb3JtYXR0ZXIoKTtcbiAgICAgICAgdmFyIGZ1bGxNc2c7XG4gICAgICAgIGlmIChtZXNzYWdlRm9ybWF0dGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICBmdWxsTXNnID0gdGhpcy5jcmVhdGVEZWZhdWx0TG9nTWVzc2FnZShtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnVsbE1zZyA9IG1lc3NhZ2VGb3JtYXR0ZXIobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2goZnVsbE1zZyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbDtcbn0oQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcl8xLkFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIpKTtcbmV4cG9ydHMuQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbCA9IENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXRlZ29yeU1lc3NhZ2VCdWZmZXJJbXBsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJPcHRpb25zXCIpO1xuLyoqXG4gKiBSdW50aW1lU2V0dGluZ3MgZm9yIGEgY2F0ZWdvcnksIGF0IHJ1bnRpbWUgdGhlc2UgYXJlIGFzc29jaWF0ZWQgdG8gYSBjYXRlZ29yeS5cbiAqL1xudmFyIENhdGVnb3J5UnVudGltZVNldHRpbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXRlZ29yeVJ1bnRpbWVTZXR0aW5ncyhjYXRlZ29yeSwgbG9nTGV2ZWwsIGxvZ2dlclR5cGUsIGxvZ0Zvcm1hdCwgY2FsbEJhY2tMb2dnZXIsIGZvcm1hdHRlckxvZ01lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGxvZ0xldmVsID09PSB2b2lkIDApIHsgbG9nTGV2ZWwgPSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRXJyb3I7IH1cbiAgICAgICAgaWYgKGxvZ2dlclR5cGUgPT09IHZvaWQgMCkgeyBsb2dnZXJUeXBlID0gTG9nZ2VyT3B0aW9uc18xLkxvZ2dlclR5cGUuQ29uc29sZTsgfVxuICAgICAgICBpZiAobG9nRm9ybWF0ID09PSB2b2lkIDApIHsgbG9nRm9ybWF0ID0gbmV3IExvZ2dlck9wdGlvbnNfMS5DYXRlZ29yeUxvZ0Zvcm1hdCgpOyB9XG4gICAgICAgIGlmIChjYWxsQmFja0xvZ2dlciA9PT0gdm9pZCAwKSB7IGNhbGxCYWNrTG9nZ2VyID0gbnVsbDsgfVxuICAgICAgICBpZiAoZm9ybWF0dGVyTG9nTWVzc2FnZSA9PT0gdm9pZCAwKSB7IGZvcm1hdHRlckxvZ01lc3NhZ2UgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYXRlZ29yeSA9IGNhdGVnb3J5O1xuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgICAgICB0aGlzLl9sb2dnZXJUeXBlID0gbG9nZ2VyVHlwZTtcbiAgICAgICAgdGhpcy5fbG9nRm9ybWF0ID0gbG9nRm9ybWF0O1xuICAgICAgICB0aGlzLl9jYWxsQmFja0xvZ2dlciA9IGNhbGxCYWNrTG9nZ2VyO1xuICAgICAgICB0aGlzLl9mb3JtYXR0ZXJMb2dNZXNzYWdlID0gZm9ybWF0dGVyTG9nTWVzc2FnZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5UnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJjYXRlZ29yeVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhdGVnb3J5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImxvZ0xldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImxvZ2dlclR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dnZXJUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyVHlwZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImxvZ0Zvcm1hdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0Zvcm1hdDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ0Zvcm1hdCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImNhbGxCYWNrTG9nZ2VyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbEJhY2tMb2dnZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsQmFja0xvZ2dlciA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImZvcm1hdHRlckxvZ01lc3NhZ2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXR0ZXJMb2dNZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9ybWF0dGVyTG9nTWVzc2FnZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3M7XG59KCkpO1xuZXhwb3J0cy5DYXRlZ29yeVJ1bnRpbWVTZXR0aW5ncyA9IENhdGVnb3J5UnVudGltZVNldHRpbmdzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGF0YVN0cnVjdHVyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9EYXRhU3RydWN0dXJlc1wiKTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbnZhciBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsXzEgPSByZXF1aXJlKFwiLi9DYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsXCIpO1xudmFyIENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsXzEgPSByZXF1aXJlKFwiLi9DYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbFwiKTtcbnZhciBDYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGxfMSA9IHJlcXVpcmUoXCIuL0NhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbFwiKTtcbnZhciBDYXRlZ29yeU1lc3NhZ2VCdWZmZXJJbXBsXzEgPSByZXF1aXJlKFwiLi9DYXRlZ29yeU1lc3NhZ2VCdWZmZXJJbXBsXCIpO1xudmFyIEV4dGVuc2lvbkhlbHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL2V4dGVuc2lvbi9FeHRlbnNpb25IZWxwZXJcIik7XG52YXIgQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NhdGVnb3J5UnVudGltZVNldHRpbmdzXCIpO1xudmFyIENhdGVnb3J5Q29uZmlndXJhdGlvbl8xID0gcmVxdWlyZShcIi4vQ2F0ZWdvcnlDb25maWd1cmF0aW9uXCIpO1xuLyoqXG4gKiBUaGUgc2VydmljZSAob25seSBhdmFpbGFibGUgYXMgc2luZ2xldG9uKSBmb3IgYWxsIGNhdGVnb3J5IHJlbGF0ZWQgc3R1ZmYgYXNcbiAqIHJldHJpZXZpbmcsIHJlZ2lzdGVyaW5nIGEgbG9nZ2VyLiBZb3Ugc2hvdWxkIG5vcm1hbGx5IE5PVCB1c2UgdGhpcyxcbiAqIGluc3RlYWQgdXNlIENhdGVnb3J5U2VydmljZUZhY3Rvcnkgd2hpY2ggaXMgbWVhbnQgZm9yIGVuZCB1c2Vycy5cbiAqL1xudmFyIENhdGVnb3J5U2VydmljZUltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhdGVnb3J5U2VydmljZUltcGwoKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRDb25maWcgPSBuZXcgQ2F0ZWdvcnlDb25maWd1cmF0aW9uXzEuQ2F0ZWdvcnlDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIHRoaXMuX21hcFN0YXRlID0gbmV3IERhdGFTdHJ1Y3R1cmVzXzEuU2ltcGxlTWFwKCk7XG4gICAgICAgIC8vIFByaXZhdGUgY29uc3RydWN0b3JcbiAgICAgICAgRXh0ZW5zaW9uSGVscGVyXzEuRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyKCk7XG4gICAgfVxuICAgIENhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIExvYWQgb24tZGVtYW5kLCB0byBhc3N1cmUgd2VicGFjayBvcmRlcmluZyBvZiBtb2R1bGUgdXNhZ2UgZG9lc24ndCBzY3JldyB0aGluZ3Mgb3ZlclxuICAgICAgICAvLyBmb3IgdXMgd2hlbiB3ZSBhY2NpZGVudGFsbHkgY2hhbmdlIHRoZSBvcmRlci5cbiAgICAgICAgaWYgKENhdGVnb3J5U2VydmljZUltcGwuX0lOU1RBTkNFID09PSBudWxsKSB7XG4gICAgICAgICAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLl9JTlNUQU5DRSA9IG5ldyBDYXRlZ29yeVNlcnZpY2VJbXBsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhdGVnb3J5U2VydmljZUltcGwuX0lOU1RBTkNFO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU9yR2V0Q2F0ZWdvcnlTdGF0ZShjYXRlZ29yeSkubG9nZ2VyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGV2ZXJ5dGhpbmcsIGluY2x1ZGluZyBhIGRlZmF1bHQgY29uZmlndXJhdGlvbiB5b3UgbWF5IGhhdmUgc2V0LlxuICAgICAqIEFmdGVyIHRoaXMgeW91IG5lZWQgdG8gcmUtcmVnaXN0ZXIgeW91ciBjYXRlZ29yaWVzIGV0Yy5cbiAgICAgKi9cbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwU3RhdGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5zZXREZWZhdWx0Q29uZmlndXJhdGlvbihuZXcgQ2F0ZWdvcnlDb25maWd1cmF0aW9uXzEuQ2F0ZWdvcnlDb25maWd1cmF0aW9uKCkpO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuZ2V0Q2F0ZWdvcnlTZXR0aW5ncyA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVPckdldENhdGVnb3J5U3RhdGUoY2F0ZWdvcnkpLmN1cnJlbnRSdW50aW1lU2V0dGluZ3M7XG4gICAgfTtcbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5nZXRPcmlnaW5hbENhdGVnb3J5U2V0dGluZ3MgPSBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3JHZXRDYXRlZ29yeVN0YXRlKGNhdGVnb3J5KS5vcmlnaW5hbFJ1bnRpbWVTZXR0aW5ncztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uLiBOZXcgcm9vdCBsb2dnZXJzIGNyZWF0ZWQgZ2V0IHRoaXNcbiAgICAgKiBhcHBsaWVkLiBJZiB5b3Ugd2FudCB0byByZXNldCBhbGwgY3VycmVudCBsb2dnZXJzIHRvIGhhdmUgdGhpc1xuICAgICAqIGFwcGxpZWQgYXMgd2VsbCwgcGFzcyBpbiByZXNldD10cnVlICh0aGUgZGVmYXVsdCBpcyBmYWxzZSkuIEFsbFxuICAgICAqIGNhdGVnb3JpZXMgd2lsbCBiZSByZXNldCB0aGVuIGFzIHdlbGwuXG4gICAgICogQHBhcmFtIGNvbmZpZyBOZXcgY29uZmlnXG4gICAgICogQHBhcmFtIHJlc2V0IERlZmF1bHRzIHRvIHRydWUuIFNldCB0byB0cnVlIHRvIHJlc2V0IGFsbCBsb2dnZXJzIGFuZCBjdXJyZW50IHJ1bnRpbWVzZXR0aW5ncy5cbiAgICAgKi9cbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5zZXREZWZhdWx0Q29uZmlndXJhdGlvbiA9IGZ1bmN0aW9uIChjb25maWcsIHJlc2V0KSB7XG4gICAgICAgIGlmIChyZXNldCA9PT0gdm9pZCAwKSB7IHJlc2V0ID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLl9kZWZhdWx0Q29uZmlnID0gY29uZmlnO1xuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcFN0YXRlLmZvckVhY2hWYWx1ZShmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS51cGRhdGVTZXR0aW5ncyhjb25maWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBuZXcgY29uZmlndXJhdGlvbiBzZXR0aW5ncyBmb3IgYSBjYXRlZ29yeSAoYW5kIHBvc3NpYmx5IGl0cyBjaGlsZCBjYXRlZ29yaWVzKVxuICAgICAqIEBwYXJhbSBjb25maWcgQ29uZmlnXG4gICAgICogQHBhcmFtIGNhdGVnb3J5IENhdGVnb3J5XG4gICAgICogQHBhcmFtIGFwcGx5Q2hpbGRyZW4gVHJ1ZSB0byBhcHBseSB0byBjaGlsZCBjYXRlZ29yaWVzLCBkZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKi9cbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5zZXRDb25maWd1cmF0aW9uQ2F0ZWdvcnkgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXRlZ29yeSwgYXBwbHlDaGlsZHJlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXBwbHlDaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGFwcGx5Q2hpbGRyZW4gPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLmNyZWF0ZU9yR2V0Q2F0ZWdvcnlTdGF0ZShjYXRlZ29yeSkudXBkYXRlU2V0dGluZ3MoY29uZmlnKTtcbiAgICAgICAgLy8gQXBwbHkgdGhlIHNldHRpbmdzIHRvIGNoaWxkcmVuIHJlY3Vyc2l2ZSBpZiByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKGFwcGx5Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNhdGVnb3J5LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gRmFsc2UgZmxhZywgYSBjaGlsZCBjYW5ub3QgcmVzZXQgYSByb290bG9nZ2VyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0Q29uZmlndXJhdGlvbkNhdGVnb3J5KGNvbmZpZywgY2hpbGQsIGFwcGx5Q2hpbGRyZW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUltcGwucHJvdG90eXBlLnJlZ2lzdGVyQ2F0ZWdvcnkgPSBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09PSBudWxsIHx8IHR5cGVvZiBjYXRlZ29yeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2F0ZWdvcnkgQ0FOTk9UIGJlIG51bGwvdW5kZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tYXBTdGF0ZS5leGlzdHMoQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRDYXRlZ29yeUtleShjYXRlZ29yeSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIHRoaXMgcm9vdCBjYXRlZ29yeSB3aXRoIG5hbWU6IFwiICsgY2F0ZWdvcnkubmFtZSArIFwiLCBpdCBhbHJlYWR5IGV4aXN0cyAoc2FtZSBuYW1lIGluIGhpZXJhcmNoeSkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlT3JHZXRDYXRlZ29yeVN0YXRlKGNhdGVnb3J5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZW5hYmxlIGludGVncmF0aW9uIHdpdGggY2hyb21lIGV4dGVuc2lvbi4gRG8gbm90IHVzZSBtYW51YWxseSwgdGhlXG4gICAgICogZXh0ZW5zaW9uIGFuZCB0aGUgbG9nZ2VyIGZyYW1ld29yayBkZWFsIHdpdGggdGhpcy5cbiAgICAgKi9cbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5lbmFibGVFeHRlbnNpb25JbnRlZ3JhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbWFwU3RhdGUuZm9yRWFjaFZhbHVlKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuZW5hYmxlRm9yRXh0ZW5zaW9uKF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIHJvb3QgY2F0ZWdvcmllcyBjdXJyZW50bHkgcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5nZXRSb290Q2F0ZWdvcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcFN0YXRlLnZhbHVlcygpLmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLmNhdGVnb3J5LnBhcmVudCA9PSBudWxsOyB9KS5tYXAoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5jYXRlZ29yeTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gQ2F0ZWdvcnkgYnkgaWRcbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBjYXRlZ29yeSB0byBmaW5kXG4gICAgICogQHJldHVybnMge0NhdGVnb3J5fSBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIENhdGVnb3J5U2VydmljZUltcGwucHJvdG90eXBlLmdldENhdGVnb3J5QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fbWFwU3RhdGUudmFsdWVzKCkuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuY2F0ZWdvcnkuaWQgPT09IGlkOyB9KS5tYXAoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5jYXRlZ29yeTsgfSk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuY3JlYXRlT3JHZXRDYXRlZ29yeVN0YXRlID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgIHZhciBrZXkgPSBDYXRlZ29yeVNlcnZpY2VJbXBsLmdldENhdGVnb3J5S2V5KGNhdGVnb3J5KTtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fbWFwU3RhdGUuZ2V0KGtleSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3U3RhdGUgPSB0aGlzLmNyZWF0ZVN0YXRlKGNhdGVnb3J5KTtcbiAgICAgICAgdGhpcy5fbWFwU3RhdGUucHV0KGtleSwgbmV3U3RhdGUpO1xuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfTtcbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5jcmVhdGVTdGF0ZSA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IENhdGVnb3J5U3RhdGUoY2F0ZWdvcnksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWZhdWx0Q29uZmlnOyB9LCBmdW5jdGlvbiAoY29uZmlnLCBjYXQpIHsgcmV0dXJuIF90aGlzLmNyZWF0ZUxvZ2dlcihjb25maWcsIGNhdCk7IH0pO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuY3JlYXRlTG9nZ2VyID0gZnVuY3Rpb24gKGNvbmZpZywgY2F0ZWdvcnkpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBpcyBhbHdheXMgYSBjb25zb2xlIGxvZ2dlclxuICAgICAgICBzd2l0Y2ggKGNvbmZpZy5sb2dnZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkNvbnNvbGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsXzEuQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbChjYXRlZ29yeSwgdGhpcyk7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLk1lc3NhZ2VCdWZmZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYXRlZ29yeU1lc3NhZ2VCdWZmZXJJbXBsXzEuQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbChjYXRlZ29yeSwgdGhpcyk7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkN1c3RvbTpcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmNhbGxCYWNrTG9nZ2VyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgY3VzdG9tIGxvZ2dlciwgY3VzdG9tIGNhbGxiYWNrIGlzIG51bGxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLmNhbGxCYWNrTG9nZ2VyKGNhdGVnb3J5LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgYSBMb2dnZXIgZm9yIExvZ2dlclR5cGU6IFwiICsgY29uZmlnLmxvZ2dlclR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLmdldENhdGVnb3J5S2V5ID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgIHJldHVybiBjYXRlZ29yeS5nZXRDYXRlZ29yeVBhdGgoKTtcbiAgICB9O1xuICAgIC8vIFNpbmdsZXRvbiBjYXRlZ29yeSBzZXJ2aWNlLCB1c2VkIGJ5IENhdGVnb3J5U2VydmljZUZhY3RvcnkgYXMgd2VsbCBhcyBDYXRlZ29yaWVzLlxuICAgIC8vIExvYWRlZCBvbiBkZW1hbmQuIERvIE5PVCBjaGFuZ2UgYXMgd2VicGFjayBtYXkgcGFjayB0aGluZ3MgaW4gd3Jvbmcgb3JkZXIgb3RoZXJ3aXNlLlxuICAgIENhdGVnb3J5U2VydmljZUltcGwuX0lOU1RBTkNFID0gbnVsbDtcbiAgICByZXR1cm4gQ2F0ZWdvcnlTZXJ2aWNlSW1wbDtcbn0oKSk7XG5leHBvcnRzLkNhdGVnb3J5U2VydmljZUltcGwgPSBDYXRlZ29yeVNlcnZpY2VJbXBsO1xudmFyIENhdGVnb3J5U3RhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhdGVnb3J5U3RhdGUoY2F0ZWdvcnksIGRlZmF1bHRDb25maWcsIGNyZWF0ZUxvZ2dlcikge1xuICAgICAgICB0aGlzLl9jYXRlZ29yeSA9IGNhdGVnb3J5O1xuICAgICAgICB0aGlzLl9sYXp5U3RhdGUgPSBuZXcgTGF6eVN0YXRlKGNhdGVnb3J5LCBkZWZhdWx0Q29uZmlnLCBjcmVhdGVMb2dnZXIpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlTdGF0ZS5wcm90b3R5cGUsIFwiY2F0ZWdvcnlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXRlZ29yeTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5U3RhdGUucHJvdG90eXBlLCBcImxvZ2dlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhenlTdGF0ZS5nZXRMb2dnZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5U3RhdGUucHJvdG90eXBlLCBcIm9yaWdpbmFsUnVudGltZVNldHRpbmdzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF6eVN0YXRlLmdldE9yaWdpbmFsUnVudGltZVNldHRpbmdzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeVN0YXRlLnByb3RvdHlwZSwgXCJjdXJyZW50UnVudGltZVNldHRpbmdzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF6eVN0YXRlLmdldEN1cnJlbnRSdW50aW1lU2V0dGluZ3MoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2F0ZWdvcnlTdGF0ZS5wcm90b3R5cGUuZW5hYmxlRm9yRXh0ZW5zaW9uID0gZnVuY3Rpb24gKHJ1bnRpbWVTZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9sYXp5U3RhdGUuZW5hYmxlRm9yRXh0ZW5zaW9uKHJ1bnRpbWVTZXR0aW5ncyk7XG4gICAgfTtcbiAgICBDYXRlZ29yeVN0YXRlLnByb3RvdHlwZS51cGRhdGVTZXR0aW5ncyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5fbGF6eVN0YXRlLnVwZGF0ZVNldHRpbmdzKGNvbmZpZyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcnlTdGF0ZTtcbn0oKSk7XG52YXIgTGF6eVN0YXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXp5U3RhdGUoY2F0ZWdvcnksIGRlZmF1bHRDb25maWcsIGNyZWF0ZUxvZ2dlcikge1xuICAgICAgICB0aGlzLl9jYXRlZ29yeSA9IGNhdGVnb3J5O1xuICAgICAgICB0aGlzLl9kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgICAgICAgdGhpcy5fY3JlYXRlTG9nZ2VyID0gY3JlYXRlTG9nZ2VyO1xuICAgIH1cbiAgICBMYXp5U3RhdGUucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB0aGlzLl9sb2dnZXIgIT09IFwidW5kZWZpbmVkXCIpO1xuICAgIH07XG4gICAgTGF6eVN0YXRlLnByb3RvdHlwZS5nZXRMb2dnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9hZExvZ2dlck9uRGVtYW5kKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZUxvZ2dlcjtcbiAgICB9O1xuICAgIExhenlTdGF0ZS5wcm90b3R5cGUuZ2V0T3JpZ2luYWxSdW50aW1lU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9hZExvZ2dlck9uRGVtYW5kKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbFJ1bnRpbWVTZXR0aW5ncztcbiAgICB9O1xuICAgIExhenlTdGF0ZS5wcm90b3R5cGUuZ2V0Q3VycmVudFJ1bnRpbWVTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2FkTG9nZ2VyT25EZW1hbmQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRSdW50aW1lU2V0dGluZ3M7XG4gICAgfTtcbiAgICBMYXp5U3RhdGUucHJvdG90eXBlLmVuYWJsZUZvckV4dGVuc2lvbiA9IGZ1bmN0aW9uIChydW50aW1lU2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5sb2FkTG9nZ2VyT25EZW1hbmQoKTtcbiAgICAgICAgaWYgKCEodGhpcy5fd3JhcHBlZExvZ2dlciBpbnN0YW5jZW9mIENhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbF8xLkNhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbCkpIHtcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVjb25maWd1cmluZyBsb2dnZXIgZm9yIGV4dGVuc2lvbiBmb3IgY2F0ZWdvcnk6IFwiICsgdGhpcy5fY2F0ZWdvcnkubmFtZSk7XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZWRMb2dnZXIgPSBuZXcgQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsXzEuQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsKHRoaXMuX2NhdGVnb3J5LCBydW50aW1lU2V0dGluZ3MpO1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGVMb2dnZXIuZGVsZWdhdGUgPSB0aGlzLl93cmFwcGVkTG9nZ2VyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXp5U3RhdGUucHJvdG90eXBlLnVwZGF0ZVNldHRpbmdzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBpZiAodGhpcy5pc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UnVudGltZVNldHRpbmdzLmxvZ0xldmVsID0gY29uZmlnLmxvZ0xldmVsO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJ1bnRpbWVTZXR0aW5ncy5sb2dnZXJUeXBlID0gY29uZmlnLmxvZ2dlclR5cGU7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UnVudGltZVNldHRpbmdzLmxvZ0Zvcm1hdCA9IGNvbmZpZy5sb2dGb3JtYXQ7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UnVudGltZVNldHRpbmdzLmNhbGxCYWNrTG9nZ2VyID0gY29uZmlnLmNhbGxCYWNrTG9nZ2VyO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJ1bnRpbWVTZXR0aW5ncy5mb3JtYXR0ZXJMb2dNZXNzYWdlID0gY29uZmlnLmZvcm1hdHRlckxvZ01lc3NhZ2U7XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSByZWFsIGxvZ2dlciwgaXQgbWF5IGhhdmUgY2hhbmdlZC5cbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlciA9IHRoaXMuX2NyZWF0ZUxvZ2dlcihjb25maWcsIHRoaXMuX2NhdGVnb3J5KTtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3dyYXBwZWRMb2dnZXIgaW5zdGFuY2VvZiBDYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGxfMS5DYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3JhcHBlZExvZ2dlciA9IHRoaXMuX2xvZ2dlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlTG9nZ2VyLmRlbGVnYXRlID0gdGhpcy5fd3JhcHBlZExvZ2dlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGlzIGNvbmZpZywgaXQgbWF5IGJlIGZvciB0aGUgY2F0ZWdvcnkgc3BlY2lmaWMsIHRoZSBkZWZhdWx0IGlzIHRoZXJlZm9yZSBub3QgZ29vZCBlbm91Z2guXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0Q29uZmlnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXp5U3RhdGUucHJvdG90eXBlLmxvYWRMb2dnZXJPbkRlbWFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9hZGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlciA9IHRoaXMuX2NyZWF0ZUxvZ2dlcih0aGlzLl9kZWZhdWx0Q29uZmlnKCksIHRoaXMuX2NhdGVnb3J5KTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZWRMb2dnZXIgPSB0aGlzLl9sb2dnZXI7XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZUxvZ2dlciA9IG5ldyBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbF8xLkNhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsKHRoaXMuX3dyYXBwZWRMb2dnZXIpO1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxSdW50aW1lU2V0dGluZ3MgPSB0aGlzLmluaXROZXdTZXR0aW5ncygpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJ1bnRpbWVTZXR0aW5ncyA9IHRoaXMuaW5pdE5ld1NldHRpbmdzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExhenlTdGF0ZS5wcm90b3R5cGUuaW5pdE5ld1NldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVmU2V0dGluZ3MgPSB0aGlzLl9kZWZhdWx0Q29uZmlnKCkuY29weSgpO1xuICAgICAgICByZXR1cm4gbmV3IENhdGVnb3J5UnVudGltZVNldHRpbmdzXzEuQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3ModGhpcy5fY2F0ZWdvcnksIGRlZlNldHRpbmdzLmxvZ0xldmVsLCBkZWZTZXR0aW5ncy5sb2dnZXJUeXBlLCBkZWZTZXR0aW5ncy5sb2dGb3JtYXQsIGRlZlNldHRpbmdzLmNhbGxCYWNrTG9nZ2VyLCBkZWZTZXR0aW5ncy5mb3JtYXR0ZXJMb2dNZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBMYXp5U3RhdGU7XG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2F0ZWdvcnlTZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENhdGVnb3J5U2VydmljZV8xID0gcmVxdWlyZShcIi4vQ2F0ZWdvcnlTZXJ2aWNlXCIpO1xuLyoqXG4gKiBDYXRlZ29yaXplZCBzZXJ2aWNlIGZvciBsb2dnaW5nLCB3aGVyZSBsb2dnaW5nIGlzIGJvdW5kIHRvIGNhdGVnb3JpZXMgd2hpY2hcbiAqIGNhbiBsb2cgaG9yaXpvbnRhbGx5IHRocm91Z2ggc3BlY2lmaWMgYXBwbGljYXRpb24gbG9naWMgKHNlcnZpY2VzLCBncm91cChzKSBvZiBjb21wb25lbnRzIGV0YykuXG4gKiBGb3IgdGhlIHN0YW5kYXJkIHdheSBvZiBsb2dnaW5nIGxpa2UgbW9zdCBmcmFtZXdvcmtzIGRvIHRoZXNlIGRheXMsIHVzZSBMRlNlcnZpY2UgaW5zdGVhZC5cbiAqIElmIHlvdSB3YW50IGZpbmUgZ3JhaW5lZCBjb250cm9sIHRvIGRpdmlkZSBzZWN0aW9ucyBvZiB5b3VyIGFwcGxpY2F0aW9uIGluXG4gKiBsb2dpY2FsIHVuaXRzIHRvIGVuYWJsZS9kaXNhYmxlIGxvZ2dpbmcgZm9yLCB0aGlzIGlzIHRoZSBzZXJ2aWNlIHlvdSB3YW50IHRvIHVzZSBpbnN0ZWFkLlxuICogQWxzbyBmb3IgdGhpcyB0eXBlIGEgYnJvd3NlciBwbHVnaW4gd2lsbCBiZSBhdmFpbGFibGUuXG4gKi9cbnZhciBDYXRlZ29yeVNlcnZpY2VGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXRlZ29yeVNlcnZpY2VGYWN0b3J5KCkge1xuICAgICAgICAvLyBQcml2YXRlIGNvbnN0cnVjdG9yLlxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBDYXRlZ29yeUxvZ2dlciBmb3IgZ2l2ZW4gUk9PVCBjYXRlZ29yeSAodGh1cyBoYXMgbm8gcGFyZW50KS5cbiAgICAgKiBZb3UgY2FuIG9ubHkgcmV0cmlldmUgbG9nZ2VycyBmb3IgdGhlaXIgcm9vdCwgd2hlbiBsb2dnaW5nXG4gICAgICogeW91IHNwZWNpZnkgdG8gbG9nIGZvciB3aGF0IChjaGlsZCljYXRlZ29yaWVzLlxuICAgICAqIEBwYXJhbSByb290IENhdGVnb3J5IHJvb3QgKGhhcyBubyBwYXJlbnQpXG4gICAgICogQHJldHVybnMge0NhdGVnb3J5TG9nZ2VyfVxuICAgICAqL1xuICAgIENhdGVnb3J5U2VydmljZUZhY3RvcnkuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIENhdGVnb3J5U2VydmljZV8xLkNhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKS5nZXRMb2dnZXIocm9vdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgZXZlcnl0aGluZywgYW55IHJlZ2lzdGVyZWQgKHJvb3QpY2F0ZWdvcmllcyBhbmQgbG9nZ2Vyc1xuICAgICAqIGFyZSBkaXNjYXJkZWQuIFJlc2V0cyB0byBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIENhdGVnb3J5U2VydmljZV8xLkNhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKS5jbGVhcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uIE5ldyByb290IGxvZ2dlcnMgY3JlYXRlZCBnZXQgdGhpc1xuICAgICAqIGFwcGxpZWQuIElmIHlvdSB3YW50IHRvIHJlc2V0IGFsbCBjdXJyZW50IGxvZ2dlcnMgdG8gaGF2ZSB0aGlzXG4gICAgICogYXBwbGllZCBhcyB3ZWxsLCBwYXNzIGluIHJlc2V0PXRydWUgKHRoZSBkZWZhdWx0IGlzIGZhbHNlKS4gQWxsXG4gICAgICogY2F0ZWdvcmllcyBydW50aW1lc2V0dGluZ3Mgd2lsbCBiZSByZXNldCB0aGVuIGFzIHdlbGwuXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgbmV3IGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSByZXNldCBJZiB0cnVlLCB3aWxsIHJlc2V0ICphbGwqIHJ1bnRpbWVzZXR0aW5ncyBmb3IgYWxsIGxvZ2dlcnMvY2F0ZWdvcmllcyB0byB0aGVzZS4gRGVmYXVsdCBpcyB0cnVlLlxuICAgICAqL1xuICAgIENhdGVnb3J5U2VydmljZUZhY3Rvcnkuc2V0RGVmYXVsdENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiAoY29uZmlnLCByZXNldCkge1xuICAgICAgICBpZiAocmVzZXQgPT09IHZvaWQgMCkgeyByZXNldCA9IHRydWU7IH1cbiAgICAgICAgQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLnNldERlZmF1bHRDb25maWd1cmF0aW9uKGNvbmZpZywgcmVzZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IG5ldyBjb25maWd1cmF0aW9uIHNldHRpbmdzIGZvciBhIGNhdGVnb3J5IChhbmQgcG9zc2libHkgaXRzIGNoaWxkIGNhdGVnb3JpZXMpXG4gICAgICogQHBhcmFtIGNvbmZpZyBDb25maWdcbiAgICAgKiBAcGFyYW0gY2F0ZWdvcnkgQ2F0ZWdvcnlcbiAgICAgKiBAcGFyYW0gYXBwbHlDaGlsZHJlbiBUcnVlIHRvIGFwcGx5IHRvIGNoaWxkIGNhdGVnb3JpZXMsIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAqL1xuICAgIENhdGVnb3J5U2VydmljZUZhY3Rvcnkuc2V0Q29uZmlndXJhdGlvbkNhdGVnb3J5ID0gZnVuY3Rpb24gKGNvbmZpZywgY2F0ZWdvcnksIGFwcGx5Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGFwcGx5Q2hpbGRyZW4gPT09IHZvaWQgMCkgeyBhcHBseUNoaWxkcmVuID0gZmFsc2U7IH1cbiAgICAgICAgQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLnNldENvbmZpZ3VyYXRpb25DYXRlZ29yeShjb25maWcsIGNhdGVnb3J5LCBhcHBseUNoaWxkcmVuKTtcbiAgICB9O1xuICAgIHJldHVybiBDYXRlZ29yeVNlcnZpY2VGYWN0b3J5O1xufSgpKTtcbmV4cG9ydHMuQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeSA9IENhdGVnb3J5U2VydmljZUZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXRlZ29yeVNlcnZpY2VGYWN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIERhdGFTdHJ1Y3R1cmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvRGF0YVN0cnVjdHVyZXNcIik7XG52YXIgTWVzc2FnZVV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvTWVzc2FnZVV0aWxzXCIpO1xudmFyIExvZ01lc3NhZ2VJbnRlcm5hbEltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ01lc3NhZ2VJbnRlcm5hbEltcGwobG9nZ2VyTmFtZSwgbWVzc2FnZSwgZXJyb3JBc1N0YWNrLCBlcnJvciwgbG9nR3JvdXBSdWxlLCBkYXRlLCBsZXZlbCwgcmVhZHkpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JBc1N0YWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLl9sb2dnZXJOYW1lID0gbG9nZ2VyTmFtZTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuX2Vycm9yQXNTdGFjayA9IGVycm9yQXNTdGFjaztcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5fbG9nR3JvdXBSdWxlID0gbG9nR3JvdXBSdWxlO1xuICAgICAgICB0aGlzLl9kYXRlID0gZGF0ZTtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSByZWFkeTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ01lc3NhZ2VJbnRlcm5hbEltcGwucHJvdG90eXBlLCBcImxvZ2dlck5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dnZXJOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dNZXNzYWdlSW50ZXJuYWxJbXBsLnByb3RvdHlwZSwgXCJlcnJvckFzU3RhY2tcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvckFzU3RhY2s7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvckFzU3RhY2sgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ01lc3NhZ2VJbnRlcm5hbEltcGwucHJvdG90eXBlLCBcImVycm9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwibG9nR3JvdXBSdWxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nR3JvdXBSdWxlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nR3JvdXBSdWxlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dNZXNzYWdlSW50ZXJuYWxJbXBsLnByb3RvdHlwZSwgXCJkYXRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ01lc3NhZ2VJbnRlcm5hbEltcGwucHJvdG90eXBlLCBcImxldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9sZXZlbCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwiaXNNZXNzYWdlTG9nRGF0YVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiAodGhpcy5fbWVzc2FnZSkgIT09IFwic3RyaW5nXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dNZXNzYWdlSW50ZXJuYWxJbXBsLnByb3RvdHlwZSwgXCJyZWFkeVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVhZHkgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ01lc3NhZ2VJbnRlcm5hbEltcGwucHJvdG90eXBlLCBcIm1lc3NhZ2VBc1N0cmluZ1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5fbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlLm1zZztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ01lc3NhZ2VJbnRlcm5hbEltcGwucHJvdG90eXBlLCBcImxvZ0RhdGFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5fbWVzc2FnZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTG9nTWVzc2FnZUludGVybmFsSW1wbDtcbn0oKSk7XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgbG9nZ2VyLCBleHRlbmQgdG8gZWFzaWx5IGltcGxlbWVudCBhIGN1c3RvbSBsb2dnZXIgdGhhdFxuICogbG9ncyB3aGVyZXZlciB5b3Ugd2FudC4gWW91IG9ubHkgbmVlZCB0byBpbXBsZW1lbnQgZG9Mb2cobXNnOiBMb2dNZXNzYWdlKSBhbmRcbiAqIGxvZyB0aGF0IHNvbWV3aGVyZSAoaXQgd2lsbCBjb250YWluIGZvcm1hdCBhbmQgZXZlcnl0aGluZyBlbHNlKS5cbiAqL1xudmFyIEFic3RyYWN0TG9nZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdExvZ2dlcihuYW1lLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9hbGxNZXNzYWdlcyA9IG5ldyBEYXRhU3RydWN0dXJlc18xLkxpbmtlZExpc3QoKTtcbiAgICAgICAgdGhpcy5fb3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyA9IGxvZ0dyb3VwUnVudGltZVNldHRpbmdzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUudHJhY2UgPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5UcmFjZSwgbXNnLCBlcnJvcik7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5EZWJ1ZywgbXNnLCBlcnJvcik7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciA9PT0gdm9pZCAwKSB7IGVycm9yID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkluZm8sIG1zZywgZXJyb3IpO1xuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5XYXJuLCBtc2csIGVycm9yKTtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciA9PT0gdm9pZCAwKSB7IGVycm9yID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yLCBtc2csIGVycm9yKTtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5mYXRhbCA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciA9PT0gdm9pZCAwKSB7IGVycm9yID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkZhdGFsLCBtc2csIGVycm9yKTtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5pc1RyYWNlRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzLmxldmVsID09PSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuVHJhY2U7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuaXNEZWJ1Z0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sZXZlbCA8PSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRGVidWc7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuaXNJbmZvRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzLmxldmVsIDw9IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5JbmZvO1xuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLmlzV2FybkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sZXZlbCA8PSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuV2FybjtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5pc0Vycm9yRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzLmxldmVsIDw9IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5FcnJvcjtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5pc0ZhdGFsRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzLmxldmVsIDw9IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5GYXRhbDtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5nZXRMb2dMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzLmxldmVsO1xuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wZW47XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWxsTWVzc2FnZXMuY2xlYXIoKTtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5jcmVhdGVEZWZhdWx0TG9nTWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgcmV0dXJuIE1lc3NhZ2VVdGlsc18xLk1lc3NhZ2VGb3JtYXRVdGlscy5yZW5kZXJEZWZhdWx0TG9nNGpNZXNzYWdlKG1zZywgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gb3B0aW9uYWwgbWVzc2FnZSBmb3JtYXR0ZXIuIEFsbCBMb2dnZXJUeXBlcyAoZXhjZXB0IGN1c3RvbSkgd2lsbCBzZWUgaWZcbiAgICAgKiB0aGV5IGhhdmUgdGhpcywgYW5kIGlmIHNvIHVzZSBpdCB0byBsb2cuXG4gICAgICogQHJldHVybnMgeygobWVzc2FnZTpMb2dNZXNzYWdlKT0+c3RyaW5nKXxudWxsfVxuICAgICAqL1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5fZ2V0TWVzc2FnZUZvcm1hdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzLmZvcm1hdHRlckxvZ01lc3NhZ2U7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuX2xvZyA9IGZ1bmN0aW9uIChsZXZlbCwgbXNnLCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRoaXMuX29wZW4gJiYgdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MubGV2ZWwgPD0gbGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbk1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtc2cgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNnKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fYWxsTWVzc2FnZXMuYWRkVGFpbCh0aGlzLmNyZWF0ZU1lc3NhZ2UobGV2ZWwsIGZ1bmN0aW9uTWVzc2FnZSwgZnVuY3Rpb25FcnJvciwgbmV3IERhdGUoKSkpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTWVzc2FnZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLmNyZWF0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAobGV2ZWwsIG1zZywgZXJyb3IsIGRhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVycm9yUmVzdWx0ID0gZXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZV8xID0gbmV3IExvZ01lc3NhZ2VJbnRlcm5hbEltcGwodGhpcy5fbmFtZSwgbXNnKCksIG51bGwsIGVycm9yUmVzdWx0LCB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sb2dHcm91cFJ1bGUsIGRhdGUsIGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgICBNZXNzYWdlVXRpbHNfMS5NZXNzYWdlRm9ybWF0VXRpbHMucmVuZGVyRXJyb3IoZXJyb3JSZXN1bHQpLnRoZW4oZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZV8xLmVycm9yQXNTdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VfMS5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc01lc3NhZ2VzKCk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZV8xLmVycm9yQXNTdGFjayA9IFwiPFVOS05PV04+IHVuYWJsZSB0byBnZXQgc3RhY2suXCI7XG4gICAgICAgICAgICAgICAgbWVzc2FnZV8xLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9jZXNzTWVzc2FnZXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VfMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExvZ01lc3NhZ2VJbnRlcm5hbEltcGwodGhpcy5fbmFtZSwgbXNnKCksIG51bGwsIGVycm9yUmVzdWx0LCB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sb2dHcm91cFJ1bGUsIGRhdGUsIGxldmVsLCB0cnVlKTtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5wcm9jZXNzTWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJhc2ljYWxseSB3ZSB3YWl0IHVudGlsIGVycm9ycyBhcmUgcmVzb2x2ZWQgKHRob3NlIG1lc3NhZ2VzXG4gICAgICAgIC8vIG1heSBub3QgYmUgcmVhZHkpLlxuICAgICAgICB2YXIgbXNncyA9IHRoaXMuX2FsbE1lc3NhZ2VzO1xuICAgICAgICBpZiAobXNncy5nZXRTaXplKCkgPiAwKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IG1zZ3MuZ2V0SGVhZCgpO1xuICAgICAgICAgICAgICAgIGlmIChtc2cgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1zZy5yZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXNncy5yZW1vdmVIZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIG5ldmVyIGJlIG51bGwgbm9ybWFsbHksIGJ1dCBzdHJpY3QgbnVsbCBjaGVja2luZyAuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zZy5tZXNzYWdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvTG9nKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChtc2dzLmdldFNpemUoKSA+IDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RMb2dnZXI7XG59KCkpO1xuZXhwb3J0cy5BYnN0cmFjdExvZ2dlciA9IEFic3RyYWN0TG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RMb2dnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBYnN0cmFjdExvZ2dlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RMb2dnZXJcIik7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL0xvZ2dlck9wdGlvbnNcIik7XG4vKipcbiAqIFNpbXBsZSBsb2dnZXIsIHRoYXQgbG9ncyB0byB0aGUgY29uc29sZS4gSWYgdGhlIGNvbnNvbGUgaXMgdW5hdmFpbGFibGUgd2lsbCB0aHJvdyBleGNlcHRpb24uXG4gKi9cbnZhciBDb25zb2xlTG9nZ2VySW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnNvbGVMb2dnZXJJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnNvbGVMb2dnZXJJbXBsKG5hbWUsIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncykgfHwgdGhpcztcbiAgICB9XG4gICAgQ29uc29sZUxvZ2dlckltcGwucHJvdG90eXBlLmRvTG9nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGxvZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGxvZ0xldmVsID0gbWVzc2FnZS5sZXZlbDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRm9ybWF0dGVyID0gdGhpcy5fZ2V0TWVzc2FnZUZvcm1hdHRlcigpO1xuICAgICAgICAgICAgdmFyIG1zZyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlRm9ybWF0dGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbXNnID0gdGhpcy5jcmVhdGVEZWZhdWx0TG9nTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgICAgICBzd2l0Y2ggKGxvZ0xldmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuVHJhY2U6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cnkgdHJhY2Ugd2UgZG9uJ3Qgd2FudCBhIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkRlYnVnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCB0cnksIHRvbyBtdWNoIGRpZmZlcmVuY2VzIG9mIGNvbnNvbGVzLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5JbmZvOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5pbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8obXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuV2FybjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yOlxuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkZhdGFsOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2cgbGV2ZWwgbm90IHN1cHBvcnRlZDogXCIgKyBsb2dMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxvZ2dlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnNvbGUgaXMgbm90IGRlZmluZWQsIGNhbm5vdCBsb2cgbXNnOiBcIiArIG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb25zb2xlTG9nZ2VySW1wbDtcbn0oQWJzdHJhY3RMb2dnZXJfMS5BYnN0cmFjdExvZ2dlcikpO1xuZXhwb3J0cy5Db25zb2xlTG9nZ2VySW1wbCA9IENvbnNvbGVMb2dnZXJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29uc29sZUxvZ2dlckltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGF0YVN0cnVjdHVyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9EYXRhU3RydWN0dXJlc1wiKTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbnZhciBMb2dnZXJGYWN0b3J5SW1wbF8xID0gcmVxdWlyZShcIi4vTG9nZ2VyRmFjdG9yeUltcGxcIik7XG52YXIgRXh0ZW5zaW9uSGVscGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZXh0ZW5zaW9uL0V4dGVuc2lvbkhlbHBlclwiKTtcbnZhciBMb2dHcm91cFJ1bGVfMSA9IHJlcXVpcmUoXCIuL0xvZ0dyb3VwUnVsZVwiKTtcbnZhciBMb2dnZXJGYWN0b3J5T3B0aW9uc18xID0gcmVxdWlyZShcIi4vTG9nZ2VyRmFjdG9yeU9wdGlvbnNcIik7XG52YXIgTEZTZXJ2aWNlSW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTEZTZXJ2aWNlSW1wbCgpIHtcbiAgICAgICAgLy8gUHJpdmF0ZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgdGhpcy5fbmFtZUNvdW50ZXIgPSAxO1xuICAgICAgICB0aGlzLl9tYXBGYWN0b3JpZXMgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5TaW1wbGVNYXAoKTtcbiAgICAgICAgRXh0ZW5zaW9uSGVscGVyXzEuRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyKCk7XG4gICAgfVxuICAgIExGU2VydmljZUltcGwuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIExvYWRlZCBvbiBkZW1hbmQuIERvIE5PVCBjaGFuZ2UgYXMgd2VicGFjayBtYXkgcGFjayB0aGluZ3MgaW4gd3Jvbmcgb3JkZXIgb3RoZXJ3aXNlLlxuICAgICAgICBpZiAoTEZTZXJ2aWNlSW1wbC5fSU5TVEFOQ0UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIExGU2VydmljZUltcGwuX0lOU1RBTkNFID0gbmV3IExGU2VydmljZUltcGwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTEZTZXJ2aWNlSW1wbC5fSU5TVEFOQ0U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgTG9nZ2VyRmFjdG9yeSB3aXRoIGdpdmVuIG9wdGlvbnMgKGlmIGFueSkuIElmIG5vIG9wdGlvbnNcbiAgICAgKiBhcmUgc3BlY2lmaWVkLCB0aGUgTG9nZ2VyRmFjdG9yeSwgd2lsbCBhY2NlcHQgYW55IG5hbWVkIGxvZ2dlciBhbmQgd2lsbFxuICAgICAqIGxvZyBvbiBpbmZvIGxldmVsIGJ5IGRlZmF1bHQgZm9yLCB0byB0aGUgY29uc29sZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLCBvcHRpb25hbC5cbiAgICAgKiBAcmV0dXJucyB7TG9nZ2VyRmFjdG9yeX1cbiAgICAgKi9cbiAgICBMRlNlcnZpY2VJbXBsLnByb3RvdHlwZS5jcmVhdGVMb2dnZXJGYWN0b3J5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gbnVsbDsgfVxuICAgICAgICB2YXIgbmFtZSA9IFwiTG9nZ2VyRmFjdG9yeVwiICsgdGhpcy5fbmFtZUNvdW50ZXIrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTmFtZWRMb2dnZXJGYWN0b3J5KG5hbWUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IExvZ2dlckZhY3RvcnkgdXNpbmcgZ2l2ZW4gbmFtZSAodXNlZCBmb3IgY29uc29sZSBhcGkvZXh0ZW5zaW9uKS5cbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIFBpY2sgc29tZXRoaW5nIHNob3J0IGJ1dCBkaXN0aW5ndWlzaGFibGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucywgb3B0aW9uYWxcbiAgICAgKiBAcmV0dXJuIHtMb2dnZXJGYWN0b3J5fVxuICAgICAqL1xuICAgIExGU2VydmljZUltcGwucHJvdG90eXBlLmNyZWF0ZU5hbWVkTG9nZ2VyRmFjdG9yeSA9IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRoaXMuX21hcEZhY3Rvcmllcy5leGlzdHMobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvZ2dlckZhY3Rvcnkgd2l0aCBuYW1lIFwiICsgbmFtZSArIFwiIGFscmVhZHkgZXhpc3RzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmFjdG9yeTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBuZXcgTG9nZ2VyRmFjdG9yeUltcGxfMS5Mb2dnZXJGYWN0b3J5SW1wbChuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBuZXcgTG9nZ2VyRmFjdG9yeUltcGxfMS5Mb2dnZXJGYWN0b3J5SW1wbChuYW1lLCBMRlNlcnZpY2VJbXBsLmNyZWF0ZURlZmF1bHRPcHRpb25zKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcEZhY3Rvcmllcy5wdXQobmFtZSwgZmFjdG9yeSk7XG4gICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFsbCBMb2dnZXJzIGZvciBMb2dnZXJGYWN0b3JpZXMgdGhhdCB3ZXJlIGNyZWF0ZWQuXG4gICAgICogQWZ0ZXIgdGhpcyBjYWxsLCBhbGwgcHJldmlvdXNseSBmZXRjaGVkIExvZ2dlcnMgKGZyb20gdGhlaXJcbiAgICAgKiBmYWN0b3JpZXMpIGFyZSB1bnVzYWJsZS4gVGhlIGZhY3RvcmllcyByZW1haW4gYXMgdGhleSB3ZXJlLlxuICAgICAqL1xuICAgIExGU2VydmljZUltcGwucHJvdG90eXBlLmNsb3NlTG9nZ2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwRmFjdG9yaWVzLnZhbHVlcygpLmZvckVhY2goZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICAgICAgICAgIGZhY3RvcnkuY2xvc2VMb2dnZXJzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tYXBGYWN0b3JpZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbmFtZUNvdW50ZXIgPSAxO1xuICAgIH07XG4gICAgTEZTZXJ2aWNlSW1wbC5wcm90b3R5cGUuZ2V0UnVudGltZVNldHRpbmdzRm9yTG9nZ2VyRmFjdG9yaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuX21hcEZhY3Rvcmllcy5mb3JFYWNoVmFsdWUoZnVuY3Rpb24gKGZhY3RvcnkpIHsgcmV0dXJuIHJlc3VsdC5wdXNoKGZhY3RvcnkpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIExGU2VydmljZUltcGwucHJvdG90eXBlLmdldExvZ0dyb3VwU2V0dGluZ3MgPSBmdW5jdGlvbiAobmFtZUxvZ2dlckZhY3RvcnksIGlkTG9nR3JvdXBSdWxlKSB7XG4gICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy5fbWFwRmFjdG9yaWVzLmdldChuYW1lTG9nZ2VyRmFjdG9yeSk7XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuZ2V0TG9nR3JvdXBSdW50aW1lU2V0dGluZ3NCeUluZGV4KGlkTG9nR3JvdXBSdWxlKTtcbiAgICB9O1xuICAgIExGU2VydmljZUltcGwucHJvdG90eXBlLmdldExvZ2dlckZhY3RvcnlSdW50aW1lU2V0dGluZ3NCeU5hbWUgPSBmdW5jdGlvbiAobmFtZUxvZ2dlckZhY3RvcnkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX21hcEZhY3Rvcmllcy5nZXQobmFtZUxvZ2dlckZhY3RvcnkpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIExGU2VydmljZUltcGwuY3JlYXRlRGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyRmFjdG9yeU9wdGlvbnNfMS5Mb2dnZXJGYWN0b3J5T3B0aW9ucygpLmFkZExvZ0dyb3VwUnVsZShuZXcgTG9nR3JvdXBSdWxlXzEuTG9nR3JvdXBSdWxlKG5ldyBSZWdFeHAoXCIuK1wiKSwgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkluZm8pKTtcbiAgICB9O1xuICAgIC8vIExvYWRlZCBvbiBkZW1hbmQuIERvIE5PVCBjaGFuZ2UgYXMgd2VicGFjayBtYXkgcGFjayB0aGluZ3MgaW4gd3Jvbmcgb3JkZXIgb3RoZXJ3aXNlLlxuICAgIExGU2VydmljZUltcGwuX0lOU1RBTkNFID0gbnVsbDtcbiAgICByZXR1cm4gTEZTZXJ2aWNlSW1wbDtcbn0oKSk7XG4vKipcbiAqIENyZWF0ZSBhbmQgY29uZmlndXJlIHlvdXIgTG9nZ2VyRmFjdG9yeSBmcm9tIGhlcmUuXG4gKi9cbnZhciBMRlNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExGU2VydmljZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IExvZ2dlckZhY3Rvcnkgd2l0aCBnaXZlbiBvcHRpb25zIChpZiBhbnkpLiBJZiBubyBvcHRpb25zXG4gICAgICogYXJlIHNwZWNpZmllZCwgdGhlIExvZ2dlckZhY3RvcnksIHdpbGwgYWNjZXB0IGFueSBuYW1lZCBsb2dnZXIgYW5kIHdpbGxcbiAgICAgKiBsb2cgb24gaW5mbyBsZXZlbCBieSBkZWZhdWx0IGZvciwgdG8gdGhlIGNvbnNvbGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucywgb3B0aW9uYWwuXG4gICAgICogQHJldHVybnMge0xvZ2dlckZhY3Rvcnl9XG4gICAgICovXG4gICAgTEZTZXJ2aWNlLmNyZWF0ZUxvZ2dlckZhY3RvcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBMRlNlcnZpY2UuSU5TVEFOQ0VfU0VSVklDRS5jcmVhdGVMb2dnZXJGYWN0b3J5KG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IExvZ2dlckZhY3RvcnkgdXNpbmcgZ2l2ZW4gbmFtZSAodXNlZCBmb3IgY29uc29sZSBhcGkvZXh0ZW5zaW9uKS5cbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIFBpY2sgc29tZXRoaW5nIHNob3J0IGJ1dCBkaXN0aW5ndWlzaGFibGUuIFRoZSB3b3JkIFwiREVGQVVMVFwiIGlzIHJlc2VydmVkIGFuZCBjYW5ub3QgYmUgdGFrZW4sIGl0IGlzIHVzZWRcbiAgICAgKiBmb3IgdGhlIGRlZmF1bHQgTG9nZ2VyRmFjdG9yeS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLCBvcHRpb25hbFxuICAgICAqIEByZXR1cm4ge0xvZ2dlckZhY3Rvcnl9XG4gICAgICovXG4gICAgTEZTZXJ2aWNlLmNyZWF0ZU5hbWVkTG9nZ2VyRmFjdG9yeSA9IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG51bGw7IH1cbiAgICAgICAgaWYgKG5hbWUgPT09IExGU2VydmljZS5ERUZBVUxUX0xPR0dFUl9GQUNUT1JZX05BTUUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvZ2dlckZhY3RvcnkgbmFtZTogXCIgKyBMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWV9OQU1FICsgXCIgaXMgcmVzZXJ2ZWQgYW5kIGNhbm5vdCBiZSB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTEZTZXJ2aWNlLklOU1RBTkNFX1NFUlZJQ0UuY3JlYXRlTmFtZWRMb2dnZXJGYWN0b3J5KG5hbWUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFsbCBMb2dnZXJzIGZvciBMb2dnZXJGYWN0b3JpZXMgdGhhdCB3ZXJlIGNyZWF0ZWQuXG4gICAgICogQWZ0ZXIgdGhpcyBjYWxsLCBhbGwgcHJldmlvdXNseSBmZXRjaGVkIExvZ2dlcnMgKGZyb20gdGhlaXJcbiAgICAgKiBmYWN0b3JpZXMpIGFyZSB1bnVzYWJsZS4gVGhlIGZhY3RvcmllcyByZW1haW4gYXMgdGhleSB3ZXJlLlxuICAgICAqL1xuICAgIExGU2VydmljZS5jbG9zZUxvZ2dlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMRlNlcnZpY2UuSU5TVEFOQ0VfU0VSVklDRS5jbG9zZUxvZ2dlcnMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBMRlNlcnZpY2VSdW50aW1lU2V0dGluZ3MgdG8gcmV0cmlldmUgaW5mb3JtYXRpb24gbG9nZ2VyZmFjdG9yaWVzXG4gICAgICogYW5kIHRoZWlyIHJ1bnRpbWUgc2V0dGluZ3MuXG4gICAgICogQHJldHVybnMge0xGU2VydmljZVJ1bnRpbWVTZXR0aW5nc31cbiAgICAgKi9cbiAgICBMRlNlcnZpY2UuZ2V0UnVudGltZVNldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTEZTZXJ2aWNlLklOU1RBTkNFX1NFUlZJQ0U7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTEZTZXJ2aWNlLCBcIkRFRkFVTFRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBwcm9wZXJ0eSByZXR1cm5zIHRoZSBkZWZhdWx0IExvZ2dlckZhY3RvcnkgKGlmIG5vdCB5ZXQgaW5pdGlhbGl6ZWQgaXQgaXMgaW5pdGlhbGl6ZWQpLlxuICAgICAgICAgKiBUaGlzIExvZ2dlckZhY3RvcnkgY2FuIGJlIHVzZWQgdG8gc2hhcmUgYW1vbmcgbXVsdGlwbGVcbiAgICAgICAgICogYXBwbGljYXRpb25zL2xpYnJhcmllcyAtIHRoYXQgd2F5IHlvdSBjYW4gZW5hYmxlL2NoYW5nZSBsb2dnaW5nIG92ZXIgZXZlcnl0aGluZyBmcm9tXG4gICAgICAgICAqIHlvdXIgb3duIGFwcGxpY2F0aW9uIHdoZW4gcmVxdWlyZWQuXG4gICAgICAgICAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIGJlIHVzZWQgYnkgbGlicmFyeSBkZXZlbG9wZXJzIHRvIG1ha2UgbG9nZ2luZyBlYXNpbHkgYXZhaWxhYmxlIGZvciB0aGVcbiAgICAgICAgICogY29uc3VtZXJzIG9mIHRoZWlyIGxpYnJhcmllcy5cbiAgICAgICAgICogSXQgaXMgaGlnaGx5IHJlY29tbWVuZGVkIHRvIHVzZSBMb2dnZXJzIGZyb20gdGhlIExvZ2dlckZhY3Rvcnkgd2l0aCB1bmlxdWUgZ3JvdXBpbmcvbmFtZXMgdG8gcHJldmVudFxuICAgICAgICAgKiBjbGFzaGVzIG9mIExvZ2dlcnMgYmV0d2VlbiBtdWx0aXBsZSBwcm9qZWN0cy5cbiAgICAgICAgICogQHJldHVybnMge0xvZ2dlckZhY3Rvcnl9IFJldHVybnMgdGhlIGRlZmF1bHQgTG9nZ2VyRmFjdG9yeVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTEZTZXJ2aWNlLmdldERlZmF1bHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTEZTZXJ2aWNlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgTEZTZXJ2aWNlLkRFRkFVTFRfTE9HR0VSX0ZBQ1RPUlkgPSBMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWSA9IExGU2VydmljZS5JTlNUQU5DRV9TRVJWSUNFLmNyZWF0ZU5hbWVkTG9nZ2VyRmFjdG9yeShMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWV9OQU1FLCBuZXcgTG9nZ2VyRmFjdG9yeU9wdGlvbnNfMS5Mb2dnZXJGYWN0b3J5T3B0aW9ucygpLmFkZExvZ0dyb3VwUnVsZShuZXcgTG9nR3JvdXBSdWxlXzEuTG9nR3JvdXBSdWxlKG5ldyBSZWdFeHAoXCIuK1wiKSwgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWTtcbiAgICB9O1xuICAgIExGU2VydmljZS5ERUZBVUxUX0xPR0dFUl9GQUNUT1JZX05BTUUgPSBcIkRFRkFVTFRcIjtcbiAgICBMRlNlcnZpY2UuSU5TVEFOQ0VfU0VSVklDRSA9IExGU2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKTtcbiAgICBMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWSA9IG51bGw7XG4gICAgcmV0dXJuIExGU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkxGU2VydmljZSA9IExGU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxGU2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbi8qKlxuICogRGVmaW5lcyBhIExvZ0dyb3VwUnVsZSwgdGhpcyBhbGxvd3MgeW91IHRvIGVpdGhlciBoYXZlIGV2ZXJ5dGhpbmcgY29uZmlndXJlZCB0aGUgc2FtZSB3YXlcbiAqIG9yIGZvciBleGFtcGxlIGxvZ2dlcnMgdGhhdCBzdGFydCB3aXRoIG5hbWUgbW9kZWwuIEl0IGFsbG93cyB5b3UgdG8gZ3JvdXAgbG9nZ2VycyB0b2dldGhlclxuICogdG8gaGF2ZSBhIGNlcnRhaW4gbG9nbGV2ZWwgYW5kIG90aGVyIHNldHRpbmdzLiBZb3UgY2FuIGNvbmZpZ3VyZSB0aGlzIHdoZW4gY3JlYXRpbmcgdGhlXG4gKiBMb2dnZXJGYWN0b3J5ICh3aGljaCBhY2NlcHRzIG11bHRpcGxlIExvZ0dyb3VwUnVsZXMpLlxuICovXG52YXIgTG9nR3JvdXBSdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBMb2dHcm91cFJ1bGUuIEJhc2ljYWxseSB5b3UgZGVmaW5lIHdoYXQgbG9nZ2VyIG5hbWUocykgbWF0Y2ggZm9yIHRoaXMgZ3JvdXAsIHdoYXQgbGV2ZWwgc2hvdWxkIGJlIHVzZWQgd2hhdCBsb2dnZXIgdHlwZSAod2hlcmUgdG8gbG9nKVxuICAgICAqIGFuZCB3aGF0IGZvcm1hdCB0byB3cml0ZSBpbi4gSWYgdGhlIGxvZ2dlclR5cGUgaXMgY3VzdG9tLCB0aGVuIHRoZSBjYWxsQmFja0xvZ2dlciBtdXN0IGJlIHN1cHBsaWVkIGFzIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJldHVybiBhIGN1c3RvbSBsb2dnZXIuXG4gICAgICogQHBhcmFtIHJlZ0V4cCBSZWd1bGFyIGV4cHJlc3Npb24sIHdoYXQgbWF0Y2hlcyBmb3IgeW91ciBsb2dnZXIgbmFtZXMgZm9yIHRoaXMgZ3JvdXBcbiAgICAgKiBAcGFyYW0gbGV2ZWwgTG9nTGV2ZWxcbiAgICAgKiBAcGFyYW0gbG9nRm9ybWF0IExvZ0Zvcm1hdFxuICAgICAqIEBwYXJhbSBsb2dnZXJUeXBlIFR5cGUgb2YgbG9nZ2VyLCBpZiBDdXN0b20sIG1ha2Ugc3VyZSB0byBpbXBsZW1lbnQgY2FsbEJhY2tMb2dnZXIgYW5kIHBhc3MgaW4sIHRoaXMgd2lsbCBiZSBjYWxsZWQgc28geW91IGNhbiByZXR1cm4geW91ciBvd24gbG9nZ2VyLlxuICAgICAqIEBwYXJhbSBjYWxsQmFja0xvZ2dlciBDYWxsYmFjayBmdW5jdGlvbiB0byByZXR1cm4gYSBuZXcgY2xlYW4gY3VzdG9tIGxvZ2dlciAoeW91cnMhKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZ0dyb3VwUnVsZShyZWdFeHAsIGxldmVsLCBsb2dGb3JtYXQsIGxvZ2dlclR5cGUsIGNhbGxCYWNrTG9nZ2VyKSB7XG4gICAgICAgIGlmIChsb2dGb3JtYXQgPT09IHZvaWQgMCkgeyBsb2dGb3JtYXQgPSBuZXcgTG9nZ2VyT3B0aW9uc18xLkxvZ0Zvcm1hdCgpOyB9XG4gICAgICAgIGlmIChsb2dnZXJUeXBlID09PSB2b2lkIDApIHsgbG9nZ2VyVHlwZSA9IExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkNvbnNvbGU7IH1cbiAgICAgICAgaWYgKGNhbGxCYWNrTG9nZ2VyID09PSB2b2lkIDApIHsgY2FsbEJhY2tMb2dnZXIgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWdFeHAgPSByZWdFeHA7XG4gICAgICAgIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gICAgICAgIHRoaXMuX2xvZ0Zvcm1hdCA9IGxvZ0Zvcm1hdDtcbiAgICAgICAgdGhpcy5fbG9nZ2VyVHlwZSA9IGxvZ2dlclR5cGU7XG4gICAgICAgIHRoaXMuX2NhbGxCYWNrTG9nZ2VyID0gY2FsbEJhY2tMb2dnZXI7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dHcm91cFJ1bGUucHJvdG90eXBlLCBcInJlZ0V4cFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ0V4cDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVsZS5wcm90b3R5cGUsIFwibGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVsZS5wcm90b3R5cGUsIFwibG9nZ2VyVHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2dlclR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dHcm91cFJ1bGUucHJvdG90eXBlLCBcImxvZ0Zvcm1hdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0Zvcm1hdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVsZS5wcm90b3R5cGUsIFwiY2FsbEJhY2tMb2dnZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsQmFja0xvZ2dlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVsZS5wcm90b3R5cGUsIFwiZm9ybWF0dGVyTG9nTWVzc2FnZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGZvcm1hdHRlckxvZ01lc3NhZ2UgZnVuY3Rpb24sIHNlZSBjb21tZW50IG9uIHRoZSBzZXR0ZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHsoKG1lc3NhZ2U6TG9nTWVzc2FnZSk9PnN0cmluZyl8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGRlZmF1bHQgZm9ybWF0dGVyTG9nTWVzc2FnZSBmdW5jdGlvbiwgaWYgc2V0IGl0IGlzIGFwcGxpZWQgdG8gYWxsIHR5cGUgb2YgbG9nZ2VycyBleGNlcHQgZm9yIGEgY3VzdG9tIGxvZ2dlci5cbiAgICAgICAgICogQnkgZGVmYXVsdCB0aGlzIGlzIG51bGwgKG5vdCBzZXQpLiBZb3UgY2FuIGFzc2lnbiBhIGZ1bmN0aW9uIHRvIGFsbG93IGN1c3RvbSBmb3JtYXR0aW5nIG9mIGEgbG9nIG1lc3NhZ2UuXG4gICAgICAgICAqIEVhY2ggbG9nIG1lc3NhZ2Ugd2lsbCBjYWxsIHRoaXMgZnVuY3Rpb24gdGhlbiBhbmQgZXhwZWN0cyB5b3VyIGZ1bmN0aW9uIHRvIGZvcm1hdCB0aGUgbWVzc2FnZSBhbmQgcmV0dXJuIGEgc3RyaW5nLlxuICAgICAgICAgKiBXaWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSBhdHRlbXB0IHRvIHNldCBhIGZvcm1hdHRlckxvZ01lc3NhZ2UgaWYgdGhlIExvZ2dlclR5cGUgaXMgY3VzdG9tLlxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGZvcm1hdHRlciBmdW5jdGlvbiwgb3IgbnVsbCB0byByZXNldCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdGhpcy5fbG9nZ2VyVHlwZSA9PT0gTG9nZ2VyT3B0aW9uc18xLkxvZ2dlclR5cGUuQ3VzdG9tKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBzcGVjaWZ5IGEgZm9ybWF0dGVyIGZvciBsb2cgbWVzc2FnZXMgaWYgeW91ciBsb2dnZXJUeXBlIGlzIEN1c3RvbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIExvZ0dyb3VwUnVsZTtcbn0oKSk7XG5leHBvcnRzLkxvZ0dyb3VwUnVsZSA9IExvZ0dyb3VwUnVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvZ0dyb3VwUnVsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcnVudGltZSBzZXR0aW5ncyBmb3IgYSBMb2dHcm91cCAoTG9nR3JvdXBSdWxlKS5cbiAqL1xudmFyIExvZ0dyb3VwUnVudGltZVNldHRpbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyhsb2dHcm91cFJ1bGUpIHtcbiAgICAgICAgdGhpcy5fZm9ybWF0dGVyTG9nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvZ0dyb3VwUnVsZSA9IGxvZ0dyb3VwUnVsZTtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBsb2dHcm91cFJ1bGUubGV2ZWw7XG4gICAgICAgIHRoaXMuX2xvZ2dlclR5cGUgPSBsb2dHcm91cFJ1bGUubG9nZ2VyVHlwZTtcbiAgICAgICAgdGhpcy5fbG9nRm9ybWF0ID0gbmV3IExvZ2dlck9wdGlvbnNfMS5Mb2dGb3JtYXQobmV3IExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0KGxvZ0dyb3VwUnVsZS5sb2dGb3JtYXQuZGF0ZUZvcm1hdC5mb3JtYXRFbnVtLCBsb2dHcm91cFJ1bGUubG9nRm9ybWF0LmRhdGVGb3JtYXQuZGF0ZVNlcGFyYXRvciksIGxvZ0dyb3VwUnVsZS5sb2dGb3JtYXQuc2hvd1RpbWVTdGFtcCwgbG9nR3JvdXBSdWxlLmxvZ0Zvcm1hdC5zaG93TG9nZ2VyTmFtZSk7XG4gICAgICAgIHRoaXMuX2NhbGxCYWNrTG9nZ2VyID0gbG9nR3JvdXBSdWxlLmNhbGxCYWNrTG9nZ2VyO1xuICAgICAgICB0aGlzLl9mb3JtYXR0ZXJMb2dNZXNzYWdlID0gbG9nR3JvdXBSdWxlLmZvcm1hdHRlckxvZ01lc3NhZ2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5wcm90b3R5cGUsIFwibG9nR3JvdXBSdWxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgb3JpZ2luYWwgTG9nR3JvdXBSdWxlIChzbyBub3QgcnVudGltZSBzZXR0aW5ncyEpXG4gICAgICAgICAqIEByZXR1cm4ge0xvZ0dyb3VwUnVsZX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVsZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJsZXZlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbGV2ZWwgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJsb2dnZXJUeXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nZ2VyVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlclR5cGUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJsb2dGb3JtYXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dGb3JtYXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dGb3JtYXQgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJjYWxsQmFja0xvZ2dlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxCYWNrTG9nZ2VyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbEJhY2tMb2dnZXIgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJMb2dNZXNzYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0dGVyTG9nTWVzc2FnZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIExvZ0dyb3VwUnVudGltZVNldHRpbmdzO1xufSgpKTtcbmV4cG9ydHMuTG9nR3JvdXBSdW50aW1lU2V0dGluZ3MgPSBMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvZ0dyb3VwUnVudGltZVNldHRpbmdzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERhdGFTdHJ1Y3R1cmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvRGF0YVN0cnVjdHVyZXNcIik7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL0xvZ2dlck9wdGlvbnNcIik7XG52YXIgQ29uc29sZUxvZ2dlckltcGxfMSA9IHJlcXVpcmUoXCIuL0NvbnNvbGVMb2dnZXJJbXBsXCIpO1xudmFyIE1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsXzEgPSByZXF1aXJlKFwiLi9NZXNzYWdlQnVmZmVyTG9nZ2VySW1wbFwiKTtcbnZhciBBYnN0cmFjdExvZ2dlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RMb2dnZXJcIik7XG52YXIgTG9nR3JvdXBSdW50aW1lU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0xvZ0dyb3VwUnVudGltZVNldHRpbmdzXCIpO1xudmFyIExvZ2dlckZhY3RvcnlJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2dnZXJGYWN0b3J5SW1wbChuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlcnMgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5TaW1wbGVNYXAoKTtcbiAgICAgICAgdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3NJbmRleGVkID0gW107XG4gICAgICAgIHRoaXMuX2xvZ2dlclRvTG9nR3JvdXBTZXR0aW5ncyA9IG5ldyBEYXRhU3RydWN0dXJlc18xLlNpbXBsZU1hcCgpO1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb25maWd1cmUob3B0aW9ucyk7XG4gICAgfVxuICAgIExvZ2dlckZhY3RvcnlJbXBsLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgLy8gQ2xvc2UgYW55IGN1cnJlbnQgb3BlbiBsb2dnZXJzLlxuICAgICAgICB0aGlzLmNsb3NlTG9nZ2VycygpO1xuICAgICAgICB0aGlzLl9sb2dnZXJUb0xvZ0dyb3VwU2V0dGluZ3MuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3NJbmRleGVkID0gW107XG4gICAgICAgIHZhciBsb2dHcm91cFJ1bGVzID0gdGhpcy5fb3B0aW9ucy5sb2dHcm91cFJ1bGVzO1xuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpwcmVmZXItZm9yLW9mICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nR3JvdXBSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3NJbmRleGVkLnB1c2gobmV3IExvZ0dyb3VwUnVudGltZVNldHRpbmdzXzEuTG9nR3JvdXBSdW50aW1lU2V0dGluZ3MobG9nR3JvdXBSdWxlc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6cHJlZmVyLWZvci1vZiAqL1xuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeUltcGwucHJvdG90eXBlLmdldExvZ2dlciA9IGZ1bmN0aW9uIChuYW1lZCkge1xuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9nZ2VyRmFjdG9yeSBpcyBub3QgZW5hYmxlZCwgcGxlYXNlIGNoZWNrIHlvdXIgb3B0aW9ucyBwYXNzZWQgaW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZ2dlciA9IHRoaXMuX2xvZ2dlcnMuZ2V0KG5hbWVkKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2dnZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBsb2dnZXIgd2l0aCBhcHByb3ByaWF0ZSBsZXZlbFxuICAgICAgICBsb2dnZXIgPSB0aGlzLmxvYWRMb2dnZXIobmFtZWQpO1xuICAgICAgICB0aGlzLl9sb2dnZXJzLnB1dChuYW1lZCwgbG9nZ2VyKTtcbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnlJbXBsLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmVuYWJsZWQ7XG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5SW1wbC5wcm90b3R5cGUuY2xvc2VMb2dnZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2dnZXJzLmZvckVhY2hWYWx1ZShmdW5jdGlvbiAobG9nZ2VyKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4gb25seSBjbG9zZSBpZiBBYnN0cmFjdExvZ2dlciBpcyB1c2VkIChvdXIgbG9nZ2VycywgYnV0IHVzZXIgbG9nZ2VycyBtYXkgbm90IGV4dGVuZCBpdCwgZXZlbiB0aG91Z2ggdW5saWtlbHkpLlxuICAgICAgICAgICAgaWYgKGxvZ2dlciBpbnN0YW5jZW9mIEFic3RyYWN0TG9nZ2VyXzEuQWJzdHJhY3RMb2dnZXIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xvZ2dlcnMuY2xlYXIoKTtcbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnlJbXBsLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnlJbXBsLnByb3RvdHlwZS5nZXRMb2dHcm91cFJ1bnRpbWVTZXR0aW5nc0J5SW5kZXggPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPCB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5nc0luZGV4ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3NJbmRleGVkW2lkeF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5SW1wbC5wcm90b3R5cGUuZ2V0TG9nR3JvdXBSdW50aW1lU2V0dGluZ3NCeUxvZ2dlck5hbWUgPSBmdW5jdGlvbiAobmFtZUxvZ2dlcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fbG9nZ2VyVG9Mb2dHcm91cFNldHRpbmdzLmdldChuYW1lTG9nZ2VyKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5SW1wbC5wcm90b3R5cGUuZ2V0TG9nR3JvdXBSdW50aW1lU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5nc0luZGV4ZWQuc2xpY2UoMCk7XG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5SW1wbC5wcm90b3R5cGUubG9hZExvZ2dlciA9IGZ1bmN0aW9uIChuYW1lZCkge1xuICAgICAgICB2YXIgbG9nR3JvdXBSdWxlcyA9IHRoaXMuX29wdGlvbnMubG9nR3JvdXBSdWxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dHcm91cFJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9nR3JvdXBSdWxlID0gbG9nR3JvdXBSdWxlc1tpXTtcbiAgICAgICAgICAgIGlmIChsb2dHcm91cFJ1bGUucmVnRXhwLnRlc3QobmFtZWQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzID0gdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3NJbmRleGVkW2ldO1xuICAgICAgICAgICAgICAgIHZhciBsb2dnZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChsb2dHcm91cFJ1bGUubG9nZ2VyVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkNvbnNvbGU6XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIgPSBuZXcgQ29uc29sZUxvZ2dlckltcGxfMS5Db25zb2xlTG9nZ2VySW1wbChuYW1lZCwgbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ2dlclR5cGUuTWVzc2FnZUJ1ZmZlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciA9IG5ldyBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbF8xLk1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsKG5hbWVkLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nZ2VyVHlwZS5DdXN0b206XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9nR3JvdXBSdWxlLmNhbGxCYWNrTG9nZ2VyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIgPSBsb2dHcm91cFJ1bGUuY2FsbEJhY2tMb2dnZXIobmFtZWQsIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgYSBjdXN0b20gbG9nZ2VyLCBjdXN0b20gY2FsbGJhY2sgaXMgbnVsbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNyZWF0ZSBhIExvZ2dlciBmb3IgTG9nZ2VyVHlwZTogXCIgKyBsb2dHcm91cFJ1bGUubG9nZ2VyVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvciBhIG5ldyBsb2dnZXIgbWFwIGl0IGJ5IGl0cyBuYW1lXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyVG9Mb2dHcm91cFNldHRpbmdzLnB1dChuYW1lZCwgbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZpbmQgYSBtYXRjaCB0byBjcmVhdGUgYSBMb2dnZXIgZm9yOiBcIiArIG5hbWVkKTtcbiAgICB9O1xuICAgIHJldHVybiBMb2dnZXJGYWN0b3J5SW1wbDtcbn0oKSk7XG5leHBvcnRzLkxvZ2dlckZhY3RvcnlJbXBsID0gTG9nZ2VyRmFjdG9yeUltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2dnZXJGYWN0b3J5SW1wbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogT3B0aW9ucyBvYmplY3QgeW91IGNhbiB1c2UgdG8gY29uZmlndXJlIHRoZSBMb2dnZXJGYWN0b3J5IHlvdSBjcmVhdGUgYXQgTEZTZXJ2aWNlLlxuICovXG52YXIgTG9nZ2VyRmFjdG9yeU9wdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlckZhY3RvcnlPcHRpb25zKCkge1xuICAgICAgICB0aGlzLl9sb2dHcm91cFJ1bGVzID0gW107XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgTG9nR3JvdXBSdWxlLCBzZWUge0xvZ0dyb3VwUnVsZSkgZm9yIGRldGFpbHNcbiAgICAgKiBAcGFyYW0gcnVsZSBSdWxlIHRvIGFkZFxuICAgICAqIEByZXR1cm5zIHtMb2dnZXJGYWN0b3J5T3B0aW9uc30gcmV0dXJucyBpdHNlbGZcbiAgICAgKi9cbiAgICBMb2dnZXJGYWN0b3J5T3B0aW9ucy5wcm90b3R5cGUuYWRkTG9nR3JvdXBSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgdGhpcy5fbG9nR3JvdXBSdWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGxvZ2dpbmcgY29tcGxldGVseSBmb3IgdGhlIExvZ2dlckZhY3RvcnkuXG4gICAgICogQHBhcmFtIGVuYWJsZWQgVHJ1ZSBmb3IgZW5hYmxlZCAoZGVmYXVsdClcbiAgICAgKiBAcmV0dXJucyB7TG9nZ2VyRmFjdG9yeU9wdGlvbnN9IHJldHVybnMgaXRzZWxmXG4gICAgICovXG4gICAgTG9nZ2VyRmFjdG9yeU9wdGlvbnMucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nZ2VyRmFjdG9yeU9wdGlvbnMucHJvdG90eXBlLCBcImxvZ0dyb3VwUnVsZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bGVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nZ2VyRmFjdG9yeU9wdGlvbnMucHJvdG90eXBlLCBcImVuYWJsZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTG9nZ2VyRmFjdG9yeU9wdGlvbnM7XG59KCkpO1xuZXhwb3J0cy5Mb2dnZXJGYWN0b3J5T3B0aW9ucyA9IExvZ2dlckZhY3RvcnlPcHRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nZ2VyRmFjdG9yeU9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBYnN0cmFjdExvZ2dlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RMb2dnZXJcIik7XG4vKipcbiAqIExvZ2dlciB3aGljaCBidWZmZXJzIGFsbCBtZXNzYWdlcywgdXNlIHdpdGggY2FyZSBkdWUgdG8gcG9zc2libGUgaGlnaCBtZW1vcnkgZm9vdHByaW50LlxuICogQ2FuIGJlIGNvbnZlbmllbnQgaW4gc29tZSBjYXNlcy4gQ2FsbCB0b1N0cmluZygpIGZvciBmdWxsIG91dHB1dCwgb3IgY2FzdCB0byB0aGlzIGNsYXNzXG4gKiBhbmQgY2FsbCBnZXRNZXNzYWdlcygpIHRvIGRvIHNvbWV0aGluZyB3aXRoIGl0IHlvdXJzZWxmLlxuICovXG52YXIgTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbChuYW1lLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5jbG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwucHJvdG90eXBlLmdldE1lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcztcbiAgICB9O1xuICAgIE1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMubWFwKGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbC5wcm90b3R5cGUuZG9Mb2cgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgbWVzc2FnZUZvcm1hdHRlciA9IHRoaXMuX2dldE1lc3NhZ2VGb3JtYXR0ZXIoKTtcbiAgICAgICAgdmFyIGZ1bGxNc2c7XG4gICAgICAgIGlmIChtZXNzYWdlRm9ybWF0dGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICBmdWxsTXNnID0gdGhpcy5jcmVhdGVEZWZhdWx0TG9nTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxNc2cgPSBtZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaChmdWxsTXNnKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbDtcbn0oQWJzdHJhY3RMb2dnZXJfMS5BYnN0cmFjdExvZ2dlcikpO1xuZXhwb3J0cy5NZXNzYWdlQnVmZmVyTG9nZ2VySW1wbCA9IE1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExvZ0dyb3VwQ29udHJvbF8xID0gcmVxdWlyZShcIi4vY29udHJvbC9Mb2dHcm91cENvbnRyb2xcIik7XG52YXIgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbF8xID0gcmVxdWlyZShcIi4vY29udHJvbC9DYXRlZ29yeVNlcnZpY2VDb250cm9sXCIpO1xudmFyIEV4dGVuc2lvbkhlbHBlcl8xID0gcmVxdWlyZShcIi4vZXh0ZW5zaW9uL0V4dGVuc2lvbkhlbHBlclwiKTtcbmV4cG9ydHMuRXh0ZW5zaW9uSGVscGVyID0gRXh0ZW5zaW9uSGVscGVyXzEuRXh0ZW5zaW9uSGVscGVyO1xuLy8gQ2F0ZWdvcnkgcmVsYXRlZFxudmFyIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL2xvZy9jYXRlZ29yeS9BYnN0cmFjdENhdGVnb3J5TG9nZ2VyXCIpO1xuZXhwb3J0cy5BYnN0cmFjdENhdGVnb3J5TG9nZ2VyID0gQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcl8xLkFic3RyYWN0Q2F0ZWdvcnlMb2dnZXI7XG52YXIgQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbF8xID0gcmVxdWlyZShcIi4vbG9nL2NhdGVnb3J5L0NhdGVnb3J5Q29uc29sZUxvZ2dlckltcGxcIik7XG5leHBvcnRzLkNhdGVnb3J5Q29uc29sZUxvZ2dlckltcGwgPSBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsXzEuQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbDtcbnZhciBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbF8xID0gcmVxdWlyZShcIi4vbG9nL2NhdGVnb3J5L0NhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsXCIpO1xuZXhwb3J0cy5DYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbCA9IENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsXzEuQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGw7XG52YXIgQ2F0ZWdvcnlfMSA9IHJlcXVpcmUoXCIuL2xvZy9jYXRlZ29yeS9DYXRlZ29yeVwiKTtcbmV4cG9ydHMuQ2F0ZWdvcnkgPSBDYXRlZ29yeV8xLkNhdGVnb3J5O1xudmFyIENhdGVnb3J5UnVudGltZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9sb2cvY2F0ZWdvcnkvQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3NcIik7XG5leHBvcnRzLkNhdGVnb3J5UnVudGltZVNldHRpbmdzID0gQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3NfMS5DYXRlZ29yeVJ1bnRpbWVTZXR0aW5ncztcbnZhciBDYXRlZ29yeUNvbmZpZ3VyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2xvZy9jYXRlZ29yeS9DYXRlZ29yeUNvbmZpZ3VyYXRpb25cIik7XG5leHBvcnRzLkNhdGVnb3J5Q29uZmlndXJhdGlvbiA9IENhdGVnb3J5Q29uZmlndXJhdGlvbl8xLkNhdGVnb3J5Q29uZmlndXJhdGlvbjtcbnZhciBDYXRlZ29yeU1lc3NhZ2VCdWZmZXJJbXBsXzEgPSByZXF1aXJlKFwiLi9sb2cvY2F0ZWdvcnkvQ2F0ZWdvcnlNZXNzYWdlQnVmZmVySW1wbFwiKTtcbmV4cG9ydHMuQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbCA9IENhdGVnb3J5TWVzc2FnZUJ1ZmZlckltcGxfMS5DYXRlZ29yeU1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsO1xudmFyIENhdGVnb3J5U2VydmljZUZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL2xvZy9jYXRlZ29yeS9DYXRlZ29yeVNlcnZpY2VGYWN0b3J5XCIpO1xuZXhwb3J0cy5DYXRlZ29yeVNlcnZpY2VGYWN0b3J5ID0gQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeV8xLkNhdGVnb3J5U2VydmljZUZhY3Rvcnk7XG52YXIgTG9nZ2VyRmFjdG9yeU9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2xvZy9zdGFuZGFyZC9Mb2dnZXJGYWN0b3J5T3B0aW9uc1wiKTtcbmV4cG9ydHMuTG9nZ2VyRmFjdG9yeU9wdGlvbnMgPSBMb2dnZXJGYWN0b3J5T3B0aW9uc18xLkxvZ2dlckZhY3RvcnlPcHRpb25zO1xudmFyIExvZ0dyb3VwUnVsZV8xID0gcmVxdWlyZShcIi4vbG9nL3N0YW5kYXJkL0xvZ0dyb3VwUnVsZVwiKTtcbmV4cG9ydHMuTG9nR3JvdXBSdWxlID0gTG9nR3JvdXBSdWxlXzEuTG9nR3JvdXBSdWxlO1xudmFyIExGU2VydmljZV8xID0gcmVxdWlyZShcIi4vbG9nL3N0YW5kYXJkL0xGU2VydmljZVwiKTtcbmV4cG9ydHMuTEZTZXJ2aWNlID0gTEZTZXJ2aWNlXzEuTEZTZXJ2aWNlO1xudmFyIEFic3RyYWN0TG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9sb2cvc3RhbmRhcmQvQWJzdHJhY3RMb2dnZXJcIik7XG5leHBvcnRzLkFic3RyYWN0TG9nZ2VyID0gQWJzdHJhY3RMb2dnZXJfMS5BYnN0cmFjdExvZ2dlcjtcbnZhciBDb25zb2xlTG9nZ2VySW1wbF8xID0gcmVxdWlyZShcIi4vbG9nL3N0YW5kYXJkL0NvbnNvbGVMb2dnZXJJbXBsXCIpO1xuZXhwb3J0cy5Db25zb2xlTG9nZ2VySW1wbCA9IENvbnNvbGVMb2dnZXJJbXBsXzEuQ29uc29sZUxvZ2dlckltcGw7XG52YXIgTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGxfMSA9IHJlcXVpcmUoXCIuL2xvZy9zdGFuZGFyZC9NZXNzYWdlQnVmZmVyTG9nZ2VySW1wbFwiKTtcbmV4cG9ydHMuTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwgPSBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbF8xLk1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2xvZy9Mb2dnZXJPcHRpb25zXCIpO1xuZXhwb3J0cy5DYXRlZ29yeUxvZ0Zvcm1hdCA9IExvZ2dlck9wdGlvbnNfMS5DYXRlZ29yeUxvZ0Zvcm1hdDtcbmV4cG9ydHMuRGF0ZUZvcm1hdCA9IExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0O1xuZXhwb3J0cy5EYXRlRm9ybWF0RW51bSA9IExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0RW51bTtcbmV4cG9ydHMuTG9nRm9ybWF0ID0gTG9nZ2VyT3B0aW9uc18xLkxvZ0Zvcm1hdDtcbmV4cG9ydHMuTG9nZ2VyVHlwZSA9IExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlO1xuZXhwb3J0cy5Mb2dMZXZlbCA9IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbDtcbi8vIFV0aWxpdGllc1xudmFyIERhdGFTdHJ1Y3R1cmVzXzEgPSByZXF1aXJlKFwiLi91dGlscy9EYXRhU3RydWN0dXJlc1wiKTtcbmV4cG9ydHMuU2ltcGxlTWFwID0gRGF0YVN0cnVjdHVyZXNfMS5TaW1wbGVNYXA7XG5leHBvcnRzLkxpbmtlZExpc3QgPSBEYXRhU3RydWN0dXJlc18xLkxpbmtlZExpc3Q7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91dGlscy9KU09OSGVscGVyXCIpKTtcbnZhciBNZXNzYWdlVXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL01lc3NhZ2VVdGlsc1wiKTtcbmV4cG9ydHMuTWVzc2FnZUZvcm1hdFV0aWxzID0gTWVzc2FnZVV0aWxzXzEuTWVzc2FnZUZvcm1hdFV0aWxzO1xuLypcbiBGdW5jdGlvbnMgdG8gZXhwb3J0IG9uIFRTTCBsaWJhcmFyeSB2YXIuXG4qL1xuLy8gRXhwb3J0IGhlbHAgZnVuY3Rpb25cbmZ1bmN0aW9uIGhlbHAoKSB7XG4gICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgIGNvbnNvbGUubG9nKFwiaGVscCgpXFxuICAgKiogU2hvd3MgdGhpcyBoZWxwXFxuXFxuIGdldExvZ0NvbnRyb2woKTogTG9nZ2VyQ29udHJvbFxcbiAgICoqIFJldHVybnMgTG9nZ2VyQ29udHJvbCBPYmplY3QsIHVzZSB0byBkeW5hbWljYWxseSBjaGFuZ2UgbG9nbGV2ZWxzIGZvciBsb2c0aiBsb2dnaW5nLlxcbiAgICoqIENhbGwgLmhlbHAoKSBvbiBMb2dnZXJDb250cm9sIG9iamVjdCBmb3IgYXZhaWxhYmxlIG9wdGlvbnMuXFxuXFxuIGdldENhdGVnb3J5Q29udHJvbCgpOiBDYXRlZ29yeVNlcnZpY2VDb250cm9sXFxuICAgKiogUmV0dXJucyBDYXRlZ29yeVNlcnZpY2VDb250cm9sIE9iamVjdCwgdXNlIHRvIGR5bmFtaWNhbGx5IGNoYW5nZSBsb2dsZXZlbHMgZm9yIGNhdGVnb3J5IGxvZ2dpbmcuXFxuICAgKiogQ2FsbCAuaGVscCgpIG9uIENhdGVnb3J5U2VydmljZUNvbnRyb2wgb2JqZWN0IGZvciBhdmFpbGFibGUgb3B0aW9ucy5cXG5cIik7XG4gICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG59XG5leHBvcnRzLmhlbHAgPSBoZWxwO1xuLy8gRXhwb3J0IExvZ0NvbnRyb2wgZnVuY3Rpb24gKGxvZzRqKVxuZnVuY3Rpb24gZ2V0TG9nQ29udHJvbCgpIHtcbiAgICByZXR1cm4gbmV3IExvZ0dyb3VwQ29udHJvbF8xLkxvZ2dlckNvbnRyb2xJbXBsKCk7XG59XG5leHBvcnRzLmdldExvZ0NvbnRyb2wgPSBnZXRMb2dDb250cm9sO1xuLy8gRXhwb3J0IENhdGVnb3J5Q29udHJvbCBmdW5jdGlvblxuZnVuY3Rpb24gZ2V0Q2F0ZWdvcnlDb250cm9sKCkge1xuICAgIHJldHVybiBuZXcgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbF8xLkNhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsKCk7XG59XG5leHBvcnRzLmdldENhdGVnb3J5Q29udHJvbCA9IGdldENhdGVnb3J5Q29udHJvbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzY3JpcHQtbG9nZ2luZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMaW5rZWROb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5rZWROb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5rZWROb2RlLnByb3RvdHlwZSwgXCJwcmV2aW91c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXMgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmtlZE5vZGUucHJvdG90eXBlLCBcIm5leHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZXh0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlua2VkTm9kZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIExpbmtlZE5vZGU7XG59KCkpO1xuLyoqXG4gKiBEb3VibGUgbGlua2VkbGlzdCBpbXBsZW1lbnRhdGlvbi5cbiAqL1xudmFyIExpbmtlZExpc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmtlZExpc3QoKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmFkZEhlYWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZUhlYWRJZk5lZWRlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgICAgICAgICAgIHZhciBuZXdIZWFkTm9kZSA9IG5ldyBMaW5rZWROb2RlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZS5wcmV2aW91cyA9IG5ld0hlYWROb2RlO1xuICAgICAgICAgICAgICAgICAgICBuZXdIZWFkTm9kZS5uZXh0ID0gbmV4dE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5ld0hlYWROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBsaXN0IGltcGxlbWVudGF0aW9uIGJyb2tlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemUrKztcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmFkZFRhaWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZUhlYWRJZk5lZWRlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBvbGRUYWlsTm9kZSA9IHRoaXMuZ2V0VGFpbE5vZGUoKTtcbiAgICAgICAgICAgIGlmIChvbGRUYWlsTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1RhaWxOb2RlID0gbmV3IExpbmtlZE5vZGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIG9sZFRhaWxOb2RlLm5leHQgPSBuZXdUYWlsTm9kZTtcbiAgICAgICAgICAgICAgICBuZXdUYWlsTm9kZS5wcmV2aW91cyA9IG9sZFRhaWxOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGlzdCBpbXBsZW1lbnRhdGlvbiBicm9rZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmdldEhlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVhZC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnJlbW92ZUhlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9sZEhlYWQgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvbGRIZWFkLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gb2xkSGVhZC5uZXh0O1xuICAgICAgICAgICAgdGhpcy5zaXplLS07XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5nZXRUYWlsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0VGFpbE5vZGUoKTtcbiAgICAgICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZW1vdmVUYWlsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0VGFpbE5vZGUoKTtcbiAgICAgICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNOb2RlID0gbm9kZS5wcmV2aW91cztcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGlzdCBpbXBsZW1lbnRhdGlvbiBpcyBicm9rZW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zaXplLS07XG4gICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgcmVjdXJzZSA9IGZ1bmN0aW9uIChmbiwgbm9kZSwgdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoZm4obm9kZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChub2RlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzZShmbiwgbmV4dE5vZGUsIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5oZWFkO1xuICAgICAgICBpZiAoY3VycmVudE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVjdXJzZShmLCBjdXJyZW50Tm9kZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuY3JlYXRlSGVhZElmTmVlZGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gbmV3IExpbmtlZE5vZGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZ2V0VGFpbE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlIChub2RlLm5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIHJldHVybiBMaW5rZWRMaXN0O1xufSgpKTtcbmV4cG9ydHMuTGlua2VkTGlzdCA9IExpbmtlZExpc3Q7XG4vKipcbiAqIE1hcCBpbXBsZW1lbnRhdGlvbiBrZXllZCBieSBzdHJpbmcgKGFsd2F5cykuXG4gKi9cbnZhciBTaW1wbGVNYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpbXBsZU1hcCgpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IHt9O1xuICAgIH1cbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXJyYXlba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gICAgU2ltcGxlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5W2tleV07XG4gICAgfTtcbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hcnJheVtrZXldO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgfTtcbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hcnJheVtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hcnJheVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFNpbXBsZU1hcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgcmFuZG9tIHN0dWZmIHRvIGFwcGVhclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG4gICAgU2ltcGxlTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgcmFuZG9tIHN0dWZmIHRvIGFwcGVhclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuZ2V0KGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMoKS5sZW5ndGg7XG4gICAgfTtcbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUoKSA9PT0gMDtcbiAgICB9O1xuICAgIFNpbXBsZU1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSB7fTtcbiAgICB9O1xuICAgIFNpbXBsZU1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYkZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmFycmF5KSB7XG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IHJhbmRvbSBzdHVmZiB0byBhcHBlYXJcbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmFycmF5W2tleV07XG4gICAgICAgICAgICAgICAgY2JGdW5jdGlvbihrZXksIHZhbHVlLCBjb3VudCk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2ltcGxlTWFwLnByb3RvdHlwZS5mb3JFYWNoVmFsdWUgPSBmdW5jdGlvbiAoY2JGdW5jdGlvbikge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5hcnJheSkge1xuICAgICAgICAgICAgLy8gVG8gcHJldmVudCByYW5kb20gc3R1ZmYgdG8gYXBwZWFyXG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hcnJheVtrZXldO1xuICAgICAgICAgICAgICAgIGNiRnVuY3Rpb24odmFsdWUsIGNvdW50KTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2ltcGxlTWFwO1xufSgpKTtcbmV4cG9ydHMuU2ltcGxlTWFwID0gU2ltcGxlTWFwO1xuLyoqXG4gKiBUdXBsZSB0byBob2xkIHR3byB2YWx1ZXMuXG4gKi9cbnZhciBUdXBsZVBhaXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR1cGxlUGFpcih4LCB5KSB7XG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFR1cGxlUGFpci5wcm90b3R5cGUsIFwieFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl94ID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUdXBsZVBhaXIucHJvdG90eXBlLCBcInlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVHVwbGVQYWlyO1xufSgpKTtcbmV4cG9ydHMuVHVwbGVQYWlyID0gVHVwbGVQYWlyO1xuLyoqXG4gKiBVdGlsaXR5IGNsYXNzIHRvIGJ1aWxkIHVwIGEgc3RyaW5nLlxuICovXG52YXIgU3RyaW5nQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nQnVpbGRlcigpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgfVxuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQgfHwgbGluZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgbXVzdCBiZSBzZXQsIGNhbm5vdCBhcHBlbmQgbnVsbCBvciB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhLnB1c2gobGluZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKGxpbmUgKyBcIlxcblwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTdHJpbmdCdWlsZGVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9O1xuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHNlcGFyYXRvcikge1xuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDApIHsgc2VwYXJhdG9yID0gXCJcIjsgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdCdWlsZGVyO1xufSgpKTtcbmV4cG9ydHMuU3RyaW5nQnVpbGRlciA9IFN0cmluZ0J1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhU3RydWN0dXJlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBNb2R1bGUgY29udGFpbmluZyBidW5jaCBvZiBKU09OIHJlbGF0ZWQgc3R1ZmYuXG4gKi9cbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vbG9nL0xvZ2dlck9wdGlvbnNcIik7XG52YXIgRGF0YVN0cnVjdHVyZXNfMSA9IHJlcXVpcmUoXCIuL0RhdGFTdHJ1Y3R1cmVzXCIpO1xudmFyIEpTT05UeXBlSW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNPTlR5cGVJbXBsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIEpTT05UeXBlSW1wbC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9O1xuICAgIEpTT05UeXBlSW1wbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9O1xuICAgIHJldHVybiBKU09OVHlwZUltcGw7XG59KCkpO1xudmFyIEpTT05Cb29sZWFuVHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTT05Cb29sZWFuVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKU09OQm9vbGVhblR5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHZhbHVlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTkJvb2xlYW5UeXBlO1xufShKU09OVHlwZUltcGwpKTtcbnZhciBKU09OTnVtYmVyVHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTT05OdW1iZXJUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTT05OdW1iZXJUeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEpTT05OdW1iZXJUeXBlO1xufShKU09OVHlwZUltcGwpKTtcbnZhciBKU09OU3RyaW5nVHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTT05TdHJpbmdUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTT05TdHJpbmdUeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgSlNPTlN0cmluZ1R5cGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05TdHJpbmdUeXBlO1xufShKU09OVHlwZUltcGwpKTtcbnZhciBKU09OT2JqZWN0VHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTT05PYmplY3RUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTT05PYmplY3RUeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEpTT05PYmplY3RUeXBlO1xufShKU09OVHlwZUltcGwpKTtcbnZhciBKU09OQXJyYXlUeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSlNPTkFycmF5VHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKU09OQXJyYXlUeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgSlNPTkFycmF5VHlwZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9O1xuICAgIHJldHVybiBKU09OQXJyYXlUeXBlO1xufShKU09OVHlwZUltcGwpKTtcbnZhciBKU09OTnVsbFR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhKU09OTnVsbFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSlNPTk51bGxUeXBlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbnVsbCkgfHwgdGhpcztcbiAgICB9XG4gICAgSlNPTk51bGxUeXBlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05OdWxsVHlwZTtcbn0oSlNPTlR5cGVJbXBsKSk7XG52YXIgSlNPTlR5cGVDb252ZXJ0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT05UeXBlQ29udmVydGVyKCkge1xuICAgIH1cbiAgICBKU09OVHlwZUNvbnZlcnRlci50b0pTT05UeXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OTnVsbFR5cGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05TdHJpbmdUeXBlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05OdW1iZXJUeXBlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQm9vbGVhblR5cGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEpTT05PYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTk9iamVjdFR5cGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGUgbm90IHN1cHBvcnRlZCBmb3IgdmFsdWU6IFwiICsgdmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05UeXBlQ29udmVydGVyO1xufSgpKTtcbnZhciBKU09OT2JqZWN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKU09OT2JqZWN0KCkge1xuICAgICAgICB0aGlzLnZhbHVlcyA9IG5ldyBEYXRhU3RydWN0dXJlc18xLlNpbXBsZU1hcCgpO1xuICAgIH1cbiAgICBKU09OT2JqZWN0LnByb3RvdHlwZS5hZGRCb29sZWFuID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tOYW1lKG5hbWUpO1xuICAgICAgICBKU09OT2JqZWN0LmNoZWNrVmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlcy5wdXQobmFtZSwgbmV3IEpTT05Cb29sZWFuVHlwZSh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEpTT05PYmplY3QucHJvdG90eXBlLmFkZE51bWJlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrTmFtZShuYW1lKTtcbiAgICAgICAgSlNPTk9iamVjdC5jaGVja1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZXMucHV0KG5hbWUsIG5ldyBKU09OTnVtYmVyVHlwZSh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEpTT05PYmplY3QucHJvdG90eXBlLmFkZFN0cmluZyA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrTmFtZShuYW1lKTtcbiAgICAgICAgSlNPTk9iamVjdC5jaGVja1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZXMucHV0KG5hbWUsIG5ldyBKU09OU3RyaW5nVHlwZSh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEpTT05PYmplY3QucHJvdG90eXBlLmFkZE51bGwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLmNoZWNrTmFtZShuYW1lKTtcbiAgICAgICAgdGhpcy52YWx1ZXMucHV0KG5hbWUsIG5ldyBKU09OTnVsbFR5cGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSlNPTk9iamVjdC5wcm90b3R5cGUuYWRkQXJyYXkgPSBmdW5jdGlvbiAobmFtZSwgYXJyYXkpIHtcbiAgICAgICAgdGhpcy5jaGVja05hbWUobmFtZSk7XG4gICAgICAgIEpTT05PYmplY3QuY2hlY2tWYWx1ZShhcnJheSk7XG4gICAgICAgIGlmIChhcnJheSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIGFycmF5IGFzIG51bGxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZXMucHV0KG5hbWUsIG5ldyBKU09OQXJyYXlUeXBlKGFycmF5KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSlNPTk9iamVjdC5wcm90b3R5cGUuYWRkT2JqZWN0ID0gZnVuY3Rpb24gKG5hbWUsIG9iamVjdCkge1xuICAgICAgICB0aGlzLmNoZWNrTmFtZShuYW1lKTtcbiAgICAgICAgSlNPTk9iamVjdC5jaGVja1ZhbHVlKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBvYmplY3QgYXMgbnVsbFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlcy5wdXQobmFtZSwgbmV3IEpTT05PYmplY3RUeXBlKG9iamVjdCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEpTT05PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHByZXR0eSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocHJldHR5ID09PSB2b2lkIDApIHsgcHJldHR5ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGNvbW1hID0gZmFsc2U7XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIGJ1ZmZlci5hcHBlbmQoXCJ7XCIpO1xuICAgICAgICB0aGlzLnZhbHVlcy5rZXlzKCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy52YWx1ZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21tYSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKFwiLFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyLmFwcGVuZCgnXCInKS5hcHBlbmQoa2V5KS5hcHBlbmQoJ1wiOicpLmFwcGVuZCh2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBjb21tYSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXIuYXBwZW5kKFwifVwiKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygpO1xuICAgIH07XG4gICAgSlNPTk9iamVjdC5wcm90b3R5cGUuY2hlY2tOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gbnVsbCB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5hbWUgaXMgbnVsbCBvciB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWVzLmV4aXN0cyhuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmFtZSBcIiArIG5hbWUgKyBcIiBpcyBhbHJlYWR5IHByZXNlbnQgZm9yIHRoaXMgb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09OT2JqZWN0LmNoZWNrVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGlzIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEpTT05PYmplY3Q7XG59KCkpO1xuZXhwb3J0cy5KU09OT2JqZWN0ID0gSlNPTk9iamVjdDtcbnZhciBKU09OQXJyYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT05BcnJheSgpIHtcbiAgICAgICAgdGhpcy5vYmplY3RzID0gW107XG4gICAgfVxuICAgIEpTT05BcnJheS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCBpcyBub3QgYWxsb3dlZCB0byBiZSB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goSlNPTlR5cGVDb252ZXJ0ZXIudG9KU09OVHlwZShvYmplY3QpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBKU09OQXJyYXkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHByZXR0eSkge1xuICAgICAgICBpZiAocHJldHR5ID09PSB2b2lkIDApIHsgcHJldHR5ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBEYXRhU3RydWN0dXJlc18xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgYnVmZmVyLmFwcGVuZChcIltcIik7XG4gICAgICAgIHRoaXMub2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXIuYXBwZW5kKFwiXVwiKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05BcnJheTtcbn0oKSk7XG5leHBvcnRzLkpTT05BcnJheSA9IEpTT05BcnJheTtcbi8qKlxuICogVXRpbGl0eSBjbGFzcyB0aGF0IGhlbHBzIHVzIGNvbnZlcnQgdGhpbmdzIHRvIGFuZCBmcm9tIGpzb24gKG5vdCBmb3Igbm9ybWFsIHVzYWdlKS5cbiAqL1xudmFyIEpTT05IZWxwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT05IZWxwZXIoKSB7XG4gICAgfVxuICAgIEpTT05IZWxwZXIuY2F0ZWdvcnlUb0pTT04gPSBmdW5jdGlvbiAoY2F0LCByZWN1cnNpdmUpIHtcbiAgICAgICAgLypcbiAgICAgICAgIHtcbiAgICAgICAgIFwiY2F0ZWdvcmllc1wiOlxuICAgICAgICAgW1xuICAgICAgICAgeyBpZD0xLFxuICAgICAgICAgbmFtZTogXCJ4XCIsXG4gICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICBsb2dMZXZlbDogXCJFcnJvclwiXG4gICAgICAgICB9LFxuICAgICAgICAgeyBpZD0yLFxuICAgICAgICAgbmFtZTogXCJ5XCIsXG4gICAgICAgICBwYXJlbnQ6IDEsXG4gICAgICAgICBsb2dMZXZlbDogXCJFcnJvclwiXG4gICAgICAgICB9XG4gICAgICAgICBdXG4gICAgICAgICB9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYXJyID0gbmV3IEpTT05BcnJheSgpO1xuICAgICAgICBKU09OSGVscGVyLl9jYXRlZ29yeVRvSlNPTihjYXQsIGFyciwgcmVjdXJzaXZlKTtcbiAgICAgICAgdmFyIG9iamVjdCA9IG5ldyBKU09OT2JqZWN0KCk7XG4gICAgICAgIG9iamVjdC5hZGRBcnJheShcImNhdGVnb3JpZXNcIiwgYXJyKTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xuICAgIEpTT05IZWxwZXIuX2NhdGVnb3J5VG9KU09OID0gZnVuY3Rpb24gKGNhdCwgYXJyLCByZWN1cnNpdmUpIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IG5ldyBKU09OT2JqZWN0KCk7XG4gICAgICAgIG9iamVjdC5hZGROdW1iZXIoXCJpZFwiLCBjYXQuaWQpO1xuICAgICAgICBvYmplY3QuYWRkU3RyaW5nKFwibmFtZVwiLCBjYXQubmFtZSk7XG4gICAgICAgIG9iamVjdC5hZGRTdHJpbmcoXCJsb2dMZXZlbFwiLCBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWxbY2F0LmxvZ0xldmVsXS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKGNhdC5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqZWN0LmFkZE51bWJlcihcInBhcmVudFwiLCBjYXQucGFyZW50LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iamVjdC5hZGROdWxsKFwicGFyZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGFyci5hZGQob2JqZWN0KTtcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgY2F0LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgSlNPTkhlbHBlci5fY2F0ZWdvcnlUb0pTT04oY2hpbGQsIGFyciwgcmVjdXJzaXZlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTkhlbHBlcjtcbn0oKSk7XG5leHBvcnRzLkpTT05IZWxwZXIgPSBKU09OSGVscGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SlNPTkhlbHBlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTVCA9IHJlcXVpcmUoXCJzdGFja3RyYWNlLWpzXCIpO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9sb2cvTG9nZ2VyT3B0aW9uc1wiKTtcbi8qKlxuICogU29tZSB1dGlsaXRpZXMgdG8gZm9ybWF0IG1lc3NhZ2VzLlxuICovXG52YXIgTWVzc2FnZUZvcm1hdFV0aWxzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXNzYWdlRm9ybWF0VXRpbHMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlciBnaXZlbiBkYXRlIGluIGdpdmVuIERhdGVGb3JtYXQgYW5kIHJldHVybiBhcyBTdHJpbmcuXG4gICAgICogQHBhcmFtIGRhdGUgRGF0ZVxuICAgICAqIEBwYXJhbSBkYXRlRm9ybWF0IEZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBkYXRlXG4gICAgICovXG4gICAgTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckRhdGUgPSBmdW5jdGlvbiAoZGF0ZSwgZGF0ZUZvcm1hdCkge1xuICAgICAgICB2YXIgbHBhZCA9IGZ1bmN0aW9uICh2YWx1ZSwgY2hhcnMsIHBhZFdpdGgpIHtcbiAgICAgICAgICAgIHZhciBob3dNYW55ID0gY2hhcnMgLSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaG93TWFueSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvd01hbnk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gcGFkV2l0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmdWxsWWVhciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSwgNCwgXCIwXCIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbW9udGggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxwYWQoKGQuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCksIDIsIFwiMFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRheSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldERhdGUoKS50b1N0cmluZygpLCAyLCBcIjBcIik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBob3VycyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldEhvdXJzKCkudG9TdHJpbmcoKSwgMiwgXCIwXCIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWludXRlcyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldE1pbnV0ZXMoKS50b1N0cmluZygpLCAyLCBcIjBcIik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZWNvbmRzID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBscGFkKGQuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCksIDIsIFwiMFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1pbGxpcyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldE1pbGxpc2Vjb25kcygpLnRvU3RyaW5nKCksIDMsIFwiMFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRhdGVTZXBhcmF0b3IgPSBkYXRlRm9ybWF0LmRhdGVTZXBhcmF0b3I7XG4gICAgICAgIHZhciBkcyA9IFwiXCI7XG4gICAgICAgIHN3aXRjaCAoZGF0ZUZvcm1hdC5mb3JtYXRFbnVtKSB7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0RW51bS5EZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIHl5eXktbW0tZGQgaGg6bW06c3MsbVxuICAgICAgICAgICAgICAgIGRzID0gZnVsbFllYXIoZGF0ZSkgKyBkYXRlU2VwYXJhdG9yICsgbW9udGgoZGF0ZSkgKyBkYXRlU2VwYXJhdG9yICsgZGF5KGRhdGUpICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICBob3VycyhkYXRlKSArIFwiOlwiICsgbWludXRlcyhkYXRlKSArIFwiOlwiICsgc2Vjb25kcyhkYXRlKSArIFwiLFwiICsgbWlsbGlzKGRhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuRGF0ZUZvcm1hdEVudW0uWWVhck1vbnRoRGF5VGltZTpcbiAgICAgICAgICAgICAgICBkcyA9IGZ1bGxZZWFyKGRhdGUpICsgZGF0ZVNlcGFyYXRvciArIG1vbnRoKGRhdGUpICsgZGF0ZVNlcGFyYXRvciArIGRheShkYXRlKSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgaG91cnMoZGF0ZSkgKyBcIjpcIiArIG1pbnV0ZXMoZGF0ZSkgKyBcIjpcIiArIHNlY29uZHMoZGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0RW51bS5ZZWFyRGF5TW9udGhXaXRoRnVsbFRpbWU6XG4gICAgICAgICAgICAgICAgZHMgPSBmdWxsWWVhcihkYXRlKSArIGRhdGVTZXBhcmF0b3IgKyBkYXkoZGF0ZSkgKyBkYXRlU2VwYXJhdG9yICsgbW9udGgoZGF0ZSkgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgIGhvdXJzKGRhdGUpICsgXCI6XCIgKyBtaW51dGVzKGRhdGUpICsgXCI6XCIgKyBzZWNvbmRzKGRhdGUpICsgXCIsXCIgKyBtaWxsaXMoZGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0RW51bS5ZZWFyRGF5TW9udGhUaW1lOlxuICAgICAgICAgICAgICAgIGRzID0gZnVsbFllYXIoZGF0ZSkgKyBkYXRlU2VwYXJhdG9yICsgZGF5KGRhdGUpICsgZGF0ZVNlcGFyYXRvciArIG1vbnRoKGRhdGUpICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICBob3VycyhkYXRlKSArIFwiOlwiICsgbWludXRlcyhkYXRlKSArIFwiOlwiICsgc2Vjb25kcyhkYXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0ZSBmb3JtYXQgZW51bTogXCIgKyBkYXRlRm9ybWF0LmZvcm1hdEVudW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgZ2l2ZW4gY2F0ZWdvcnkgbG9nIG1lc3NhZ2UgaW4gZGVmYXVsdCBmb3JtYXQuXG4gICAgICogQHBhcmFtIG1zZyBNZXNzYWdlIHRvIGZvcm1hdFxuICAgICAqIEBwYXJhbSBhZGRTdGFjayBJZiB0cnVlIGFkZHMgdGhlIHN0YWNrIHRvIHRoZSBvdXRwdXQsIG90aGVyd2lzZSBza2lwcyBpdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBtZXNzYWdlXG4gICAgICovXG4gICAgTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckRlZmF1bHRNZXNzYWdlID0gZnVuY3Rpb24gKG1zZywgYWRkU3RhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHZhciBsb2dGb3JtYXQgPSBtc2cubG9nRm9ybWF0O1xuICAgICAgICBpZiAobG9nRm9ybWF0LnNob3dUaW1lU3RhbXApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBNZXNzYWdlRm9ybWF0VXRpbHMucmVuZGVyRGF0ZShtc2cuZGF0ZSwgbG9nRm9ybWF0LmRhdGVGb3JtYXQpICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbFttc2cubGV2ZWxdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChtc2cuaXNSZXNvbHZlZEVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiIChyZXNvbHZlZClcIjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gXCIgXCI7XG4gICAgICAgIGlmIChsb2dGb3JtYXQuc2hvd0NhdGVnb3J5TmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiW1wiO1xuICAgICAgICAgICAgbXNnLmNhdGVnb3JpZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChpZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiwgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZS5uYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBub3JtYWwgc3RyaW5nIG1lc3NhZ2UgZmlyc3RcbiAgICAgICAgdmFyIGFjdHVhbFN0cmluZ01zZyA9IFwiXCI7XG4gICAgICAgIHZhciBkYXRhU3RyaW5nID0gXCJcIjtcbiAgICAgICAgdmFyIG1lc3NhZ2VPckxvZ0RhdGEgPSBtc2cubWVzc2FnZTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlT3JMb2dEYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhY3R1YWxTdHJpbmdNc2cgPSBtZXNzYWdlT3JMb2dEYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxvZ0RhdGEgPSBtZXNzYWdlT3JMb2dEYXRhO1xuICAgICAgICAgICAgYWN0dWFsU3RyaW5nTXNnID0gbG9nRGF0YS5tc2c7XG4gICAgICAgICAgICAvLyBXZSBkbyBoYXZlIGRhdGE/XG4gICAgICAgICAgICBpZiAobG9nRGF0YS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YVN0cmluZyA9IFwiIFtkYXRhXTogXCIgKyAobG9nRGF0YS5kcyA/IGxvZ0RhdGEuZHMobG9nRGF0YS5kYXRhKSA6IEpTT04uc3RyaW5naWZ5KGxvZ0RhdGEuZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIiBcIiArIGFjdHVhbFN0cmluZ01zZyArIFwiXCIgKyBkYXRhU3RyaW5nO1xuICAgICAgICBpZiAoYWRkU3RhY2sgJiYgbXNnLmVycm9yQXNTdGFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCIgKyBtc2cuZXJyb3JBc1N0YWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGdpdmVuIGxvZzRqIGxvZyBtZXNzYWdlIGluIGRlZmF1bHQgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBtc2cgTWVzc2FnZSB0byBmb3JtYXRcbiAgICAgKiBAcGFyYW0gYWRkU3RhY2sgSWYgdHJ1ZSBhZGRzIHRoZSBzdGFjayB0byB0aGUgb3V0cHV0LCBvdGhlcndpc2Ugc2tpcHMgaXRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBGb3JtYXR0ZWQgbWVzc2FnZVxuICAgICAqL1xuICAgIE1lc3NhZ2VGb3JtYXRVdGlscy5yZW5kZXJEZWZhdWx0TG9nNGpNZXNzYWdlID0gZnVuY3Rpb24gKG1zZywgYWRkU3RhY2spIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IG1zZy5sb2dHcm91cFJ1bGUubG9nRm9ybWF0O1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKGZvcm1hdC5zaG93VGltZVN0YW1wKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckRhdGUobXNnLmRhdGUsIGZvcm1hdC5kYXRlRm9ybWF0KSArIFwiIFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWxbbXNnLmxldmVsXS50b1VwcGVyQ2FzZSgpICsgXCIgXCI7XG4gICAgICAgIGlmIChmb3JtYXQuc2hvd0xvZ2dlck5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIltcIiArIG1zZy5sb2dnZXJOYW1lICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBub3JtYWwgc3RyaW5nIG1lc3NhZ2UgZmlyc3RcbiAgICAgICAgdmFyIGFjdHVhbFN0cmluZ01zZyA9IFwiXCI7XG4gICAgICAgIHZhciBkYXRhU3RyaW5nID0gXCJcIjtcbiAgICAgICAgaWYgKHR5cGVvZiBtc2cubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWN0dWFsU3RyaW5nTXNnID0gbXNnLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbG9nRGF0YSA9IG1zZy5tZXNzYWdlO1xuICAgICAgICAgICAgYWN0dWFsU3RyaW5nTXNnID0gbG9nRGF0YS5tc2c7XG4gICAgICAgICAgICAvLyBXZSBkbyBoYXZlIGRhdGE/XG4gICAgICAgICAgICBpZiAobG9nRGF0YS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YVN0cmluZyA9IFwiIFtkYXRhXTogXCIgKyAobG9nRGF0YS5kcyA/IGxvZ0RhdGEuZHMobG9nRGF0YS5kYXRhKSA6IEpTT04uc3RyaW5naWZ5KGxvZ0RhdGEuZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIiBcIiArIGFjdHVhbFN0cmluZ01zZyArIFwiXCIgKyBkYXRhU3RyaW5nO1xuICAgICAgICBpZiAoYWRkU3RhY2sgJiYgbXNnLmVycm9yQXNTdGFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCIgKyBtc2cuZXJyb3JBc1N0YWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZXJyb3IgYXMgc3RhY2tcbiAgICAgKiBAcGFyYW0gZXJyb3IgUmV0dXJuIGVycm9yIGFzIFByb21pc2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fFByb21pc2V9IFByb21pc2UgZm9yIHN0YWNrXG4gICAgICovXG4gICAgTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBlcnJvci5uYW1lICsgXCI6IFwiICsgZXJyb3IubWVzc2FnZSArIFwiXFxuQFwiO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgb25lIGhhcyBhIHByb21pc2UgdG9vXG4gICAgICAgICAgICBTVC5mcm9tRXJyb3IoZXJyb3IsIHsgb2ZmbGluZTogdHJ1ZSB9KS50aGVuKGZ1bmN0aW9uIChmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tTdHIgPSAoZnJhbWVzLm1hcChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfSkpLmpvaW4oXCJcXG4gIFwiKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cIiArIHN0YWNrU3RyO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVzb2x2ZXMgb3VyIHJldHVybmVkIHByb21pc2VcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gXCJVbmV4cGVjdGVkIGVycm9yIG9iamVjdCB3YXMgcGFzc2VkIGluLiBcIjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJDb3VsZCBub3QgcmVzb2x2ZSBpdCwgc3RyaW5naWZpZWQgb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2Fubm90IHN0cmluZ2lmeSBjYW4gb25seSB0ZWxsIHNvbWV0aGluZyB3YXMgd3JvbmcuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIkNvdWxkIG5vdCByZXNvbHZlIGl0IG9yIHN0cmluZ2lmeSBpdC5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VGb3JtYXRVdGlscztcbn0oKSk7XG5leHBvcnRzLk1lc3NhZ2VGb3JtYXRVdGlscyA9IE1lc3NhZ2VGb3JtYXRVdGlscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc3NhZ2VVdGlscy5qcy5tYXAiLCIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLkNzc1NlbGVjdG9yR2VuZXJhdG9yPWUoKTp0LkNzc1NlbGVjdG9yR2VuZXJhdG9yPWUoKX0oc2VsZiwoZnVuY3Rpb24oKXtyZXR1cm4oKCk9Pnt2YXIgdD17NDI2Oih0LGUsbik9Pnt2YXIgcj1uKDUyOSk7ZnVuY3Rpb24gbyh0LGUsbil7QXJyYXkuaXNBcnJheSh0KT90LnB1c2goZSk6dFtuXT1lfXQuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZSxuLGksdT1bXTtpZihBcnJheS5pc0FycmF5KHQpKW49W10sZT10Lmxlbmd0aC0xO2Vsc2V7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fG51bGw9PT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RpbmcgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBidXQgYFwiKyhudWxsPT09dD9cIm51bGxcIjp0eXBlb2YgdCkrXCJgIHByb3ZpZGVkLlwiKTtuPXt9LGk9T2JqZWN0LmtleXModCksZT1pLmxlbmd0aC0xfXJldHVybiBmdW5jdGlvbiBuKGMscyl7dmFyIGwsYSxmLGQ7Zm9yKGE9aT9pW3NdOnMsQXJyYXkuaXNBcnJheSh0W2FdKXx8KHZvaWQgMD09PXRbYV0/dFthXT1bXTp0W2FdPVt0W2FdXSksbD0wO2w8dFthXS5sZW5ndGg7bCsrKW8oKGQ9YyxmPUFycmF5LmlzQXJyYXkoZCk/W10uY29uY2F0KGQpOnIoZCkpLHRbYV1bbF0sYSkscz49ZT91LnB1c2goZik6bihmLHMrMSl9KG4sMCksdX19LDUyOTp0PT57dC5leHBvcnRzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXt9LG49MDtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXt2YXIgcj1hcmd1bWVudHNbbl07Zm9yKHZhciBvIGluIHIpZS5jYWxsKHIsbykmJih0W29dPXJbb10pfXJldHVybiB0fTt2YXIgZT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5fX0sZT17fTtmdW5jdGlvbiBuKHIpe3ZhciBvPWVbcl07aWYodm9pZCAwIT09bylyZXR1cm4gby5leHBvcnRzO3ZhciBpPWVbcl09e2V4cG9ydHM6e319O3JldHVybiB0W3JdKGksaS5leHBvcnRzLG4pLGkuZXhwb3J0c31uLm49dD0+e3ZhciBlPXQmJnQuX19lc01vZHVsZT8oKT0+dC5kZWZhdWx0OigpPT50O3JldHVybiBuLmQoZSx7YTplfSksZX0sbi5kPSh0LGUpPT57Zm9yKHZhciByIGluIGUpbi5vKGUscikmJiFuLm8odCxyKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQscix7ZW51bWVyYWJsZTohMCxnZXQ6ZVtyXX0pfSxuLm89KHQsZSk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpLG4ucj10PT57XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX07dmFyIHI9e307cmV0dXJuKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bi5yKHIpLG4uZChyLHtkZWZhdWx0OigpPT5VLGdldENzc1NlbGVjdG9yOigpPT5IfSk7dmFyIHQsZSxvPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2w/XCJzeW1ib2xcIjp0eXBlb2YgdH07ZnVuY3Rpb24gaSh0KXtyZXR1cm4gbnVsbCE9dCYmXCJvYmplY3RcIj09PSh2b2lkIDA9PT10P1widW5kZWZpbmVkXCI6byh0KSkmJjE9PT10Lm5vZGVUeXBlJiZcIm9iamVjdFwiPT09byh0LnN0eWxlKSYmXCJvYmplY3RcIj09PW8odC5vd25lckRvY3VtZW50KX1mdW5jdGlvbiB1KHQ9XCJ1bmtub3duIHByb2JsZW1cIiwuLi5lKXtjb25zb2xlLndhcm4oYENzc1NlbGVjdG9yR2VuZXJhdG9yOiAke3R9YCwuLi5lKX0hZnVuY3Rpb24odCl7dC5OT05FPVwibm9uZVwiLHQuREVTQ0VOREFOVD1cImRlc2NlbmRhbnRcIix0LkNISUxEPVwiY2hpbGRcIn0odHx8KHQ9e30pKSxmdW5jdGlvbih0KXt0LmlkPVwiaWRcIix0LmNsYXNzPVwiY2xhc3NcIix0LnRhZz1cInRhZ1wiLHQuYXR0cmlidXRlPVwiYXR0cmlidXRlXCIsdC5udGhjaGlsZD1cIm50aGNoaWxkXCIsdC5udGhvZnR5cGU9XCJudGhvZnR5cGVcIn0oZXx8KGU9e30pKTtjb25zdCBjPXtzZWxlY3RvcnM6W2UuaWQsZS5jbGFzcyxlLnRhZyxlLmF0dHJpYnV0ZV0saW5jbHVkZVRhZzohMSx3aGl0ZWxpc3Q6W10sYmxhY2tsaXN0OltdLGNvbWJpbmVXaXRoaW5TZWxlY3RvcjohMCxjb21iaW5lQmV0d2VlblNlbGVjdG9yczohMCxyb290Om51bGwsbWF4Q29tYmluYXRpb25zOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSxtYXhDYW5kaWRhdGVzOk51bWJlci5QT1NJVElWRV9JTkZJTklUWX07ZnVuY3Rpb24gcyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFJlZ0V4cH1mdW5jdGlvbiBsKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fHxzKHQpfWZ1bmN0aW9uIGEodCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/dC5maWx0ZXIobCk6W119ZnVuY3Rpb24gZih0KXtjb25zdCBlPVtOb2RlLkRPQ1VNRU5UX05PREUsTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFLE5vZGUuRUxFTUVOVF9OT0RFXTtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBOb2RlfSh0KSYmZS5pbmNsdWRlcyh0Lm5vZGVUeXBlKX1mdW5jdGlvbiBkKHQsZSl7aWYoZih0KSlyZXR1cm4gdC5jb250YWlucyhlKXx8dShcImVsZW1lbnQgcm9vdCBtaXNtYXRjaFwiLFwiUHJvdmlkZWQgcm9vdCBkb2VzIG5vdCBjb250YWluIHRoZSBlbGVtZW50LiBUaGlzIHdpbGwgbW9zdCBsaWtlbHkgcmVzdWx0IGluIHByb2R1Y2luZyBhIGZhbGxiYWNrIHNlbGVjdG9yIHVzaW5nIGVsZW1lbnQncyByZWFsIHJvb3Qgbm9kZS4gSWYgeW91IHBsYW4gdG8gdXNlIHRoZSBzZWxlY3RvciB1c2luZyBwcm92aWRlZCByb290IChlLmcuIGByb290LnF1ZXJ5U2VsZWN0b3JgKSwgaXQgd2lsbCBudG8gd29yayBhcyBpbnRlbmRlZC5cIiksdDtjb25zdCBuPWUuZ2V0Um9vdE5vZGUoe2NvbXBvc2VkOiExfSk7cmV0dXJuIGYobik/KG4hPT1kb2N1bWVudCYmdShcInNoYWRvdyByb290IGluZmVycmVkXCIsXCJZb3UgZGlkIG5vdCBwcm92aWRlIGEgcm9vdCBhbmQgdGhlIGVsZW1lbnQgaXMgYSBjaGlsZCBvZiBTaGFkb3cgRE9NLiBUaGlzIHdpbGwgcHJvZHVjZSBhIHNlbGVjdG9yIHVzaW5nIFNoYWRvd1Jvb3QgYXMgYSByb290LiBJZiB5b3UgcGxhbiB0byB1c2UgdGhlIHNlbGVjdG9yIHVzaW5nIGRvY3VtZW50IGFzIGEgcm9vdCAoZS5nLiBgZG9jdW1lbnQucXVlcnlTZWxlY3RvcmApLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGludGVuZGVkLlwiKSxuKTplLm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIjpyb290XCIpfWZ1bmN0aW9uIHAodCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/dDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9ZnVuY3Rpb24gbSh0PVtdKXtjb25zdFtlPVtdLC4uLm5dPXQ7cmV0dXJuIDA9PT1uLmxlbmd0aD9lOm4ucmVkdWNlKCgodCxlKT0+dC5maWx0ZXIoKHQ9PmUuaW5jbHVkZXModCkpKSksZSl9ZnVuY3Rpb24geSh0KXtyZXR1cm5bXS5jb25jYXQoLi4udCl9ZnVuY3Rpb24gaCh0KXtjb25zdCBlPXQubWFwKCh0PT5zKHQpP3Q6bmV3IFJlZ0V4cChcIl5cIit0LnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrPy5dL2csXCJcXFxcJCZcIikucmVwbGFjZSgvXFwqL2csXCIuK1wiKStcIiRcIikpKTtyZXR1cm4gdD0+ZS5zb21lKChlPT5lLnRlc3QodCkpKX1mdW5jdGlvbiBnKHQsZSxuKXtjb25zdCByPUFycmF5LmZyb20oZChuLHRbMF0pLnF1ZXJ5U2VsZWN0b3JBbGwoZSkpO3JldHVybiByLmxlbmd0aD09PXQubGVuZ3RoJiZ0LmV2ZXJ5KCh0PT5yLmluY2x1ZGVzKHQpKSl9ZnVuY3Rpb24gYih0LGUpe3JldHVybiBlPW51bGwhPWU/ZTp0WzBdLm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIjpyb290XCIpLG0odC5tYXAoKHQ9PmZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj1bXTtsZXQgcj10O2Zvcig7aShyKSYmciE9PWU7KW4ucHVzaChyKSxyPXIucGFyZW50RWxlbWVudDtyZXR1cm4gbn0odCxlKSkpKX1mdW5jdGlvbiBTKHQpe2NvbnN0IGU9dC5wYXJlbnROb2RlO2lmKGUpe2NvbnN0IG49QXJyYXkuZnJvbShlLmNoaWxkTm9kZXMpLmZpbHRlcihpKS5pbmRleE9mKHQpO2lmKG4+LTEpcmV0dXJuW2A6bnRoLWNoaWxkKCR7bisxfSlgXX1yZXR1cm5bXX1mdW5jdGlvbiBOKHQpe3JldHVybiBtKHQubWFwKFMpKX1jb25zdCB2PSh0Lk5PTkUsdC5OT05FLHQuREVTQ0VOREFOVCx0LkRFU0NFTkRBTlQsdC5DSElMRCx0LkNISUxELG5ldyBSZWdFeHAoW1wiXiRcIixcIlxcXFxzXCIsXCJeXFxcXGRcIl0uam9pbihcInxcIikpKSx3PW5ldyBSZWdFeHAoW1wiXiRcIixcIl5cXFxcZFwiXS5qb2luKFwifFwiKSksRT1bZS5udGhvZnR5cGUsZS50YWcsZS5pZCxlLmNsYXNzLGUuYXR0cmlidXRlLGUubnRoY2hpbGRdO2Z1bmN0aW9uIHgodCl7cmV0dXJuW1wiOnJvb3RcIiwuLi5iKFt0XSkubWFwKCh0PT5OKFt0XSlbMF0pKS5yZXZlcnNlKCldLmpvaW4oXCIgPiBcIil9dmFyIEE9big0MjYpLEM9bi5uKEEpO2NvbnN0IE89aChbXCJjbGFzc1wiLFwiaWRcIixcIm5nLSpcIl0pO2Z1bmN0aW9uIFQoe25vZGVOYW1lOnR9KXtyZXR1cm5gWyR7dH1dYH1mdW5jdGlvbiBqKHtub2RlTmFtZTp0LG5vZGVWYWx1ZTplfSl7cmV0dXJuYFske3R9PScke1YoZSl9J11gfWZ1bmN0aW9uIEkoe25vZGVOYW1lOnR9KXtyZXR1cm4hTyh0KX1mdW5jdGlvbiBEKHQpe2NvbnN0IGU9QXJyYXkuZnJvbSh0LmF0dHJpYnV0ZXMpLmZpbHRlcihJKTtyZXR1cm5bLi4uZS5tYXAoVCksLi4uZS5tYXAoaildfWZ1bmN0aW9uICQodCl7cmV0dXJuKHQuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCIpLnRyaW0oKS5zcGxpdCgvXFxzKy8pLmZpbHRlcigodD0+IXcudGVzdCh0KSkpLm1hcCgodD0+YC4ke1YodCl9YCkpfWZ1bmN0aW9uIF8odCl7cmV0dXJuW1YodC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXX1mdW5jdGlvbiBrKHQpe2NvbnN0IGU9Wy4uLm5ldyBTZXQoeSh0Lm1hcChfKSkpXTtyZXR1cm4gMD09PWUubGVuZ3RofHxlLmxlbmd0aD4xP1tdOltlWzBdXX1mdW5jdGlvbiBSKHQpe2NvbnN0IGU9ayhbdF0pWzBdLG49dC5wYXJlbnRFbGVtZW50O2lmKG4pe2NvbnN0IHI9QXJyYXkuZnJvbShuLmNoaWxkcmVuKS5maWx0ZXIoKHQ9PnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT09ZSkpLmluZGV4T2YodCk7aWYocj4tMSlyZXR1cm5bYCR7ZX06bnRoLW9mLXR5cGUoJHtyKzF9KWBdfXJldHVybltdfWZ1bmN0aW9uIFAodD1bXSx7bWF4UmVzdWx0czplPU51bWJlci5QT1NJVElWRV9JTkZJTklUWX09e30pe2NvbnN0IG49W107bGV0IHI9MCxvPUwoMSk7Zm9yKDtvLmxlbmd0aDw9dC5sZW5ndGgmJnI8ZTspcis9MSxuLnB1c2goby5tYXAoKGU9PnRbZV0pKSksbz1NKG8sdC5sZW5ndGgtMSk7cmV0dXJuIG59ZnVuY3Rpb24gTSh0PVtdLGU9MCl7Y29uc3Qgbj10Lmxlbmd0aDtpZigwPT09bilyZXR1cm5bXTtjb25zdCByPVsuLi50XTtyW24tMV0rPTE7Zm9yKGxldCB0PW4tMTt0Pj0wO3QtLSlpZihyW3RdPmUpe2lmKDA9PT10KXJldHVybiBMKG4rMSk7clt0LTFdKyssclt0XT1yW3QtMV0rMX1yZXR1cm4gcltuLTFdPmU/TChuKzEpOnJ9ZnVuY3Rpb24gTCh0PTEpe3JldHVybiBBcnJheS5mcm9tKEFycmF5KHQpLmtleXMoKSl9Y29uc3QgcT1cIjpcIi5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLEY9L1sgIVwiIyQlJicoKVxcW1xcXXt8fTw+KissLi87PT9AXmB+XFxcXF0vO2Z1bmN0aW9uIFYodD1cIlwiKXt2YXIgZSxuO3JldHVybiBudWxsIT09KG49bnVsbD09PShlPW51bGw9PT1DU1N8fHZvaWQgMD09PUNTUz92b2lkIDA6Q1NTLmVzY2FwZSl8fHZvaWQgMD09PWU/dm9pZCAwOmUuY2FsbChDU1MsdCkpJiZ2b2lkIDAhPT1uP246ZnVuY3Rpb24odD1cIlwiKXtyZXR1cm4gdC5zcGxpdChcIlwiKS5tYXAoKHQ9PlwiOlwiPT09dD9gXFxcXCR7cX0gYDpGLnRlc3QodCk/YFxcXFwke3R9YDplc2NhcGUodCkucmVwbGFjZSgvJS9nLFwiXFxcXFwiKSkpLmpvaW4oXCJcIil9KHQpfWNvbnN0IFk9e3RhZzprLGlkOmZ1bmN0aW9uKHQpe3JldHVybiAwPT09dC5sZW5ndGh8fHQubGVuZ3RoPjE/W106ZnVuY3Rpb24odCl7Y29uc3QgZT10LmdldEF0dHJpYnV0ZShcImlkXCIpfHxcIlwiLG49YCMke1YoZSl9YCxyPXQuZ2V0Um9vdE5vZGUoe2NvbXBvc2VkOiExfSk7cmV0dXJuIXYudGVzdChlKSYmZyhbdF0sbixyKT9bbl06W119KHRbMF0pfSxjbGFzczpmdW5jdGlvbih0KXtyZXR1cm4gbSh0Lm1hcCgkKSl9LGF0dHJpYnV0ZTpmdW5jdGlvbih0KXtyZXR1cm4gbSh0Lm1hcChEKSl9LG50aGNoaWxkOk4sbnRob2Z0eXBlOmZ1bmN0aW9uKHQpe3JldHVybiBtKHQubWFwKFIpKX19O2Z1bmN0aW9uIEIodCl7cmV0dXJuIHQuaW5jbHVkZXMoZS50YWcpfHx0LmluY2x1ZGVzKGUubnRob2Z0eXBlKT9bLi4udF06Wy4uLnQsZS50YWddfWZ1bmN0aW9uIEcodD17fSl7Y29uc3Qgbj1bLi4uRV07cmV0dXJuIHRbZS50YWddJiZ0W2UubnRob2Z0eXBlXSYmbi5zcGxpY2Uobi5pbmRleE9mKGUudGFnKSwxKSxuLm1hcCgoZT0+e3JldHVybihyPXQpW249ZV0/cltuXS5qb2luKFwiXCIpOlwiXCI7dmFyIG4scn0pKS5qb2luKFwiXCIpfWZ1bmN0aW9uIFcodCxlLG49XCJcIixyKXtjb25zdCBvPWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJcIj09PWU/dDpmdW5jdGlvbih0LGUpe3JldHVyblsuLi50Lm1hcCgodD0+ZStcIiBcIit0KSksLi4udC5tYXAoKHQ9PmUrXCIgPiBcIit0KSldfSh0LGUpfShmdW5jdGlvbih0LGUsbil7Y29uc3Qgcj15KGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2NvbnN0e3NlbGVjdG9yczplLGNvbWJpbmVCZXR3ZWVuU2VsZWN0b3JzOm4saW5jbHVkZVRhZzpyLG1heENhbmRpZGF0ZXM6b309dCxpPW4/UChlLHttYXhSZXN1bHRzOm99KTplLm1hcCgodD0+W3RdKSk7cmV0dXJuIHI/aS5tYXAoQik6aX0oZSkubWFwKChlPT5mdW5jdGlvbih0LGUpe2NvbnN0IG49e307cmV0dXJuIHQuZm9yRWFjaCgodD0+e2NvbnN0IHI9ZVt0XTtyLmxlbmd0aD4wJiYoblt0XT1yKX0pKSxDKCkobikubWFwKEcpfShlLHQpKSkuZmlsdGVyKCh0PT50Lmxlbmd0aD4wKSl9KGZ1bmN0aW9uKHQsZSl7Y29uc3R7YmxhY2tsaXN0Om4sd2hpdGVsaXN0OnIsY29tYmluZVdpdGhpblNlbGVjdG9yOm8sbWF4Q29tYmluYXRpb25zOml9PWUsdT1oKG4pLGM9aChyKTtyZXR1cm4gZnVuY3Rpb24odCl7Y29uc3R7c2VsZWN0b3JzOmUsaW5jbHVkZVRhZzpufT10LHI9W10uY29uY2F0KGUpO3JldHVybiBuJiYhci5pbmNsdWRlcyhcInRhZ1wiKSYmci5wdXNoKFwidGFnXCIpLHJ9KGUpLnJlZHVjZSgoKGUsbik9Pntjb25zdCByPWZ1bmN0aW9uKHQ9W10sZSl7cmV0dXJuIHQuc29ydCgoKHQsbik9Pntjb25zdCByPWUodCksbz1lKG4pO3JldHVybiByJiYhbz8tMTohciYmbz8xOjB9KSl9KGZ1bmN0aW9uKHQ9W10sZSxuKXtyZXR1cm4gdC5maWx0ZXIoKHQ9Pm4odCl8fCFlKHQpKSl9KGZ1bmN0aW9uKHQsZSl7dmFyIG47cmV0dXJuKG51bGwhPT0obj1ZW2VdKSYmdm9pZCAwIT09bj9uOigpPT5bXSkodCl9KHQsbiksdSxjKSxjKTtyZXR1cm4gZVtuXT1vP1Aocix7bWF4UmVzdWx0czppfSk6ci5tYXAoKHQ9Plt0XSkpLGV9KSx7fSl9KHQsbiksbikpO3JldHVyblsuLi5uZXcgU2V0KHIpXX0odCxyLnJvb3Qsciksbik7Zm9yKGNvbnN0IGUgb2YgbylpZihnKHQsZSxyLnJvb3QpKXJldHVybiBlO3JldHVybiBudWxsfWZ1bmN0aW9uIEgodCxuPXt9KXtjb25zdCByPWZ1bmN0aW9uKHQpe2NvbnN0IGU9KEFycmF5LmlzQXJyYXkodCk/dDpbdF0pLmZpbHRlcihpKTtyZXR1cm5bLi4ubmV3IFNldChlKV19KHQpLG89ZnVuY3Rpb24odCxuPXt9KXtjb25zdCByPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxjKSxuKTtyZXR1cm57c2VsZWN0b3JzOihvPXIuc2VsZWN0b3JzLEFycmF5LmlzQXJyYXkobyk/by5maWx0ZXIoKHQ9PntyZXR1cm4gbj1lLHI9dCxPYmplY3QudmFsdWVzKG4pLmluY2x1ZGVzKHIpO3ZhciBuLHJ9KSk6W10pLHdoaXRlbGlzdDphKHIud2hpdGVsaXN0KSxibGFja2xpc3Q6YShyLmJsYWNrbGlzdCkscm9vdDpkKHIucm9vdCx0KSxjb21iaW5lV2l0aGluU2VsZWN0b3I6ISFyLmNvbWJpbmVXaXRoaW5TZWxlY3Rvcixjb21iaW5lQmV0d2VlblNlbGVjdG9yczohIXIuY29tYmluZUJldHdlZW5TZWxlY3RvcnMsaW5jbHVkZVRhZzohIXIuaW5jbHVkZVRhZyxtYXhDb21iaW5hdGlvbnM6cChyLm1heENvbWJpbmF0aW9ucyksbWF4Q2FuZGlkYXRlczpwKHIubWF4Q2FuZGlkYXRlcyl9O3ZhciBvfShyWzBdLG4pO2xldCB1PVwiXCIscz1vLnJvb3Q7ZnVuY3Rpb24gbCgpe3JldHVybiBmdW5jdGlvbih0LGUsbj1cIlwiLHIpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gbnVsbDtjb25zdCBvPVt0Lmxlbmd0aD4xP3Q6W10sLi4uYih0LGUpLm1hcCgodD0+W3RdKSldO2Zvcihjb25zdCB0IG9mIG8pe2NvbnN0IGU9Vyh0LDAsbixyKTtpZihlKXJldHVybntmb3VuZEVsZW1lbnRzOnQsc2VsZWN0b3I6ZX19cmV0dXJuIG51bGx9KHIscyx1LG8pfWxldCBmPWwoKTtmb3IoO2Y7KXtjb25zdHtmb3VuZEVsZW1lbnRzOnQsc2VsZWN0b3I6ZX09ZjtpZihnKHIsZSxvLnJvb3QpKXJldHVybiBlO3M9dFswXSx1PWUsZj1sKCl9cmV0dXJuIHIubGVuZ3RoPjE/ci5tYXAoKHQ9PkgodCxvKSkpLmpvaW4oXCIsIFwiKTpmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXAoeCkuam9pbihcIiwgXCIpfShyKX1jb25zdCBVPUh9KSgpLHJ9KSgpfSkpOyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5kZXgudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=