/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-selector-generator/build/index.js":
/*!************************************************************!*\
  !*** ./node_modules/css-selector-generator/build/index.js ***!
  \************************************************************/
/***/ ((module) => {

!function(t,e){ true?module.exports=e():0}(self,(function(){return(()=>{var t={426:(t,e,n)=>{var r=n(529);function o(t,e,n){Array.isArray(t)?t.push(e):t[n]=e}t.exports=function(t){var e,n,i,u=[];if(Array.isArray(t))n=[],e=t.length-1;else{if("object"!=typeof t||null===t)throw new TypeError("Expecting an Array or an Object, but `"+(null===t?"null":typeof t)+"` provided.");n={},i=Object.keys(t),e=i.length-1}return function n(c,s){var a,l,f,p;for(l=i?i[s]:s,Array.isArray(t[l])||(void 0===t[l]?t[l]=[]:t[l]=[t[l]]),a=0;a<t[l].length;a++)o((p=c,f=Array.isArray(p)?[].concat(p):r(p)),t[l][a],l),s>=e?u.push(f):n(f,s+1)}(n,0),u}},529:t=>{t.exports=function(){for(var t={},n=0;n<arguments.length;n++){var r=arguments[n];for(var o in r)e.call(r,o)&&(t[o]=r[o])}return t};var e=Object.prototype.hasOwnProperty}},e={};function n(r){var o=e[r];if(void 0!==o)return o.exports;var i=e[r]={exports:{}};return t[r](i,i.exports,n),i.exports}n.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return n.d(e,{a:e}),e},n.d=(t,e)=>{for(var r in e)n.o(e,r)&&!n.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},n.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var r={};return(()=>{"use strict";n.r(r),n.d(r,{default:()=>W,getCssSelector:()=>B});var t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol?"symbol":typeof t};function e(e){return null!=e&&"object"===(void 0===e?"undefined":t(e))&&1===e.nodeType&&"object"===t(e.style)&&"object"===t(e.ownerDocument)}function o(t=[]){const[e=[],...n]=t;return 0===n.length?e:n.reduce(((t,e)=>t.filter((t=>e.includes(t)))),e)}function i(t=[]){if(0===t.length)return new RegExp(".^");const e=t.map((t=>"string"==typeof t?"^"+t.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".+")+"$":t.source)).join("|");return new RegExp(e)}function u(t,e,n=document){const r=Array.from(n.querySelectorAll(e));return r.length===t.length&&t.every((t=>r.includes(t)))}function c(t,n){return n=null!=n?n:t[0].ownerDocument.querySelector(":root"),o(t.map((t=>function(t,n){const r=[];let o=t;for(;e(o)&&o!==n;)r.push(o),o=o.parentElement;return r}(t,n))))}function s(t){const n=t.parentNode;if(n){const r=Array.from(n.childNodes).filter(e).indexOf(t);if(r>-1)return[`:nth-child(${r+1})`]}return[]}function a(t){return o(t.map(s))}const l=new RegExp(["^$","\\s","^\\d"].join("|")),f=new RegExp(["^$","^\\d"].join("|")),p=["id","class","tag","attribute","nthchild","nthoftype"],d=["nthoftype","tag","id","class","attribute","nthchild"];function m(t){return[":root",...c([t]).map((t=>a([t])[0])).reverse()].join(" > ")}const y={selectors:["id","class","tag","attribute"],includeTag:!1,whitelist:[],blacklist:[],combineWithinSelector:!0,combineBetweenSelectors:!0,root:document,maxCombinations:Number.POSITIVE_INFINITY,maxCandidates:Number.POSITIVE_INFINITY};function g(t){return"string"==typeof t||function(t){return t instanceof RegExp}(t)}function b(t){return Array.isArray(t)?t.filter(g):[]}function h(t,e){return function(t){const e=[Node.DOCUMENT_NODE,Node.DOCUMENT_FRAGMENT_NODE,Node.ELEMENT_NODE];return function(t){return t instanceof Node}(t)&&e.includes(t.nodeType)}(t)?t:e.ownerDocument.querySelector(":root")}function S(t){return"number"==typeof t?t:Number.POSITIVE_INFINITY}var v=n(426),x=n.n(v);const N=i(["class","id","ng-*"]);function A({nodeName:t}){return`[${t}]`}function j({nodeName:t,nodeValue:e}){return`[${t}='${R(e)}']`}function w({nodeName:t}){return!N.test(t)}function E(t){const e=Array.from(t.attributes).filter(w);return[...e.map(A),...e.map(j)]}function O(t){return(t.getAttribute("class")||"").trim().split(/\s+/).filter((t=>!f.test(t))).map((t=>`.${R(t)}`))}function T(t){const e=[...new Set(t.map((t=>R(t.tagName.toLowerCase()))))];return 0===e.length||e.length>1?[]:[e[0]]}function C(t){const e=T([t])[0],n=t.parentElement;if(n){const r=Array.from(n.children).filter((t=>t.tagName.toLowerCase()===e)).indexOf(t);if(r>-1)return[`${e}:nth-of-type(${r+1})`]}return[]}function I(t=[],{maxResults:e=Number.POSITIVE_INFINITY}={}){const n=[];let r=0,o=_(1);for(;o.length<=t.length&&r<e;)r+=1,n.push(o.map((e=>t[e]))),o=$(o,t.length-1);return n}function $(t=[],e=0){const n=t.length;if(0===n)return[];const r=[...t];r[n-1]+=1;for(let t=n-1;t>=0;t--)if(r[t]>e){if(0===t)return _(n+1);r[t-1]++,r[t]=r[t-1]+1}return r[n-1]>e?_(n+1):r}function _(t=1){return Array.from(Array(t).keys())}const D=":".charCodeAt(0).toString(16).toUpperCase(),P=/[ !"#$%&'()\[\]{|}<>*+,./;=?@^`~\\]/;function R(t=""){var e,n;return null!==(n=null===(e=null===CSS||void 0===CSS?void 0:CSS.escape)||void 0===e?void 0:e.call(CSS,t))&&void 0!==n?n:function(t=""){return t.split("").map((t=>":"===t?`\\${D} `:P.test(t)?`\\${t}`:escape(t).replace(/%/g,"\\"))).join("")}(t)}const M={tag:T,id:function(t){if(0===t.length||t.length>1)return[];const e=t[0],n=e.getAttribute("id")||"",r=`#${R(n)}`;return!l.test(n)&&u([e],r,e.ownerDocument)?[r]:[]},class:function(t){return o(t.map(O))},attribute:function(t){return o(t.map(E))},nthchild:a,nthoftype:function(t){return o(t.map(C))}};function k(t){return t.includes("tag")||t.includes("nthoftype")?[...t]:[...t,"tag"]}function F(t={}){const e=[...d];return t.tag&&t.nthoftype&&e.splice(e.indexOf("tag"),1),e.map((e=>{return(r=t)[n=e]?r[n].join(""):"";var n,r})).join("")}function V(t,e,n="",r){const o=function(t,e){return""===e?t:function(t,e){return[...t.map((t=>e+" "+t)),...t.map((t=>e+" > "+t))]}(t,e)}(function(t,e,n){const r=(o=function(t,e){return function(t){const{selectors:e,combineBetweenSelectors:n,includeTag:r,maxCandidates:o}=t,i=n?I(e,{maxResults:o}):e.map((t=>[t]));return r?i.map(k):i}(e).map((e=>function(t,e){const n={};return t.forEach((t=>{const r=e[t];r.length>0&&(n[t]=r)})),x()(n).map(F)}(e,t))).filter((t=>t.length>0))}(function(t,e){const{blacklist:n,whitelist:r,combineWithinSelector:o,maxCombinations:u}=e,c=i(n),s=i(r);return function(t){const{selectors:e,includeTag:n}=t,r=[].concat(e);return n&&!r.includes("tag")&&r.push("tag"),r}(e).reduce(((e,n)=>{const r=function(t=[],e){return t.sort(((t,n)=>{const r=e.test(t),o=e.test(n);return r&&!o?-1:!r&&o?1:0}))}(function(t=[],e,n){return t.filter((t=>n.test(t)||!e.test(t)))}(function(t,e){var n;return(null!==(n=M[e])&&void 0!==n?n:()=>[])(t)}(t,n),c,s),s);return e[n]=o?I(r,{maxResults:u}):r.map((t=>[t])),e}),{})}(t,n),n),[].concat(...o));var o;return[...new Set(r)]}(t,r.root,r),n);for(const e of o)if(u(t,e,r.root))return e;return null}function B(t,n={}){const r=function(t){const n=(Array.isArray(t)?t:[t]).filter(e);return[...new Set(n)]}(t),o=function(t,e={}){const n=Object.assign(Object.assign({},y),e);return{selectors:(r=n.selectors,Array.isArray(r)?r.filter((t=>p.includes(t))):[]),whitelist:b(n.whitelist),blacklist:b(n.blacklist),root:h(n.root,t),combineWithinSelector:!!n.combineWithinSelector,combineBetweenSelectors:!!n.combineBetweenSelectors,includeTag:!!n.includeTag,maxCombinations:S(n.maxCombinations),maxCandidates:S(n.maxCandidates)};var r}(r[0],n);let i="",s=o.root;function a(){return function(t,e,n="",r){if(0===t.length)return null;const o=[t.length>1?t:[],...c(t,e).map((t=>[t]))];for(const t of o){const e=V(t,0,n,r);if(e)return{foundElements:t,selector:e}}return null}(r,s,i,o)}let l=a();for(;l;){const{foundElements:t,selector:e}=l;if(u(r,e,o.root))return e;s=t[0],i=e,l=a()}return r.length>1?r.map((t=>B(t,o))).join(", "):function(t){return t.map(m).join(", ")}(r)}const W=B})(),r})()}));

/***/ }),

/***/ "./node_modules/error-stack-parser/error-stack-parser.js":
/*!***************************************************************!*\
  !*** ./node_modules/error-stack-parser/error-stack-parser.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function ErrorStackParser(StackFrame) {
    'use strict';

    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+\:\d+/;
    var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;

    function _map(array, fn, thisArg) {
        if (typeof Array.prototype.map === 'function') {
            return array.map(fn, thisArg);
        } else {
            var output = new Array(array.length);
            for (var i = 0; i < array.length; i++) {
                output[i] = fn.call(thisArg, array[i]);
            }
            return output;
        }
    }

    function _filter(array, fn, thisArg) {
        if (typeof Array.prototype.filter === 'function') {
            return array.filter(fn, thisArg);
        } else {
            var output = [];
            for (var i = 0; i < array.length; i++) {
                if (fn.call(thisArg, array[i])) {
                    output.push(array[i]);
                }
            }
            return output;
        }
    }

    function _indexOf(array, target) {
        if (typeof Array.prototype.indexOf === 'function') {
            return array.indexOf(target);
        } else {
            for (var i = 0; i < array.length; i++) {
                if (array[i] === target) {
                    return i;
                }
            }
            return -1;
        }
    }

    return {
        /**
         * Given an Error object, extract the most information from it.
         *
         * @param {Error} error object
         * @return {Array} of StackFrames
         */
        parse: function ErrorStackParser$$parse(error) {
            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
                return this.parseOpera(error);
            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
                return this.parseV8OrIE(error);
            } else if (error.stack) {
                return this.parseFFOrSafari(error);
            } else {
                throw new Error('Cannot parse given Error object');
            }
        },

        // Separate line and column numbers from a string of the form: (URI:Line:Column)
        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
            // Fail-fast but return locations like "(native)"
            if (urlLike.indexOf(':') === -1) {
                return [urlLike];
            }

            var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
            var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
            return [parts[1], parts[2] || undefined, parts[3] || undefined];
        },

        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
            var filtered = _filter(error.stack.split('\n'), function(line) {
                return !!line.match(CHROME_IE_STACK_REGEXP);
            }, this);

            return _map(filtered, function(line) {
                if (line.indexOf('(eval ') > -1) {
                    // Throw away eval information until we implement stacktrace.js/stackframe#8
                    line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
                }
                var tokens = line.replace(/^\s+/, '').replace(/\(eval code/g, '(').split(/\s+/).slice(1);
                var locationParts = this.extractLocation(tokens.pop());
                var functionName = tokens.join(' ') || undefined;
                var fileName = _indexOf(['eval', '<anonymous>'], locationParts[0]) > -1 ? undefined : locationParts[0];

                return new StackFrame(functionName, undefined, fileName, locationParts[1], locationParts[2], line);
            }, this);
        },

        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
            var filtered = _filter(error.stack.split('\n'), function(line) {
                return !line.match(SAFARI_NATIVE_CODE_REGEXP);
            }, this);

            return _map(filtered, function(line) {
                // Throw away eval information until we implement stacktrace.js/stackframe#8
                if (line.indexOf(' > eval') > -1) {
                    line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval\:\d+\:\d+/g, ':$1');
                }

                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
                    // Safari eval frames only have function names and nothing else
                    return new StackFrame(line);
                } else {
                    var tokens = line.split('@');
                    var locationParts = this.extractLocation(tokens.pop());
                    var functionName = tokens.join('@') || undefined;
                    return new StackFrame(functionName,
                        undefined,
                        locationParts[0],
                        locationParts[1],
                        locationParts[2],
                        line);
                }
            }, this);
        },

        parseOpera: function ErrorStackParser$$parseOpera(e) {
            if (!e.stacktrace || (e.message.indexOf('\n') > -1 &&
                e.message.split('\n').length > e.stacktrace.split('\n').length)) {
                return this.parseOpera9(e);
            } else if (!e.stack) {
                return this.parseOpera10(e);
            } else {
                return this.parseOpera11(e);
            }
        },

        parseOpera9: function ErrorStackParser$$parseOpera9(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n');
            var result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(new StackFrame(undefined, undefined, match[2], match[1], undefined, lines[i]));
                }
            }

            return result;
        },

        parseOpera10: function ErrorStackParser$$parseOpera10(e) {
            var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n');
            var result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(
                        new StackFrame(
                            match[3] || undefined,
                            undefined,
                            match[2],
                            match[1],
                            undefined,
                            lines[i]
                        )
                    );
                }
            }

            return result;
        },

        // Opera 10.65+ Error.stack very similar to FF/Safari
        parseOpera11: function ErrorStackParser$$parseOpera11(error) {
            var filtered = _filter(error.stack.split('\n'), function(line) {
                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
            }, this);

            return _map(filtered, function(line) {
                var tokens = line.split('@');
                var locationParts = this.extractLocation(tokens.pop());
                var functionCall = (tokens.shift() || '');
                var functionName = functionCall
                        .replace(/<anonymous function(: (\w+))?>/, '$2')
                        .replace(/\([^\)]*\)/g, '') || undefined;
                var argsRaw;
                if (functionCall.match(/\(([^\)]*)\)/)) {
                    argsRaw = functionCall.replace(/^[^\(]+\(([^\)]*)\)$/, '$1');
                }
                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?
                    undefined : argsRaw.split(',');
                return new StackFrame(
                    functionName,
                    args,
                    locationParts[0],
                    locationParts[1],
                    locationParts[2],
                    line);
            }, this);
        }
    };
}));



/***/ }),

/***/ "./node_modules/query-selector-shadow-dom/src/normalize.js":
/*!*****************************************************************!*\
  !*** ./node_modules/query-selector-shadow-dom/src/normalize.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "normalizeSelector": () => (/* binding */ normalizeSelector)
/* harmony export */ });
/* istanbul ignore file */


// normalize-selector-rev-02.js
/*
  author: kyle simpson (@getify)
  original source: https://gist.github.com/getify/9679380

  modified for tests by david kaye (@dfkaye)
  21 march 2014

  rev-02 incorporate kyle's changes 3/2/42014
*/

function normalizeSelector(sel) {
  // save unmatched text, if any
  function saveUnmatched() {
    if (unmatched) {
      // whitespace needed after combinator?
      if (tokens.length > 0 && /^[~+>]$/.test(tokens[tokens.length - 1])) {
        tokens.push(" ");
      }

      // save unmatched text
      tokens.push(unmatched);
    }
  }

  var tokens = [],
    match,
    unmatched,
    regex,
    state = [0],
    next_match_idx = 0,
    prev_match_idx,
    not_escaped_pattern = /(?:[^\\]|(?:^|[^\\])(?:\\\\)+)$/,
    whitespace_pattern = /^\s+$/,
    state_patterns = [
      /\s+|\/\*|["'>~+[(]/g, // general
      /\s+|\/\*|["'[\]()]/g, // [..] set
      /\s+|\/\*|["'[\]()]/g, // (..) set
      null, // string literal (placeholder)
      /\*\//g, // comment
    ];
  sel = sel.trim();

  // eslint-disable-next-line no-constant-condition
  while (true) {
    unmatched = "";

    regex = state_patterns[state[state.length - 1]];

    regex.lastIndex = next_match_idx;
    match = regex.exec(sel);

    // matched text to process?
    if (match) {
      prev_match_idx = next_match_idx;
      next_match_idx = regex.lastIndex;

      // collect the previous string chunk not matched before this token
      if (prev_match_idx < next_match_idx - match[0].length) {
        unmatched = sel.substring(
          prev_match_idx,
          next_match_idx - match[0].length
        );
      }

      // general, [ ] pair, ( ) pair?
      if (state[state.length - 1] < 3) {
        saveUnmatched();

        // starting a [ ] pair?
        if (match[0] === "[") {
          state.push(1);
        }
        // starting a ( ) pair?
        else if (match[0] === "(") {
          state.push(2);
        }
        // starting a string literal?
        else if (/^["']$/.test(match[0])) {
          state.push(3);
          state_patterns[3] = new RegExp(match[0], "g");
        }
        // starting a comment?
        else if (match[0] === "/*") {
          state.push(4);
        }
        // ending a [ ] or ( ) pair?
        else if (/^[\])]$/.test(match[0]) && state.length > 0) {
          state.pop();
        }
        // handling whitespace or a combinator?
        else if (/^(?:\s+|[~+>])$/.test(match[0])) {
          // need to insert whitespace before?
          if (
            tokens.length > 0 &&
            !whitespace_pattern.test(tokens[tokens.length - 1]) &&
            state[state.length - 1] === 0
          ) {
            // add normalized whitespace
            tokens.push(" ");
          }

          // case-insensitive attribute selector CSS L4
          if (
            state[state.length - 1] === 1 &&
            tokens.length === 5 &&
            tokens[2].charAt(tokens[2].length - 1) === "="
          ) {
            tokens[4] = " " + tokens[4];
          }

          // whitespace token we can skip?
          if (whitespace_pattern.test(match[0])) {
            continue;
          }
        }

        // save matched text
        tokens.push(match[0]);
      }
      // otherwise, string literal or comment
      else {
        // save unmatched text
        tokens[tokens.length - 1] += unmatched;

        // unescaped terminator to string literal or comment?
        if (not_escaped_pattern.test(tokens[tokens.length - 1])) {
          // comment terminator?
          if (state[state.length - 1] === 4) {
            // ok to drop comment?
            if (
              tokens.length < 2 ||
              whitespace_pattern.test(tokens[tokens.length - 2])
            ) {
              tokens.pop();
            }
            // otherwise, turn comment into whitespace
            else {
              tokens[tokens.length - 1] = " ";
            }

            // handled already
            match[0] = "";
          }

          state.pop();
        }

        // append matched text to existing token
        tokens[tokens.length - 1] += match[0];
      }
    }
    // otherwise, end of processing (no more matches)
    else {
      unmatched = sel.substr(next_match_idx);
      saveUnmatched();

      break;
    }
  }

  return tokens.join("").trim();
}


/***/ }),

/***/ "./node_modules/query-selector-shadow-dom/src/querySelectorDeep.js":
/*!*************************************************************************!*\
  !*** ./node_modules/query-selector-shadow-dom/src/querySelectorDeep.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "querySelectorAllDeep": () => (/* binding */ querySelectorAllDeep),
/* harmony export */   "querySelectorDeep": () => (/* binding */ querySelectorDeep),
/* harmony export */   "collectAllElementsDeep": () => (/* binding */ collectAllElementsDeep)
/* harmony export */ });
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normalize */ "./node_modules/query-selector-shadow-dom/src/normalize.js");
/**
 * @author Georgegriff@ (George Griffiths)
 * License Apache-2.0
 */



/**
* Finds first matching elements on the page that may be in a shadow root using a complex selector of n-depth
*
* Don't have to specify all shadow roots to button, tree is travered to find the correct element
*
* Example querySelectorAllDeep('downloads-item:nth-child(4) #remove');
*
* Example should work on chrome://downloads outputting the remove button inside of a download card component
*
* Example find first active download link element querySelectorDeep('#downloads-list .is-active a[href^="https://"]');
*
* Another example querySelectorAllDeep('#downloads-list div#title-area + a');
e.g.
*/
function querySelectorAllDeep(selector, root = document, allElements = null) {
    return _querySelectorDeep(selector, true, root, allElements);
}

function querySelectorDeep(selector, root = document, allElements = null) {
    return _querySelectorDeep(selector, false, root, allElements);
}

function _querySelectorDeep(selector, findMany, root, allElements = null) {
    selector = (0,_normalize__WEBPACK_IMPORTED_MODULE_0__.normalizeSelector)(selector);
    let lightElement = root.querySelector(selector);

    if (document.head.createShadowRoot || document.head.attachShadow) {
        // no need to do any special if selector matches something specific in light-dom
        if (!findMany && lightElement) {
            return lightElement;
        }

        // split on commas because those are a logical divide in the operation
        const selectionsToMake = splitByCharacterUnlessQuoted(selector, ',');

        return selectionsToMake.reduce((acc, minimalSelector) => {
            // if not finding many just reduce the first match
            if (!findMany && acc) {
                return acc;
            }
            // do best to support complex selectors and split the query
            const splitSelector = splitByCharacterUnlessQuoted(minimalSelector
                    //remove white space at start of selector
                    .replace(/^\s+/g, '')
                    .replace(/\s*([>+~]+)\s*/g, '$1'), ' ')
                    // filter out entry white selectors
                    .filter((entry) => !!entry)
                    // convert "a > b" to ["a", "b"]
                    .map((entry) => splitByCharacterUnlessQuoted(entry, '>'));

            const possibleElementsIndex = splitSelector.length - 1;
            const lastSplitPart = splitSelector[possibleElementsIndex][splitSelector[possibleElementsIndex].length - 1];
            const possibleElements = collectAllElementsDeep(lastSplitPart, root, allElements);
            const findElements = findMatchingElement(splitSelector, possibleElementsIndex, root);
            if (findMany) {
                acc = acc.concat(possibleElements.filter(findElements));
                return acc;
            } else {
                acc = possibleElements.find(findElements);
                return acc || null;
            }
        }, findMany ? [] : null);


    } else {
        if (!findMany) {
            return lightElement;
        } else {
            return root.querySelectorAll(selector);
        }
    }

}

function findMatchingElement(splitSelector, possibleElementsIndex, root) {
    return (element) => {
        let position = possibleElementsIndex;
        let parent = element;
        let foundElement = false;
        while (parent && !isDocumentNode(parent)) {
            let foundMatch = true;
            if (splitSelector[position].length === 1) {
                foundMatch = parent.matches(splitSelector[position]);
            } else {
                // selector is in the format "a > b"
                // make sure a few parents match in order
                const reversedParts = ([]).concat(splitSelector[position]).reverse();
                let newParent = parent;
                for (const part of reversedParts) {
                    if (!newParent || !newParent.matches(part)) {
                        foundMatch = false;
                        break;
                    }
                    newParent = findParentOrHost(newParent, root);
                }
            }

            if (foundMatch && position === 0) {
                foundElement = true;
                break;
            }
            if (foundMatch) {
                position--;
            }
            parent = findParentOrHost(parent, root);
        }
        return foundElement;
    };

}

function splitByCharacterUnlessQuoted(selector, character) {
    return selector.match(/\\?.|^$/g).reduce((p, c) => {
        if (c === '"' && !p.sQuote) {
            p.quote ^= 1;
            p.a[p.a.length - 1] += c;
        } else if (c === '\'' && !p.quote) {
            p.sQuote ^= 1;
            p.a[p.a.length - 1] += c;

        } else if (!p.quote && !p.sQuote && c === character) {
            p.a.push('');
        } else {
            p.a[p.a.length - 1] += c;
        }
        return p;
    }, { a: [''] }).a;
}

/**
 * Checks if the node is a document node or not.
 * @param {Node} node
 * @returns {node is Document | DocumentFragment}
 */
function isDocumentNode(node) {
    return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.DOCUMENT_NODE;
}

function findParentOrHost(element, root) {
    const parentNode = element.parentNode;
    return (parentNode && parentNode.host && parentNode.nodeType === 11) ? parentNode.host : parentNode === root ? null : parentNode;
}

/**
 * Finds all elements on the page, inclusive of those within shadow roots.
 * @param {string=} selector Simple selector to filter the elements by. e.g. 'a', 'div.main'
 * @return {!Array<string>} List of anchor hrefs.
 * @author ebidel@ (Eric Bidelman)
 * License Apache-2.0
 */
function collectAllElementsDeep(selector = null, root, cachedElements = null) {
    let allElements = [];

    if (cachedElements) {
        allElements = cachedElements;
    } else {
        const findAllElements = function(nodes) {
            for (let i = 0; i < nodes.length; i++) {
                const el = nodes[i];
                allElements.push(el);
                // If the element has a shadow root, dig deeper.
                if (el.shadowRoot) {
                    findAllElements(el.shadowRoot.querySelectorAll('*'));
                }
            }
        };
        if(root.shadowRoot) {
            findAllElements(root.shadowRoot.querySelectorAll('*'));
        }
        findAllElements(root.querySelectorAll('*'));
    }

    return selector ? allElements.filter(el => el.matches(selector)) : allElements;	}



/***/ }),

/***/ "./node_modules/source-map/lib/array-set.js":
/*!**************************************************!*\
  !*** ./node_modules/source-map/lib/array-set.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var has = Object.prototype.hasOwnProperty;

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = util.toSetString(aStr);
  var isDuplicate = has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    this._set[sStr] = idx;
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  var sStr = util.toSetString(aStr);
  return has.call(this._set, sStr);
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  var sStr = util.toSetString(aStr);
  if (has.call(this._set, sStr)) {
    return this._set[sStr];
  }
  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;


/***/ }),

/***/ "./node_modules/source-map/lib/base64-vlq.js":
/*!***************************************************!*\
  !*** ./node_modules/source-map/lib/base64-vlq.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(/*! ./base64 */ "./node_modules/source-map/lib/base64.js");

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),

/***/ "./node_modules/source-map/lib/base64.js":
/*!***********************************************!*\
  !*** ./node_modules/source-map/lib/base64.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),

/***/ "./node_modules/source-map/lib/binary-search.js":
/*!******************************************************!*\
  !*** ./node_modules/source-map/lib/binary-search.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};


/***/ }),

/***/ "./node_modules/source-map/lib/mapping-list.js":
/*!*****************************************************!*\
  !*** ./node_modules/source-map/lib/mapping-list.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;


/***/ }),

/***/ "./node_modules/source-map/lib/quick-sort.js":
/*!***************************************************!*\
  !*** ./node_modules/source-map/lib/quick-sort.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};


/***/ }),

/***/ "./node_modules/source-map/lib/source-map-consumer.js":
/*!************************************************************!*\
  !*** ./node_modules/source-map/lib/source-map-consumer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var binarySearch = __webpack_require__(/*! ./binary-search */ "./node_modules/source-map/lib/binary-search.js");
var ArraySet = (__webpack_require__(/*! ./array-set */ "./node_modules/source-map/lib/array-set.js").ArraySet);
var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/source-map/lib/base64-vlq.js");
var quickSort = (__webpack_require__(/*! ./quick-sort */ "./node_modules/source-map/lib/quick-sort.js").quickSort);

function SourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap)
    : new BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      if (source != null && sourceRoot != null) {
        source = util.join(sourceRoot, source);
      }
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util.relative(this.sourceRoot, needle.source);
    }
    if (!this._sources.has(needle.source)) {
      return [];
    }
    needle.source = this._sources.indexOf(needle.source);

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._sources.toArray().map(function (s) {
      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
    }, this);
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          if (this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    if (this.sourceRoot != null) {
      source = util.relative(this.sourceRoot, source);
    }
    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    source = this._sources.indexOf(source);

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        if (section.consumer.sourceRoot !== null) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);
        this._names.add(name);
        name = this._names.indexOf(name);

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ }),

/***/ "./node_modules/source-map/lib/source-map-generator.js":
/*!*************************************************************!*\
  !*** ./node_modules/source-map/lib/source-map-generator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "./node_modules/source-map/lib/base64-vlq.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");
var ArraySet = (__webpack_require__(/*! ./array-set */ "./node_modules/source-map/lib/array-set.js").ArraySet);
var MappingList = (__webpack_require__(/*! ./mapping-list */ "./node_modules/source-map/lib/mapping-list.js").MappingList);

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;


/***/ }),

/***/ "./node_modules/source-map/lib/source-node.js":
/*!****************************************************!*\
  !*** ./node_modules/source-map/lib/source-node.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = (__webpack_require__(/*! ./source-map-generator */ "./node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator);
var util = __webpack_require__(/*! ./util */ "./node_modules/source-map/lib/util.js");

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are removed from this array, by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var shiftNextLine = function() {
      var lineContents = remainingLines.shift();
      // The last line of a file might not have a newline.
      var newLine = remainingLines.shift() || "";
      return lineContents + newLine;
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[0];
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[0];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[0] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLines.length > 0) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;


/***/ }),

/***/ "./node_modules/source-map/lib/util.js":
/*!*********************************************!*\
  !*** ./node_modules/source-map/lib/util.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = mappingA.source - mappingB.source;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return mappingA.name - mappingB.name;
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


/***/ }),

/***/ "./node_modules/source-map/source-map.js":
/*!***********************************************!*\
  !*** ./node_modules/source-map/source-map.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ "./node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ "./node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer;
exports.SourceNode = __webpack_require__(/*! ./lib/source-node */ "./node_modules/source-map/lib/source-node.js").SourceNode;


/***/ }),

/***/ "./node_modules/stack-generator/node_modules/stackframe/stackframe.js":
/*!****************************************************************************!*\
  !*** ./node_modules/stack-generator/node_modules/stackframe/stackframe.js ***!
  \****************************************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function() {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.substring(1);
    }

    function _getter(p) {
        return function() {
            return this[p];
        };
    }

    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
    var numericProps = ['columnNumber', 'lineNumber'];
    var stringProps = ['fileName', 'functionName', 'source'];
    var arrayProps = ['args'];
    var objectProps = ['evalOrigin'];

    var props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);

    function StackFrame(obj) {
        if (!obj) return;
        for (var i = 0; i < props.length; i++) {
            if (obj[props[i]] !== undefined) {
                this['set' + _capitalize(props[i])](obj[props[i]]);
            }
        }
    }

    StackFrame.prototype = {
        getArgs: function() {
            return this.args;
        },
        setArgs: function(v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        getEvalOrigin: function() {
            return this.evalOrigin;
        },
        setEvalOrigin: function(v) {
            if (v instanceof StackFrame) {
                this.evalOrigin = v;
            } else if (v instanceof Object) {
                this.evalOrigin = new StackFrame(v);
            } else {
                throw new TypeError('Eval Origin must be an Object or StackFrame');
            }
        },

        toString: function() {
            var fileName = this.getFileName() || '';
            var lineNumber = this.getLineNumber() || '';
            var columnNumber = this.getColumnNumber() || '';
            var functionName = this.getFunctionName() || '';
            if (this.getIsEval()) {
                if (fileName) {
                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
                }
                return '[eval]:' + lineNumber + ':' + columnNumber;
            }
            if (functionName) {
                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
            }
            return fileName + ':' + lineNumber + ':' + columnNumber;
        }
    };

    StackFrame.fromString = function StackFrame$$fromString(str) {
        var argsStartIndex = str.indexOf('(');
        var argsEndIndex = str.lastIndexOf(')');

        var functionName = str.substring(0, argsStartIndex);
        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
        var locationString = str.substring(argsEndIndex + 1);

        if (locationString.indexOf('@') === 0) {
            var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
            var fileName = parts[1];
            var lineNumber = parts[2];
            var columnNumber = parts[3];
        }

        return new StackFrame({
            functionName: functionName,
            args: args || undefined,
            fileName: fileName,
            lineNumber: lineNumber || undefined,
            columnNumber: columnNumber || undefined
        });
    };

    for (var i = 0; i < booleanProps.length; i++) {
        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);
        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {
            return function(v) {
                this[p] = Boolean(v);
            };
        })(booleanProps[i]);
    }

    for (var j = 0; j < numericProps.length; j++) {
        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);
        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {
            return function(v) {
                if (!_isNumber(v)) {
                    throw new TypeError(p + ' must be a Number');
                }
                this[p] = Number(v);
            };
        })(numericProps[j]);
    }

    for (var k = 0; k < stringProps.length; k++) {
        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);
        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {
            return function(v) {
                this[p] = String(v);
            };
        })(stringProps[k]);
    }

    return StackFrame;
}));


/***/ }),

/***/ "./node_modules/stack-generator/stack-generator.js":
/*!*********************************************************!*\
  !*** ./node_modules/stack-generator/stack-generator.js ***!
  \*********************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! stackframe */ "./node_modules/stack-generator/node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function (StackFrame) {
    return {
        backtrace: function StackGenerator$$backtrace(opts) {
            var stack = [];
            var maxStackSize = 10;

            if (typeof opts === 'object' && typeof opts.maxStackSize === 'number') {
                maxStackSize = opts.maxStackSize;
            }

            var curr = arguments.callee;
            while (curr && stack.length < maxStackSize) {
                // Allow V8 optimizations
                var args = new Array(curr['arguments'].length);
                for(var i = 0; i < args.length; ++i) {
                    args[i] = curr['arguments'][i];
                }
                if (/function(?:\s+([\w$]+))+\s*\(/.test(curr.toString())) {
                    stack.push(new StackFrame({functionName: RegExp.$1 || undefined, args: args}));
                } else {
                    stack.push(new StackFrame({args: args}));
                }

                try {
                    curr = curr.caller;
                } catch (e) {
                    break;
                }
            }
            return stack;
        }
    };
}));


/***/ }),

/***/ "./node_modules/stackframe/stackframe.js":
/*!***********************************************!*\
  !*** ./node_modules/stackframe/stackframe.js ***!
  \***********************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    'use strict';
    function _isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    function StackFrame(functionName, args, fileName, lineNumber, columnNumber, source) {
        if (functionName !== undefined) {
            this.setFunctionName(functionName);
        }
        if (args !== undefined) {
            this.setArgs(args);
        }
        if (fileName !== undefined) {
            this.setFileName(fileName);
        }
        if (lineNumber !== undefined) {
            this.setLineNumber(lineNumber);
        }
        if (columnNumber !== undefined) {
            this.setColumnNumber(columnNumber);
        }
        if (source !== undefined) {
            this.setSource(source);
        }
    }

    StackFrame.prototype = {
        getFunctionName: function () {
            return this.functionName;
        },
        setFunctionName: function (v) {
            this.functionName = String(v);
        },

        getArgs: function () {
            return this.args;
        },
        setArgs: function (v) {
            if (Object.prototype.toString.call(v) !== '[object Array]') {
                throw new TypeError('Args must be an Array');
            }
            this.args = v;
        },

        // NOTE: Property name may be misleading as it includes the path,
        // but it somewhat mirrors V8's JavaScriptStackTraceApi
        // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi and Gecko's
        // http://mxr.mozilla.org/mozilla-central/source/xpcom/base/nsIException.idl#14
        getFileName: function () {
            return this.fileName;
        },
        setFileName: function (v) {
            this.fileName = String(v);
        },

        getLineNumber: function () {
            return this.lineNumber;
        },
        setLineNumber: function (v) {
            if (!_isNumber(v)) {
                throw new TypeError('Line Number must be a Number');
            }
            this.lineNumber = Number(v);
        },

        getColumnNumber: function () {
            return this.columnNumber;
        },
        setColumnNumber: function (v) {
            if (!_isNumber(v)) {
                throw new TypeError('Column Number must be a Number');
            }
            this.columnNumber = Number(v);
        },

        getSource: function () {
            return this.source;
        },
        setSource: function (v) {
            this.source = String(v);
        },

        toString: function() {
            var functionName = this.getFunctionName() || '{anonymous}';
            var args = '(' + (this.getArgs() || []).join(',') + ')';
            var fileName = this.getFileName() ? ('@' + this.getFileName()) : '';
            var lineNumber = _isNumber(this.getLineNumber()) ? (':' + this.getLineNumber()) : '';
            var columnNumber = _isNumber(this.getColumnNumber()) ? (':' + this.getColumnNumber()) : '';
            return functionName + args + fileName + lineNumber + columnNumber;
        }
    };

    return StackFrame;
}));


/***/ }),

/***/ "./node_modules/stacktrace-gps/stacktrace-gps.js":
/*!*******************************************************!*\
  !*** ./node_modules/stacktrace-gps/stacktrace-gps.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! source-map */ "./node_modules/source-map/source-map.js"), __webpack_require__(/*! stackframe */ "./node_modules/stackframe/stackframe.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function(SourceMap, StackFrame) {
    'use strict';

    /**
     * Make a X-Domain request to url and callback.
     *
     * @param {String} url
     * @returns {Promise} with response text if fulfilled
     */
    function _xdr(url) {
        return new Promise(function(resolve, reject) {
            var req = new XMLHttpRequest();
            req.open('get', url);
            req.onerror = reject;
            req.onreadystatechange = function onreadystatechange() {
                if (req.readyState === 4) {
                    if (req.status >= 200 && req.status < 300) {
                        resolve(req.responseText);
                    } else {
                        reject(new Error('HTTP status: ' + req.status + ' retrieving ' + url));
                    }
                }
            };
            req.send();
        });

    }

    /**
     * Convert a Base64-encoded string into its original representation.
     * Used for inline sourcemaps.
     *
     * @param {String} b64str Base-64 encoded string
     * @returns {String} original representation of the base64-encoded string.
     */
    function _atob(b64str) {
        if (typeof window !== 'undefined' && window.atob) {
            return window.atob(b64str);
        } else {
            throw new Error('You must supply a polyfill for window.atob in this environment');
        }
    }

    function _parseJson(string) {
        if (typeof JSON !== 'undefined' && JSON.parse) {
            return JSON.parse(string);
        } else {
            throw new Error('You must supply a polyfill for JSON.parse in this environment');
        }
    }

    function _findFunctionName(source, lineNumber/*, columnNumber*/) {
        // function {name}({args}) m[1]=name m[2]=args
        var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
        // {name} = function ({args}) TODO args capture
        var reFunctionExpression = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*function\b/;
        // {name} = eval()
        var reFunctionEvaluation = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
        var lines = source.split('\n');

        // Walk backwards in the source lines until we find the line which matches one of the patterns above
        var code = '';
        var maxLines = Math.min(lineNumber, 20);
        var m;
        for (var i = 0; i < maxLines; ++i) {
            // lineNo is 1-based, source[] is 0-based
            var line = lines[lineNumber - i - 1];
            var commentPos = line.indexOf('//');
            if (commentPos >= 0) {
                line = line.substr(0, commentPos);
            }

            if (line) {
                code = line + code;
                m = reFunctionExpression.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
                m = reFunctionDeclaration.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
                m = reFunctionEvaluation.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
            }
        }
        return undefined;
    }

    function _ensureSupportedEnvironment() {
        if (typeof Object.defineProperty !== 'function' || typeof Object.create !== 'function') {
            throw new Error('Unable to consume source maps in older browsers');
        }
    }

    function _ensureStackFrameIsLegit(stackframe) {
        if (typeof stackframe !== 'object') {
            throw new TypeError('Given StackFrame is not an object');
        } else if (typeof stackframe.fileName !== 'string') {
            throw new TypeError('Given file name is not a String');
        } else if (typeof stackframe.lineNumber !== 'number' ||
            stackframe.lineNumber % 1 !== 0 ||
            stackframe.lineNumber < 1) {
            throw new TypeError('Given line number must be a positive integer');
        } else if (typeof stackframe.columnNumber !== 'number' ||
            stackframe.columnNumber % 1 !== 0 ||
            stackframe.columnNumber < 0) {
            throw new TypeError('Given column number must be a non-negative integer');
        }
        return true;
    }

    function _findSourceMappingURL(source) {
        var m = /\/\/[#@] ?sourceMappingURL=([^\s'"]+)\s*$/.exec(source);
        if (m && m[1]) {
            return m[1];
        } else {
            throw new Error('sourceMappingURL not found');
        }
    }

    function _extractLocationInfoFromSourceMap(stackframe, rawSourceMap, sourceCache) {
        return new Promise(function(resolve, reject) {
            var mapConsumer = new SourceMap.SourceMapConsumer(rawSourceMap);

            var loc = mapConsumer.originalPositionFor({
                line: stackframe.lineNumber,
                column: stackframe.columnNumber
            });

            if (loc.source) {
                var mappedSource = mapConsumer.sourceContentFor(loc.source);
                if (mappedSource) {
                    sourceCache[loc.source] = mappedSource;
                }
                resolve(
                    new StackFrame(
                        loc.name || stackframe.functionName,
                        stackframe.args,
                        loc.source,
                        loc.line,
                        loc.column));
            } else {
                reject(new Error('Could not get original source for given stackframe and source map'));
            }
        });
    }

    /**
     * @constructor
     * @param {Object} opts
     *      opts.sourceCache = {url: "Source String"} => preload source cache
     *      opts.offline = True to prevent network requests.
     *              Best effort without sources or source maps.
     *      opts.ajax = Promise returning function to make X-Domain requests
     */
    return function StackTraceGPS(opts) {
        if (!(this instanceof StackTraceGPS)) {
            return new StackTraceGPS(opts);
        }
        opts = opts || {};

        this.sourceCache = opts.sourceCache || {};

        this.ajax = opts.ajax || _xdr;

        this._atob = opts.atob || _atob;

        this._get = function _get(location) {
            return new Promise(function(resolve, reject) {
                var isDataUrl = location.substr(0, 5) === 'data:';
                if (this.sourceCache[location]) {
                    resolve(this.sourceCache[location]);
                } else if (opts.offline && !isDataUrl) {
                    reject(new Error('Cannot make network requests in offline mode'));
                } else {
                    if (isDataUrl) {
                        // data URLs can have parameters.
                        // see http://tools.ietf.org/html/rfc2397
                        var supportedEncodingRegexp =
                            /^data:application\/json;([\w=:"-]+;)*base64,/;
                        var match = location.match(supportedEncodingRegexp);
                        if (match) {
                            var sourceMapStart = match[0].length;
                            var encodedSource = location.substr(sourceMapStart);
                            var source = this._atob(encodedSource);
                            this.sourceCache[location] = source;
                            resolve(source);
                        } else {
                            reject(new Error('The encoding of the inline sourcemap is not supported'));
                        }
                    } else {
                        var xhrPromise = this.ajax(location, {method: 'get'});
                        // Cache the Promise to prevent duplicate in-flight requests
                        this.sourceCache[location] = xhrPromise;
                        xhrPromise.then(resolve, reject);
                    }
                }
            }.bind(this));
        };

        /**
         * Given a StackFrame, enhance function name and use source maps for a
         * better StackFrame.
         *
         * @param {StackFrame} stackframe object
         * @returns {Promise} that resolves with with source-mapped StackFrame
         */
        this.pinpoint = function StackTraceGPS$$pinpoint(stackframe) {
            return new Promise(function(resolve, reject) {
                this.getMappedLocation(stackframe).then(function(mappedStackFrame) {
                    function resolveMappedStackFrame() {
                        resolve(mappedStackFrame);
                    }

                    this.findFunctionName(mappedStackFrame)
                        .then(resolve, resolveMappedStackFrame)
                        ['catch'](resolveMappedStackFrame);
                }.bind(this), reject);
            }.bind(this));
        };

        /**
         * Given a StackFrame, guess function name from location information.
         *
         * @param {StackFrame} stackframe
         * @returns {Promise} that resolves with enhanced StackFrame.
         */
        this.findFunctionName = function StackTraceGPS$$findFunctionName(stackframe) {
            return new Promise(function(resolve, reject) {
                _ensureStackFrameIsLegit(stackframe);
                this._get(stackframe.fileName).then(function getSourceCallback(source) {
                    var lineNumber = stackframe.lineNumber;
                    var columnNumber = stackframe.columnNumber;
                    var guessedFunctionName = _findFunctionName(source, lineNumber, columnNumber);
                    // Only replace functionName if we found something
                    if (guessedFunctionName) {
                        resolve(new StackFrame(guessedFunctionName,
                            stackframe.args,
                            stackframe.fileName,
                            lineNumber,
                            columnNumber));
                    } else {
                        resolve(stackframe);
                    }
                }, reject)['catch'](reject);
            }.bind(this));
        };

        /**
         * Given a StackFrame, seek source-mapped location and return new enhanced StackFrame.
         *
         * @param {StackFrame} stackframe
         * @returns {Promise} that resolves with enhanced StackFrame.
         */
        this.getMappedLocation = function StackTraceGPS$$getMappedLocation(stackframe) {
            return new Promise(function(resolve, reject) {
                _ensureSupportedEnvironment();
                _ensureStackFrameIsLegit(stackframe);

                var sourceCache = this.sourceCache;
                var fileName = stackframe.fileName;
                this._get(fileName).then(function(source) {
                    var sourceMappingURL = _findSourceMappingURL(source);
                    var isDataUrl = sourceMappingURL.substr(0, 5) === 'data:';
                    var base = fileName.substring(0, fileName.lastIndexOf('/') + 1);

                    if (sourceMappingURL[0] !== '/' && !isDataUrl && !(/^https?:\/\/|^\/\//i).test(sourceMappingURL)) {
                        sourceMappingURL = base + sourceMappingURL;
                    }

                    this._get(sourceMappingURL).then(function(sourceMap) {
                        if (typeof sourceMap === 'string') {
                            sourceMap = _parseJson(sourceMap.replace(/^\)\]\}'/, ''));
                        }
                        if (typeof sourceMap.sourceRoot === 'undefined') {
                            sourceMap.sourceRoot = base;
                        }

                        _extractLocationInfoFromSourceMap(stackframe, sourceMap, sourceCache)
                            .then(resolve)['catch'](function() {
                            resolve(stackframe);
                        });
                    }, reject)['catch'](reject);
                }.bind(this), reject)['catch'](reject);
            }.bind(this));
        };
    };
}));


/***/ }),

/***/ "./node_modules/stacktrace-js/stacktrace.js":
/*!**************************************************!*\
  !*** ./node_modules/stacktrace-js/stacktrace.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {
    'use strict';
    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

    /* istanbul ignore next */
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! error-stack-parser */ "./node_modules/error-stack-parser/error-stack-parser.js"), __webpack_require__(/*! stack-generator */ "./node_modules/stack-generator/stack-generator.js"), __webpack_require__(/*! stacktrace-gps */ "./node_modules/stacktrace-gps/stacktrace-gps.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function StackTrace(ErrorStackParser, StackGenerator, StackTraceGPS) {
    var _options = {
        filter: function(stackframe) {
            // Filter out stackframes for this library by default
            return (stackframe.functionName || '').indexOf('StackTrace$$') === -1 &&
                (stackframe.functionName || '').indexOf('ErrorStackParser$$') === -1 &&
                (stackframe.functionName || '').indexOf('StackTraceGPS$$') === -1 &&
                (stackframe.functionName || '').indexOf('StackGenerator$$') === -1;
        },
        sourceCache: {}
    };

    var _generateError = function StackTrace$$GenerateError() {
        try {
            // Error must be thrown to get stack in IE
            throw new Error();
        } catch (err) {
            return err;
        }
    };

    /**
     * Merge 2 given Objects. If a conflict occurs the second object wins.
     * Does not do deep merges.
     *
     * @param {Object} first base object
     * @param {Object} second overrides
     * @returns {Object} merged first and second
     * @private
     */
    function _merge(first, second) {
        var target = {};

        [first, second].forEach(function(obj) {
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    target[prop] = obj[prop];
                }
            }
            return target;
        });

        return target;
    }

    function _isShapedLikeParsableError(err) {
        return err.stack || err['opera#sourceloc'];
    }

    function _filtered(stackframes, filter) {
        if (typeof filter === 'function') {
            return stackframes.filter(filter);
        }
        return stackframes;
    }

    return {
        /**
         * Get a backtrace from invocation point.
         *
         * @param {Object} opts
         * @returns {Array} of StackFrame
         */
        get: function StackTrace$$get(opts) {
            var err = _generateError();
            return _isShapedLikeParsableError(err) ? this.fromError(err, opts) : this.generateArtificially(opts);
        },

        /**
         * Get a backtrace from invocation point.
         * IMPORTANT: Does not handle source maps or guess function names!
         *
         * @param {Object} opts
         * @returns {Array} of StackFrame
         */
        getSync: function StackTrace$$getSync(opts) {
            opts = _merge(_options, opts);
            var err = _generateError();
            var stack = _isShapedLikeParsableError(err) ? ErrorStackParser.parse(err) : StackGenerator.backtrace(opts);
            return _filtered(stack, opts.filter);
        },

        /**
         * Given an error object, parse it.
         *
         * @param {Error} error object
         * @param {Object} opts
         * @returns {Promise} for Array[StackFrame}
         */
        fromError: function StackTrace$$fromError(error, opts) {
            opts = _merge(_options, opts);
            var gps = new StackTraceGPS(opts);
            return new Promise(function(resolve) {
                var stackframes = _filtered(ErrorStackParser.parse(error), opts.filter);
                resolve(Promise.all(stackframes.map(function(sf) {
                    return new Promise(function(resolve) {
                        function resolveOriginal() {
                            resolve(sf);
                        }

                        gps.pinpoint(sf).then(resolve, resolveOriginal)['catch'](resolveOriginal);
                    });
                })));
            }.bind(this));
        },

        /**
         * Use StackGenerator to generate a backtrace.
         *
         * @param {Object} opts
         * @returns {Promise} of Array[StackFrame]
         */
        generateArtificially: function StackTrace$$generateArtificially(opts) {
            opts = _merge(_options, opts);
            var stackFrames = StackGenerator.backtrace(opts);
            if (typeof opts.filter === 'function') {
                stackFrames = stackFrames.filter(opts.filter);
            }
            return Promise.resolve(stackFrames);
        },

        /**
         * Given a function, wrap it such that invocations trigger a callback that
         * is called with a stack trace.
         *
         * @param {Function} fn to be instrumented
         * @param {Function} callback function to call with a stack trace on invocation
         * @param {Function} errback optional function to call with error if unable to get stack trace.
         * @param {Object} thisArg optional context object (e.g. window)
         */
        instrument: function StackTrace$$instrument(fn, callback, errback, thisArg) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot instrument non-function object');
            } else if (typeof fn.__stacktraceOriginalFn === 'function') {
                // Already instrumented, return given Function
                return fn;
            }

            var instrumented = function StackTrace$$instrumented() {
                try {
                    this.get().then(callback, errback)['catch'](errback);
                    return fn.apply(thisArg || this, arguments);
                } catch (e) {
                    if (_isShapedLikeParsableError(e)) {
                        this.fromError(e).then(callback, errback)['catch'](errback);
                    }
                    throw e;
                }
            }.bind(this);
            instrumented.__stacktraceOriginalFn = fn;

            return instrumented;
        },

        /**
         * Given a function that has been instrumented,
         * revert the function to it's original (non-instrumented) state.
         *
         * @param {Function} fn to de-instrument
         */
        deinstrument: function StackTrace$$deinstrument(fn) {
            if (typeof fn !== 'function') {
                throw new Error('Cannot de-instrument non-function object');
            } else if (typeof fn.__stacktraceOriginalFn === 'function') {
                return fn.__stacktraceOriginalFn;
            } else {
                // Function not instrumented, return original
                return fn;
            }
        },

        /**
         * Given an error message and Array of StackFrames, serialize and POST to given URL.
         *
         * @param {Array} stackframes
         * @param {String} url
         * @param {String} errorMsg
         */
        report: function StackTrace$$report(stackframes, url, errorMsg) {
            return new Promise(function(resolve, reject) {
                var req = new XMLHttpRequest();
                req.onerror = reject;
                req.onreadystatechange = function onreadystatechange() {
                    if (req.readyState === 4) {
                        if (req.status >= 200 && req.status < 400) {
                            resolve(req.responseText);
                        } else {
                            reject(new Error('POST to ' + url + ' failed with status: ' + req.status));
                        }
                    }
                };
                req.open('post', url);
                req.setRequestHeader('Content-Type', 'application/json');

                var reportPayload = {stack: stackframes};
                if (errorMsg !== undefined) {
                    reportPayload.message = errorMsg;
                }

                req.send(JSON.stringify(reportPayload));
            });
        }
    };
}));


/***/ }),

/***/ "./src/_infra/AifexServiceHTTP.ts":
/*!****************************************!*\
  !*** ./src/_infra/AifexServiceHTTP.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Website_1 = __importDefault(__webpack_require__(/*! ../domain/Website */ "./src/domain/Website.ts"));
const Session_1 = __importDefault(__webpack_require__(/*! ../domain/Session */ "./src/domain/Session.ts"));
const AifexPluginInfo_1 = __importDefault(__webpack_require__(/*! ../domain/AifexPluginInfo */ "./src/domain/AifexPluginInfo.ts"));
const OK_STATUS = 200;
const INVALID_PARAMETERS_STATUS = 400;
const FORBIDDEN_STATUS = 403;
const NOT_FOUND_STATUS = 404;
const INTERNAL_SERVER_ERROR_STATUS = 500;
class AifexServiceHTTP {
    ping(serverURL) {
        return fetch(`${serverURL}/api/ping`, {
            method: "GET",
            headers: { "Content-Type": "application/json" },
        })
            .then(response => {
            console.log(response);
            if (response.ok) {
                console.log('ok');
                return;
            }
            else {
                console.log('error');
                throw new Error(response.statusText);
            }
        });
    }
    getPluginInfo(serverURL) {
        const option = {
            method: "GET",
            headers: { "Content-Type": "application/json" },
        };
        return fetch(`${serverURL}/api/plugin-info`, option)
            .then(response => {
            if (!response.ok) {
                throw new Error(response.statusText);
            }
            return response.json();
        })
            .then(details => {
            details.url = `${serverURL}/download`;
            return new AifexPluginInfo_1.default(details.version, details.name, details.description, details.url);
        });
    }
    getSession(serverURL, sessionId, token) {
        const SESSION_URL = serverURL + '/api/sessions/' + sessionId;
        return fetch(SESSION_URL, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json', "Authorization": `Bearer ${token === null || token === void 0 ? void 0 : token.token}` },
        })
            .then((response) => {
            if (response.status === OK_STATUS) {
                return response
                    .json()
                    .then((session) => {
                    return new Session_1.default(session.id, session.webSite.id, session.baseURL, session.name, session.description, session.overlayType, session.recordingMode);
                });
            }
            if (response.status === INVALID_PARAMETERS_STATUS) {
                return undefined;
            }
            if (response.status === NOT_FOUND_STATUS) {
                return undefined;
            }
            if (response.status === FORBIDDEN_STATUS) {
                return "Unauthorized";
            }
            if (response.status === INTERNAL_SERVER_ERROR_STATUS) {
                return Promise.reject(`server error`);
            }
        });
    }
    getWebSite(serverURL, webSiteId, token) {
        return fetch(`${serverURL}/api/websites/${webSiteId}`, {
            method: 'GET',
            headers: { 'Content-Type': 'application/json', "Authorization": `Bearer ${token === null || token === void 0 ? void 0 : token.token}` },
        })
            .then((response) => {
            if (response.status === OK_STATUS) {
                return response
                    .json()
                    .then(websiteData => {
                    return new Website_1.default(websiteData.id, websiteData.name, websiteData.mappingList);
                });
            }
            if (response.status === INVALID_PARAMETERS_STATUS) {
                return Promise.reject(`sessionId is malformed`);
            }
            if (response.status === NOT_FOUND_STATUS) {
                return;
            }
            if (response.status === INTERNAL_SERVER_ERROR_STATUS) {
                return Promise.reject(`server error`);
            }
        });
    }
    createEmptyExploration(testerName, serverURL, sessionId) {
        const body = {
            testerName,
            interactionList: [],
        };
        const option = {
            method: "POST",
            body: JSON.stringify(body),
            headers: { "Content-Type": "application/json" },
        };
        return fetch(`${serverURL}/api/sessions/${sessionId}/explorations`, option)
            .then((response) => {
            if (response.status === OK_STATUS) {
                return response.json().then(data => {
                    return data.explorationNumber;
                });
            }
            if (response.status === NOT_FOUND_STATUS) {
                return Promise.reject(new Error(`no session not found for Id`));
            }
            if (response.status === INVALID_PARAMETERS_STATUS) {
                return Promise.reject(new Error(`sessionId and/or exploration is malformed`));
            }
            if (response.status === INTERNAL_SERVER_ERROR_STATUS) {
                return Promise.reject(new Error(`server error`));
            }
        });
    }
    sendAction(explorationNumber, action, serverURL, sessionId) {
        const body = {
            interactionList: [{
                    concreteType: action.getConcreteType(),
                    kind: action.prefix,
                    value: action.suffix,
                    date: action.date
                }]
        };
        const option = {
            method: "POST",
            body: JSON.stringify(body),
            headers: { "Content-Type": "application/json" },
        };
        return fetch(`${serverURL}/api/sessions/${sessionId}/explorations/${explorationNumber}/interactions`, option)
            .then((response) => {
            if (response.status === OK_STATUS) {
                return;
            }
            if (response.status === NOT_FOUND_STATUS) {
                return Promise.reject(new Error(`sessionId not found`));
            }
            if (response.status === INVALID_PARAMETERS_STATUS) {
                return Promise.reject(new Error(`sessionId and/or exploration is malformed`));
            }
            if (response.status === INTERNAL_SERVER_ERROR_STATUS) {
                return Promise.reject(new Error(`server error`));
            }
        }).catch(error => {
            console.error(error);
            throw new Error("Service Failed to push new action");
        });
    }
}
exports["default"] = AifexServiceHTTP;


/***/ }),

/***/ "./src/_infra/BrowserServiceSessionStorage.ts":
/*!****************************************************!*\
  !*** ./src/_infra/BrowserServiceSessionStorage.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
const EXPLORATION_NUMBER_KEY = 'EXPLORATION_NUMBER_KEY';
class BrowserServiceSessionStorage {
    getExplorationNumber() {
        Logger_1.logger.debug("BrowserServiceSessionStorage.getExplorationNumber");
        const explorationNumberItem = sessionStorage.getItem(EXPLORATION_NUMBER_KEY);
        if (explorationNumberItem) {
            const parsedNumber = parseInt(explorationNumberItem);
            if (isNaN(parsedNumber)) {
                Logger_1.logger.debug("BrowserServiceSessionStorage.getExplorationNumber: NaN");
                return undefined;
            }
            else {
                Logger_1.logger.debug("BrowserServiceSessionStorage.getExplorationNumber: " + parsedNumber);
                return parsedNumber;
            }
        }
        Logger_1.logger.debug("BrowserServiceSessionStorage.getExplorationNumber: undefined");
    }
    saveExplorationNumber(explorationNumber) {
        Logger_1.logger.debug("BrowserServiceSessionStorage.saveExplorationNumber: " + explorationNumber);
        sessionStorage.setItem(EXPLORATION_NUMBER_KEY, explorationNumber.toString());
    }
}
exports["default"] = BrowserServiceSessionStorage;


/***/ }),

/***/ "./src/domain/Action.ts":
/*!******************************!*\
  !*** ./src/domain/Action.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Action {
    constructor(prefix, suffix, ruleList = [], htmlElementList = []) {
        this.prefix = prefix;
        this.suffix = suffix;
        this.ruleList = ruleList;
        this.htmlElementList = htmlElementList;
        this.date = new Date();
    }
    setRuleList(ruleList) {
        this.ruleList = ruleList;
    }
    getConcreteType() {
        return "Action";
    }
    toString() {
        if (this.suffix) {
            return `${this.prefix}$${this.suffix}`;
        }
        else {
            return this.prefix;
        }
    }
    equals(action) {
        return ((this.prefix === action.prefix) && (this.suffix === action.suffix));
    }
    static parseAction(actionText) {
        const parts = actionText.split("$");
        if (parts.length === 1) {
            return new Action(parts[0]);
        }
        else if (parts.length === 2) {
            return new Action(parts[0], parts[1]);
        }
        else {
            throw new Error("Failed to parse action : " + actionText);
        }
    }
}
exports["default"] = Action;


/***/ }),

/***/ "./src/domain/AifexPluginInfo.ts":
/*!***************************************!*\
  !*** ./src/domain/AifexPluginInfo.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class AifexPluginInfo {
    constructor(version, name, description, url) {
        this.version = version;
        this.name = name;
        this.description = description;
        this.url = url;
    }
}
exports["default"] = AifexPluginInfo;


/***/ }),

/***/ "./src/domain/AttributeValueRule.ts":
/*!******************************************!*\
  !*** ./src/domain/AttributeValueRule.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
class AttributeValueRule extends SimpleRule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description, attributeName) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
        this.attributeName = attributeName;
    }
    makeAction(event) {
        const element = this.findActionMappedTarget(event);
        if (element !== undefined) {
            let attributeValue = element.getAttribute(this.attributeName);
            if (attributeValue) {
                return new Action_1.default(this.prefix, attributeValue);
            }
        }
        return new Action_1.default(this.prefix);
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix === undefined) {
            return super.actionToElements(action);
        }
        else {
            let suffix = action.suffix;
            const elements = this.findMatchedElements();
            return elements.filter(domElement => {
                if (domElement instanceof HTMLElement) {
                    return domElement.getAttribute(this.attributeName) === suffix;
                }
                else {
                    return false;
                }
            });
        }
    }
}
exports["default"] = AttributeValueRule;


/***/ }),

/***/ "./src/domain/BrowserScript.ts":
/*!*************************************!*\
  !*** ./src/domain/BrowserScript.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const ClassMutationHandler_1 = __importDefault(__webpack_require__(/*! ./ClassMutationHandler */ "./src/domain/ClassMutationHandler.ts"));
const EventListener_1 = __importDefault(__webpack_require__(/*! ./EventListener */ "./src/domain/EventListener.ts"));
const PageMutationHandler_1 = __importDefault(__webpack_require__(/*! ./PageMutationHandler */ "./src/domain/PageMutationHandler.ts"));
const RuleService_1 = __importDefault(__webpack_require__(/*! ./RuleService */ "./src/domain/RuleService.ts"));
class BrowserScript {
    constructor(serverURL, sessionId, token, aifexService, browserService) {
        this._serverURL = serverURL;
        this._sessionId = sessionId;
        this._token = token;
        this._aifexService = aifexService;
        this._browserService = browserService;
        this._ruleService = new RuleService_1.default();
        this._eventListener = new EventListener_1.default(this._ruleService);
        this._eventListener.addObserver(this.processNewAction.bind(this));
        new ClassMutationHandler_1.default();
        this._pageMutationHandler = new PageMutationHandler_1.default(this.onMutation.bind(this));
        this._pageMutationHandler.init();
    }
    start() {
        return this._aifexService.getSession(this._serverURL, this._sessionId, undefined)
            .then((sessionResult) => {
            if (sessionResult && sessionResult !== "Unauthorized") {
                this._webSiteId = sessionResult.webSiteId;
                this._aifexService.getWebSite(this._serverURL, this._webSiteId, undefined)
                    .then((webSiteResult) => {
                    if (webSiteResult && webSiteResult !== 'Unauthorized') {
                        const rules = webSiteResult.mappingList.map((ru) => this._ruleService.createRule(ru));
                        this._ruleService.loadRules(rules);
                        this._ruleService.mapRulesToElements();
                        Logger_1.logger.debug(`Rules loaded : ${rules.length}`);
                        this._eventListener.start();
                    }
                })
                    .then(() => {
                    const currentExplorationNumber = this._browserService.getExplorationNumber();
                    if (currentExplorationNumber !== undefined) {
                        this._explorationNumber = currentExplorationNumber;
                    }
                    else {
                        this._aifexService.createEmptyExploration("BROWSER_SCRIPT", this._serverURL, this._sessionId)
                            .then((explorationNumber) => {
                            this._explorationNumber = explorationNumber;
                            this._browserService.saveExplorationNumber(this._explorationNumber);
                        })
                            .then(() => {
                            this.processNewAction(new Action_1.default("start", undefined));
                        });
                    }
                });
            }
        });
    }
    processNewAction(action) {
        if (this._explorationNumber === undefined) {
            throw new Error("The exploration has not been correctly started");
        }
        this._aifexService.sendAction(this._explorationNumber, action, this._serverURL, this._sessionId);
    }
    onMutation() {
        this._ruleService.mapRulesToElements();
    }
}
exports["default"] = BrowserScript;


/***/ }),

/***/ "./src/domain/CSSContextMapper.ts":
/*!****************************************!*\
  !*** ./src/domain/CSSContextMapper.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ContextMapper_1 = __importDefault(__webpack_require__(/*! ./ContextMapper */ "./src/domain/ContextMapper.ts"));
class CSSContextMapper extends ContextMapper_1.default {
    constructor(context) {
        super(context);
    }
    buildElementToRuleMap() {
        if (this._context) {
            const cssQueryResult = document.querySelector(this._context);
            if (cssQueryResult && cssQueryResult instanceof HTMLElement) {
                return this.buildElementToRuleMapForSelectors(cssQueryResult);
            }
            else {
                return new Map();
            }
        }
        else {
            return new Map();
        }
    }
}
exports["default"] = CSSContextMapper;


/***/ }),

/***/ "./src/domain/CSSSelectorRule.ts":
/*!***************************************!*\
  !*** ./src/domain/CSSSelectorRule.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const Rule_1 = __importDefault(__webpack_require__(/*! ./Rule */ "./src/domain/Rule.ts"));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
const css_selector_generator_1 = __importDefault(__webpack_require__(/*! css-selector-generator */ "./node_modules/css-selector-generator/build/index.js"));
class CSSSelectorRule extends Rule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        if (event.target) {
            let suffix;
            try {
                suffix = (0, css_selector_generator_1.default)(event.target, { selectors: ['id', 'tag'] });
            }
            catch (e) {
                Logger_1.logger.error(`exception`, new Error('css exception'));
            }
            return new Action_1.default(this.prefix, suffix);
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix) {
            const elements = [];
            const parentElements = this.findMatchedElements();
            document.querySelectorAll(action.suffix).forEach((element) => {
                if (parentElements.some((parent) => parent.contains(element))) {
                    if (element instanceof HTMLElement || element instanceof SVGElement) {
                        elements.push(element);
                    }
                }
            });
            return elements;
        }
        else {
            return [];
        }
    }
}
exports["default"] = CSSSelectorRule;


/***/ }),

/***/ "./src/domain/CSSSelectorWithValueRule.ts":
/*!************************************************!*\
  !*** ./src/domain/CSSSelectorWithValueRule.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const Rule_1 = __importDefault(__webpack_require__(/*! ./Rule */ "./src/domain/Rule.ts"));
const css_selector_generator_1 = __importDefault(__webpack_require__(/*! css-selector-generator */ "./node_modules/css-selector-generator/build/index.js"));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class CSSSelectorWithValueRule extends Rule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        if (event.target) {
            if (event.target instanceof HTMLElement || event.target instanceof SVGElement) {
                let value = this.getValue(event.target);
                let suffix;
                try {
                    suffix = (0, css_selector_generator_1.default)(event.target, { selectors: ['id', 'tag'] });
                }
                catch (e) {
                    Logger_1.logger.error(`exception`, new Error('css exception'));
                }
                if (value !== undefined && value.trim().length > 0) {
                    suffix += `?${value}`;
                }
                return new Action_1.default(this.prefix, suffix);
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix) {
            const elements = [];
            const parentElements = this.findMatchedElements();
            let sharpCharIndex = action.suffix.indexOf('?');
            let cssSelector = sharpCharIndex === -1 ? action.suffix : action.suffix.substring(0, sharpCharIndex);
            document.querySelectorAll(cssSelector).forEach((element) => {
                if (parentElements.some((parent) => parent.contains(element))) {
                    if (element instanceof HTMLElement || element instanceof SVGElement) {
                        elements.push(element);
                    }
                }
            });
            return elements;
        }
        else {
            return [];
        }
    }
    getValue(element) {
        if (element instanceof HTMLInputElement) {
            return element.value;
        }
        const valueAttribute = element.getAttribute('value');
        if (valueAttribute) {
            return valueAttribute;
        }
    }
}
exports["default"] = CSSSelectorWithValueRule;


/***/ }),

/***/ "./src/domain/ClassMutationHandler.ts":
/*!********************************************!*\
  !*** ./src/domain/ClassMutationHandler.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class ClassMutationHandler {
    constructor() {
        this._observer = new MutationObserver((records) => {
            for (const record of records) {
                if (record.type === "attributes") {
                    if (record.attributeName === "class") {
                        if (record.target instanceof HTMLElement) {
                            Logger_1.logger.debug('class mutation');
                            if (record.target.matches(':hover')) {
                                let currentClass = record.target.getAttribute('class');
                                let createEvent = false;
                                if (record.oldValue) {
                                    if (currentClass && currentClass.includes(record.oldValue)) {
                                        createEvent = true;
                                    }
                                }
                                else {
                                    if (currentClass) {
                                        createEvent = true;
                                    }
                                }
                                if (createEvent) {
                                    Logger_1.logger.debug('create event');
                                    let event = new Event('css-class-added', { bubbles: true });
                                    record.target.dispatchEvent(event);
                                }
                            }
                        }
                    }
                }
            }
        });
        const config = { attributes: true, subtree: true, attributeOldValue: true };
        this._observer.observe(document.body, config);
        Logger_1.logger.info('class mutation handler initialized');
    }
}
exports["default"] = ClassMutationHandler;


/***/ }),

/***/ "./src/domain/ContextLessMapper.ts":
/*!*****************************************!*\
  !*** ./src/domain/ContextLessMapper.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ContextMapper_1 = __importDefault(__webpack_require__(/*! ./ContextMapper */ "./src/domain/ContextMapper.ts"));
class ContextLessMapper extends ContextMapper_1.default {
    constructor() {
        super(undefined);
    }
    buildElementToRuleMap() {
        return this.buildElementToRuleMapForSelectors();
    }
}
exports["default"] = ContextLessMapper;


/***/ }),

/***/ "./src/domain/ContextMapper.ts":
/*!*************************************!*\
  !*** ./src/domain/ContextMapper.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class ContextMapper {
    constructor(context) {
        this._context = context;
        this._cssSelector2Rules = new Map();
        this._xpathSelector2Rules = new Map();
    }
    add(rule) {
        if (rule.contextCSS !== this._context && rule.contextURL !== this._context && rule.contextXPath !== this._context) {
            throw new Error('cannot add rule with a different context ');
        }
        if (rule.css) {
            if (!this._cssSelector2Rules.has(rule.css)) {
                this._cssSelector2Rules.set(rule.css, []);
            }
            let rules4Selector = this._cssSelector2Rules.get(rule.css);
            if (rules4Selector) {
                rules4Selector.push(rule);
            }
        }
        if (rule.xpath) {
            if (!this._xpathSelector2Rules.has(rule.xpath)) {
                this._xpathSelector2Rules.set(rule.xpath, []);
            }
            let rules4Selector = this._xpathSelector2Rules.get(rule.xpath);
            if (rules4Selector) {
                rules4Selector.push(rule);
            }
        }
    }
    buildElementToRuleMapForSelectors(context) {
        const elementToRules = new Map();
        for (const [selector, rules] of this._cssSelector2Rules) {
            let querySelector;
            if (context) {
                querySelector = context.querySelectorAll(selector);
            }
            else {
                querySelector = document.querySelectorAll(selector);
            }
            querySelector.forEach(element => {
                let rules4Element = elementToRules.get(element);
                if (!rules4Element) {
                    rules4Element = [];
                    elementToRules.set(element, rules4Element);
                }
                rules4Element.push(...rules);
            });
        }
        for (const [selector, rules] of this._xpathSelector2Rules) {
            let queryXpath;
            let queryXpathResult;
            try {
                if (context) {
                    queryXpath = document.evaluate(selector, context, null, XPathResult.ANY_TYPE, null);
                }
                else {
                    queryXpath = document.evaluate(selector, document, null, XPathResult.ANY_TYPE, null);
                }
            }
            catch (e) {
                Logger_1.logger.error('XPath Error:', new Error("e"));
            }
            if (queryXpath) {
                queryXpathResult = queryXpath.iterateNext();
                while (queryXpathResult) {
                    if (queryXpathResult instanceof HTMLElement || queryXpathResult instanceof SVGElement) {
                        let noContext = !context;
                        let resultInContext = context && context.contains(queryXpathResult);
                        if (noContext || resultInContext) {
                            let rules4Element = elementToRules.get(queryXpathResult);
                            if (!rules4Element) {
                                rules4Element = [];
                                elementToRules.set(queryXpathResult, rules4Element);
                            }
                            rules4Element.push(...rules);
                        }
                    }
                    queryXpathResult = queryXpath.iterateNext();
                }
            }
        }
        return elementToRules;
    }
}
exports["default"] = ContextMapper;


/***/ }),

/***/ "./src/domain/EventListener.ts":
/*!*************************************!*\
  !*** ./src/domain/EventListener.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Logger_1 = __webpack_require__(/*! ../framework/Logger */ "./src/framework/Logger.ts");
class EventListener {
    constructor(ruleService) {
        this._ruleService = ruleService;
        this._handledEvents = [];
        this._observers = [];
    }
    start() {
        this._handledEvents = this._ruleService.getEventsToHandle();
        Logger_1.logger.debug(`EventListener: there are ${this._handledEvents.length} events to handle`);
        this._handledEvents.forEach((handledEvent) => {
            document.addEventListener(handledEvent, this.exploratoryListener.bind(this), true);
        });
    }
    addObserver(observerFunction) {
        this._observers.push(observerFunction);
    }
    exploratoryListener(event) {
        let unsafeEvent = event;
        if (unsafeEvent.isTrusted) {
            if (!unsafeEvent.explored) {
                unsafeEvent.explored = true;
                Logger_1.logger.debug(`EventListener: event ${unsafeEvent.type} is being handled`);
                const rule = this._ruleService.getMatchingRule(event);
                if (rule) {
                    const action = rule.makeAction(event);
                    if (action) {
                        Logger_1.logger.info(`action : ${action.toString()}`);
                        this._observers.forEach((observer) => {
                            observer(action);
                        });
                    }
                    else {
                        Logger_1.logger.debug('no action');
                    }
                }
            }
        }
    }
}
exports["default"] = EventListener;


/***/ }),

/***/ "./src/domain/IndexRule.ts":
/*!*********************************!*\
  !*** ./src/domain/IndexRule.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
class IndexRule extends SimpleRule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        const matchingElements = this.findMatchedElements();
        for (let i = 0; i < matchingElements.length; i++) {
            let targetElements = event.composedPath().filter((target) => target instanceof HTMLElement || target instanceof SVGElement);
            if (targetElements.length > 0 && matchingElements[i].contains(targetElements[0])) {
                return new Action_1.default(this.prefix, i.toString());
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix === undefined) {
            return super.actionToElements(action);
        }
        const index = parseInt(action.suffix, 10);
        const elements = this.findMatchedElements();
        if (index !== undefined || null) {
            if (elements.length > index) {
                return [elements[index]];
            }
            else {
                return [];
            }
        }
        else {
            return elements;
        }
    }
}
exports["default"] = IndexRule;


/***/ }),

/***/ "./src/domain/InnerTextRule.ts":
/*!*************************************!*\
  !*** ./src/domain/InnerTextRule.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
class InnerTextRule extends SimpleRule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        const element = this.findActionMappedTarget(event);
        if (element) {
            if (element instanceof HTMLElement) {
                return new Action_1.default(this.prefix, element.innerText.trim());
            }
            else {
                return new Action_1.default(this.prefix, "svg");
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix === undefined) {
            return super.actionToElements(action);
        }
        else {
            let suffix = action.suffix;
            const elements = this.findMatchedElements();
            return elements.filter(domElement => {
                if (domElement instanceof HTMLElement) {
                    return domElement.innerText.trim() === suffix.trim();
                }
                else if (domElement instanceof SVGElement) {
                    return "svg" === suffix.trim();
                }
                else {
                    return false;
                }
            });
        }
    }
}
exports["default"] = InnerTextRule;


/***/ }),

/***/ "./src/domain/PageMutationHandler.ts":
/*!*******************************************!*\
  !*** ./src/domain/PageMutationHandler.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const MUTATION_REFRESH_CHECK = 1000;
const DOM_IDS = ["AIFEX_probabilityPopup", "AIFEX_tab"];
class PageMutationHandler {
    constructor(onPageMutation) {
        this.onPageMutation = onPageMutation;
        this.beRefreshing = false;
        this.mutationHasOccured = false;
        this.willRefresh = false;
    }
    init() {
        this.lastMutation = Date.now();
        this.observer = new MutationObserver((records) => {
            let watchedPageHasMutated = false;
            for (const record of records) {
                if (record.type === "childList") {
                    if (this.isWatchedNodeList(record.addedNodes) && !this.isIncludedInAIFEXElement(record.addedNodes)) {
                        watchedPageHasMutated = true;
                    }
                }
            }
            if (watchedPageHasMutated) {
                if (!this.beRefreshing) {
                    this.beRefreshing = true;
                    this.onPageMutation();
                    setTimeout(() => {
                        this.beRefreshing = false;
                    }, MUTATION_REFRESH_CHECK);
                }
                else {
                    if (!this.willRefresh) {
                        this.willRefresh = true;
                        const TIME_CHECK_MULTIPLIER = 2;
                        setTimeout(() => {
                            this.beRefreshing = true;
                            this.onPageMutation();
                            setTimeout(() => {
                                this.beRefreshing = false;
                                this.willRefresh = false;
                            }, MUTATION_REFRESH_CHECK);
                        }, TIME_CHECK_MULTIPLIER * MUTATION_REFRESH_CHECK);
                    }
                }
            }
        });
        const config = { attributes: false, childList: true, characterData: false, subtree: true };
        this.observer.observe(document.body, config);
    }
    isWatchedNodeList(nodeList) {
        let isWatched = false;
        nodeList.forEach(node => {
            if (node instanceof HTMLElement) {
                if (node.tagName !== "SCRIPT" && node.tagName !== "IFRAME" && node.tagName !== "IMG") {
                    if (!node.style) {
                        isWatched = true;
                    }
                    if (!node.style.display) {
                        isWatched = true;
                    }
                    if (node.style.display !== "none") {
                        isWatched = true;
                    }
                }
            }
        });
        return isWatched;
    }
    isIncludedInAIFEXElement(nodeList) {
        const AIFEXElementList = DOM_IDS.map(id => document.getElementById(id)).filter((element) => element !== null);
        let isIncluded = true;
        nodeList.forEach(node => {
            if (node instanceof HTMLElement) {
                if (!AIFEXElementList.some((aifexNode) => {
                    return aifexNode.contains(node);
                })) {
                    isIncluded = false;
                }
            }
        });
        return isIncluded;
    }
}
exports["default"] = PageMutationHandler;


/***/ }),

/***/ "./src/domain/Rule.ts":
/*!****************************!*\
  !*** ./src/domain/Rule.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const query_selector_shadow_dom_1 = __webpack_require__(/*! query-selector-shadow-dom */ "./node_modules/query-selector-shadow-dom/src/querySelectorDeep.js");
class Rule {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        this.event = event;
        this.code = code;
        this.css = css;
        this.xpath = xpath;
        this.prefix = prefix;
        this.suffix = suffix;
        this.key = key;
        this.contextURL = contextURL;
        this.contextCSS = contextCSS;
        this.contextXPath = contextXPath;
        this.description = description;
    }
    match(event) {
        if (event.type !== this.event) {
            return false;
        }
        if (event instanceof KeyboardEvent) {
            if (this.event === "keyup" || this.event === "keydown" || this.event === "keypress") {
                if (this.code && event.code !== this.code) {
                    return false;
                }
                if (this.key && event.key !== this.key) {
                    return false;
                }
            }
            return true;
        }
        else {
            return true;
        }
    }
    findActionMappedTarget(event) {
        const target = event.composedPath()[0];
        if (target instanceof HTMLElement || target instanceof SVGElement) {
            if (target.hasAttribute("aifex_style")) {
                return target;
            }
            else {
                let closest = target.closest("[aifex_style]");
                if (closest && (closest instanceof HTMLElement || closest instanceof SVGElement)) {
                    return closest;
                }
            }
        }
    }
    findMatchedElements() {
        let context;
        if (this.contextXPath) {
            try {
                const result = document.evaluate(this.contextXPath, document, null, XPathResult.ANY_TYPE, null);
                context = result.iterateNext();
            }
            catch (e) {
                console.error(e);
            }
            if (!context) {
                return [];
            }
        }
        if (this.contextCSS) {
            context = document.querySelector(this.contextCSS);
            if (!context) {
                return [];
            }
        }
        let elements = [];
        if (this.xpath) {
            try {
                let result;
                if (context) {
                    result = document.evaluate(this.xpath, context, null, XPathResult.ANY_TYPE, null);
                }
                else {
                    result = document.evaluate(this.xpath, document, null, XPathResult.ANY_TYPE, null);
                }
                let node = result.iterateNext();
                while (node) {
                    elements.push(node);
                    node = result.iterateNext();
                }
            }
            catch (e) {
                console.error(e);
            }
        }
        if (this.css) {
            if (context) {
                elements = (0, query_selector_shadow_dom_1.querySelectorAllDeep)(this.css, context);
            }
            else {
                elements = (0, query_selector_shadow_dom_1.querySelectorAllDeep)(this.css);
            }
        }
        return elements.filter((element) => element instanceof HTMLElement || element instanceof SVGElement);
    }
}
exports["default"] = Rule;


/***/ }),

/***/ "./src/domain/RuleMapper.ts":
/*!**********************************!*\
  !*** ./src/domain/RuleMapper.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const URLContextMapper_1 = __importDefault(__webpack_require__(/*! ./URLContextMapper */ "./src/domain/URLContextMapper.ts"));
const XPathContextMapper_1 = __importDefault(__webpack_require__(/*! ./XPathContextMapper */ "./src/domain/XPathContextMapper.ts"));
const ContextLessMapper_1 = __importDefault(__webpack_require__(/*! ./ContextLessMapper */ "./src/domain/ContextLessMapper.ts"));
const CSSContextMapper_1 = __importDefault(__webpack_require__(/*! ./CSSContextMapper */ "./src/domain/CSSContextMapper.ts"));
class RuleMapper {
    constructor(rules) {
        this._cssContext2ContextMapper = new Map();
        this._xpathContext2ContextMapper = new Map();
        this._urlContext2ContextMapper = new Map();
        this._contextLessMapper = new ContextLessMapper_1.default();
        this._prefix2Rules = new Map();
        this._eventInRules = [];
        this.rules = rules;
        rules.forEach(rule => {
            let rules4Prefix = this._prefix2Rules.get(rule.prefix);
            if (!rules4Prefix) {
                rules4Prefix = [];
                this._prefix2Rules.set(rule.prefix, rules4Prefix);
            }
            rules4Prefix.push(rule);
            if (!this._eventInRules.includes(rule.event)) {
                this._eventInRules.push(rule.event);
            }
            if (rule.contextCSS) {
                let contextMapper4CssContext = this._cssContext2ContextMapper.get(rule.contextCSS);
                if (!contextMapper4CssContext) {
                    contextMapper4CssContext = new CSSContextMapper_1.default(rule.contextCSS);
                    this._cssContext2ContextMapper.set(rule.contextCSS, contextMapper4CssContext);
                }
                contextMapper4CssContext.add(rule);
            }
            else if (rule.contextXPath) {
                let contextMapper4XpathContext = this._xpathContext2ContextMapper.get(rule.contextXPath);
                if (!contextMapper4XpathContext) {
                    contextMapper4XpathContext = new XPathContextMapper_1.default(rule.contextXPath);
                    this._xpathContext2ContextMapper.set(rule.contextXPath, contextMapper4XpathContext);
                }
                contextMapper4XpathContext.add(rule);
            }
            else if (rule.contextURL) {
                let contexMapper4URLContext = this._urlContext2ContextMapper.get(rule.contextURL);
                if (!contexMapper4URLContext) {
                    contexMapper4URLContext = new URLContextMapper_1.default(rule.contextURL);
                    this._urlContext2ContextMapper.set(rule.contextURL, contexMapper4URLContext);
                }
                contexMapper4URLContext.add(rule);
            }
            else {
                this._contextLessMapper.add(rule);
            }
        });
    }
    getIsLoaded() {
        return this._prefix2Rules.size > 0;
    }
    getRuleListByPrefix(prefix) {
        let rules4prefis = this._prefix2Rules.get(prefix);
        if (rules4prefis) {
            return rules4prefis;
        }
        else {
            return [];
        }
    }
    get eventInRules() {
        return this._eventInRules;
    }
    buildElementToRuleMap() {
        const result = new Map();
        for (const mapper of this._urlContext2ContextMapper.values()) {
            for (const [element, rules] of mapper.buildElementToRuleMap()) {
                let rules4element = result.get(element);
                if (!rules4element) {
                    rules4element = [];
                    result.set(element, rules4element);
                }
                rules4element.push(...rules);
            }
        }
        for (const mapper of this._cssContext2ContextMapper.values()) {
            for (const [element, rules] of mapper.buildElementToRuleMap()) {
                let rules4element = result.get(element);
                if (!rules4element) {
                    rules4element = [];
                    result.set(element, rules4element);
                }
                rules4element.push(...rules);
            }
        }
        for (const mapper of this._xpathContext2ContextMapper.values()) {
            for (const [element, rules] of mapper.buildElementToRuleMap()) {
                let rules4element = result.get(element);
                if (!rules4element) {
                    rules4element = [];
                    result.set(element, rules4element);
                }
                rules4element.push(...rules);
            }
        }
        for (const [element, rules] of this._contextLessMapper.buildElementToRuleMap()) {
            let rules4element = result.get(element);
            if (!rules4element) {
                rules4element = [];
                result.set(element, rules4element);
            }
            rules4element.push(...rules);
        }
        return result;
    }
}
exports["default"] = RuleMapper;


/***/ }),

/***/ "./src/domain/RuleService.ts":
/*!***********************************!*\
  !*** ./src/domain/RuleService.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const RuleMapper_1 = __importDefault(__webpack_require__(/*! ./RuleMapper */ "./src/domain/RuleMapper.ts"));
const IndexRule_1 = __importDefault(__webpack_require__(/*! ./IndexRule */ "./src/domain/IndexRule.ts"));
const InnerTextRule_1 = __importDefault(__webpack_require__(/*! ./InnerTextRule */ "./src/domain/InnerTextRule.ts"));
const ValueRule_1 = __importDefault(__webpack_require__(/*! ./ValueRule */ "./src/domain/ValueRule.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
const CSSSelectorRule_1 = __importDefault(__webpack_require__(/*! ./CSSSelectorRule */ "./src/domain/CSSSelectorRule.ts"));
const AttributeValueRule_1 = __importDefault(__webpack_require__(/*! ./AttributeValueRule */ "./src/domain/AttributeValueRule.ts"));
const CSSSelectorWithValueRule_1 = __importDefault(__webpack_require__(/*! ./CSSSelectorWithValueRule */ "./src/domain/CSSSelectorWithValueRule.ts"));
class RuleService {
    constructor() {
        this.elementRules = new Map();
        this._ruleMapper = new RuleMapper_1.default([]);
    }
    get elementListMatchedByRule() {
        return Array.from(this.elementRules.keys());
    }
    getEventsToHandle() {
        return this._ruleMapper.eventInRules;
    }
    loadRules(rules) {
        this._ruleMapper = new RuleMapper_1.default(rules);
    }
    mapRulesToElements() {
        this.elementRules = this._ruleMapper.buildElementToRuleMap();
    }
    getMatchingRule(event) {
        let elements = event.composedPath().filter((target) => target instanceof HTMLElement || target instanceof SVGElement);
        for (const element of elements) {
            const rules = this.elementRules.get(element);
            if (rules !== undefined) {
                const matchingRule = rules.find((rule) => rule.match(event));
                if (matchingRule) {
                    return matchingRule;
                }
            }
        }
    }
    getRuleListByAction(action) {
        return this._ruleMapper.getRuleListByPrefix(action.prefix);
    }
    getHTMLElementsMatchedByAction(action) {
        const elements = new Set();
        action.ruleList.forEach(rule => {
            const elementListForRule = rule.actionToElements(action);
            elementListForRule.forEach(element => elements.add(element));
        });
        return [...elements.values()];
    }
    createRule(data) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32;
        switch (data.output.suffix) {
            case "innerText":
                return new InnerTextRule_1.default(data.output.prefix, (_a = data.output) === null || _a === void 0 ? void 0 : _a.suffix, data.match.event, (_b = data.match) === null || _b === void 0 ? void 0 : _b.css, (_c = data.match) === null || _c === void 0 ? void 0 : _c.xpath, (_d = data.match) === null || _d === void 0 ? void 0 : _d.code, (_e = data.match) === null || _e === void 0 ? void 0 : _e.key, (_f = data === null || data === void 0 ? void 0 : data.context) === null || _f === void 0 ? void 0 : _f.url, (_g = data === null || data === void 0 ? void 0 : data.context) === null || _g === void 0 ? void 0 : _g.css, (_h = data === null || data === void 0 ? void 0 : data.context) === null || _h === void 0 ? void 0 : _h.xpath, data.description);
            case "index":
                return new IndexRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_j = data.match) === null || _j === void 0 ? void 0 : _j.css, (_k = data.match) === null || _k === void 0 ? void 0 : _k.xpath, (_l = data.match) === null || _l === void 0 ? void 0 : _l.code, (_m = data.match) === null || _m === void 0 ? void 0 : _m.key, (_o = data === null || data === void 0 ? void 0 : data.context) === null || _o === void 0 ? void 0 : _o.url, (_p = data === null || data === void 0 ? void 0 : data.context) === null || _p === void 0 ? void 0 : _p.css, (_q = data === null || data === void 0 ? void 0 : data.context) === null || _q === void 0 ? void 0 : _q.xpath, data.description);
            case "value":
                return new ValueRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_r = data.match) === null || _r === void 0 ? void 0 : _r.css, (_s = data.match) === null || _s === void 0 ? void 0 : _s.xpath, (_t = data.match) === null || _t === void 0 ? void 0 : _t.code, (_u = data.match) === null || _u === void 0 ? void 0 : _u.key, (_v = data === null || data === void 0 ? void 0 : data.context) === null || _v === void 0 ? void 0 : _v.url, (_w = data === null || data === void 0 ? void 0 : data.context) === null || _w === void 0 ? void 0 : _w.css, (_x = data === null || data === void 0 ? void 0 : data.context) === null || _x === void 0 ? void 0 : _x.xpath, data.description);
            case "cssSelector":
                return new CSSSelectorRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_y = data.match) === null || _y === void 0 ? void 0 : _y.css, (_z = data.match) === null || _z === void 0 ? void 0 : _z.xpath, (_0 = data.match) === null || _0 === void 0 ? void 0 : _0.code, (_1 = data.match) === null || _1 === void 0 ? void 0 : _1.key, (_2 = data === null || data === void 0 ? void 0 : data.context) === null || _2 === void 0 ? void 0 : _2.url, (_3 = data === null || data === void 0 ? void 0 : data.context) === null || _3 === void 0 ? void 0 : _3.css, (_4 = data === null || data === void 0 ? void 0 : data.context) === null || _4 === void 0 ? void 0 : _4.xpath, data.description);
            case "cssSelectorWithValue":
                return new CSSSelectorWithValueRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_5 = data.match) === null || _5 === void 0 ? void 0 : _5.css, (_6 = data.match) === null || _6 === void 0 ? void 0 : _6.xpath, (_7 = data.match) === null || _7 === void 0 ? void 0 : _7.code, (_8 = data.match) === null || _8 === void 0 ? void 0 : _8.key, (_9 = data === null || data === void 0 ? void 0 : data.context) === null || _9 === void 0 ? void 0 : _9.url, (_10 = data === null || data === void 0 ? void 0 : data.context) === null || _10 === void 0 ? void 0 : _10.css, (_11 = data === null || data === void 0 ? void 0 : data.context) === null || _11 === void 0 ? void 0 : _11.xpath, data.description);
            case "attributeValue":
                if (data.match.attributeName === undefined) {
                    return new SimpleRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_12 = data.match) === null || _12 === void 0 ? void 0 : _12.css, (_13 = data.match) === null || _13 === void 0 ? void 0 : _13.xpath, (_14 = data.match) === null || _14 === void 0 ? void 0 : _14.code, (_15 = data.match) === null || _15 === void 0 ? void 0 : _15.key, (_16 = data === null || data === void 0 ? void 0 : data.context) === null || _16 === void 0 ? void 0 : _16.url, (_17 = data === null || data === void 0 ? void 0 : data.context) === null || _17 === void 0 ? void 0 : _17.css, (_18 = data === null || data === void 0 ? void 0 : data.context) === null || _18 === void 0 ? void 0 : _18.xpath, data.description);
                }
                else {
                    return new AttributeValueRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_19 = data.match) === null || _19 === void 0 ? void 0 : _19.css, (_20 = data.match) === null || _20 === void 0 ? void 0 : _20.xpath, (_21 = data.match) === null || _21 === void 0 ? void 0 : _21.code, (_22 = data.match) === null || _22 === void 0 ? void 0 : _22.key, (_23 = data === null || data === void 0 ? void 0 : data.context) === null || _23 === void 0 ? void 0 : _23.url, (_24 = data === null || data === void 0 ? void 0 : data.context) === null || _24 === void 0 ? void 0 : _24.css, (_25 = data === null || data === void 0 ? void 0 : data.context) === null || _25 === void 0 ? void 0 : _25.xpath, data.description, data.match.attributeName);
                }
            default:
                return new SimpleRule_1.default(data.output.prefix, data.output.suffix, data.match.event, (_26 = data.match) === null || _26 === void 0 ? void 0 : _26.css, (_27 = data.match) === null || _27 === void 0 ? void 0 : _27.xpath, (_28 = data.match) === null || _28 === void 0 ? void 0 : _28.code, (_29 = data.match) === null || _29 === void 0 ? void 0 : _29.key, (_30 = data === null || data === void 0 ? void 0 : data.context) === null || _30 === void 0 ? void 0 : _30.url, (_31 = data === null || data === void 0 ? void 0 : data.context) === null || _31 === void 0 ? void 0 : _31.css, (_32 = data === null || data === void 0 ? void 0 : data.context) === null || _32 === void 0 ? void 0 : _32.xpath, data.description);
        }
    }
}
exports["default"] = RuleService;


/***/ }),

/***/ "./src/domain/Session.ts":
/*!*******************************!*\
  !*** ./src/domain/Session.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class Session {
    constructor(id, webSiteId, baseURL, name, description, overlayType, recordingMode) {
        if (id === null || id === undefined) {
            throw new Error('cannot create Session without id');
        }
        if (webSiteId === null || webSiteId === undefined) {
            throw new Error('cannot create Session without webSiteId');
        }
        this.id = id;
        this.webSiteId = webSiteId;
        this.baseURL = baseURL;
        this.name = name;
        this.description = description;
        this.overlayType = overlayType;
        this.recordingMode = recordingMode;
    }
}
exports["default"] = Session;


/***/ }),

/***/ "./src/domain/SimpleRule.ts":
/*!**********************************!*\
  !*** ./src/domain/SimpleRule.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const Rule_1 = __importDefault(__webpack_require__(/*! ./Rule */ "./src/domain/Rule.ts"));
class SimpleRule extends Rule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        return new Action_1.default(this.prefix);
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        const elements = this.findMatchedElements();
        return elements;
    }
}
exports["default"] = SimpleRule;


/***/ }),

/***/ "./src/domain/URLContextMapper.ts":
/*!****************************************!*\
  !*** ./src/domain/URLContextMapper.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ContextMapper_1 = __importDefault(__webpack_require__(/*! ./ContextMapper */ "./src/domain/ContextMapper.ts"));
class URLContextMapper extends ContextMapper_1.default {
    constructor(context) {
        super(context);
    }
    buildElementToRuleMap() {
        if (this._context && document.URL.startsWith(this._context)) {
            return this.buildElementToRuleMapForSelectors();
        }
        else {
            return new Map();
        }
    }
}
exports["default"] = URLContextMapper;


/***/ }),

/***/ "./src/domain/ValueRule.ts":
/*!*********************************!*\
  !*** ./src/domain/ValueRule.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Action_1 = __importDefault(__webpack_require__(/*! ./Action */ "./src/domain/Action.ts"));
const SimpleRule_1 = __importDefault(__webpack_require__(/*! ./SimpleRule */ "./src/domain/SimpleRule.ts"));
class ValueRule extends SimpleRule_1.default {
    constructor(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description) {
        super(prefix, suffix, event, css, xpath, code, key, contextURL, contextCSS, contextXPath, description);
    }
    makeAction(event) {
        let target = event.target;
        if (target) {
            if (target instanceof HTMLInputElement) {
                return new Action_1.default(this.prefix, target.value);
            }
            else if (target instanceof HTMLSelectElement) {
                return new Action_1.default(this.prefix, "svg");
            }
        }
    }
    actionToElements(action) {
        if (action.prefix !== this.prefix) {
            return [];
        }
        if (action.suffix === undefined) {
            return super.actionToElements(action);
        }
        const elements = this.findMatchedElements();
        return elements;
    }
}
exports["default"] = ValueRule;


/***/ }),

/***/ "./src/domain/Website.ts":
/*!*******************************!*\
  !*** ./src/domain/Website.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class WebSite {
    constructor(id, name, mappingList) {
        this.id = id;
        this.name = name;
        this.mappingList = mappingList;
    }
}
exports["default"] = WebSite;


/***/ }),

/***/ "./src/domain/XPathContextMapper.ts":
/*!******************************************!*\
  !*** ./src/domain/XPathContextMapper.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ContextMapper_1 = __importDefault(__webpack_require__(/*! ./ContextMapper */ "./src/domain/ContextMapper.ts"));
class XPathContextMapper extends ContextMapper_1.default {
    constructor(context) {
        super(context);
    }
    buildElementToRuleMap() {
        if (this._context) {
            const xpathQueryResult = document.evaluate(this._context, document, null, XPathResult.ANY_TYPE, null);
            const context = xpathQueryResult.iterateNext();
            if (context instanceof HTMLElement || context instanceof SVGElement) {
                return this.buildElementToRuleMapForSelectors();
            }
            else {
                return new Map();
            }
        }
        else {
            return new Map();
        }
    }
}
exports["default"] = XPathContextMapper;


/***/ }),

/***/ "./src/framework/Logger.ts":
/*!*********************************!*\
  !*** ./src/framework/Logger.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logger = void 0;
const typescript_logging_1 = __webpack_require__(/*! typescript-logging */ "./node_modules/typescript-logging/dist/commonjs/typescript-logging.js");
let logLevel;
switch ("development") {
    case 'production':
        logLevel = typescript_logging_1.LogLevel.Error;
        break;
    case 'development':
        logLevel = typescript_logging_1.LogLevel.Debug;
        break;
    case 'github':
        logLevel = typescript_logging_1.LogLevel.Error;
        break;
    default:
        logLevel = typescript_logging_1.LogLevel.Error;
}
typescript_logging_1.CategoryServiceFactory.setDefaultConfiguration(new typescript_logging_1.CategoryConfiguration(logLevel));
exports.logger = new typescript_logging_1.Category("TabScript");


/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const BrowserScript_1 = __importDefault(__webpack_require__(/*! ./domain/BrowserScript */ "./src/domain/BrowserScript.ts"));
const Logger_1 = __webpack_require__(/*! ./framework/Logger */ "./src/framework/Logger.ts");
const AifexServiceHTTP_1 = __importDefault(__webpack_require__(/*! ./_infra/AifexServiceHTTP */ "./src/_infra/AifexServiceHTTP.ts"));
const BrowserServiceSessionStorage_1 = __importDefault(__webpack_require__(/*! ./_infra/BrowserServiceSessionStorage */ "./src/_infra/BrowserServiceSessionStorage.ts"));
Logger_1.logger.info("AIFEX script is running.");
const AIFEX_SCRIPT = document.getElementById("AIFEX");
if (AIFEX_SCRIPT) {
    Logger_1.logger.info("AIFEX SCRIPT Element is found.");
    const CONNEXION_URL = AIFEX_SCRIPT.getAttribute("connexion-url");
    if (CONNEXION_URL) {
        Logger_1.logger.info("AIFEX connexion-url Element is found.");
        try {
            const AIFEX_URL = new URL(CONNEXION_URL);
            let sessionId = AIFEX_URL.searchParams.get('sessionId');
            if (sessionId) {
                Logger_1.logger.info("AIFEX sessionId is found.");
                const AIFEX_SERVICE = new AifexServiceHTTP_1.default();
                const BROWSER_SERVICE = new BrowserServiceSessionStorage_1.default();
                const BROWSER_SCRIPT = new BrowserScript_1.default(AIFEX_URL.origin, sessionId, undefined, AIFEX_SERVICE, BROWSER_SERVICE);
                BROWSER_SCRIPT.start();
            }
        }
        catch (e) {
            Logger_1.logger.error("Invalid connexion URL", new Error("Invalid connexion URL"));
        }
    }
}
else {
    Logger_1.logger.error("AIFEX SCRIPT Element is not found.", new Error("AIFEX SCRIPT Element is not found."));
}


/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/control/CategoryServiceControl.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/control/CategoryServiceControl.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var CategoryService_1 = __webpack_require__(/*! ../log/category/CategoryService */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js");
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var DataStructures_1 = __webpack_require__(/*! ../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
/**
 * Implementation class for CategoryServiceControl.
 */
var CategoryServiceControlImpl = (function () {
    function CategoryServiceControlImpl() {
    }
    CategoryServiceControlImpl.prototype.help = function () {
        /* tslint:disable:no-console */
        console.log(CategoryServiceControlImpl._help);
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl.prototype.example = function () {
        /* tslint:disable:no-console */
        console.log(CategoryServiceControlImpl._example);
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl.prototype.showSettings = function (id) {
        if (id === void 0) { id = "all"; }
        var result = new DataStructures_1.StringBuilder();
        var service = CategoryServiceControlImpl._getCategoryService();
        var categories = CategoryServiceControlImpl._getCategories(id);
        categories.forEach(function (category) {
            CategoryServiceControlImpl._processCategory(service, category, result, 0);
        });
        /* tslint:disable:no-console */
        console.log(result.toString());
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl.prototype.change = function (settings) {
        var service = CategoryServiceControlImpl._getCategoryService();
        var categories = CategoryServiceControlImpl._getCategories(settings.category);
        var logLevel = null;
        var formatEnum = null;
        var showCategoryName = null;
        var showTimestamp = null;
        var result = null;
        var addResult = function (value) {
            if (result !== null) {
                result += ", ";
            }
            if (result === null) {
                result = value;
            }
            else {
                result += value;
            }
        };
        addResult("recursive=" + settings.recursive);
        if (typeof settings.logLevel === "string") {
            logLevel = LoggerOptions_1.LogLevel.fromString(settings.logLevel);
            addResult("logLevel=" + settings.logLevel);
        }
        if (typeof settings.logFormat === "string") {
            formatEnum = LoggerOptions_1.DateFormatEnum.fromString(settings.logFormat);
            addResult("logFormat=" + settings.logFormat);
        }
        if (typeof settings.showCategoryName === "boolean") {
            showCategoryName = settings.showCategoryName;
            addResult("showCategoryName=" + settings.showCategoryName);
        }
        if (typeof settings.showTimestamp === "boolean") {
            showTimestamp = settings.showTimestamp;
            addResult("showTimestamp=" + settings.showTimestamp);
        }
        var applyChanges = function (cat) {
            var categorySettings = service.getCategorySettings(cat);
            // Should not happen but make tslint happy
            if (categorySettings !== null) {
                if (logLevel !== null) {
                    categorySettings.logLevel = logLevel;
                }
                if (formatEnum !== null) {
                    categorySettings.logFormat.dateFormat.formatEnum = formatEnum;
                }
                if (showTimestamp !== null) {
                    categorySettings.logFormat.showTimeStamp = showTimestamp;
                }
                if (showCategoryName !== null) {
                    categorySettings.logFormat.showCategoryName = showCategoryName;
                }
            }
        };
        categories.forEach(function (cat) { return CategoryServiceControlImpl._applyToCategory(cat, settings.recursive, applyChanges); });
        /* tslint:disable:no-console */
        console.log("Applied changes: " + result + " to categories '" + settings.category + "'.");
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl.prototype.reset = function (id) {
        if (id === void 0) { id = "all"; }
        var service = CategoryServiceControlImpl._getCategoryService();
        var categories = CategoryServiceControlImpl._getCategories(id);
        var applyChanges = function (cat) {
            var categorySettings = service.getCategorySettings(cat);
            var original = service.getOriginalCategorySettings(cat);
            // Should not happen but make tslint happy
            if (categorySettings !== null && original !== null) {
                categorySettings.logLevel = original.logLevel;
                categorySettings.logFormat.dateFormat.formatEnum = original.logFormat.dateFormat.formatEnum;
                categorySettings.logFormat.showTimeStamp = original.logFormat.showTimeStamp;
                categorySettings.logFormat.showCategoryName = original.logFormat.showCategoryName;
            }
        };
        categories.forEach(function (cat) { return CategoryServiceControlImpl._applyToCategory(cat, true, applyChanges); });
        /* tslint:disable:no-console */
        console.log("Applied reset to category: " + id + ".");
        /* tslint:enable:no-console */
    };
    CategoryServiceControlImpl._processCategory = function (service, category, result, indent) {
        var settings = service.getCategorySettings(category);
        if (settings !== null) {
            result.append("  " + category.id + ": ");
            if (indent > 0) {
                for (var i = 0; i < indent; i++) {
                    result.append("  ");
                }
            }
            result.append(category.name + " (" + LoggerOptions_1.LogLevel[settings.logLevel].toString() + "@" + LoggerOptions_1.LoggerType[settings.loggerType].toString() + ")\n");
            if (category.children.length > 0) {
                category.children.forEach(function (child) {
                    CategoryServiceControlImpl._processCategory(service, child, result, indent + 1);
                });
            }
        }
    };
    CategoryServiceControlImpl._applyToCategory = function (category, recursive, apply) {
        apply(category);
        if (recursive) {
            category.children.forEach(function (child) {
                CategoryServiceControlImpl._applyToCategory(child, recursive, apply);
            });
        }
    };
    CategoryServiceControlImpl._getCategoryService = function () {
        return CategoryService_1.CategoryServiceImpl.getInstance();
    };
    CategoryServiceControlImpl._getCategories = function (idCategory) {
        var service = CategoryServiceControlImpl._getCategoryService();
        var categories = [];
        if (idCategory === "all") {
            categories = service.getRootCategories();
        }
        else {
            var category = service.getCategoryById(idCategory);
            if (category === null) {
                throw new Error("Failed to find category with id " + idCategory);
            }
            categories.push(category);
        }
        return categories;
    };
    CategoryServiceControlImpl._help = "\n  help(): void\n    ** Shows this help.\n\n  example(): void\n    ** Shows an example on how to use this.\n\n  showSettings(id: number | \"all\" = \"all\"): void\n    ** Shows settings for a specific category, or for all. The id of categories can be found by calling this method without parameter.\n\n  change(settings: CategoryServiceControlSettings): void\n    ** Changes the current settings for one or all categories.\n    **\n       CategoryServiceControlSettings, properties of object:\n         category: number | \"all\"\n           ** Apply to specific category, or \"all\".\n           ** Required\n\n         recursive: boolean\n           ** Apply to child categories (true) or not.\n           ** Required\n\n         logLevel: \"Fatal\" | \"Error\" | \"Warn\" | \"Info\" | \"Debug\" | \"Trace\" | undefined\n           ** Set log level, undefined will not change the setting.\n           ** Optional\n\n         logFormat: \"Default\" | \"YearMonthDayTime\" | \"YearDayMonthWithFullTime\" | \"YearDayMonthTime\" | undefined\n           ** Set the log format, undefined will not change the setting.\n           ** Optional\n\n         showTimestamp: boolean | undefined\n           ** Whether to show timestamp, undefined will not change the setting.\n           ** Optional\n\n         showCategoryName: boolean | undefined\n           ** Whether to show the category name, undefined will not change the setting.\n           ** Optional\n\n   reset(id: number | \"all\"): void\n     ** Resets everything to original values, for one specific or for all categories.\n";
    CategoryServiceControlImpl._example = "\n  Examples:\n    change({category: \"all\", recursive:true, logLevel: \"Info\"})\n      ** Change loglevel to Info for all categories, apply to child categories as well.\n\n    change({category: 1, recursive:false, logLevel: \"Warn\"})\n      ** Change logLevel for category 1, do not recurse.\n\n    change({category: \"all\", recursive:true, logLevel: \"Debug\", logFormat: \"YearDayMonthTime\", showTimestamp:false, showCategoryName:false})\n      ** Change loglevel to Debug for all categories, apply format, do not show timestamp and category names - recursively to child categories.\n\n";
    return CategoryServiceControlImpl;
}());
exports.CategoryServiceControlImpl = CategoryServiceControlImpl;
//# sourceMappingURL=CategoryServiceControl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/control/LogGroupControl.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/control/LogGroupControl.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var LFService_1 = __webpack_require__(/*! ../log/standard/LFService */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LFService.js");
var DataStructures_1 = __webpack_require__(/*! ../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var LoggerControlImpl = (function () {
    function LoggerControlImpl() {
    }
    LoggerControlImpl.prototype.help = function () {
        /* tslint:disable:no-console */
        console.log(LoggerControlImpl._help);
        /* tslint:enable:no-console */
    };
    LoggerControlImpl.prototype.listFactories = function () {
        var rtSettingsFactories = LoggerControlImpl._getRuntimeSettingsLoggerFactories();
        var result = new DataStructures_1.StringBuilder();
        result.appendLine("Registered LoggerFactories (index / name)");
        for (var i = 0; i < rtSettingsFactories.length; i++) {
            var rtSettingsFactory = rtSettingsFactories[i];
            result.append("  " + i).append(": " + rtSettingsFactory.getName() + "\n");
        }
        /* tslint:disable:no-console */
        console.log(result.toString());
        /* tslint:enable:no-console */
    };
    LoggerControlImpl.prototype.showSettings = function (id) {
        if (id === void 0) { id = "all"; }
        var result = [];
        if (id === "all") {
            var idx_1 = 0;
            LoggerControlImpl._getRuntimeSettingsLoggerFactories().forEach(function (item) {
                result.push(new DataStructures_1.TuplePair(idx_1++, item));
            });
        }
        else {
            var settings = LoggerControlImpl._getRuntimeSettingsLoggerFactories();
            if (id >= 0 && id < settings.length) {
                result.push(new DataStructures_1.TuplePair(id, settings[id]));
            }
            else {
                throw new Error("Requested number: " + id + " was not found.");
            }
        }
        for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
            var setting = result_1[_i];
            /* tslint:disable:no-console */
            console.log("  LoggerFactory: " + setting.y.getName() + " (id=" + setting.x + ")");
            var logGroupRuntimeSettings = setting.y.getLogGroupRuntimeSettings();
            for (var g = 0; g < logGroupRuntimeSettings.length; g++) {
                var groupSetting = logGroupRuntimeSettings[g];
                console.log("     LogGroup: (id=" + g + ")");
                console.log("       RegExp: " + groupSetting.logGroupRule.regExp.source);
                console.log("       Level: " + LoggerOptions_1.LogLevel[groupSetting.level].toString());
                console.log("       LoggerType: " + LoggerOptions_1.LoggerType[groupSetting.loggerType].toString());
            }
            /* tslint:enable:no-console */
        }
    };
    LoggerControlImpl.prototype.reset = function (idFactory) {
        if (idFactory === void 0) { idFactory = "all"; }
        var loggerFactoriesSettings = LoggerControlImpl._getRuntimeSettingsLoggerFactories();
        var result = [];
        if (idFactory === "all") {
            result = loggerFactoriesSettings;
        }
        else {
            if (idFactory >= 0 && idFactory < loggerFactoriesSettings.length) {
                result.push(loggerFactoriesSettings[idFactory]);
            }
        }
        result.forEach(function (setting) {
            /* tslint:disable:no-console */
            console.log("Reset all settings for factory " + idFactory);
            /* tslint:enable:no-console */
            var control = new LoggerFactoryControlImpl(setting);
            control.reset();
        });
    };
    LoggerControlImpl.prototype.getLoggerFactoryControl = function (idFactory) {
        var loggerFactoriesSettings = LoggerControlImpl._getRuntimeSettingsLoggerFactories();
        if (idFactory >= 0 && idFactory < loggerFactoriesSettings.length) {
            return new LoggerFactoryControlImpl(loggerFactoriesSettings[idFactory]);
        }
        throw new Error("idFactory is invalid (less than 0) or non existing id.");
    };
    LoggerControlImpl._getRuntimeSettingsLoggerFactories = function () {
        return LoggerControlImpl._getSettings().getRuntimeSettingsForLoggerFactories();
    };
    LoggerControlImpl._getSettings = function () {
        return LFService_1.LFService.getRuntimeSettings();
    };
    LoggerControlImpl._help = "\n  help(): void\n    ** Shows this help.\n\n  listFactories(): void\n    ** List all registered LoggerFactories with associated log groups with respective ids (ids can be used to target a factory and/or group).\n\n  showSettings(idFactory: number | \"all\"): void\n    ** Show log group settings for idFactory (use listFactories to find id for a LoggerFactory). If idFactory is \"all\" shows all factories.\n\n  getLoggerFactoryControl(idFactory: number): LoggerFactoryControl\n    ** Return LoggerFactoryControl when found for given idFactory or throws Error if invalid or null, get the id by using listFactories()\n\n  reset(idFactory: number | \"all\"): void\n    ** Resets given factory or all factories back to original values.\n";
    return LoggerControlImpl;
}());
exports.LoggerControlImpl = LoggerControlImpl;
var LoggerFactoryControlImpl = (function () {
    function LoggerFactoryControlImpl(settings) {
        this._settings = settings;
    }
    LoggerFactoryControlImpl.prototype.help = function () {
        /* tslint:disable:no-console */
        console.log(LoggerFactoryControlImpl._help);
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype.example = function () {
        /* tslint:disable:no-console */
        console.log(LoggerFactoryControlImpl._example);
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype.showSettings = function (id) {
        if (id === void 0) { id = "all"; }
        var result = new DataStructures_1.StringBuilder();
        var logGroupRuntimeSettings = this._settings.getLogGroupRuntimeSettings();
        result.appendLine("Registered LogGroups (index / expression)");
        for (var i = 0; i < logGroupRuntimeSettings.length; i++) {
            var logGroupRuntimeSetting = logGroupRuntimeSettings[i];
            result.appendLine("  " + i + ": " + logGroupRuntimeSetting.logGroupRule.regExp.source + ", logLevel=" +
                LoggerOptions_1.LogLevel[logGroupRuntimeSetting.level].toString() + ", showTimestamp=" + logGroupRuntimeSetting.logFormat.showTimeStamp +
                ", showLoggerName=" + logGroupRuntimeSetting.logFormat.showLoggerName +
                ", format=" + LoggerOptions_1.DateFormatEnum[logGroupRuntimeSetting.logFormat.dateFormat.formatEnum].toString());
        }
        /* tslint:disable:no-console */
        console.log(result.toString());
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype.change = function (settings) {
        var logGroupRuntimeSettings = this._getLogGroupRunTimeSettingsFor(settings.group);
        var logLevel = null;
        var formatEnum = null;
        var showLoggerName = null;
        var showTimestamp = null;
        var result = null;
        var addResult = function (value) {
            if (result !== null) {
                result += ", ";
            }
            if (result === null) {
                result = value;
            }
            else {
                result += value;
            }
        };
        if (typeof settings.logLevel === "string") {
            logLevel = LoggerOptions_1.LogLevel.fromString(settings.logLevel);
            addResult("logLevel=" + settings.logLevel);
        }
        if (typeof settings.logFormat === "string") {
            formatEnum = LoggerOptions_1.DateFormatEnum.fromString(settings.logFormat);
            addResult("logFormat=" + settings.logFormat);
        }
        if (typeof settings.showLoggerName === "boolean") {
            showLoggerName = settings.showLoggerName;
            addResult("showLoggerName=" + settings.showLoggerName);
        }
        if (typeof settings.showTimestamp === "boolean") {
            showTimestamp = settings.showTimestamp;
            addResult("showTimestamp=" + settings.showTimestamp);
        }
        logGroupRuntimeSettings.forEach(function (s) {
            if (logLevel !== null) {
                s.level = logLevel;
            }
            if (formatEnum !== null) {
                s.logFormat.dateFormat.formatEnum = formatEnum;
            }
            if (showTimestamp !== null) {
                s.logFormat.showTimeStamp = showTimestamp;
            }
            if (showLoggerName !== null) {
                s.logFormat.showLoggerName = showLoggerName;
            }
        });
        /* tslint:disable:no-console */
        console.log("Applied changes: " + result + " to log groups '" + settings.group + "'.");
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype.reset = function (idGroup) {
        if (idGroup === void 0) { idGroup = "all"; }
        var settings = this._getLogGroupRunTimeSettingsFor(idGroup);
        for (var _i = 0, settings_1 = settings; _i < settings_1.length; _i++) {
            var setting = settings_1[_i];
            setting.level = setting.logGroupRule.level;
            setting.logFormat.showTimeStamp = setting.logGroupRule.logFormat.showTimeStamp;
            setting.logFormat.showLoggerName = setting.logGroupRule.logFormat.showLoggerName;
            setting.logFormat.dateFormat.formatEnum = setting.logGroupRule.logFormat.dateFormat.formatEnum;
        }
        /* tslint:disable:no-console */
        console.log("Reset all settings for group " + idGroup);
        /* tslint:enable:no-console */
    };
    LoggerFactoryControlImpl.prototype._getLogGroupRunTimeSettingsFor = function (idGroup) {
        var settings = [];
        if (idGroup === "all") {
            settings = this._settings.getLogGroupRuntimeSettings();
        }
        else {
            this._checkIndex(idGroup);
            settings.push(this._settings.getLogGroupRuntimeSettings()[idGroup]);
        }
        return settings;
    };
    LoggerFactoryControlImpl.prototype._checkIndex = function (index) {
        if (index < 0 || index >= this._settings.getLogGroupRuntimeSettings().length) {
            throw new Error("Invalid index, use listLogGroups to find out a valid one.");
        }
    };
    LoggerFactoryControlImpl._help = "\n  help(): void\n    ** Shows this help.\n\n  example(): void\n    ** Shows an example of usage.\n\n  showSettings(id: number | \"all\"): void\n    ** Prints settings for given group id, \"all\" for all group.\n\n  change(settings: LogGroupControlSettings): void\n    ** Changes the current settings for one or all log groups.\n    **\n       LogGroupControlSettings, properties of object:\n         group: number | \"all\"\n           ** Apply to specific group, or \"all\".\n           ** Required\n\n         logLevel: \"Fatal\" | \"Error\" | \"Warn\" | \"Info\" | \"Debug\" | \"Trace\" | undefined\n           ** Set log level, undefined will not change the setting.\n           ** Optional\n\n         logFormat: \"Default\" | \"YearMonthDayTime\" | \"YearDayMonthWithFullTime\" | \"YearDayMonthTime\" | undefined\n           ** Set the log format, undefined will not change the setting.\n           ** Optional\n\n         showTimestamp: boolean | undefined\n           ** Whether to show timestamp, undefined will not change the setting.\n           ** Optional\n\n         showLoggerName: boolean | undefined\n           ** Whether to show the logger name, undefined will not change the setting.\n           ** Optional\n\n  reset(id: number | \"all\"): void\n    ** Resets everything to original values, for one specific or for all groups.\n\n  help():\n    ** Shows this help.\n";
    LoggerFactoryControlImpl._example = "\n  Examples:\n    change({group: \"all\", logLevel: \"Info\"})\n      ** Change loglevel to Info for all groups.\n\n    change({group: 1, recursive:false, logLevel: \"Warn\"})\n      ** Change logLevel for group 1 to Warn.\n\n    change({group: \"all\", logLevel: \"Debug\", logFormat: \"YearDayMonthTime\", showTimestamp:false, showLoggerName:false})\n      ** Change loglevel to Debug for all groups, apply format, do not show timestamp and logger names.\n";
    return LoggerFactoryControlImpl;
}());
//# sourceMappingURL=LogGroupControl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js":
/*!************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var CategoryService_1 = __webpack_require__(/*! ../log/category/CategoryService */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js");
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var MessageUtils_1 = __webpack_require__(/*! ../utils/MessageUtils */ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js");
var ExtensionHelper = (function () {
    function ExtensionHelper() {
        // Private constructor
    }
    /**
     * Enables the window event listener to listen to messages (from extensions).
     * Can be registered/enabled only once.
     */
    ExtensionHelper.register = function () {
        if (!ExtensionHelper.registered) {
            var listener = function (evt) {
                var msg = evt.data;
                if (msg !== null) {
                    ExtensionHelper.processMessageFromExtension(msg);
                }
            };
            if (typeof window !== "undefined" && typeof window.removeEventListener !== "undefined" && typeof window.addEventListener !== "undefined") {
                window.removeEventListener("message", listener);
                window.addEventListener("message", listener);
                ExtensionHelper.registered = true;
            }
        }
    };
    ExtensionHelper.processMessageFromExtension = function (msg) {
        if (!ExtensionHelper.registered) {
            return;
        }
        /* tslint:disable:no-console */
        if (msg.from === "tsl-extension") {
            var data = msg.data;
            switch (data.type) {
                case "register":
                    ExtensionHelper.enableExtensionIntegration();
                    break;
                case "request-change-loglevel":
                    var valueRequest = data.value;
                    var catsApplied = ExtensionHelper.applyLogLevel(valueRequest.categoryId, valueRequest.logLevel, valueRequest.recursive);
                    if (catsApplied.length > 0) {
                        // Send changes back
                        ExtensionHelper.sendCategoriesRuntimeUpdateMessage(catsApplied);
                    }
                    break;
                default:
                    console.log("Unknown command to process message from extension, command was: " + data.type);
                    break;
            }
        }
        /* tslint:enable:no-console */
    };
    ExtensionHelper.sendCategoryLogMessage = function (msg) {
        if (!ExtensionHelper.registered) {
            return;
        }
        var categoryIds = msg.categories.map(function (cat) {
            return cat.id;
        });
        var content = {
            type: "log-message",
            value: {
                categories: categoryIds,
                errorAsStack: msg.errorAsStack,
                formattedMessage: MessageUtils_1.MessageFormatUtils.renderDefaultMessage(msg, false),
                logLevel: LoggerOptions_1.LogLevel[msg.level].toString(),
                message: msg.messageAsString,
                resolvedErrorMessage: msg.isResolvedErrorMessage
            }
        };
        var message = {
            data: content,
            from: "tsl-logging",
        };
        ExtensionHelper.sendMessage(message);
    };
    ExtensionHelper.sendCategoriesRuntimeUpdateMessage = function (categories) {
        if (!ExtensionHelper.registered) {
            return;
        }
        var service = CategoryService_1.CategoryServiceImpl.getInstance();
        var catLevels = { categories: Array() };
        categories.forEach(function (cat) {
            var catSettings = service.getCategorySettings(cat);
            if (catSettings != null) {
                catLevels.categories.push({ id: cat.id, logLevel: LoggerOptions_1.LogLevel[catSettings.logLevel].toString() });
            }
        });
        var content = {
            type: "categories-rt-update",
            value: catLevels,
        };
        var message = {
            data: content,
            from: "tsl-logging"
        };
        ExtensionHelper.sendMessage(message);
    };
    ExtensionHelper.sendRootCategoriesToExtension = function () {
        if (!ExtensionHelper.registered) {
            return;
        }
        var categories = CategoryService_1.CategoryServiceImpl.getInstance().getRootCategories().map(function (cat) {
            return ExtensionHelper.getCategoryAsJSON(cat);
        });
        var content = {
            type: "root-categories-tree",
            value: categories
        };
        var message = {
            data: content,
            from: "tsl-logging"
        };
        ExtensionHelper.sendMessage(message);
    };
    /**
     * If extension integration is enabled, will send the root categories over to the extension.
     * Otherwise does nothing.
     */
    ExtensionHelper.getCategoryAsJSON = function (cat) {
        var childCategories = cat.children.map(function (child) {
            return ExtensionHelper.getCategoryAsJSON(child);
        });
        return {
            children: childCategories,
            id: cat.id,
            logLevel: LoggerOptions_1.LogLevel[cat.logLevel].toString(),
            name: cat.name,
            parentId: (cat.parent != null ? cat.parent.id : null),
        };
    };
    ExtensionHelper.applyLogLevel = function (categoryId, logLevel, recursive) {
        var cats = [];
        var category = CategoryService_1.CategoryServiceImpl.getInstance().getCategoryById(categoryId);
        if (category != null) {
            ExtensionHelper._applyLogLevelRecursive(category, LoggerOptions_1.LogLevel.fromString(logLevel), recursive, cats);
        }
        else {
            /* tslint:disable:no-console */
            console.log("Could not change log level, failed to find category with id: " + categoryId);
            /* tslint:enable:no-console */
        }
        return cats;
    };
    ExtensionHelper._applyLogLevelRecursive = function (category, logLevel, recursive, cats) {
        var categorySettings = CategoryService_1.CategoryServiceImpl.getInstance().getCategorySettings(category);
        if (categorySettings != null) {
            categorySettings.logLevel = logLevel;
            cats.push(category);
            if (recursive) {
                category.children.forEach(function (child) {
                    ExtensionHelper._applyLogLevelRecursive(child, logLevel, recursive, cats);
                });
            }
        }
    };
    ExtensionHelper.getAllCategories = function () {
        var cats = [];
        var addCats = function (cat, allCats) {
            allCats.push(cat);
            cat.children.forEach(function (catChild) {
                addCats(catChild, allCats);
            });
        };
        CategoryService_1.CategoryServiceImpl.getInstance().getRootCategories().forEach(function (cat) {
            addCats(cat, cats);
        });
        return cats;
    };
    ExtensionHelper.sendMessage = function (msg) {
        if (!ExtensionHelper.registered) {
            return;
        }
        if (typeof window !== "undefined" && typeof window.postMessage !== "undefined") {
            window.postMessage(msg, "*");
        }
    };
    /**
     *  Extension framework will call this to enable the integration between two,
     *  after this call the framework will respond with postMessage() messages.
     */
    ExtensionHelper.enableExtensionIntegration = function () {
        if (!ExtensionHelper.registered) {
            return;
        }
        var instance = CategoryService_1.CategoryServiceImpl.getInstance();
        instance.enableExtensionIntegration();
        // Send over all categories
        ExtensionHelper.sendRootCategoriesToExtension();
        // Send over the current runtime levels
        var cats = ExtensionHelper.getAllCategories();
        ExtensionHelper.sendCategoriesRuntimeUpdateMessage(cats);
    };
    ExtensionHelper.registered = false;
    return ExtensionHelper;
}());
exports.ExtensionHelper = ExtensionHelper;
//# sourceMappingURL=ExtensionHelper.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js":
/*!****************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Log level for a logger.
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Trace"] = 0] = "Trace";
    LogLevel[LogLevel["Debug"] = 1] = "Debug";
    LogLevel[LogLevel["Info"] = 2] = "Info";
    LogLevel[LogLevel["Warn"] = 3] = "Warn";
    LogLevel[LogLevel["Error"] = 4] = "Error";
    LogLevel[LogLevel["Fatal"] = 5] = "Fatal";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/* tslint:disable:no-namespace */
(function (LogLevel) {
    /**
     * Returns LogLevel based on string representation
     * @param val Value
     * @returns {LogLevel}, Error is thrown if invalid.
     */
    function fromString(val) {
        if (val == null) {
            throw new Error("Argument must be set");
        }
        switch (val.toLowerCase()) {
            case "trace":
                return LogLevel.Trace;
            case "debug":
                return LogLevel.Debug;
            case "info":
                return LogLevel.Info;
            case "warn":
                return LogLevel.Warn;
            case "error":
                return LogLevel.Error;
            case "fatal":
                return LogLevel.Fatal;
            default:
                throw new Error("Unsupported value for conversion: " + val);
        }
    }
    LogLevel.fromString = fromString;
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
/* tslint:disable:enable-namespace */
/**
 * Where to log to? Pick one of the constants. Custom requires a callback to be present, see LFService.createLoggerFactory(...)
 * where this comes into play.
 */
var LoggerType;
(function (LoggerType) {
    LoggerType[LoggerType["Console"] = 0] = "Console";
    LoggerType[LoggerType["MessageBuffer"] = 1] = "MessageBuffer";
    LoggerType[LoggerType["Custom"] = 2] = "Custom";
})(LoggerType = exports.LoggerType || (exports.LoggerType = {}));
/**
 * Defines several date enums used for formatting a date.
 */
var DateFormatEnum;
(function (DateFormatEnum) {
    /**
     * Displays as: year-month-day hour:minute:second,millis -> 1999-02-12 23:59:59,123
     * Note the date separator can be set separately.
     */
    DateFormatEnum[DateFormatEnum["Default"] = 0] = "Default";
    /**
     * Displays as: year-month-day hour:minute:second -> 1999-02-12 23:59:59
     * Note the date separator can be set separately.
     */
    DateFormatEnum[DateFormatEnum["YearMonthDayTime"] = 1] = "YearMonthDayTime";
    /**
     * Displays as: year-day-month hour:minute:second,millis -> 1999-12-02 23:59:59,123
     * Note the date separator can be set separately.
     */
    DateFormatEnum[DateFormatEnum["YearDayMonthWithFullTime"] = 2] = "YearDayMonthWithFullTime";
    /**
     * Displays as: year-day-month hour:minute:second -> 1999-12-02 23:59:59
     * Note the date separator can be set separately.
     */
    DateFormatEnum[DateFormatEnum["YearDayMonthTime"] = 3] = "YearDayMonthTime";
})(DateFormatEnum = exports.DateFormatEnum || (exports.DateFormatEnum = {}));
/* tslint:disable:no-namespace */
(function (DateFormatEnum) {
    /**
     * Returns LogLevel based on string representation
     * @param val Value
     * @returns {LogLevel}, Error is thrown if invalid.
     */
    function fromString(val) {
        if (val == null) {
            throw new Error("Argument must be set");
        }
        switch (val.toLowerCase()) {
            case "default":
                return DateFormatEnum.Default;
            case "yearmonthdayTime":
                return DateFormatEnum.YearMonthDayTime;
            case "yeardaymonthwithfulltime":
                return DateFormatEnum.YearDayMonthWithFullTime;
            case "yeardaymonthtime":
                return DateFormatEnum.YearDayMonthTime;
            default:
                throw new Error("Unsupported value for conversion: " + val);
        }
    }
    DateFormatEnum.fromString = fromString;
})(DateFormatEnum = exports.DateFormatEnum || (exports.DateFormatEnum = {}));
/* tslint:disable:enable-namespace */
/**
 * DateFormat class, stores data on how to format a date.
 */
var DateFormat = (function () {
    /**
     * Constructor to define the dateformat used for logging, can be called empty as it uses defaults.
     * @param formatEnum DateFormatEnum, use one of the constants from the enum. Defaults to DateFormatEnum.Default
     * @param dateSeparator Separator used between dates, defaults to -
     */
    function DateFormat(formatEnum, dateSeparator) {
        if (formatEnum === void 0) { formatEnum = DateFormatEnum.Default; }
        if (dateSeparator === void 0) { dateSeparator = "-"; }
        this._formatEnum = formatEnum;
        this._dateSeparator = dateSeparator;
    }
    Object.defineProperty(DateFormat.prototype, "formatEnum", {
        get: function () {
            return this._formatEnum;
        },
        set: function (value) {
            this._formatEnum = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateFormat.prototype, "dateSeparator", {
        get: function () {
            return this._dateSeparator;
        },
        set: function (value) {
            this._dateSeparator = value;
        },
        enumerable: true,
        configurable: true
    });
    DateFormat.prototype.copy = function () {
        return new DateFormat(this._formatEnum, this._dateSeparator);
    };
    return DateFormat;
}());
exports.DateFormat = DateFormat;
/**
 * Information about the log format, what will a log line look like?
 */
var LogFormat = (function () {
    /**
     * Constructor to create a LogFormat. Can be created without parameters where it will use sane defaults.
     * @param dateFormat DateFormat (what needs the date look like in the log line)
     * @param showTimeStamp Show date timestamp at all?
     * @param showLoggerName Show the logger name?
     */
    function LogFormat(dateFormat, showTimeStamp, showLoggerName) {
        if (dateFormat === void 0) { dateFormat = new DateFormat(); }
        if (showTimeStamp === void 0) { showTimeStamp = true; }
        if (showLoggerName === void 0) { showLoggerName = true; }
        this._showTimeStamp = true;
        this._showLoggerName = true;
        this._dateFormat = dateFormat;
        this._showTimeStamp = showTimeStamp;
        this._showLoggerName = showLoggerName;
    }
    Object.defineProperty(LogFormat.prototype, "dateFormat", {
        get: function () {
            return this._dateFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogFormat.prototype, "showTimeStamp", {
        get: function () {
            return this._showTimeStamp;
        },
        set: function (value) {
            this._showTimeStamp = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogFormat.prototype, "showLoggerName", {
        get: function () {
            return this._showLoggerName;
        },
        set: function (value) {
            this._showLoggerName = value;
        },
        enumerable: true,
        configurable: true
    });
    return LogFormat;
}());
exports.LogFormat = LogFormat;
/**
 * Information about the log format, what will a log line look like?
 */
var CategoryLogFormat = (function () {
    /**
     * Create an instance defining the category log format used.
     * @param dateFormat Date format (uses default), for details see DateFormat class.
     * @param showTimeStamp True to show timestamp in the logging, defaults to true.
     * @param showCategoryName True to show category name in the logging, defaults to true.
     */
    function CategoryLogFormat(dateFormat, showTimeStamp, showCategoryName) {
        if (dateFormat === void 0) { dateFormat = new DateFormat(); }
        if (showTimeStamp === void 0) { showTimeStamp = true; }
        if (showCategoryName === void 0) { showCategoryName = true; }
        this._dateFormat = dateFormat;
        this._showTimeStamp = showTimeStamp;
        this._showCategoryName = showCategoryName;
    }
    Object.defineProperty(CategoryLogFormat.prototype, "dateFormat", {
        get: function () {
            return this._dateFormat;
        },
        set: function (value) {
            this._dateFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogFormat.prototype, "showTimeStamp", {
        get: function () {
            return this._showTimeStamp;
        },
        set: function (value) {
            this._showTimeStamp = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogFormat.prototype, "showCategoryName", {
        get: function () {
            return this._showCategoryName;
        },
        set: function (value) {
            this._showCategoryName = value;
        },
        enumerable: true,
        configurable: true
    });
    CategoryLogFormat.prototype.copy = function () {
        return new CategoryLogFormat(this._dateFormat.copy(), this._showTimeStamp, this._showCategoryName);
    };
    return CategoryLogFormat;
}());
exports.CategoryLogFormat = CategoryLogFormat;
//# sourceMappingURL=LoggerOptions.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var MessageUtils_1 = __webpack_require__(/*! ../../utils/MessageUtils */ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var CategoryLogMessageImpl = (function () {
    function CategoryLogMessageImpl(message, error, categories, date, level, logFormat, ready) {
        this._resolvedErrorMessage = false;
        this._errorAsStack = null;
        this._message = message;
        this._error = error;
        this._categories = categories;
        this._date = date;
        this._level = level;
        this._logFormat = logFormat;
        this._ready = ready;
    }
    Object.defineProperty(CategoryLogMessageImpl.prototype, "message", {
        get: function () {
            return this._message;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "error", {
        get: function () {
            return this._error;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "categories", {
        get: function () {
            return this._categories;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "date", {
        get: function () {
            return this._date;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "level", {
        get: function () {
            return this._level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "isMessageLogData", {
        get: function () {
            return typeof (this._message) !== "string";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "messageAsString", {
        get: function () {
            if (typeof (this._message) === "string") {
                return this._message;
            }
            return this._message.msg;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "logData", {
        get: function () {
            var result = null;
            if (typeof (this._message) !== "string") {
                result = this.message;
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "isResolvedErrorMessage", {
        get: function () {
            return this._resolvedErrorMessage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryLogMessageImpl.prototype, "errorAsStack", {
        get: function () {
            return this._errorAsStack;
        },
        set: function (stack) {
            this._errorAsStack = stack;
        },
        enumerable: true,
        configurable: true
    });
    CategoryLogMessageImpl.prototype.isReady = function () {
        return this._ready;
    };
    CategoryLogMessageImpl.prototype.setReady = function (value) {
        this._ready = value;
    };
    Object.defineProperty(CategoryLogMessageImpl.prototype, "resolvedErrorMessage", {
        get: function () {
            return this._resolvedErrorMessage;
        },
        set: function (value) {
            this._resolvedErrorMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    return CategoryLogMessageImpl;
}());
/**
 * Abstract category logger, use as your base class for new type of loggers (it
 * saves you a lot of work) and override doLog(CategoryLogMessage). The message argument
 * provides full access to anything related to the logging event.
 * If you just want the standard line of logging, call: this.createDefaultLogMessage(msg) on
 * this class which will return you the formatted log message as string (e.g. the
 * default loggers all use this).
 */
var AbstractCategoryLogger = (function () {
    function AbstractCategoryLogger(rootCategory, runtimeSettings) {
        this.allMessages = new DataStructures_1.LinkedList();
        this.rootCategory = rootCategory;
        this.runtimeSettings = runtimeSettings;
    }
    AbstractCategoryLogger.prototype.trace = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Trace, msg, null, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.debug = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Debug, msg, null, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.info = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Info, msg, null, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.warn = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Warn, msg, null, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.error = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Error, msg, error, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.fatal = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Fatal, msg, error, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.resolved = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this._log.apply(this, [LoggerOptions_1.LogLevel.Error, msg, error, true].concat(categories));
    };
    AbstractCategoryLogger.prototype.log = function (level, msg, error) {
        var categories = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            categories[_i - 3] = arguments[_i];
        }
        this._log.apply(this, [level, msg, error, false].concat(categories));
    };
    AbstractCategoryLogger.prototype.getRootCategory = function () {
        return this.rootCategory;
    };
    AbstractCategoryLogger.prototype.createDefaultLogMessage = function (msg) {
        return MessageUtils_1.MessageFormatUtils.renderDefaultMessage(msg, true);
    };
    /**
     * Return optional message formatter. All LoggerTypes (except custom) will see if
     * they have this, and if so use it to log.
     * @returns {((message:CategoryLogMessage)=>string)|null}
     */
    AbstractCategoryLogger.prototype._getMessageFormatter = function () {
        var categorySettings = this.runtimeSettings.getCategorySettings(this.rootCategory);
        // Should not happen but make ts happy
        if (categorySettings === null) {
            throw new Error("Did not find CategorySettings for rootCategory: " + this.rootCategory.name);
        }
        return categorySettings.formatterLogMessage;
    };
    AbstractCategoryLogger.prototype._log = function (level, msg, error, resolved) {
        if (error === void 0) { error = null; }
        if (resolved === void 0) { resolved = false; }
        var categories = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            categories[_i - 4] = arguments[_i];
        }
        // this._logInternal(level, () => msg, () => error, resolved, ...categories);
        var functionMessage = function () {
            if (typeof msg === "function") {
                return msg();
            }
            return msg;
        };
        var functionError = function () {
            if (typeof error === "function") {
                return error();
            }
            return error;
        };
        this._logInternal.apply(this, [level, functionMessage, functionError, resolved].concat(categories));
    };
    AbstractCategoryLogger.prototype._logInternal = function (level, msg, error, resolved) {
        var _this = this;
        var categories = [];
        for (var _i = 4; _i < arguments.length; _i++) {
            categories[_i - 4] = arguments[_i];
        }
        var logCategories = [this.rootCategory];
        // Log root category by default if none present
        if (typeof categories !== "undefined" && categories.length > 0) {
            logCategories = logCategories.concat(categories.filter(function (c) { return c !== _this.rootCategory; }));
        }
        var _loop_1 = function (i) {
            var category = logCategories[i];
            if (category === null) {
                throw new Error("Cannot have a null element within categories, at index=" + i);
            }
            var settings = this_1.runtimeSettings.getCategorySettings(category);
            if (settings === null) {
                throw new Error("Category with path: " + category.getCategoryPath() + " is not registered with this logger, maybe " +
                    "you registered it with a different root logger?");
            }
            if (settings.logLevel <= level) {
                var actualError = error !== null ? error() : null;
                if (actualError === null) {
                    var logMessage = new CategoryLogMessageImpl(msg(), actualError, logCategories, new Date(), level, settings.logFormat, true);
                    logMessage.resolvedErrorMessage = resolved;
                    this_1.allMessages.addTail(logMessage);
                    this_1.processMessages();
                }
                else {
                    var logMessage_1 = new CategoryLogMessageImpl(msg(), actualError, logCategories, new Date(), level, settings.logFormat, false);
                    logMessage_1.resolvedErrorMessage = resolved;
                    this_1.allMessages.addTail(logMessage_1);
                    MessageUtils_1.MessageFormatUtils.renderError(actualError).then(function (stack) {
                        logMessage_1.errorAsStack = stack;
                        logMessage_1.setReady(true);
                        _this.processMessages();
                    }).catch(function () {
                        logMessage_1.errorAsStack = "<UNKNOWN> unable to get stack.";
                        logMessage_1.setReady(true);
                        _this.processMessages();
                    });
                }
                return "break";
            }
        };
        var this_1 = this;
        // Get the runtime levels for given categories. If their level is lower than given level, we log.
        // In addition we pass along which category/categories we log this statement for.
        for (var i = 0; i < logCategories.length; i++) {
            var state_1 = _loop_1(i);
            if (state_1 === "break")
                break;
        }
    };
    AbstractCategoryLogger.prototype.processMessages = function () {
        // Basically we wait until errors are resolved (those messages
        // may not be ready).
        var msgs = this.allMessages;
        if (msgs.getSize() > 0) {
            do {
                var msg = msgs.getHead();
                if (msg != null) {
                    if (!msg.isReady()) {
                        break;
                    }
                    msgs.removeHead();
                    this.doLog(msg);
                }
            } while (msgs.getSize() > 0);
        }
    };
    return AbstractCategoryLogger;
}());
exports.AbstractCategoryLogger = AbstractCategoryLogger;
//# sourceMappingURL=AbstractCategoryLogger.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/Category.js":
/*!********************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/Category.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var CategoryService_1 = __webpack_require__(/*! ./CategoryService */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js");
/**
 * Category for use with categorized logging.
 * At minimum you need one category, which will serve as the root category.
 * You can create child categories (like a tree). You can have multiple root
 * categories.
 */
var Category = (function () {
    function Category(name, parent) {
        if (parent === void 0) { parent = null; }
        this._children = [];
        this._logLevel = LoggerOptions_1.LogLevel.Error;
        if (name.indexOf("#") !== -1) {
            throw new Error("Cannot use # in a name of a Category");
        }
        this._id = Category.nextId();
        this._name = name;
        this._parent = parent;
        if (this._parent !== null) {
            this._parent._children.push(this);
        }
        CategoryService_1.CategoryServiceImpl.getInstance().registerCategory(this);
    }
    Object.defineProperty(Category.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Category.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Category.prototype, "children", {
        get: function () {
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Category.prototype, "logLevel", {
        get: function () {
            return this._logLevel;
        },
        enumerable: true,
        configurable: true
    });
    Category.prototype.trace = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).trace.apply(_a, [msg].concat(categories));
        var _a;
    };
    Category.prototype.debug = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).debug.apply(_a, [msg].concat(categories));
        var _a;
    };
    Category.prototype.info = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).info.apply(_a, [msg].concat(categories));
        var _a;
    };
    Category.prototype.warn = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).warn.apply(_a, [msg].concat(categories));
        var _a;
    };
    Category.prototype.error = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).error.apply(_a, [msg, error].concat(categories));
        var _a;
    };
    Category.prototype.fatal = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).fatal.apply(_a, [msg, error].concat(categories));
        var _a;
    };
    Category.prototype.resolved = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).resolved.apply(_a, [msg, error].concat(categories));
        var _a;
    };
    Category.prototype.log = function (level, msg, error) {
        var categories = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            categories[_i - 3] = arguments[_i];
        }
        this.loadCategoryLogger();
        (_a = this._logger).log.apply(_a, [level, msg, error].concat(categories));
        var _a;
    };
    Category.prototype.getCategoryPath = function () {
        var result = this.name;
        var cat = this.parent;
        while (cat != null) {
            result = cat.name + "#" + result;
            cat = cat.parent;
        }
        return result;
    };
    Object.defineProperty(Category.prototype, "id", {
        /**
         * Returns the id for this category (this
         * is for internal purposes only).
         * @returns {number} Id
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Category.prototype.loadCategoryLogger = function () {
        if (!this._logger) {
            this._logger = CategoryService_1.CategoryServiceImpl.getInstance().getLogger(this);
        }
        if (typeof this._logger === "undefined" || this._logger === null) {
            throw new Error("Failed to load a logger for category (should not happen): " + this.name);
        }
    };
    Category.nextId = function () {
        return Category.currentId++;
    };
    Category.currentId = 1;
    return Category;
}());
exports.Category = Category;
//# sourceMappingURL=Category.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConfiguration.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConfiguration.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Default configuration, can be used to initially set a different default configuration
 * on the CategoryServiceFactory. This will be applied to all categories already registered (or
 * registered in the future). Can also be applied to one Category (and childs).
 */
var CategoryConfiguration = (function () {
    /**
     * Create a new instance
     * @param logLevel Log level for all loggers, default is LogLevel.Error
     * @param loggerType Where to log, default is LoggerType.Console
     * @param logFormat What logging format to use, use default instance, for default values see CategoryLogFormat.
     * @param callBackLogger Optional callback, if LoggerType.Custom is used as loggerType. In that case must return a new Logger instance.
     *            It is recommended to extend AbstractCategoryLogger to make your custom logger.
     */
    function CategoryConfiguration(logLevel, loggerType, logFormat, callBackLogger) {
        if (logLevel === void 0) { logLevel = LoggerOptions_1.LogLevel.Error; }
        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }
        if (logFormat === void 0) { logFormat = new LoggerOptions_1.CategoryLogFormat(); }
        if (callBackLogger === void 0) { callBackLogger = null; }
        this._formatterLogMessage = null;
        this._logLevel = logLevel;
        this._loggerType = loggerType;
        this._logFormat = logFormat;
        this._callBackLogger = callBackLogger;
        if (this._loggerType === LoggerOptions_1.LoggerType.Custom && this.callBackLogger === null) {
            throw new Error("If you specify loggerType to be Custom, you must provide the callBackLogger argument");
        }
    }
    Object.defineProperty(CategoryConfiguration.prototype, "logLevel", {
        get: function () {
            return this._logLevel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryConfiguration.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryConfiguration.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryConfiguration.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryConfiguration.prototype, "formatterLogMessage", {
        /**
         * Get the formatterLogMessage function, see comment on the setter.
         * @returns {((message:CategoryLogMessage)=>string)|null}
         */
        get: function () {
            return this._formatterLogMessage;
        },
        /**
         * Set the default formatterLogMessage function, if set it is applied to all type of loggers except for a custom logger.
         * By default this is null (not set). You can assign a function to allow custom formatting of a log message.
         * Each log message will call this function then and expects your function to format the message and return a string.
         * Will throw an error if you attempt to set a formatterLogMessage if the LoggerType is custom.
         * @param value The formatter function, or null to reset it.
         */
        set: function (value) {
            if (value !== null && this._loggerType === LoggerOptions_1.LoggerType.Custom) {
                throw new Error("You cannot specify a formatter for log messages if your loggerType is Custom");
            }
            this._formatterLogMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    CategoryConfiguration.prototype.copy = function () {
        var config = new CategoryConfiguration(this.logLevel, this.loggerType, this.logFormat.copy(), this.callBackLogger);
        config.formatterLogMessage = this.formatterLogMessage;
        return config;
    };
    return CategoryConfiguration;
}());
exports.CategoryConfiguration = CategoryConfiguration;
//# sourceMappingURL=CategoryConfiguration.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConsoleLoggerImpl.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConsoleLoggerImpl.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var AbstractCategoryLogger_1 = __webpack_require__(/*! ./AbstractCategoryLogger */ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js");
/**
 * Simple logger, that logs to the console. If the console is unavailable will throw an exception.
 */
var CategoryConsoleLoggerImpl = (function (_super) {
    __extends(CategoryConsoleLoggerImpl, _super);
    function CategoryConsoleLoggerImpl(rootCategory, runtimeSettings) {
        return _super.call(this, rootCategory, runtimeSettings) || this;
    }
    CategoryConsoleLoggerImpl.prototype.doLog = function (msg) {
        if (console !== undefined) {
            var messageFormatter = this._getMessageFormatter();
            var fullMsg = void 0;
            if (messageFormatter === null) {
                fullMsg = this.createDefaultLogMessage(msg);
            }
            else {
                fullMsg = messageFormatter(msg);
            }
            var logged = false;
            /* tslint:disable:no-console */
            switch (msg.level) {
                case LoggerOptions_1.LogLevel.Trace:
                    // Don't try trace we don't want stacks
                    break;
                case LoggerOptions_1.LogLevel.Debug:
                    // Don't try, too much differences of consoles.
                    break;
                case LoggerOptions_1.LogLevel.Info:
                    if (console.info) {
                        console.info(fullMsg);
                        logged = true;
                    }
                    break;
                case LoggerOptions_1.LogLevel.Warn:
                    if (console.warn) {
                        console.warn(fullMsg);
                        logged = true;
                    }
                    break;
                case LoggerOptions_1.LogLevel.Error:
                case LoggerOptions_1.LogLevel.Fatal:
                    if (console.error) {
                        console.error(fullMsg);
                        logged = true;
                    }
                    break;
                default:
                    throw new Error("Unsupported level: " + msg.level);
            }
            if (!logged) {
                console.log(fullMsg);
            }
            /* tslint:enable:no-console */
        }
        else {
            throw new Error("Console is not defined, cannot log msg: " + msg.messageAsString);
        }
    };
    return CategoryConsoleLoggerImpl;
}(AbstractCategoryLogger_1.AbstractCategoryLogger));
exports.CategoryConsoleLoggerImpl = CategoryConsoleLoggerImpl;
//# sourceMappingURL=CategoryConsoleLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryDelegateLoggerImpl.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryDelegateLoggerImpl.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Delegate logger, delegates logging to given logger (constructor).
 */
var CategoryDelegateLoggerImpl = (function () {
    function CategoryDelegateLoggerImpl(delegate) {
        this._delegate = delegate;
    }
    Object.defineProperty(CategoryDelegateLoggerImpl.prototype, "delegate", {
        get: function () {
            return this._delegate;
        },
        set: function (value) {
            this._delegate = value;
        },
        enumerable: true,
        configurable: true
    });
    CategoryDelegateLoggerImpl.prototype.trace = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        (_a = this._delegate).trace.apply(_a, [msg].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.debug = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        (_a = this._delegate).debug.apply(_a, [msg].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.info = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        (_a = this._delegate).info.apply(_a, [msg].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.warn = function (msg) {
        var categories = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            categories[_i - 1] = arguments[_i];
        }
        (_a = this._delegate).warn.apply(_a, [msg].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.error = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        (_a = this._delegate).error.apply(_a, [msg, error].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.fatal = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        (_a = this._delegate).fatal.apply(_a, [msg, error].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.resolved = function (msg, error) {
        var categories = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            categories[_i - 2] = arguments[_i];
        }
        (_a = this._delegate).resolved.apply(_a, [msg, error].concat(categories));
        var _a;
    };
    CategoryDelegateLoggerImpl.prototype.log = function (level, msg, error) {
        var categories = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            categories[_i - 3] = arguments[_i];
        }
        (_a = this._delegate).log.apply(_a, [level, msg, error].concat(categories));
        var _a;
    };
    return CategoryDelegateLoggerImpl;
}());
exports.CategoryDelegateLoggerImpl = CategoryDelegateLoggerImpl;
//# sourceMappingURL=CategoryDelegateLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryExtensionLoggerImpl.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryExtensionLoggerImpl.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ExtensionHelper_1 = __webpack_require__(/*! ../../extension/ExtensionHelper */ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js");
var AbstractCategoryLogger_1 = __webpack_require__(/*! ./AbstractCategoryLogger */ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js");
/**
 * This class should not be used directly, it is used for communication with the extension only.
 */
var CategoryExtensionLoggerImpl = (function (_super) {
    __extends(CategoryExtensionLoggerImpl, _super);
    function CategoryExtensionLoggerImpl(rootCategory, runtimeSettings) {
        return _super.call(this, rootCategory, runtimeSettings) || this;
    }
    CategoryExtensionLoggerImpl.prototype.doLog = function (msg) {
        if (typeof window !== "undefined") {
            ExtensionHelper_1.ExtensionHelper.sendCategoryLogMessage(msg);
        }
        else {
            /* tslint:disable:no-console */
            console.log("window is not available, you must be running in a browser for this. Dropped message.");
            /* tslint:enable:no-console */
        }
    };
    return CategoryExtensionLoggerImpl;
}(AbstractCategoryLogger_1.AbstractCategoryLogger));
exports.CategoryExtensionLoggerImpl = CategoryExtensionLoggerImpl;
//# sourceMappingURL=CategoryExtensionLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryMessageBufferImpl.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryMessageBufferImpl.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var AbstractCategoryLogger_1 = __webpack_require__(/*! ./AbstractCategoryLogger */ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js");
/**
 * Logger which buffers all messages, use with care due to possible high memory footprint.
 * Can be convenient in some cases. Call toString() for full output, or cast to this class
 * and call getMessages() to do something with it yourself.
 */
var CategoryMessageBufferLoggerImpl = (function (_super) {
    __extends(CategoryMessageBufferLoggerImpl, _super);
    function CategoryMessageBufferLoggerImpl() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.messages = [];
        return _this;
    }
    CategoryMessageBufferLoggerImpl.prototype.getMessages = function () {
        return this.messages;
    };
    CategoryMessageBufferLoggerImpl.prototype.toString = function () {
        return this.messages.map(function (msg) {
            return msg;
        }).join("\n");
    };
    CategoryMessageBufferLoggerImpl.prototype.doLog = function (msg) {
        var messageFormatter = this._getMessageFormatter();
        var fullMsg;
        if (messageFormatter === null) {
            fullMsg = this.createDefaultLogMessage(msg);
        }
        else {
            fullMsg = messageFormatter(msg);
        }
        this.messages.push(fullMsg);
    };
    return CategoryMessageBufferLoggerImpl;
}(AbstractCategoryLogger_1.AbstractCategoryLogger));
exports.CategoryMessageBufferLoggerImpl = CategoryMessageBufferLoggerImpl;
//# sourceMappingURL=CategoryMessageBufferImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryRuntimeSettings.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryRuntimeSettings.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * RuntimeSettings for a category, at runtime these are associated to a category.
 */
var CategoryRuntimeSettings = (function () {
    function CategoryRuntimeSettings(category, logLevel, loggerType, logFormat, callBackLogger, formatterLogMessage) {
        if (logLevel === void 0) { logLevel = LoggerOptions_1.LogLevel.Error; }
        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }
        if (logFormat === void 0) { logFormat = new LoggerOptions_1.CategoryLogFormat(); }
        if (callBackLogger === void 0) { callBackLogger = null; }
        if (formatterLogMessage === void 0) { formatterLogMessage = null; }
        this._formatterLogMessage = null;
        this._category = category;
        this._logLevel = logLevel;
        this._loggerType = loggerType;
        this._logFormat = logFormat;
        this._callBackLogger = callBackLogger;
        this._formatterLogMessage = formatterLogMessage;
    }
    Object.defineProperty(CategoryRuntimeSettings.prototype, "category", {
        get: function () {
            return this._category;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "logLevel", {
        get: function () {
            return this._logLevel;
        },
        set: function (value) {
            this._logLevel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        set: function (value) {
            this._loggerType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        set: function (value) {
            this._logFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        set: function (value) {
            this._callBackLogger = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryRuntimeSettings.prototype, "formatterLogMessage", {
        get: function () {
            return this._formatterLogMessage;
        },
        set: function (value) {
            this._formatterLogMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    return CategoryRuntimeSettings;
}());
exports.CategoryRuntimeSettings = CategoryRuntimeSettings;
//# sourceMappingURL=CategoryRuntimeSettings.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var CategoryConsoleLoggerImpl_1 = __webpack_require__(/*! ./CategoryConsoleLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConsoleLoggerImpl.js");
var CategoryDelegateLoggerImpl_1 = __webpack_require__(/*! ./CategoryDelegateLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryDelegateLoggerImpl.js");
var CategoryExtensionLoggerImpl_1 = __webpack_require__(/*! ./CategoryExtensionLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryExtensionLoggerImpl.js");
var CategoryMessageBufferImpl_1 = __webpack_require__(/*! ./CategoryMessageBufferImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryMessageBufferImpl.js");
var ExtensionHelper_1 = __webpack_require__(/*! ../../extension/ExtensionHelper */ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js");
var CategoryRuntimeSettings_1 = __webpack_require__(/*! ./CategoryRuntimeSettings */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryRuntimeSettings.js");
var CategoryConfiguration_1 = __webpack_require__(/*! ./CategoryConfiguration */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConfiguration.js");
/**
 * The service (only available as singleton) for all category related stuff as
 * retrieving, registering a logger. You should normally NOT use this,
 * instead use CategoryServiceFactory which is meant for end users.
 */
var CategoryServiceImpl = (function () {
    function CategoryServiceImpl() {
        this._defaultConfig = new CategoryConfiguration_1.CategoryConfiguration();
        this._mapState = new DataStructures_1.SimpleMap();
        // Private constructor
        ExtensionHelper_1.ExtensionHelper.register();
    }
    CategoryServiceImpl.getInstance = function () {
        // Load on-demand, to assure webpack ordering of module usage doesn't screw things over
        // for us when we accidentally change the order.
        if (CategoryServiceImpl._INSTANCE === null) {
            CategoryServiceImpl._INSTANCE = new CategoryServiceImpl();
        }
        return CategoryServiceImpl._INSTANCE;
    };
    CategoryServiceImpl.prototype.getLogger = function (category) {
        return this.createOrGetCategoryState(category).logger;
    };
    /**
     * Clears everything, including a default configuration you may have set.
     * After this you need to re-register your categories etc.
     */
    CategoryServiceImpl.prototype.clear = function () {
        this._mapState.clear();
        this.setDefaultConfiguration(new CategoryConfiguration_1.CategoryConfiguration());
    };
    CategoryServiceImpl.prototype.getCategorySettings = function (category) {
        return this.createOrGetCategoryState(category).currentRuntimeSettings;
    };
    CategoryServiceImpl.prototype.getOriginalCategorySettings = function (category) {
        return this.createOrGetCategoryState(category).originalRuntimeSettings;
    };
    /**
     * Set the default configuration. New root loggers created get this
     * applied. If you want to reset all current loggers to have this
     * applied as well, pass in reset=true (the default is false). All
     * categories will be reset then as well.
     * @param config New config
     * @param reset Defaults to true. Set to true to reset all loggers and current runtimesettings.
     */
    CategoryServiceImpl.prototype.setDefaultConfiguration = function (config, reset) {
        if (reset === void 0) { reset = true; }
        this._defaultConfig = config;
        if (reset) {
            this._mapState.forEachValue(function (state) {
                state.updateSettings(config);
            });
        }
    };
    /**
     * Set new configuration settings for a category (and possibly its child categories)
     * @param config Config
     * @param category Category
     * @param applyChildren True to apply to child categories, defaults to false.
     */
    CategoryServiceImpl.prototype.setConfigurationCategory = function (config, category, applyChildren) {
        var _this = this;
        if (applyChildren === void 0) { applyChildren = false; }
        this.createOrGetCategoryState(category).updateSettings(config);
        // Apply the settings to children recursive if requested
        if (applyChildren) {
            category.children.forEach(function (child) {
                // False flag, a child cannot reset a rootlogger
                _this.setConfigurationCategory(config, child, applyChildren);
            });
        }
    };
    CategoryServiceImpl.prototype.registerCategory = function (category) {
        if (category === null || typeof category === "undefined") {
            throw new Error("Category CANNOT be null/undefined");
        }
        if (this._mapState.exists(CategoryServiceImpl.getCategoryKey(category))) {
            throw new Error("Cannot add this root category with name: " + category.name + ", it already exists (same name in hierarchy).");
        }
        this.createOrGetCategoryState(category);
    };
    /**
     * Used to enable integration with chrome extension. Do not use manually, the
     * extension and the logger framework deal with this.
     */
    CategoryServiceImpl.prototype.enableExtensionIntegration = function () {
        var _this = this;
        this._mapState.forEachValue(function (state) { return state.enableForExtension(_this); });
    };
    /**
     * Return all root categories currently registered.
     */
    CategoryServiceImpl.prototype.getRootCategories = function () {
        return this._mapState.values().filter(function (state) { return state.category.parent == null; }).map(function (state) { return state.category; });
    };
    /**
     * Return Category by id
     * @param id The id of the category to find
     * @returns {Category} or null if not found
     */
    CategoryServiceImpl.prototype.getCategoryById = function (id) {
        var result = this._mapState.values().filter(function (state) { return state.category.id === id; }).map(function (state) { return state.category; });
        if (result.length === 1) {
            return result[0];
        }
        return null;
    };
    CategoryServiceImpl.prototype.createOrGetCategoryState = function (category) {
        var key = CategoryServiceImpl.getCategoryKey(category);
        var state = this._mapState.get(key);
        if (typeof state !== "undefined") {
            return state;
        }
        var newState = this.createState(category);
        this._mapState.put(key, newState);
        return newState;
    };
    CategoryServiceImpl.prototype.createState = function (category) {
        var _this = this;
        return new CategoryState(category, function () { return _this._defaultConfig; }, function (config, cat) { return _this.createLogger(config, cat); });
    };
    CategoryServiceImpl.prototype.createLogger = function (config, category) {
        // Default is always a console logger
        switch (config.loggerType) {
            case LoggerOptions_1.LoggerType.Console:
                return new CategoryConsoleLoggerImpl_1.CategoryConsoleLoggerImpl(category, this);
            case LoggerOptions_1.LoggerType.MessageBuffer:
                return new CategoryMessageBufferImpl_1.CategoryMessageBufferLoggerImpl(category, this);
            case LoggerOptions_1.LoggerType.Custom:
                if (config.callBackLogger === null) {
                    throw new Error("Cannot create custom logger, custom callback is null");
                }
                else {
                    return config.callBackLogger(category, this);
                }
            default:
                throw new Error("Cannot create a Logger for LoggerType: " + config.loggerType);
        }
    };
    CategoryServiceImpl.getCategoryKey = function (category) {
        return category.getCategoryPath();
    };
    // Singleton category service, used by CategoryServiceFactory as well as Categories.
    // Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.
    CategoryServiceImpl._INSTANCE = null;
    return CategoryServiceImpl;
}());
exports.CategoryServiceImpl = CategoryServiceImpl;
var CategoryState = (function () {
    function CategoryState(category, defaultConfig, createLogger) {
        this._category = category;
        this._lazyState = new LazyState(category, defaultConfig, createLogger);
    }
    Object.defineProperty(CategoryState.prototype, "category", {
        get: function () {
            return this._category;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryState.prototype, "logger", {
        get: function () {
            return this._lazyState.getLogger();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryState.prototype, "originalRuntimeSettings", {
        get: function () {
            return this._lazyState.getOriginalRuntimeSettings();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryState.prototype, "currentRuntimeSettings", {
        get: function () {
            return this._lazyState.getCurrentRuntimeSettings();
        },
        enumerable: true,
        configurable: true
    });
    CategoryState.prototype.enableForExtension = function (runtimeSettings) {
        this._lazyState.enableForExtension(runtimeSettings);
    };
    CategoryState.prototype.updateSettings = function (config) {
        this._lazyState.updateSettings(config);
    };
    return CategoryState;
}());
var LazyState = (function () {
    function LazyState(category, defaultConfig, createLogger) {
        this._category = category;
        this._defaultConfig = defaultConfig;
        this._createLogger = createLogger;
    }
    LazyState.prototype.isLoaded = function () {
        return (typeof this._logger !== "undefined");
    };
    LazyState.prototype.getLogger = function () {
        this.loadLoggerOnDemand();
        return this._delegateLogger;
    };
    LazyState.prototype.getOriginalRuntimeSettings = function () {
        this.loadLoggerOnDemand();
        return this._originalRuntimeSettings;
    };
    LazyState.prototype.getCurrentRuntimeSettings = function () {
        this.loadLoggerOnDemand();
        return this._currentRuntimeSettings;
    };
    LazyState.prototype.enableForExtension = function (runtimeSettings) {
        this.loadLoggerOnDemand();
        if (!(this._wrappedLogger instanceof CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl)) {
            /* tslint:disable no-console */
            console.log("Reconfiguring logger for extension for category: " + this._category.name);
            /* tslint:enable no-console */
            this._wrappedLogger = new CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl(this._category, runtimeSettings);
            this._delegateLogger.delegate = this._wrappedLogger;
        }
    };
    LazyState.prototype.updateSettings = function (config) {
        if (this.isLoaded()) {
            this._currentRuntimeSettings.logLevel = config.logLevel;
            this._currentRuntimeSettings.loggerType = config.loggerType;
            this._currentRuntimeSettings.logFormat = config.logFormat;
            this._currentRuntimeSettings.callBackLogger = config.callBackLogger;
            this._currentRuntimeSettings.formatterLogMessage = config.formatterLogMessage;
            // Replace the real logger, it may have changed.
            this._logger = this._createLogger(config, this._category);
            if (!(this._wrappedLogger instanceof CategoryExtensionLoggerImpl_1.CategoryExtensionLoggerImpl)) {
                this._wrappedLogger = this._logger;
            }
            this._delegateLogger.delegate = this._wrappedLogger;
        }
        else {
            // Set this config, it may be for the category specific, the default is therefore not good enough.
            this._defaultConfig = function () { return config; };
        }
    };
    LazyState.prototype.loadLoggerOnDemand = function () {
        if (!this.isLoaded()) {
            this._logger = this._createLogger(this._defaultConfig(), this._category);
            this._wrappedLogger = this._logger;
            this._delegateLogger = new CategoryDelegateLoggerImpl_1.CategoryDelegateLoggerImpl(this._wrappedLogger);
            this._originalRuntimeSettings = this.initNewSettings();
            this._currentRuntimeSettings = this.initNewSettings();
        }
    };
    LazyState.prototype.initNewSettings = function () {
        var defSettings = this._defaultConfig().copy();
        return new CategoryRuntimeSettings_1.CategoryRuntimeSettings(this._category, defSettings.logLevel, defSettings.loggerType, defSettings.logFormat, defSettings.callBackLogger, defSettings.formatterLogMessage);
    };
    return LazyState;
}());
//# sourceMappingURL=CategoryService.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryServiceFactory.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/category/CategoryServiceFactory.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var CategoryService_1 = __webpack_require__(/*! ./CategoryService */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryService.js");
/**
 * Categorized service for logging, where logging is bound to categories which
 * can log horizontally through specific application logic (services, group(s) of components etc).
 * For the standard way of logging like most frameworks do these days, use LFService instead.
 * If you want fine grained control to divide sections of your application in
 * logical units to enable/disable logging for, this is the service you want to use instead.
 * Also for this type a browser plugin will be available.
 */
var CategoryServiceFactory = (function () {
    function CategoryServiceFactory() {
        // Private constructor.
    }
    /**
     * Return a CategoryLogger for given ROOT category (thus has no parent).
     * You can only retrieve loggers for their root, when logging
     * you specify to log for what (child)categories.
     * @param root Category root (has no parent)
     * @returns {CategoryLogger}
     */
    CategoryServiceFactory.getLogger = function (root) {
        return CategoryService_1.CategoryServiceImpl.getInstance().getLogger(root);
    };
    /**
     * Clears everything, any registered (root)categories and loggers
     * are discarded. Resets to default configuration.
     */
    CategoryServiceFactory.clear = function () {
        return CategoryService_1.CategoryServiceImpl.getInstance().clear();
    };
    /**
     * Set the default configuration. New root loggers created get this
     * applied. If you want to reset all current loggers to have this
     * applied as well, pass in reset=true (the default is false). All
     * categories runtimesettings will be reset then as well.
     * @param config The new default configuration
     * @param reset If true, will reset *all* runtimesettings for all loggers/categories to these. Default is true.
     */
    CategoryServiceFactory.setDefaultConfiguration = function (config, reset) {
        if (reset === void 0) { reset = true; }
        CategoryService_1.CategoryServiceImpl.getInstance().setDefaultConfiguration(config, reset);
    };
    /**
     * Set new configuration settings for a category (and possibly its child categories)
     * @param config Config
     * @param category Category
     * @param applyChildren True to apply to child categories, defaults to false.
     */
    CategoryServiceFactory.setConfigurationCategory = function (config, category, applyChildren) {
        if (applyChildren === void 0) { applyChildren = false; }
        CategoryService_1.CategoryServiceImpl.getInstance().setConfigurationCategory(config, category, applyChildren);
    };
    return CategoryServiceFactory;
}());
exports.CategoryServiceFactory = CategoryServiceFactory;
//# sourceMappingURL=CategoryServiceFactory.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var MessageUtils_1 = __webpack_require__(/*! ../../utils/MessageUtils */ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js");
var LogMessageInternalImpl = (function () {
    function LogMessageInternalImpl(loggerName, message, errorAsStack, error, logGroupRule, date, level, ready) {
        this._errorAsStack = null;
        this._error = null;
        this._loggerName = loggerName;
        this._message = message;
        this._errorAsStack = errorAsStack;
        this._error = error;
        this._logGroupRule = logGroupRule;
        this._date = date;
        this._level = level;
        this._ready = ready;
    }
    Object.defineProperty(LogMessageInternalImpl.prototype, "loggerName", {
        get: function () {
            return this._loggerName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "message", {
        get: function () {
            return this._message;
        },
        set: function (value) {
            this._message = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "errorAsStack", {
        get: function () {
            return this._errorAsStack;
        },
        set: function (value) {
            this._errorAsStack = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "error", {
        get: function () {
            return this._error;
        },
        set: function (value) {
            this._error = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "logGroupRule", {
        get: function () {
            return this._logGroupRule;
        },
        set: function (value) {
            this._logGroupRule = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "date", {
        get: function () {
            return this._date;
        },
        set: function (value) {
            this._date = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "level", {
        get: function () {
            return this._level;
        },
        set: function (value) {
            this._level = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "isMessageLogData", {
        get: function () {
            return typeof (this._message) !== "string";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "ready", {
        get: function () {
            return this._ready;
        },
        set: function (value) {
            this._ready = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "messageAsString", {
        get: function () {
            if (typeof (this._message) === "string") {
                return this._message;
            }
            return this._message.msg;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogMessageInternalImpl.prototype, "logData", {
        get: function () {
            var result = null;
            if (typeof (this._message) !== "string") {
                result = this.message;
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    return LogMessageInternalImpl;
}());
/**
 * Abstract base logger, extend to easily implement a custom logger that
 * logs wherever you want. You only need to implement doLog(msg: LogMessage) and
 * log that somewhere (it will contain format and everything else).
 */
var AbstractLogger = (function () {
    function AbstractLogger(name, logGroupRuntimeSettings) {
        this._allMessages = new DataStructures_1.LinkedList();
        this._open = true;
        this._name = name;
        this._logGroupRuntimeSettings = logGroupRuntimeSettings;
    }
    Object.defineProperty(AbstractLogger.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    AbstractLogger.prototype.trace = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Trace, msg, error);
    };
    AbstractLogger.prototype.debug = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Debug, msg, error);
    };
    AbstractLogger.prototype.info = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Info, msg, error);
    };
    AbstractLogger.prototype.warn = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Warn, msg, error);
    };
    AbstractLogger.prototype.error = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Error, msg, error);
    };
    AbstractLogger.prototype.fatal = function (msg, error) {
        if (error === void 0) { error = null; }
        this._log(LoggerOptions_1.LogLevel.Fatal, msg, error);
    };
    AbstractLogger.prototype.isTraceEnabled = function () {
        return this._logGroupRuntimeSettings.level === LoggerOptions_1.LogLevel.Trace;
    };
    AbstractLogger.prototype.isDebugEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Debug;
    };
    AbstractLogger.prototype.isInfoEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Info;
    };
    AbstractLogger.prototype.isWarnEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Warn;
    };
    AbstractLogger.prototype.isErrorEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Error;
    };
    AbstractLogger.prototype.isFatalEnabled = function () {
        return this._logGroupRuntimeSettings.level <= LoggerOptions_1.LogLevel.Fatal;
    };
    AbstractLogger.prototype.getLogLevel = function () {
        return this._logGroupRuntimeSettings.level;
    };
    AbstractLogger.prototype.isOpen = function () {
        return this._open;
    };
    AbstractLogger.prototype.close = function () {
        this._open = false;
        this._allMessages.clear();
    };
    AbstractLogger.prototype.createDefaultLogMessage = function (msg) {
        return MessageUtils_1.MessageFormatUtils.renderDefaultLog4jMessage(msg, true);
    };
    /**
     * Return optional message formatter. All LoggerTypes (except custom) will see if
     * they have this, and if so use it to log.
     * @returns {((message:LogMessage)=>string)|null}
     */
    AbstractLogger.prototype._getMessageFormatter = function () {
        return this._logGroupRuntimeSettings.formatterLogMessage;
    };
    AbstractLogger.prototype._log = function (level, msg, error) {
        if (error === void 0) { error = null; }
        if (this._open && this._logGroupRuntimeSettings.level <= level) {
            var functionMessage = function () {
                if (typeof msg === "function") {
                    return msg();
                }
                return msg;
            };
            var functionError = function () {
                if (typeof error === "function") {
                    return error();
                }
                return error;
            };
            this._allMessages.addTail(this.createMessage(level, functionMessage, functionError, new Date()));
            this.processMessages();
        }
    };
    AbstractLogger.prototype.createMessage = function (level, msg, error, date) {
        var _this = this;
        var errorResult = error();
        if (errorResult !== null) {
            var message_1 = new LogMessageInternalImpl(this._name, msg(), null, errorResult, this._logGroupRuntimeSettings.logGroupRule, date, level, false);
            MessageUtils_1.MessageFormatUtils.renderError(errorResult).then(function (stack) {
                message_1.errorAsStack = stack;
                message_1.ready = true;
                _this.processMessages();
            }).catch(function () {
                message_1.errorAsStack = "<UNKNOWN> unable to get stack.";
                message_1.ready = true;
                _this.processMessages();
            });
            return message_1;
        }
        return new LogMessageInternalImpl(this._name, msg(), null, errorResult, this._logGroupRuntimeSettings.logGroupRule, date, level, true);
    };
    AbstractLogger.prototype.processMessages = function () {
        // Basically we wait until errors are resolved (those messages
        // may not be ready).
        var msgs = this._allMessages;
        if (msgs.getSize() > 0) {
            do {
                var msg = msgs.getHead();
                if (msg != null) {
                    if (!msg.ready) {
                        break;
                    }
                    msgs.removeHead();
                    // This can never be null normally, but strict null checking ...
                    if (msg.message !== null) {
                        this.doLog(msg);
                    }
                }
            } while (msgs.getSize() > 0);
        }
    };
    return AbstractLogger;
}());
exports.AbstractLogger = AbstractLogger;
//# sourceMappingURL=AbstractLogger.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/ConsoleLoggerImpl.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/ConsoleLoggerImpl.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var AbstractLogger_1 = __webpack_require__(/*! ./AbstractLogger */ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Simple logger, that logs to the console. If the console is unavailable will throw exception.
 */
var ConsoleLoggerImpl = (function (_super) {
    __extends(ConsoleLoggerImpl, _super);
    function ConsoleLoggerImpl(name, logGroupRuntimeSettings) {
        return _super.call(this, name, logGroupRuntimeSettings) || this;
    }
    ConsoleLoggerImpl.prototype.doLog = function (message) {
        if (console !== undefined) {
            var logged = false;
            var logLevel = message.level;
            var messageFormatter = this._getMessageFormatter();
            var msg = void 0;
            if (messageFormatter === null) {
                msg = this.createDefaultLogMessage(message);
            }
            else {
                msg = messageFormatter(message);
            }
            /* tslint:disable:no-console */
            switch (logLevel) {
                case LoggerOptions_1.LogLevel.Trace:
                    // Do not try trace we don't want a stack
                    break;
                case LoggerOptions_1.LogLevel.Debug:
                    // Don't try, too much differences of consoles.
                    break;
                case LoggerOptions_1.LogLevel.Info:
                    if (console.info) {
                        console.info(msg);
                        logged = true;
                    }
                    break;
                case LoggerOptions_1.LogLevel.Warn:
                    if (console.warn) {
                        console.warn(msg);
                        logged = true;
                    }
                    break;
                case LoggerOptions_1.LogLevel.Error:
                case LoggerOptions_1.LogLevel.Fatal:
                    if (console.error) {
                        console.error(msg);
                        logged = true;
                    }
                    break;
                default:
                    throw new Error("Log level not supported: " + logLevel);
            }
            if (!logged) {
                console.log(msg);
            }
            /* tslint:enable:no-console */
        }
        else {
            throw new Error("Console is not defined, cannot log msg: " + message.message);
        }
    };
    return ConsoleLoggerImpl;
}(AbstractLogger_1.AbstractLogger));
exports.ConsoleLoggerImpl = ConsoleLoggerImpl;
//# sourceMappingURL=ConsoleLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LFService.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LFService.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var LoggerFactoryImpl_1 = __webpack_require__(/*! ./LoggerFactoryImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryImpl.js");
var ExtensionHelper_1 = __webpack_require__(/*! ../../extension/ExtensionHelper */ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js");
var LogGroupRule_1 = __webpack_require__(/*! ./LogGroupRule */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRule.js");
var LoggerFactoryOptions_1 = __webpack_require__(/*! ./LoggerFactoryOptions */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryOptions.js");
var LFServiceImpl = (function () {
    function LFServiceImpl() {
        // Private constructor.
        this._nameCounter = 1;
        this._mapFactories = new DataStructures_1.SimpleMap();
        ExtensionHelper_1.ExtensionHelper.register();
    }
    LFServiceImpl.getInstance = function () {
        // Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.
        if (LFServiceImpl._INSTANCE === null) {
            LFServiceImpl._INSTANCE = new LFServiceImpl();
        }
        return LFServiceImpl._INSTANCE;
    };
    /**
     * Create a new LoggerFactory with given options (if any). If no options
     * are specified, the LoggerFactory, will accept any named logger and will
     * log on info level by default for, to the console.
     * @param options Options, optional.
     * @returns {LoggerFactory}
     */
    LFServiceImpl.prototype.createLoggerFactory = function (options) {
        if (options === void 0) { options = null; }
        var name = "LoggerFactory" + this._nameCounter++;
        return this.createNamedLoggerFactory(name, options);
    };
    /**
     * Create a new LoggerFactory using given name (used for console api/extension).
     * @param name Name Pick something short but distinguishable.
     * @param options Options, optional
     * @return {LoggerFactory}
     */
    LFServiceImpl.prototype.createNamedLoggerFactory = function (name, options) {
        if (options === void 0) { options = null; }
        if (this._mapFactories.exists(name)) {
            throw new Error("LoggerFactory with name " + name + " already exists.");
        }
        var factory;
        if (options !== null) {
            factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(name, options);
        }
        else {
            factory = new LoggerFactoryImpl_1.LoggerFactoryImpl(name, LFServiceImpl.createDefaultOptions());
        }
        this._mapFactories.put(name, factory);
        return factory;
    };
    /**
     * Closes all Loggers for LoggerFactories that were created.
     * After this call, all previously fetched Loggers (from their
     * factories) are unusable. The factories remain as they were.
     */
    LFServiceImpl.prototype.closeLoggers = function () {
        this._mapFactories.values().forEach(function (factory) {
            factory.closeLoggers();
        });
        this._mapFactories.clear();
        this._nameCounter = 1;
    };
    LFServiceImpl.prototype.getRuntimeSettingsForLoggerFactories = function () {
        var result = [];
        this._mapFactories.forEachValue(function (factory) { return result.push(factory); });
        return result;
    };
    LFServiceImpl.prototype.getLogGroupSettings = function (nameLoggerFactory, idLogGroupRule) {
        var factory = this._mapFactories.get(nameLoggerFactory);
        if (typeof factory === "undefined") {
            return null;
        }
        return factory.getLogGroupRuntimeSettingsByIndex(idLogGroupRule);
    };
    LFServiceImpl.prototype.getLoggerFactoryRuntimeSettingsByName = function (nameLoggerFactory) {
        var result = this._mapFactories.get(nameLoggerFactory);
        if (typeof result === "undefined") {
            return null;
        }
        return result;
    };
    LFServiceImpl.createDefaultOptions = function () {
        return new LoggerFactoryOptions_1.LoggerFactoryOptions().addLogGroupRule(new LogGroupRule_1.LogGroupRule(new RegExp(".+"), LoggerOptions_1.LogLevel.Info));
    };
    // Loaded on demand. Do NOT change as webpack may pack things in wrong order otherwise.
    LFServiceImpl._INSTANCE = null;
    return LFServiceImpl;
}());
/**
 * Create and configure your LoggerFactory from here.
 */
var LFService = (function () {
    function LFService() {
    }
    /**
     * Create a new LoggerFactory with given options (if any). If no options
     * are specified, the LoggerFactory, will accept any named logger and will
     * log on info level by default for, to the console.
     * @param options Options, optional.
     * @returns {LoggerFactory}
     */
    LFService.createLoggerFactory = function (options) {
        if (options === void 0) { options = null; }
        return LFService.INSTANCE_SERVICE.createLoggerFactory(options);
    };
    /**
     * Create a new LoggerFactory using given name (used for console api/extension).
     * @param name Name Pick something short but distinguishable. The word "DEFAULT" is reserved and cannot be taken, it is used
     * for the default LoggerFactory.
     * @param options Options, optional
     * @return {LoggerFactory}
     */
    LFService.createNamedLoggerFactory = function (name, options) {
        if (options === void 0) { options = null; }
        if (name === LFService.DEFAULT_LOGGER_FACTORY_NAME) {
            throw new Error("LoggerFactory name: " + LFService.DEFAULT_LOGGER_FACTORY_NAME + " is reserved and cannot be used.");
        }
        return LFService.INSTANCE_SERVICE.createNamedLoggerFactory(name, options);
    };
    /**
     * Closes all Loggers for LoggerFactories that were created.
     * After this call, all previously fetched Loggers (from their
     * factories) are unusable. The factories remain as they were.
     */
    LFService.closeLoggers = function () {
        return LFService.INSTANCE_SERVICE.closeLoggers();
    };
    /**
     * Return LFServiceRuntimeSettings to retrieve information loggerfactories
     * and their runtime settings.
     * @returns {LFServiceRuntimeSettings}
     */
    LFService.getRuntimeSettings = function () {
        return LFService.INSTANCE_SERVICE;
    };
    Object.defineProperty(LFService, "DEFAULT", {
        /**
         * This property returns the default LoggerFactory (if not yet initialized it is initialized).
         * This LoggerFactory can be used to share among multiple
         * applications/libraries - that way you can enable/change logging over everything from
         * your own application when required.
         * It is recommended to be used by library developers to make logging easily available for the
         * consumers of their libraries.
         * It is highly recommended to use Loggers from the LoggerFactory with unique grouping/names to prevent
         * clashes of Loggers between multiple projects.
         * @returns {LoggerFactory} Returns the default LoggerFactory
         */
        get: function () {
            return LFService.getDefault();
        },
        enumerable: true,
        configurable: true
    });
    LFService.getDefault = function () {
        if (LFService.DEFAULT_LOGGER_FACTORY === null) {
            LFService.DEFAULT_LOGGER_FACTORY = LFService.DEFAULT_LOGGER_FACTORY = LFService.INSTANCE_SERVICE.createNamedLoggerFactory(LFService.DEFAULT_LOGGER_FACTORY_NAME, new LoggerFactoryOptions_1.LoggerFactoryOptions().addLogGroupRule(new LogGroupRule_1.LogGroupRule(new RegExp(".+"), LoggerOptions_1.LogLevel.Error)));
        }
        return LFService.DEFAULT_LOGGER_FACTORY;
    };
    LFService.DEFAULT_LOGGER_FACTORY_NAME = "DEFAULT";
    LFService.INSTANCE_SERVICE = LFServiceImpl.getInstance();
    LFService.DEFAULT_LOGGER_FACTORY = null;
    return LFService;
}());
exports.LFService = LFService;
//# sourceMappingURL=LFService.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRule.js":
/*!************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRule.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Defines a LogGroupRule, this allows you to either have everything configured the same way
 * or for example loggers that start with name model. It allows you to group loggers together
 * to have a certain loglevel and other settings. You can configure this when creating the
 * LoggerFactory (which accepts multiple LogGroupRules).
 */
var LogGroupRule = (function () {
    /**
     * Create a LogGroupRule. Basically you define what logger name(s) match for this group, what level should be used what logger type (where to log)
     * and what format to write in. If the loggerType is custom, then the callBackLogger must be supplied as callback function to return a custom logger.
     * @param regExp Regular expression, what matches for your logger names for this group
     * @param level LogLevel
     * @param logFormat LogFormat
     * @param loggerType Type of logger, if Custom, make sure to implement callBackLogger and pass in, this will be called so you can return your own logger.
     * @param callBackLogger Callback function to return a new clean custom logger (yours!)
     */
    function LogGroupRule(regExp, level, logFormat, loggerType, callBackLogger) {
        if (logFormat === void 0) { logFormat = new LoggerOptions_1.LogFormat(); }
        if (loggerType === void 0) { loggerType = LoggerOptions_1.LoggerType.Console; }
        if (callBackLogger === void 0) { callBackLogger = null; }
        this._formatterLogMessage = null;
        this._regExp = regExp;
        this._level = level;
        this._logFormat = logFormat;
        this._loggerType = loggerType;
        this._callBackLogger = callBackLogger;
    }
    Object.defineProperty(LogGroupRule.prototype, "regExp", {
        get: function () {
            return this._regExp;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "level", {
        get: function () {
            return this._level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRule.prototype, "formatterLogMessage", {
        /**
         * Get the formatterLogMessage function, see comment on the setter.
         * @returns {((message:LogMessage)=>string)|null}
         */
        get: function () {
            return this._formatterLogMessage;
        },
        /**
         * Set the default formatterLogMessage function, if set it is applied to all type of loggers except for a custom logger.
         * By default this is null (not set). You can assign a function to allow custom formatting of a log message.
         * Each log message will call this function then and expects your function to format the message and return a string.
         * Will throw an error if you attempt to set a formatterLogMessage if the LoggerType is custom.
         * @param value The formatter function, or null to reset it.
         */
        set: function (value) {
            if (value !== null && this._loggerType === LoggerOptions_1.LoggerType.Custom) {
                throw new Error("You cannot specify a formatter for log messages if your loggerType is Custom");
            }
            this._formatterLogMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    return LogGroupRule;
}());
exports.LogGroupRule = LogGroupRule;
//# sourceMappingURL=LogGroupRule.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRuntimeSettings.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRuntimeSettings.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Represents the runtime settings for a LogGroup (LogGroupRule).
 */
var LogGroupRuntimeSettings = (function () {
    function LogGroupRuntimeSettings(logGroupRule) {
        this._formatterLogMessage = null;
        this._logGroupRule = logGroupRule;
        this._level = logGroupRule.level;
        this._loggerType = logGroupRule.loggerType;
        this._logFormat = new LoggerOptions_1.LogFormat(new LoggerOptions_1.DateFormat(logGroupRule.logFormat.dateFormat.formatEnum, logGroupRule.logFormat.dateFormat.dateSeparator), logGroupRule.logFormat.showTimeStamp, logGroupRule.logFormat.showLoggerName);
        this._callBackLogger = logGroupRule.callBackLogger;
        this._formatterLogMessage = logGroupRule.formatterLogMessage;
    }
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "logGroupRule", {
        /**
         * Returns original LogGroupRule (so not runtime settings!)
         * @return {LogGroupRule}
         */
        get: function () {
            return this._logGroupRule;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "level", {
        get: function () {
            return this._level;
        },
        set: function (value) {
            this._level = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "loggerType", {
        get: function () {
            return this._loggerType;
        },
        set: function (value) {
            this._loggerType = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "logFormat", {
        get: function () {
            return this._logFormat;
        },
        set: function (value) {
            this._logFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "callBackLogger", {
        get: function () {
            return this._callBackLogger;
        },
        set: function (value) {
            this._callBackLogger = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LogGroupRuntimeSettings.prototype, "formatterLogMessage", {
        get: function () {
            return this._formatterLogMessage;
        },
        set: function (value) {
            this._formatterLogMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    return LogGroupRuntimeSettings;
}());
exports.LogGroupRuntimeSettings = LogGroupRuntimeSettings;
//# sourceMappingURL=LogGroupRuntimeSettings.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryImpl.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryImpl.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var DataStructures_1 = __webpack_require__(/*! ../../utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var LoggerOptions_1 = __webpack_require__(/*! ../LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var ConsoleLoggerImpl_1 = __webpack_require__(/*! ./ConsoleLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/ConsoleLoggerImpl.js");
var MessageBufferLoggerImpl_1 = __webpack_require__(/*! ./MessageBufferLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/MessageBufferLoggerImpl.js");
var AbstractLogger_1 = __webpack_require__(/*! ./AbstractLogger */ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js");
var LogGroupRuntimeSettings_1 = __webpack_require__(/*! ./LogGroupRuntimeSettings */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRuntimeSettings.js");
var LoggerFactoryImpl = (function () {
    function LoggerFactoryImpl(name, options) {
        this._loggers = new DataStructures_1.SimpleMap();
        this._logGroupRuntimeSettingsIndexed = [];
        this._loggerToLogGroupSettings = new DataStructures_1.SimpleMap();
        this._name = name;
        this.configure(options);
    }
    LoggerFactoryImpl.prototype.configure = function (options) {
        this._options = options;
        // Close any current open loggers.
        this.closeLoggers();
        this._loggerToLogGroupSettings.clear();
        this._logGroupRuntimeSettingsIndexed = [];
        var logGroupRules = this._options.logGroupRules;
        /* tslint:disable:prefer-for-of */
        for (var i = 0; i < logGroupRules.length; i++) {
            this._logGroupRuntimeSettingsIndexed.push(new LogGroupRuntimeSettings_1.LogGroupRuntimeSettings(logGroupRules[i]));
        }
        /* tslint:enable:prefer-for-of */
    };
    LoggerFactoryImpl.prototype.getLogger = function (named) {
        if (!this._options.enabled) {
            throw new Error("LoggerFactory is not enabled, please check your options passed in");
        }
        var logger = this._loggers.get(named);
        if (typeof logger !== "undefined") {
            return logger;
        }
        // Initialize logger with appropriate level
        logger = this.loadLogger(named);
        this._loggers.put(named, logger);
        return logger;
    };
    LoggerFactoryImpl.prototype.isEnabled = function () {
        return this._options.enabled;
    };
    LoggerFactoryImpl.prototype.closeLoggers = function () {
        this._loggers.forEachValue(function (logger) {
            // We can only close if AbstractLogger is used (our loggers, but user loggers may not extend it, even though unlikely).
            if (logger instanceof AbstractLogger_1.AbstractLogger) {
                logger.close();
            }
        });
        this._loggers.clear();
    };
    LoggerFactoryImpl.prototype.getName = function () {
        return this._name;
    };
    LoggerFactoryImpl.prototype.getLogGroupRuntimeSettingsByIndex = function (idx) {
        if (idx >= 0 && idx < this._logGroupRuntimeSettingsIndexed.length) {
            return this._logGroupRuntimeSettingsIndexed[idx];
        }
        return null;
    };
    LoggerFactoryImpl.prototype.getLogGroupRuntimeSettingsByLoggerName = function (nameLogger) {
        var result = this._loggerToLogGroupSettings.get(nameLogger);
        if (typeof result === "undefined") {
            return null;
        }
        return result;
    };
    LoggerFactoryImpl.prototype.getLogGroupRuntimeSettings = function () {
        return this._logGroupRuntimeSettingsIndexed.slice(0);
    };
    LoggerFactoryImpl.prototype.loadLogger = function (named) {
        var logGroupRules = this._options.logGroupRules;
        for (var i = 0; i < logGroupRules.length; i++) {
            var logGroupRule = logGroupRules[i];
            if (logGroupRule.regExp.test(named)) {
                var logGroupRuntimeSettings = this._logGroupRuntimeSettingsIndexed[i];
                var logger = void 0;
                switch (logGroupRule.loggerType) {
                    case LoggerOptions_1.LoggerType.Console:
                        logger = new ConsoleLoggerImpl_1.ConsoleLoggerImpl(named, logGroupRuntimeSettings);
                        break;
                    case LoggerOptions_1.LoggerType.MessageBuffer:
                        logger = new MessageBufferLoggerImpl_1.MessageBufferLoggerImpl(named, logGroupRuntimeSettings);
                        break;
                    case LoggerOptions_1.LoggerType.Custom:
                        if (logGroupRule.callBackLogger != null) {
                            logger = logGroupRule.callBackLogger(named, logGroupRuntimeSettings);
                        }
                        else {
                            throw new Error("Cannot create a custom logger, custom callback is null");
                        }
                        break;
                    default:
                        throw new Error("Cannot create a Logger for LoggerType: " + logGroupRule.loggerType);
                }
                // For a new logger map it by its name
                this._loggerToLogGroupSettings.put(named, logGroupRuntimeSettings);
                return logger;
            }
        }
        throw new Error("Failed to find a match to create a Logger for: " + named);
    };
    return LoggerFactoryImpl;
}());
exports.LoggerFactoryImpl = LoggerFactoryImpl;
//# sourceMappingURL=LoggerFactoryImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryOptions.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryOptions.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Options object you can use to configure the LoggerFactory you create at LFService.
 */
var LoggerFactoryOptions = (function () {
    function LoggerFactoryOptions() {
        this._logGroupRules = [];
        this._enabled = true;
    }
    /**
     * Add LogGroupRule, see {LogGroupRule) for details
     * @param rule Rule to add
     * @returns {LoggerFactoryOptions} returns itself
     */
    LoggerFactoryOptions.prototype.addLogGroupRule = function (rule) {
        this._logGroupRules.push(rule);
        return this;
    };
    /**
     * Enable or disable logging completely for the LoggerFactory.
     * @param enabled True for enabled (default)
     * @returns {LoggerFactoryOptions} returns itself
     */
    LoggerFactoryOptions.prototype.setEnabled = function (enabled) {
        this._enabled = enabled;
        return this;
    };
    Object.defineProperty(LoggerFactoryOptions.prototype, "logGroupRules", {
        get: function () {
            return this._logGroupRules;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoggerFactoryOptions.prototype, "enabled", {
        get: function () {
            return this._enabled;
        },
        enumerable: true,
        configurable: true
    });
    return LoggerFactoryOptions;
}());
exports.LoggerFactoryOptions = LoggerFactoryOptions;
//# sourceMappingURL=LoggerFactoryOptions.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/log/standard/MessageBufferLoggerImpl.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/log/standard/MessageBufferLoggerImpl.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
var AbstractLogger_1 = __webpack_require__(/*! ./AbstractLogger */ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js");
/**
 * Logger which buffers all messages, use with care due to possible high memory footprint.
 * Can be convenient in some cases. Call toString() for full output, or cast to this class
 * and call getMessages() to do something with it yourself.
 */
var MessageBufferLoggerImpl = (function (_super) {
    __extends(MessageBufferLoggerImpl, _super);
    function MessageBufferLoggerImpl(name, logGroupRuntimeSettings) {
        var _this = _super.call(this, name, logGroupRuntimeSettings) || this;
        _this.messages = [];
        return _this;
    }
    MessageBufferLoggerImpl.prototype.close = function () {
        this.messages = [];
        _super.prototype.close.call(this);
    };
    MessageBufferLoggerImpl.prototype.getMessages = function () {
        return this.messages;
    };
    MessageBufferLoggerImpl.prototype.toString = function () {
        return this.messages.map(function (msg) {
            return msg;
        }).join("\n");
    };
    MessageBufferLoggerImpl.prototype.doLog = function (message) {
        var messageFormatter = this._getMessageFormatter();
        var fullMsg;
        if (messageFormatter === null) {
            fullMsg = this.createDefaultLogMessage(message);
        }
        else {
            fullMsg = messageFormatter(message);
        }
        this.messages.push(fullMsg);
    };
    return MessageBufferLoggerImpl;
}(AbstractLogger_1.AbstractLogger));
exports.MessageBufferLoggerImpl = MessageBufferLoggerImpl;
//# sourceMappingURL=MessageBufferLoggerImpl.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/typescript-logging.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/typescript-logging.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", ({ value: true }));
var LogGroupControl_1 = __webpack_require__(/*! ./control/LogGroupControl */ "./node_modules/typescript-logging/dist/commonjs/control/LogGroupControl.js");
var CategoryServiceControl_1 = __webpack_require__(/*! ./control/CategoryServiceControl */ "./node_modules/typescript-logging/dist/commonjs/control/CategoryServiceControl.js");
var ExtensionHelper_1 = __webpack_require__(/*! ./extension/ExtensionHelper */ "./node_modules/typescript-logging/dist/commonjs/extension/ExtensionHelper.js");
exports.ExtensionHelper = ExtensionHelper_1.ExtensionHelper;
// Category related
var AbstractCategoryLogger_1 = __webpack_require__(/*! ./log/category/AbstractCategoryLogger */ "./node_modules/typescript-logging/dist/commonjs/log/category/AbstractCategoryLogger.js");
exports.AbstractCategoryLogger = AbstractCategoryLogger_1.AbstractCategoryLogger;
var CategoryConsoleLoggerImpl_1 = __webpack_require__(/*! ./log/category/CategoryConsoleLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConsoleLoggerImpl.js");
exports.CategoryConsoleLoggerImpl = CategoryConsoleLoggerImpl_1.CategoryConsoleLoggerImpl;
var CategoryDelegateLoggerImpl_1 = __webpack_require__(/*! ./log/category/CategoryDelegateLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryDelegateLoggerImpl.js");
exports.CategoryDelegateLoggerImpl = CategoryDelegateLoggerImpl_1.CategoryDelegateLoggerImpl;
var Category_1 = __webpack_require__(/*! ./log/category/Category */ "./node_modules/typescript-logging/dist/commonjs/log/category/Category.js");
exports.Category = Category_1.Category;
var CategoryRuntimeSettings_1 = __webpack_require__(/*! ./log/category/CategoryRuntimeSettings */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryRuntimeSettings.js");
exports.CategoryRuntimeSettings = CategoryRuntimeSettings_1.CategoryRuntimeSettings;
var CategoryConfiguration_1 = __webpack_require__(/*! ./log/category/CategoryConfiguration */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryConfiguration.js");
exports.CategoryConfiguration = CategoryConfiguration_1.CategoryConfiguration;
var CategoryMessageBufferImpl_1 = __webpack_require__(/*! ./log/category/CategoryMessageBufferImpl */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryMessageBufferImpl.js");
exports.CategoryMessageBufferLoggerImpl = CategoryMessageBufferImpl_1.CategoryMessageBufferLoggerImpl;
var CategoryServiceFactory_1 = __webpack_require__(/*! ./log/category/CategoryServiceFactory */ "./node_modules/typescript-logging/dist/commonjs/log/category/CategoryServiceFactory.js");
exports.CategoryServiceFactory = CategoryServiceFactory_1.CategoryServiceFactory;
var LoggerFactoryOptions_1 = __webpack_require__(/*! ./log/standard/LoggerFactoryOptions */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LoggerFactoryOptions.js");
exports.LoggerFactoryOptions = LoggerFactoryOptions_1.LoggerFactoryOptions;
var LogGroupRule_1 = __webpack_require__(/*! ./log/standard/LogGroupRule */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LogGroupRule.js");
exports.LogGroupRule = LogGroupRule_1.LogGroupRule;
var LFService_1 = __webpack_require__(/*! ./log/standard/LFService */ "./node_modules/typescript-logging/dist/commonjs/log/standard/LFService.js");
exports.LFService = LFService_1.LFService;
var AbstractLogger_1 = __webpack_require__(/*! ./log/standard/AbstractLogger */ "./node_modules/typescript-logging/dist/commonjs/log/standard/AbstractLogger.js");
exports.AbstractLogger = AbstractLogger_1.AbstractLogger;
var ConsoleLoggerImpl_1 = __webpack_require__(/*! ./log/standard/ConsoleLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/ConsoleLoggerImpl.js");
exports.ConsoleLoggerImpl = ConsoleLoggerImpl_1.ConsoleLoggerImpl;
var MessageBufferLoggerImpl_1 = __webpack_require__(/*! ./log/standard/MessageBufferLoggerImpl */ "./node_modules/typescript-logging/dist/commonjs/log/standard/MessageBufferLoggerImpl.js");
exports.MessageBufferLoggerImpl = MessageBufferLoggerImpl_1.MessageBufferLoggerImpl;
var LoggerOptions_1 = __webpack_require__(/*! ./log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
exports.CategoryLogFormat = LoggerOptions_1.CategoryLogFormat;
exports.DateFormat = LoggerOptions_1.DateFormat;
exports.DateFormatEnum = LoggerOptions_1.DateFormatEnum;
exports.LogFormat = LoggerOptions_1.LogFormat;
exports.LoggerType = LoggerOptions_1.LoggerType;
exports.LogLevel = LoggerOptions_1.LogLevel;
// Utilities
var DataStructures_1 = __webpack_require__(/*! ./utils/DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
exports.SimpleMap = DataStructures_1.SimpleMap;
exports.LinkedList = DataStructures_1.LinkedList;
__export(__webpack_require__(/*! ./utils/JSONHelper */ "./node_modules/typescript-logging/dist/commonjs/utils/JSONHelper.js"));
var MessageUtils_1 = __webpack_require__(/*! ./utils/MessageUtils */ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js");
exports.MessageFormatUtils = MessageUtils_1.MessageFormatUtils;
/*
 Functions to export on TSL libarary var.
*/
// Export help function
function help() {
    /* tslint:disable:no-console */
    console.log("help()\n   ** Shows this help\n\n getLogControl(): LoggerControl\n   ** Returns LoggerControl Object, use to dynamically change loglevels for log4j logging.\n   ** Call .help() on LoggerControl object for available options.\n\n getCategoryControl(): CategoryServiceControl\n   ** Returns CategoryServiceControl Object, use to dynamically change loglevels for category logging.\n   ** Call .help() on CategoryServiceControl object for available options.\n");
    /* tslint:enable:no-console */
}
exports.help = help;
// Export LogControl function (log4j)
function getLogControl() {
    return new LogGroupControl_1.LoggerControlImpl();
}
exports.getLogControl = getLogControl;
// Export CategoryControl function
function getCategoryControl() {
    return new CategoryServiceControl_1.CategoryServiceControlImpl();
}
exports.getCategoryControl = getCategoryControl;
//# sourceMappingURL=typescript-logging.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var LinkedNode = (function () {
    function LinkedNode(value) {
        this._previous = null;
        this._next = null;
        this._value = value;
    }
    Object.defineProperty(LinkedNode.prototype, "previous", {
        get: function () {
            return this._previous;
        },
        set: function (value) {
            this._previous = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinkedNode.prototype, "next", {
        get: function () {
            return this._next;
        },
        set: function (value) {
            this._next = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinkedNode.prototype, "value", {
        get: function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    return LinkedNode;
}());
/**
 * Double linkedlist implementation.
 */
var LinkedList = (function () {
    function LinkedList() {
        this.head = null;
        this.size = 0;
    }
    LinkedList.prototype.addHead = function (value) {
        if (!this.createHeadIfNeeded(value)) {
            if (this.head != null) {
                var nextNode = this.head.next;
                var newHeadNode = new LinkedNode(value);
                if (nextNode != null) {
                    nextNode.previous = newHeadNode;
                    newHeadNode.next = nextNode;
                }
                this.head = newHeadNode;
            }
            else {
                throw new Error("This should never happen, list implementation broken");
            }
        }
        this.size++;
    };
    LinkedList.prototype.addTail = function (value) {
        if (!this.createHeadIfNeeded(value)) {
            var oldTailNode = this.getTailNode();
            if (oldTailNode != null) {
                var newTailNode = new LinkedNode(value);
                oldTailNode.next = newTailNode;
                newTailNode.previous = oldTailNode;
            }
            else {
                throw new Error("List implementation broken");
            }
        }
        this.size++;
    };
    LinkedList.prototype.clear = function () {
        this.head = null;
        this.size = 0;
    };
    LinkedList.prototype.getHead = function () {
        if (this.head != null) {
            return this.head.value;
        }
        return null;
    };
    LinkedList.prototype.removeHead = function () {
        if (this.head != null) {
            var oldHead = this.head;
            var value = oldHead.value;
            this.head = oldHead.next;
            this.size--;
            return value;
        }
        return null;
    };
    LinkedList.prototype.getTail = function () {
        var node = this.getTailNode();
        if (node != null) {
            return node.value;
        }
        return null;
    };
    LinkedList.prototype.removeTail = function () {
        var node = this.getTailNode();
        if (node != null) {
            if (node === this.head) {
                this.head = null;
            }
            else {
                var previousNode = node.previous;
                if (previousNode != null) {
                    previousNode.next = null;
                }
                else {
                    throw new Error("List implementation is broken");
                }
            }
            this.size--;
            return node.value;
        }
        return null;
    };
    LinkedList.prototype.getSize = function () {
        return this.size;
    };
    LinkedList.prototype.filter = function (f) {
        var recurse = function (fn, node, values) {
            if (fn(node.value)) {
                values.push(node.value);
            }
            var nextNode = node.next;
            if (nextNode != null) {
                recurse(fn, nextNode, values);
            }
        };
        var result = [];
        var currentNode = this.head;
        if (currentNode != null) {
            recurse(f, currentNode, result);
        }
        return result;
    };
    LinkedList.prototype.createHeadIfNeeded = function (value) {
        if (this.head == null) {
            this.head = new LinkedNode(value);
            return true;
        }
        return false;
    };
    LinkedList.prototype.getTailNode = function () {
        if (this.head == null) {
            return null;
        }
        var node = this.head;
        while (node.next != null) {
            node = node.next;
        }
        return node;
    };
    return LinkedList;
}());
exports.LinkedList = LinkedList;
/**
 * Map implementation keyed by string (always).
 */
var SimpleMap = (function () {
    function SimpleMap() {
        this.array = {};
    }
    SimpleMap.prototype.put = function (key, value) {
        this.array[key] = value;
    };
    SimpleMap.prototype.get = function (key) {
        return this.array[key];
    };
    SimpleMap.prototype.exists = function (key) {
        var value = this.array[key];
        return (typeof value !== "undefined");
    };
    SimpleMap.prototype.remove = function (key) {
        var value = this.array[key];
        if (typeof value !== "undefined") {
            delete this.array[key];
        }
        return value;
    };
    SimpleMap.prototype.keys = function () {
        var keys = [];
        for (var key in this.array) {
            // To prevent random stuff to appear
            if (this.array.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys;
    };
    SimpleMap.prototype.values = function () {
        var values = [];
        for (var key in this.array) {
            // To prevent random stuff to appear
            if (this.array.hasOwnProperty(key)) {
                values.push(this.get(key));
            }
        }
        return values;
    };
    SimpleMap.prototype.size = function () {
        return this.keys().length;
    };
    SimpleMap.prototype.isEmpty = function () {
        return this.size() === 0;
    };
    SimpleMap.prototype.clear = function () {
        this.array = {};
    };
    SimpleMap.prototype.forEach = function (cbFunction) {
        var count = 0;
        for (var key in this.array) {
            // To prevent random stuff to appear
            if (this.array.hasOwnProperty(key)) {
                var value = this.array[key];
                cbFunction(key, value, count);
                count++;
            }
        }
    };
    SimpleMap.prototype.forEachValue = function (cbFunction) {
        var count = 0;
        for (var key in this.array) {
            // To prevent random stuff to appear
            if (this.array.hasOwnProperty(key)) {
                var value = this.array[key];
                cbFunction(value, count);
                count++;
            }
        }
    };
    return SimpleMap;
}());
exports.SimpleMap = SimpleMap;
/**
 * Tuple to hold two values.
 */
var TuplePair = (function () {
    function TuplePair(x, y) {
        this._x = x;
        this._y = y;
    }
    Object.defineProperty(TuplePair.prototype, "x", {
        get: function () {
            return this._x;
        },
        set: function (value) {
            this._x = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuplePair.prototype, "y", {
        get: function () {
            return this._y;
        },
        set: function (value) {
            this._y = value;
        },
        enumerable: true,
        configurable: true
    });
    return TuplePair;
}());
exports.TuplePair = TuplePair;
/**
 * Utility class to build up a string.
 */
var StringBuilder = (function () {
    function StringBuilder() {
        this.data = [];
    }
    StringBuilder.prototype.append = function (line) {
        if (line === undefined || line == null) {
            throw new Error("String must be set, cannot append null or undefined");
        }
        this.data.push(line);
        return this;
    };
    StringBuilder.prototype.appendLine = function (line) {
        this.data.push(line + "\n");
        return this;
    };
    StringBuilder.prototype.isEmpty = function () {
        return this.data.length === 0;
    };
    StringBuilder.prototype.clear = function () {
        this.data = [];
    };
    StringBuilder.prototype.toString = function (separator) {
        if (separator === void 0) { separator = ""; }
        return this.data.join(separator);
    };
    return StringBuilder;
}());
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=DataStructures.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/utils/JSONHelper.js":
/*!***************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/utils/JSONHelper.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Module containing bunch of JSON related stuff.
 */
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
var DataStructures_1 = __webpack_require__(/*! ./DataStructures */ "./node_modules/typescript-logging/dist/commonjs/utils/DataStructures.js");
var JSONTypeImpl = (function () {
    function JSONTypeImpl(value) {
        this._value = value;
    }
    JSONTypeImpl.prototype.getValue = function () {
        return this._value;
    };
    JSONTypeImpl.prototype.toString = function () {
        var value = this.getValue();
        if (value != null) {
            return value.toString();
        }
        return "null";
    };
    return JSONTypeImpl;
}());
var JSONBooleanType = (function (_super) {
    __extends(JSONBooleanType, _super);
    function JSONBooleanType(value) {
        return _super.call(this, value) || this;
    }
    return JSONBooleanType;
}(JSONTypeImpl));
var JSONNumberType = (function (_super) {
    __extends(JSONNumberType, _super);
    function JSONNumberType(value) {
        return _super.call(this, value) || this;
    }
    return JSONNumberType;
}(JSONTypeImpl));
var JSONStringType = (function (_super) {
    __extends(JSONStringType, _super);
    function JSONStringType(value) {
        return _super.call(this, value) || this;
    }
    JSONStringType.prototype.toString = function () {
        var value = this.getValue();
        if (value != null) {
            return JSON.stringify(value.toString());
        }
        return "null";
    };
    return JSONStringType;
}(JSONTypeImpl));
var JSONObjectType = (function (_super) {
    __extends(JSONObjectType, _super);
    function JSONObjectType(value) {
        return _super.call(this, value) || this;
    }
    return JSONObjectType;
}(JSONTypeImpl));
var JSONArrayType = (function (_super) {
    __extends(JSONArrayType, _super);
    function JSONArrayType(value) {
        return _super.call(this, value) || this;
    }
    JSONArrayType.prototype.toString = function () {
        var value = this.getValue();
        if (value != null) {
            return value.toString();
        }
        return "null";
    };
    return JSONArrayType;
}(JSONTypeImpl));
var JSONNullType = (function (_super) {
    __extends(JSONNullType, _super);
    function JSONNullType() {
        return _super.call(this, null) || this;
    }
    JSONNullType.prototype.toString = function () {
        return "null";
    };
    return JSONNullType;
}(JSONTypeImpl));
var JSONTypeConverter = (function () {
    function JSONTypeConverter() {
    }
    JSONTypeConverter.toJSONType = function (value) {
        if (value === null) {
            return new JSONNullType();
        }
        if (typeof value === "string") {
            return new JSONStringType(value);
        }
        if (typeof value === "number") {
            return new JSONNumberType(value);
        }
        if (typeof value === "boolean") {
            return new JSONBooleanType(value);
        }
        if (value instanceof JSONObject) {
            return new JSONObjectType(value);
        }
        throw new Error("Type not supported for value: " + value);
    };
    return JSONTypeConverter;
}());
var JSONObject = (function () {
    function JSONObject() {
        this.values = new DataStructures_1.SimpleMap();
    }
    JSONObject.prototype.addBoolean = function (name, value) {
        this.checkName(name);
        JSONObject.checkValue(value);
        this.values.put(name, new JSONBooleanType(value));
        return this;
    };
    JSONObject.prototype.addNumber = function (name, value) {
        this.checkName(name);
        JSONObject.checkValue(value);
        this.values.put(name, new JSONNumberType(value));
        return this;
    };
    JSONObject.prototype.addString = function (name, value) {
        this.checkName(name);
        JSONObject.checkValue(value);
        this.values.put(name, new JSONStringType(value));
        return this;
    };
    JSONObject.prototype.addNull = function (name) {
        this.checkName(name);
        this.values.put(name, new JSONNullType());
        return this;
    };
    JSONObject.prototype.addArray = function (name, array) {
        this.checkName(name);
        JSONObject.checkValue(array);
        if (array == null) {
            throw new Error("Cannot add array as null");
        }
        this.values.put(name, new JSONArrayType(array));
        return this;
    };
    JSONObject.prototype.addObject = function (name, object) {
        this.checkName(name);
        JSONObject.checkValue(object);
        if (object == null) {
            throw new Error("Cannot add object as null");
        }
        this.values.put(name, new JSONObjectType(object));
        return this;
    };
    JSONObject.prototype.toString = function (pretty) {
        var _this = this;
        if (pretty === void 0) { pretty = false; }
        var comma = false;
        var buffer = new DataStructures_1.StringBuilder();
        buffer.append("{");
        this.values.keys().forEach(function (key) {
            var value = _this.values.get(key);
            if (value != null) {
                if (comma) {
                    buffer.append(",");
                }
                buffer.append('"').append(key).append('":').append(value.toString());
                comma = true;
            }
        });
        buffer.append("}");
        return buffer.toString();
    };
    JSONObject.prototype.checkName = function (name) {
        if (name == null || name === undefined) {
            throw new Error("Name is null or undefined");
        }
        if (this.values.exists(name)) {
            throw new Error("Name " + name + " is already present for this object");
        }
    };
    JSONObject.checkValue = function (value) {
        if (value === undefined) {
            throw new Error("Value is undefined");
        }
    };
    return JSONObject;
}());
exports.JSONObject = JSONObject;
var JSONArray = (function () {
    function JSONArray() {
        this.objects = [];
    }
    JSONArray.prototype.add = function (object) {
        if (object === undefined) {
            throw new Error("Object is not allowed to be undefined");
        }
        this.objects.push(JSONTypeConverter.toJSONType(object));
        return this;
    };
    JSONArray.prototype.toString = function (pretty) {
        if (pretty === void 0) { pretty = false; }
        var buffer = new DataStructures_1.StringBuilder();
        buffer.append("[");
        this.objects.forEach(function (value, index) {
            if (index > 0) {
                buffer.append(",");
            }
            buffer.append(value.toString());
        });
        buffer.append("]");
        return buffer.toString();
    };
    return JSONArray;
}());
exports.JSONArray = JSONArray;
/**
 * Utility class that helps us convert things to and from json (not for normal usage).
 */
var JSONHelper = (function () {
    function JSONHelper() {
    }
    JSONHelper.categoryToJSON = function (cat, recursive) {
        /*
         {
         "categories":
         [
         { id=1,
         name: "x",
         parent: null,
         logLevel: "Error"
         },
         { id=2,
         name: "y",
         parent: 1,
         logLevel: "Error"
         }
         ]
         }
         */
        var arr = new JSONArray();
        JSONHelper._categoryToJSON(cat, arr, recursive);
        var object = new JSONObject();
        object.addArray("categories", arr);
        return object;
    };
    JSONHelper._categoryToJSON = function (cat, arr, recursive) {
        var object = new JSONObject();
        object.addNumber("id", cat.id);
        object.addString("name", cat.name);
        object.addString("logLevel", LoggerOptions_1.LogLevel[cat.logLevel].toString());
        if (cat.parent != null) {
            object.addNumber("parent", cat.parent.id);
        }
        else {
            object.addNull("parent");
        }
        arr.add(object);
        if (recursive) {
            cat.children.forEach(function (child) {
                JSONHelper._categoryToJSON(child, arr, recursive);
            });
        }
    };
    return JSONHelper;
}());
exports.JSONHelper = JSONHelper;
//# sourceMappingURL=JSONHelper.js.map

/***/ }),

/***/ "./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/typescript-logging/dist/commonjs/utils/MessageUtils.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ST = __webpack_require__(/*! stacktrace-js */ "./node_modules/stacktrace-js/stacktrace.js");
var LoggerOptions_1 = __webpack_require__(/*! ../log/LoggerOptions */ "./node_modules/typescript-logging/dist/commonjs/log/LoggerOptions.js");
/**
 * Some utilities to format messages.
 */
var MessageFormatUtils = (function () {
    function MessageFormatUtils() {
    }
    /**
     * Render given date in given DateFormat and return as String.
     * @param date Date
     * @param dateFormat Format
     * @returns {string} Formatted date
     */
    MessageFormatUtils.renderDate = function (date, dateFormat) {
        var lpad = function (value, chars, padWith) {
            var howMany = chars - value.length;
            if (howMany > 0) {
                var res = "";
                for (var i = 0; i < howMany; i++) {
                    res += padWith;
                }
                res += value;
                return res;
            }
            return value;
        };
        var fullYear = function (d) {
            return lpad(d.getFullYear().toString(), 4, "0");
        };
        var month = function (d) {
            return lpad((d.getMonth() + 1).toString(), 2, "0");
        };
        var day = function (d) {
            return lpad(d.getDate().toString(), 2, "0");
        };
        var hours = function (d) {
            return lpad(d.getHours().toString(), 2, "0");
        };
        var minutes = function (d) {
            return lpad(d.getMinutes().toString(), 2, "0");
        };
        var seconds = function (d) {
            return lpad(d.getSeconds().toString(), 2, "0");
        };
        var millis = function (d) {
            return lpad(d.getMilliseconds().toString(), 3, "0");
        };
        var dateSeparator = dateFormat.dateSeparator;
        var ds = "";
        switch (dateFormat.formatEnum) {
            case LoggerOptions_1.DateFormatEnum.Default:
                // yyyy-mm-dd hh:mm:ss,m
                ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + " " +
                    hours(date) + ":" + minutes(date) + ":" + seconds(date) + "," + millis(date);
                break;
            case LoggerOptions_1.DateFormatEnum.YearMonthDayTime:
                ds = fullYear(date) + dateSeparator + month(date) + dateSeparator + day(date) + " " +
                    hours(date) + ":" + minutes(date) + ":" + seconds(date);
                break;
            case LoggerOptions_1.DateFormatEnum.YearDayMonthWithFullTime:
                ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + " " +
                    hours(date) + ":" + minutes(date) + ":" + seconds(date) + "," + millis(date);
                break;
            case LoggerOptions_1.DateFormatEnum.YearDayMonthTime:
                ds = fullYear(date) + dateSeparator + day(date) + dateSeparator + month(date) + " " +
                    hours(date) + ":" + minutes(date) + ":" + seconds(date);
                break;
            default:
                throw new Error("Unsupported date format enum: " + dateFormat.formatEnum);
        }
        return ds;
    };
    /**
     * Renders given category log message in default format.
     * @param msg Message to format
     * @param addStack If true adds the stack to the output, otherwise skips it
     * @returns {string} Formatted message
     */
    MessageFormatUtils.renderDefaultMessage = function (msg, addStack) {
        var result = "";
        var logFormat = msg.logFormat;
        if (logFormat.showTimeStamp) {
            result += MessageFormatUtils.renderDate(msg.date, logFormat.dateFormat) + " ";
        }
        result += LoggerOptions_1.LogLevel[msg.level].toUpperCase();
        if (msg.isResolvedErrorMessage) {
            result += " (resolved)";
        }
        result += " ";
        if (logFormat.showCategoryName) {
            result += "[";
            msg.categories.forEach(function (value, idx) {
                if (idx > 0) {
                    result += ", ";
                }
                result += value.name;
            });
            result += "]";
        }
        // Get the normal string message first
        var actualStringMsg = "";
        var dataString = "";
        var messageOrLogData = msg.message;
        if (typeof messageOrLogData === "string") {
            actualStringMsg = messageOrLogData;
        }
        else {
            var logData = messageOrLogData;
            actualStringMsg = logData.msg;
            // We do have data?
            if (logData.data) {
                dataString = " [data]: " + (logData.ds ? logData.ds(logData.data) : JSON.stringify(logData.data));
            }
        }
        result += " " + actualStringMsg + "" + dataString;
        if (addStack && msg.errorAsStack !== null) {
            result += "\n" + msg.errorAsStack;
        }
        return result;
    };
    /**
     * Renders given log4j log message in default format.
     * @param msg Message to format
     * @param addStack If true adds the stack to the output, otherwise skips it
     * @returns {string} Formatted message
     */
    MessageFormatUtils.renderDefaultLog4jMessage = function (msg, addStack) {
        var format = msg.logGroupRule.logFormat;
        var result = "";
        if (format.showTimeStamp) {
            result += MessageFormatUtils.renderDate(msg.date, format.dateFormat) + " ";
        }
        result += LoggerOptions_1.LogLevel[msg.level].toUpperCase() + " ";
        if (format.showLoggerName) {
            result += "[" + msg.loggerName + "]";
        }
        // Get the normal string message first
        var actualStringMsg = "";
        var dataString = "";
        if (typeof msg.message === "string") {
            actualStringMsg = msg.message;
        }
        else {
            var logData = msg.message;
            actualStringMsg = logData.msg;
            // We do have data?
            if (logData.data) {
                dataString = " [data]: " + (logData.ds ? logData.ds(logData.data) : JSON.stringify(logData.data));
            }
        }
        result += " " + actualStringMsg + "" + dataString;
        if (addStack && msg.errorAsStack !== null) {
            result += "\n" + msg.errorAsStack;
        }
        return result;
    };
    /**
     * Render error as stack
     * @param error Return error as Promise
     * @returns {Promise<string>|Promise} Promise for stack
     */
    MessageFormatUtils.renderError = function (error) {
        var result = error.name + ": " + error.message + "\n@";
        return new Promise(function (resolve) {
            // This one has a promise too
            ST.fromError(error, { offline: true }).then(function (frames) {
                var stackStr = (frames.map(function (frame) {
                    return frame.toString();
                })).join("\n  ");
                result += "\n" + stackStr;
                // This resolves our returned promise
                resolve(result);
            }).catch(function () {
                result = "Unexpected error object was passed in. ";
                try {
                    result += "Could not resolve it, stringified object: " + JSON.stringify(error);
                }
                catch (e) {
                    // Cannot stringify can only tell something was wrong.
                    result += "Could not resolve it or stringify it.";
                }
                resolve(result);
            });
        });
    };
    return MessageFormatUtils;
}());
exports.MessageFormatUtils = MessageFormatUtils;
//# sourceMappingURL=MessageUtils.js.map

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQUlGRVhTY3JpcHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsZUFBZSxLQUFpRCxvQkFBb0IsQ0FBdUksQ0FBQyxrQkFBa0IsWUFBWSxPQUFPLGNBQWMsYUFBYSxrQkFBa0Isa0NBQWtDLHNCQUFzQixlQUFlLHNDQUFzQyxLQUFLLHVJQUF1SSxJQUFJLCtCQUErQix1QkFBdUIsWUFBWSw0RUFBNEUsY0FBYyxvRkFBb0YsU0FBUyxTQUFTLHFCQUFxQixZQUFZLEtBQUssbUJBQW1CLEtBQUssbUJBQW1CLHdDQUF3QyxVQUFVLHVDQUF1QyxNQUFNLGNBQWMsV0FBVywrQkFBK0IsWUFBWSxZQUFZLHFDQUFxQyxRQUFRLDBDQUEwQyxjQUFjLElBQUksSUFBSSxhQUFhLCtEQUErRCx1QkFBdUIsRUFBRSw4REFBOEQsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsR0FBRyxTQUFTLFlBQVksYUFBYSxjQUFjLG1DQUFtQyxFQUFFLDhFQUE4RSxnQkFBZ0IsYUFBYSwrRUFBK0UsY0FBYywrSEFBK0gsaUJBQWlCLG1CQUFtQix3RUFBd0UsaUJBQWlCLHdDQUF3QywwREFBMEQsbUVBQW1FLHFCQUFxQiwyQkFBMkIsMENBQTBDLHdEQUF3RCxnQkFBZ0IsdUZBQXVGLFdBQVcsUUFBUSxLQUFLLFlBQVksNkJBQTZCLFNBQVMsU0FBUyxjQUFjLHFCQUFxQixNQUFNLHNEQUFzRCw2QkFBNkIsSUFBSSxJQUFJLFNBQVMsY0FBYyxtQkFBbUIsNE1BQTRNLGNBQWMsb0VBQW9FLFNBQVMsc09BQXNPLGNBQWMsc0NBQXNDLDJCQUEyQixJQUFJLGNBQWMsdUNBQXVDLGdCQUFnQixtQkFBbUIsMkVBQTJFLG1CQUFtQix5QkFBeUIsNEJBQTRCLDZDQUE2QyxjQUFjLG9EQUFvRCxzQkFBc0IsaUNBQWlDLFlBQVksV0FBVyxFQUFFLFVBQVUsRUFBRSxHQUFHLFlBQVksdUJBQXVCLEVBQUUsVUFBVSxFQUFFLElBQUksS0FBSyxJQUFJLFlBQVksV0FBVyxFQUFFLGlCQUFpQixjQUFjLDJDQUEyQyxnQ0FBZ0MsY0FBYyw0RkFBNEYsS0FBSyxJQUFJLGNBQWMsNkRBQTZELDBDQUEwQyxjQUFjLG9DQUFvQyxNQUFNLG1GQUFtRixrQkFBa0IsRUFBRSxlQUFlLElBQUksSUFBSSxTQUFTLGlCQUFpQixzQ0FBc0MsR0FBRyxFQUFFLFdBQVcsZUFBZSxLQUFLLHdCQUF3QixpREFBaUQsU0FBUyxxQkFBcUIsaUJBQWlCLGtCQUFrQixlQUFlLFVBQVUsY0FBYyxLQUFLLGVBQWUsdUJBQXVCLHVCQUF1Qix5QkFBeUIsZ0JBQWdCLG1DQUFtQyx3RUFBd0UsRUFBRSxRQUFRLFdBQVcsaUJBQWlCLFFBQVEsc0lBQXNJLHdDQUF3QyxHQUFHLGlCQUFpQixFQUFFLDBDQUEwQyxJQUFJLFNBQVMscUJBQXFCLHFDQUFxQyw4Q0FBOEMsS0FBSyxFQUFFLGtEQUFrRCxtQkFBbUIsbUJBQW1CLHVCQUF1QixtQkFBbUIsa0NBQWtDLHFCQUFxQixjQUFjLHNFQUFzRSxlQUFlLEVBQUUsZUFBZSxtRUFBbUUsa0NBQWtDLFFBQVEsWUFBWSx1QkFBdUIsc0JBQXNCLDZCQUE2Qix3REFBd0QsTUFBTSxpQkFBaUIseUJBQXlCLG1CQUFtQixNQUFNLG1FQUFtRSxZQUFZLGFBQWEsa0JBQWtCLG9CQUFvQiwwQkFBMEIsV0FBVyxzQkFBc0IsYUFBYSxxQkFBcUIsaUJBQWlCLGdDQUFnQyxlQUFlLE1BQU0sa0VBQWtFLGlCQUFpQixtQkFBbUIsTUFBTSx5QkFBeUIsa0JBQWtCLDhDQUE4QyxvQkFBb0IseUJBQXlCLHVCQUF1Qiw4QkFBOEIsMEJBQTBCLEdBQUcsb0JBQW9CLDRDQUE0QyxlQUFlLE1BQU0sZ0RBQWdELGNBQWMsbUJBQW1CLGFBQWEsb0JBQW9CLElBQUksRUFBRSwwQkFBMEIsTUFBTSxzQkFBc0IsZ0JBQWdCLDJDQUEyQyxZQUFZLGlCQUFpQixFQUFFLG9CQUFvQiwyQ0FBMkMsc0JBQXNCLHFCQUFxQixFQUFFLHNDQUFzQyxPQUFPLE9BQU8sbVZBQW1WLE1BQU0sU0FBUyxrQkFBa0IsYUFBYSw0QkFBNEIsNEJBQTRCLGtEQUFrRCxrQkFBa0IsbUJBQW1CLFlBQVksNEJBQTRCLFlBQVksVUFBVSxVQUFVLEtBQUssRUFBRSxFQUFFLE1BQU0sMkJBQTJCLEdBQUcsMEJBQTBCLGlCQUFpQiw0REFBNEQsMkJBQTJCLElBQUksVUFBVSxNQUFNLElBQUk7Ozs7Ozs7Ozs7QUNBcm9QO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBMEM7QUFDbEQsUUFBUSxpQ0FBNkIsQ0FBQyxnRkFBWSxDQUFDLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDN0QsTUFBTSxLQUFLLEVBSU47QUFDTCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdk5EOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsZUFBZSw2REFBaUI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1QsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3Q0FBd0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxvQkFBb0I7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLHNCQUFzQiwrQ0FBK0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7Ozs7Ozs7Ozs7O0FDempDaEMsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLGlFQUFjO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyxxREFBUTtBQUMzQixlQUFlLCtGQUErQjtBQUM5QyxrQkFBa0Isd0dBQXFDOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7Ozs7Ozs7Ozs7QUNuWjFCLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsK0hBQW9EO0FBQzdFLFdBQVcsbUJBQU8sQ0FBQyxxREFBUTs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUgsV0FBVztBQUNYOztBQUVBLGtCQUFrQjs7Ozs7Ozs7Ozs7QUN0WmxCLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7Ozs7Ozs7Ozs7O0FDaGEzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEpBQXFGO0FBQ3JGLDBKQUFrRjtBQUNsRiw0SEFBNEQ7Ozs7Ozs7Ozs7O0FDUDVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBMEM7QUFDbEQsUUFBUSxpQ0FBcUIsRUFBRSxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQ3pDLE1BQU0sS0FBSyxFQUlOO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxDQUFDOzs7Ozs7Ozs7OztBQzlJRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQTBDO0FBQ2xELFFBQVEsaUNBQTBCLENBQUMsNkdBQVksQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQzFELE1BQU0sS0FBSyxFQUlOO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlEQUFpRDtBQUNoRyxrQkFBa0I7QUFDbEIsK0NBQStDLFdBQVc7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7OztBQzVDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQTBDO0FBQ2xELFFBQVEsaUNBQXFCLEVBQUUsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUN6QyxNQUFNLEtBQUssRUFJTjtBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLDJEQUEyRCxVQUFVO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUMxR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRCxRQUFRLGlDQUF5QixDQUFDLGdGQUFZLEVBQUUsZ0ZBQVksQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQ3ZFLE1BQU0sS0FBSyxFQUlOO0FBQ0wsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixLQUFLLEVBQUUsS0FBSztBQUNqQztBQUNBLFlBQVksTUFBTSxhQUFhLEtBQUs7QUFDcEM7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw4REFBOEQsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0IscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQixxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0IscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7OztBQzlTRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQTBDO0FBQ2xELFFBQVEsaUNBQXFCLENBQUMsd0dBQW9CLEVBQUUsK0ZBQWlCLEVBQUUsNEZBQWdCLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUNsRyxNQUFNLEtBQUssRUFJTjtBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwTkQsMkdBQXdDO0FBQ3hDLDJHQUF3QztBQUN4QyxtSUFBd0Q7QUFDeEQsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDO0FBQ3RCLE1BQU0seUJBQXlCLEdBQUcsR0FBRyxDQUFDO0FBQ3RDLE1BQU0sZ0JBQWdCLEdBQUcsR0FBRyxDQUFDO0FBQzdCLE1BQU0sZ0JBQWdCLEdBQUcsR0FBRyxDQUFDO0FBQzdCLE1BQU0sNEJBQTRCLEdBQUcsR0FBRyxDQUFDO0FBQ3pDLE1BQXFCLGdCQUFnQjtJQUVwQyxJQUFJLENBQUMsU0FBaUI7UUFDckIsT0FBTyxLQUFLLENBQUMsR0FBRyxTQUFTLFdBQVcsRUFBRTtZQUNyQyxNQUFNLEVBQUUsS0FBSztZQUNiLE9BQU8sRUFBRSxFQUFFLGNBQWMsRUFBRSxrQkFBa0IsRUFBRTtTQUMvQyxDQUFDO2FBQ0EsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ2hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDdEIsSUFBSSxRQUFRLENBQUMsRUFBRSxFQUFFO2dCQUNoQixPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNsQixPQUFPO2FBQ1A7aUJBQU07Z0JBQ04sT0FBTyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDckM7UUFDRixDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQsYUFBYSxDQUFDLFNBQWlCO1FBQzlCLE1BQU0sTUFBTSxHQUFHO1lBQ2QsTUFBTSxFQUFFLEtBQUs7WUFDYixPQUFPLEVBQUUsRUFBRSxjQUFjLEVBQUUsa0JBQWtCLEVBQUU7U0FDL0MsQ0FBQztRQUNGLE9BQU8sS0FBSyxDQUFDLEdBQUcsU0FBUyxrQkFBa0IsRUFBRSxNQUFNLENBQUM7YUFDbEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFO2dCQUNqQixNQUFNLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUNyQztZQUNELE9BQU8sUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3hCLENBQUMsQ0FBQzthQUNELElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUNmLE9BQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxTQUFTLFdBQVc7WUFDckMsT0FBTyxJQUFJLHlCQUFlLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzdGLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRCxVQUFVLENBQUMsU0FBaUIsRUFBRSxTQUFpQixFQUFFLEtBQXdCO1FBQ3hFLE1BQU0sV0FBVyxHQUFHLFNBQVMsR0FBRyxnQkFBZ0IsR0FBRyxTQUFTLENBQUM7UUFDN0QsT0FBTyxLQUFLLENBQUMsV0FBVyxFQUFFO1lBQ3pCLE1BQU0sRUFBRSxLQUFLO1lBQ2IsT0FBTyxFQUFFLEVBQUUsY0FBYyxFQUFFLGtCQUFrQixFQUFFLGVBQWUsRUFBRSxVQUFVLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxLQUFLLEVBQUUsRUFBRTtTQUMxRixDQUFDO2FBQ0EsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7WUFDbEIsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLFNBQVMsRUFBRTtnQkFDbEMsT0FBTyxRQUFRO3FCQUNiLElBQUksRUFBRTtxQkFDTixJQUFJLENBQUMsQ0FBQyxPQVNOLEVBQUUsRUFBRTtvQkFDSixPQUFPLElBQUksaUJBQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO2dCQUNwSixDQUFDLENBQUMsQ0FBQzthQUNKO1lBQ0QsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLHlCQUF5QixFQUFFO2dCQUNsRCxPQUFPLFNBQVMsQ0FBQzthQUNqQjtZQUNELElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxnQkFBZ0IsRUFBRTtnQkFDekMsT0FBTyxTQUFTLENBQUM7YUFDakI7WUFDRCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssZ0JBQWdCLEVBQUU7Z0JBQ3pDLE9BQU8sY0FBYyxDQUFDO2FBQ3RCO1lBQ0QsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLDRCQUE0QixFQUFFO2dCQUNyRCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7YUFDdEM7UUFDRixDQUFDLENBQUM7SUFDSixDQUFDO0lBRUQsVUFBVSxDQUFDLFNBQWlCLEVBQUUsU0FBaUIsRUFBRSxLQUF3QjtRQUN4RSxPQUFPLEtBQUssQ0FBQyxHQUFHLFNBQVMsaUJBQWlCLFNBQVMsRUFBRSxFQUFFO1lBQ3RELE1BQU0sRUFBRSxLQUFLO1lBQ2IsT0FBTyxFQUFFLEVBQUUsY0FBYyxFQUFFLGtCQUFrQixFQUFFLGVBQWUsRUFBRSxVQUFVLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxLQUFLLEVBQUUsRUFBRTtTQUMxRixDQUFDO2FBQ0EsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7WUFDbEIsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLFNBQVMsRUFBRTtnQkFDbEMsT0FBTyxRQUFRO3FCQUNiLElBQUksRUFBRTtxQkFDTixJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUU7b0JBQ25CLE9BQU8sSUFBSSxpQkFBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFLEVBQUUsV0FBVyxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQy9FLENBQUMsQ0FBQzthQUNIO1lBQ0QsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLHlCQUF5QixFQUFFO2dCQUNsRCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsd0JBQXdCLENBQUMsQ0FBQzthQUNoRDtZQUNELElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxnQkFBZ0IsRUFBRTtnQkFDekMsT0FBTzthQUNQO1lBQ0QsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLDRCQUE0QixFQUFFO2dCQUNyRCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7YUFDdEM7UUFDRixDQUFDLENBQUM7SUFFSixDQUFDO0lBRUQsc0JBQXNCLENBQUMsVUFBa0IsRUFBRSxTQUFpQixFQUFFLFNBQWlCO1FBQzlFLE1BQU0sSUFBSSxHQUFHO1lBQ1osVUFBVTtZQUNWLGVBQWUsRUFBRSxFQUFFO1NBQ25CLENBQUM7UUFDRixNQUFNLE1BQU0sR0FBRztZQUNkLE1BQU0sRUFBRSxNQUFNO1lBQ2QsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO1lBQzFCLE9BQU8sRUFBRSxFQUFFLGNBQWMsRUFBRSxrQkFBa0IsRUFBRTtTQUMvQyxDQUFDO1FBQ0YsT0FBTyxLQUFLLENBQ1gsR0FBRyxTQUFTLGlCQUFpQixTQUFTLGVBQWUsRUFDckQsTUFBTSxDQUNOO2FBQ0MsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7WUFDbEIsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLFNBQVMsRUFBRTtnQkFDbEMsT0FBTyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO29CQUNsQyxPQUFPLElBQUksQ0FBQyxpQkFBaUI7Z0JBQzlCLENBQUMsQ0FBQzthQUNGO1lBQ0QsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLGdCQUFnQixFQUFFO2dCQUN6QyxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxDQUFDO2FBQ2hFO1lBQ0QsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLHlCQUF5QixFQUFFO2dCQUNsRCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQyxDQUFDO2FBQzlFO1lBQ0QsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLDRCQUE0QixFQUFFO2dCQUNyRCxPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQzthQUNqRDtRQUNGLENBQUMsQ0FBQztJQUVKLENBQUM7SUFFRCxVQUFVLENBQUMsaUJBQXlCLEVBQUUsTUFBYyxFQUFFLFNBQWlCLEVBQUUsU0FBaUI7UUFFekYsTUFBTSxJQUFJLEdBQUc7WUFDWixlQUFlLEVBQUUsQ0FBQztvQkFDakIsWUFBWSxFQUFFLE1BQU0sQ0FBQyxlQUFlLEVBQUU7b0JBQ3RDLElBQUksRUFBRSxNQUFNLENBQUMsTUFBTTtvQkFDbkIsS0FBSyxFQUFFLE1BQU0sQ0FBQyxNQUFNO29CQUNwQixJQUFJLEVBQUUsTUFBTSxDQUFDLElBQUk7aUJBQ2pCLENBQUM7U0FDRjtRQUNELE1BQU0sTUFBTSxHQUFHO1lBQ2QsTUFBTSxFQUFFLE1BQU07WUFDZCxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7WUFDMUIsT0FBTyxFQUFFLEVBQUUsY0FBYyxFQUFFLGtCQUFrQixFQUFFO1NBQy9DLENBQUM7UUFDRixPQUFPLEtBQUssQ0FDWCxHQUFHLFNBQVMsaUJBQWlCLFNBQVMsaUJBQWlCLGlCQUFpQixlQUFlLEVBQ3ZGLE1BQU0sQ0FBQzthQUNOLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ2xCLElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUU7Z0JBQ2xDLE9BQU87YUFDUDtZQUNELElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxnQkFBZ0IsRUFBRTtnQkFDekMsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQzthQUN4RDtZQUNELElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyx5QkFBeUIsRUFBRTtnQkFDbEQsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUMsQ0FBQzthQUM5RTtZQUNELElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyw0QkFBNEIsRUFBRTtnQkFDckQsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7YUFDakQ7UUFDRixDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDaEIsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7UUFDdEQsQ0FBQyxDQUFDO0lBRUosQ0FBQztDQUNEO0FBM0tELHNDQTJLQzs7Ozs7Ozs7Ozs7Ozs7QUNyTEQsNkZBQTZDO0FBRTdDLE1BQU0sc0JBQXNCLEdBQUcsd0JBQXdCLENBQUM7QUFDeEQsTUFBcUIsNEJBQTRCO0lBQ2hELG9CQUFvQjtRQUNiLGVBQU0sQ0FBQyxLQUFLLENBQUMsbURBQW1ELENBQUMsQ0FBQztRQUNsRSxNQUFNLHFCQUFxQixHQUFHLGNBQWMsQ0FBQyxPQUFPLENBQUMsc0JBQXNCLENBQUMsQ0FBQztRQUM3RSxJQUFJLHFCQUFxQixFQUFFO1lBQ3ZCLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1lBQ3JELElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxFQUFFO2dCQUNyQixlQUFNLENBQUMsS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7Z0JBQ3ZFLE9BQU8sU0FBUyxDQUFDO2FBQ3BCO2lCQUFNO2dCQUNILGVBQU0sQ0FBQyxLQUFLLENBQUMscURBQXFELEdBQUcsWUFBWSxDQUFDLENBQUM7Z0JBQ25GLE9BQU8sWUFBWSxDQUFDO2FBQ3ZCO1NBQ0o7UUFDRCxlQUFNLENBQUMsS0FBSyxDQUFDLDhEQUE4RCxDQUFDLENBQUM7SUFDakYsQ0FBQztJQUVKLHFCQUFxQixDQUFDLGlCQUF5QjtRQUN4QyxlQUFNLENBQUMsS0FBSyxDQUFDLHNEQUFzRCxHQUFHLGlCQUFpQixDQUFDLENBQUM7UUFDekYsY0FBYyxDQUFDLE9BQU8sQ0FBQyxzQkFBc0IsRUFBRSxpQkFBaUIsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ2pGLENBQUM7Q0FDSjtBQXJCRCxrREFxQkM7Ozs7Ozs7Ozs7Ozs7O0FDdkJELE1BQXFCLE1BQU07SUFRdkIsWUFBWSxNQUFjLEVBQUUsTUFBZSxFQUFFLFdBQW1CLEVBQUUsRUFBRSxrQkFBZ0MsRUFBRTtRQUNsRyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztRQUN2QyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUVNLFdBQVcsQ0FBQyxRQUFnQjtRQUMvQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztJQUM3QixDQUFDO0lBRU0sZUFBZTtRQUNsQixPQUFPLFFBQVEsQ0FBQztJQUNwQixDQUFDO0lBRU0sUUFBUTtRQUNYLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNiLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUMxQzthQUFNO1lBQ0gsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQ3RCO0lBQ0wsQ0FBQztJQUVNLE1BQU0sQ0FBQyxNQUFjO1FBQ3hCLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sS0FBSyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDL0UsQ0FBQztJQUVELE1BQU0sQ0FBQyxXQUFXLENBQUMsVUFBa0I7UUFDakMsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNwQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3BCLE9BQU8sSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBRTlCO2FBQU0sSUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMzQixPQUFPLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN6QzthQUFNO1lBQ0gsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBMkIsR0FBRyxVQUFVLENBQUMsQ0FBQztTQUM3RDtJQUNMLENBQUM7Q0FHSjtBQWpERCw0QkFpREM7Ozs7Ozs7Ozs7Ozs7O0FDbkRELE1BQXFCLGVBQWU7SUFNaEMsWUFBWSxPQUFlLEVBQUUsSUFBWSxFQUFFLFdBQW1CLEVBQUUsR0FBVztRQUN2RSxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztRQUMvQixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztJQUNuQixDQUFDO0NBQ0o7QUFaRCxxQ0FZQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaRCxnR0FBOEI7QUFDOUIsNEdBQXNDO0FBRXRDLE1BQXFCLGtCQUFtQixTQUFRLG9CQUFVO0lBSXRELFlBQVksTUFBYyxFQUN0QixNQUEwQixFQUMxQixLQUFhLEVBQUUsR0FBdUIsRUFDdEMsS0FBeUIsRUFDekIsSUFBd0IsRUFDeEIsR0FBdUIsRUFDdkIsVUFBOEIsRUFDOUIsVUFBOEIsRUFDOUIsWUFBZ0MsRUFDaEMsV0FBbUIsRUFDbkIsYUFBcUI7UUFFckIsS0FBSyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxXQUFXLENBQUMsQ0FBQztRQUN2RyxJQUFJLENBQUMsYUFBYSxHQUFHLGFBQWE7SUFDdEMsQ0FBQztJQUVELFVBQVUsQ0FBQyxLQUFhO1FBQ3BCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVuRCxJQUFJLE9BQU8sS0FBSyxTQUFTLEVBQUU7WUFDdkIsSUFBSSxjQUFjLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDO1lBQzdELElBQUksY0FBYyxFQUFFO2dCQUNoQixPQUFPLElBQUksZ0JBQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxDQUFDO2FBQ2xEO1NBQ0o7UUFDRCxPQUFPLElBQUksZ0JBQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUdELGdCQUFnQixDQUFDLE1BQWM7UUFDM0IsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDL0IsT0FBTyxFQUFFLENBQUM7U0FDYjtRQUNELElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDN0IsT0FBTyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDekM7YUFBTTtZQUNILElBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7WUFDM0IsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7WUFDNUMsT0FBTyxRQUFRLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFO2dCQUNoQyxJQUFJLFVBQVUsWUFBWSxXQUFXLEVBQUU7b0JBQ25DLE9BQU8sVUFBVSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssTUFBTSxDQUFDO2lCQUNqRTtxQkFBTTtvQkFDSCxPQUFPLEtBQUssQ0FBQztpQkFDaEI7WUFDTCxDQUFDLENBQUMsQ0FBQztTQUNOO0lBQ0wsQ0FBQztDQUNKO0FBbkRELHdDQW1EQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0REQsNkZBQTZDO0FBQzdDLGdHQUE4QjtBQUc5QiwwSUFBMEQ7QUFDMUQscUhBQTRDO0FBQzVDLHVJQUF3RDtBQUN4RCwrR0FBd0M7QUFJeEMsTUFBcUIsYUFBYTtJQWM5QixZQUFZLFNBQWlCLEVBQUUsU0FBaUIsRUFBRSxLQUF3QixFQUFFLFlBQTBCLEVBQUUsY0FBOEI7UUFDbEksSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUM7UUFDNUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUM7UUFDNUIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7UUFDcEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxZQUFZLENBQUM7UUFDbEMsSUFBSSxDQUFDLGVBQWUsR0FBRyxjQUFjLENBQUM7UUFDdEMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLHFCQUFXLEVBQUUsQ0FBQztRQUN0QyxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksdUJBQWEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDM0QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBRWxFLElBQUksOEJBQW9CLEVBQUUsQ0FBQztRQUUzQixJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSw2QkFBbUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ2hGLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNyQyxDQUFDO0lBRUQsS0FBSztRQUNELE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVSxFQUFFLFNBQVMsQ0FBQzthQUM1RSxJQUFJLENBQUMsQ0FBQyxhQUFhLEVBQUUsRUFBRTtZQUNwQixJQUFJLGFBQWEsSUFBSSxhQUFhLEtBQUssY0FBYyxFQUFFO2dCQUNuRCxJQUFJLENBQUMsVUFBVSxHQUFHLGFBQWEsQ0FBQyxTQUFTLENBQUM7Z0JBQzFDLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUM7cUJBQ3JFLElBQUksQ0FBQyxDQUFDLGFBQWEsRUFBRSxFQUFFO29CQUNwQixJQUFJLGFBQWEsSUFBSSxhQUFhLEtBQUssY0FBYyxFQUFFO3dCQUNuRCxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQVEsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzt3QkFDNUYsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7d0JBQ25DLElBQUksQ0FBQyxZQUFZLENBQUMsa0JBQWtCLEVBQUUsQ0FBQzt3QkFDdkMsZUFBTSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7d0JBQy9DLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLENBQUM7cUJBQy9CO2dCQUNMLENBQUMsQ0FBQztxQkFDRCxJQUFJLENBQUMsR0FBRyxFQUFFO29CQUNQLE1BQU0sd0JBQXdCLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO29CQUM3RSxJQUFJLHdCQUF3QixLQUFLLFNBQVMsRUFBRTt3QkFDeEMsSUFBSSxDQUFDLGtCQUFrQixHQUFHLHdCQUF3QixDQUFDO3FCQUN0RDt5QkFBTTt3QkFDSCxJQUFJLENBQUMsYUFBYSxDQUFDLHNCQUFzQixDQUFDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQzs2QkFDNUYsSUFBSSxDQUFDLENBQUMsaUJBQWlCLEVBQUUsRUFBRTs0QkFDeEIsSUFBSSxDQUFDLGtCQUFrQixHQUFHLGlCQUFpQixDQUFDOzRCQUM1QyxJQUFJLENBQUMsZUFBZSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO3dCQUN4RSxDQUFDLENBQUM7NkJBQ0QsSUFBSSxDQUFDLEdBQUcsRUFBRTs0QkFDUCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxnQkFBTSxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO3dCQUMxRCxDQUFDLENBQUM7cUJBQ0w7Z0JBQ0wsQ0FBQyxDQUFDO2FBQ1Q7UUFDTCxDQUFDLENBQUM7SUFDVixDQUFDO0lBRUQsZ0JBQWdCLENBQUMsTUFBYztRQUMzQixJQUFJLElBQUksQ0FBQyxrQkFBa0IsS0FBSyxTQUFTLEVBQUU7WUFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxnREFBZ0QsQ0FBQztTQUNwRTtRQUNELElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDckcsQ0FBQztJQUVPLFVBQVU7UUFDZCxJQUFJLENBQUMsWUFBWSxDQUFDLGtCQUFrQixFQUFFLENBQUM7SUFDM0MsQ0FBQztDQUVKO0FBM0VELG1DQTJFQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0RkQscUhBQTRDO0FBRzVDLE1BQXFCLGdCQUFpQixTQUFRLHVCQUFhO0lBRXZELFlBQVksT0FBZ0I7UUFDeEIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25CLENBQUM7SUFFRCxxQkFBcUI7UUFDakIsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2YsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDN0QsSUFBSSxjQUFjLElBQUksY0FBYyxZQUFZLFdBQVcsRUFBRTtnQkFDekQsT0FBTyxJQUFJLENBQUMsaUNBQWlDLENBQUMsY0FBYyxDQUFDLENBQUM7YUFDakU7aUJBQU07Z0JBQ0gsT0FBTyxJQUFJLEdBQUcsRUFBRSxDQUFDO2FBQ3BCO1NBQ0o7YUFBTTtZQUNILE9BQU8sSUFBSSxHQUFHLEVBQUUsQ0FBQztTQUNwQjtJQUVMLENBQUM7Q0FFSjtBQXBCRCxzQ0FvQkM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkJELGdHQUE4QjtBQUM5QiwwRkFBMEI7QUFDMUIsNkZBQTJDO0FBQzNDLDRKQUFvRDtBQUVwRCxNQUFxQixlQUFnQixTQUFRLGNBQUk7SUFDN0MsWUFBWSxNQUFjLEVBQUUsTUFBMEIsRUFBRSxLQUFhLEVBQUUsR0FBdUIsRUFBRSxLQUF5QixFQUNySCxJQUF3QixFQUFFLEdBQXVCLEVBQUUsVUFBOEIsRUFBRSxVQUE4QixFQUFFLFlBQWdDLEVBQUUsV0FBbUI7UUFDeEssS0FBSyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxXQUFXLENBQUMsQ0FBQztJQUMzRyxDQUFDO0lBRUQsVUFBVSxDQUFDLEtBQWE7UUFDcEIsSUFBSSxLQUFLLENBQUMsTUFBTSxFQUFFO1lBQ2QsSUFBSSxNQUFNLENBQUM7WUFDWCxJQUFJO2dCQUNBLE1BQU0sR0FBRyxvQ0FBYyxFQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsRUFBQyxTQUFTLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUMsQ0FBQyxDQUFDO2FBQ3JFO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1IsZUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUMsSUFBSSxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQzthQUN4RDtZQUNELE9BQU8sSUFBSSxnQkFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDMUM7SUFDTCxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsTUFBYztRQUMzQixJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUMvQixPQUFPLEVBQUUsQ0FBQztTQUNiO1FBRUQsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2YsTUFBTSxRQUFRLEdBQWdDLEVBQUUsQ0FBQztZQUNqRCxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztZQUNsRCxRQUFRLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBRSxDQUFDLE9BQU8sRUFBRSxFQUFFO2dCQUMxRCxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRTtvQkFDM0QsSUFBSSxPQUFPLFlBQVksV0FBVyxJQUFJLE9BQU8sWUFBWSxVQUFVLEVBQUU7d0JBQ2pFLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7cUJBQzFCO2lCQUNKO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFDSCxPQUFPLFFBQVEsQ0FBQztTQUNuQjthQUFNO1lBQ0gsT0FBTyxFQUFFLENBQUM7U0FDYjtJQUNMLENBQUM7Q0FDSjtBQXRDRCxxQ0FzQ0M7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0NELGdHQUE4QjtBQUM5QiwwRkFBMEI7QUFDMUIsNEpBQW9EO0FBQ3BELDZGQUEyQztBQUUzQyxNQUFxQix3QkFBeUIsU0FBUSxjQUFJO0lBQ3RELFlBQVksTUFBYyxFQUFFLE1BQTBCLEVBQUUsS0FBYSxFQUFFLEdBQXVCLEVBQUUsS0FBeUIsRUFDckgsSUFBd0IsRUFBRSxHQUF1QixFQUFFLFVBQThCLEVBQUUsVUFBOEIsRUFBRSxZQUFnQyxFQUFFLFdBQW1CO1FBQ3hLLEtBQUssQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDM0csQ0FBQztJQUVELFVBQVUsQ0FBQyxLQUFhO1FBQ3BCLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtZQUNkLElBQUksS0FBSyxDQUFDLE1BQU0sWUFBWSxXQUFXLElBQUksS0FBSyxDQUFDLE1BQU0sWUFBWSxVQUFVLEVBQUU7Z0JBQzNFLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUN4QyxJQUFJLE1BQU0sQ0FBQztnQkFDWCxJQUFJO29CQUNBLE1BQU0sR0FBRyxvQ0FBYyxFQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsRUFBQyxTQUFTLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUMsQ0FBQyxDQUFDO2lCQUNyRTtnQkFBQyxPQUFPLENBQUMsRUFBRTtvQkFDUixlQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBQyxJQUFJLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO2lCQUN4RDtnQkFDRCxJQUFJLEtBQUssS0FBSyxTQUFTLElBQUksS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7b0JBQ2hELE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRSxDQUFDO2lCQUN6QjtnQkFDRCxPQUFPLElBQUksZ0JBQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO2FBQzFDO1NBQ0o7SUFDTCxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsTUFBYztRQUMzQixJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUMvQixPQUFPLEVBQUUsQ0FBQztTQUNiO1FBRUQsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2YsTUFBTSxRQUFRLEdBQWdDLEVBQUUsQ0FBQztZQUNqRCxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztZQUNsRCxJQUFJLGNBQWMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNoRCxJQUFJLFdBQVcsR0FBRyxjQUFjLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxjQUFjLENBQUMsQ0FBQztZQUNyRyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLENBQUMsT0FBTyxDQUFFLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ3hELElBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFO29CQUMzRCxJQUFJLE9BQU8sWUFBWSxXQUFXLElBQUksT0FBTyxZQUFZLFVBQVUsRUFBRTt3QkFDakUsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztxQkFDMUI7aUJBQ0o7WUFDTCxDQUFDLENBQUMsQ0FBQztZQUNILE9BQU8sUUFBUSxDQUFDO1NBQ25CO2FBQU07WUFDSCxPQUFPLEVBQUUsQ0FBQztTQUNiO0lBQ0wsQ0FBQztJQUVELFFBQVEsQ0FBQyxPQUFpQztRQUN0QyxJQUFJLE9BQU8sWUFBWSxnQkFBZ0IsRUFBRTtZQUNyQyxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUM7U0FDeEI7UUFFRCxNQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3JELElBQUksY0FBYyxFQUFFO1lBQ2hCLE9BQU8sY0FBYyxDQUFDO1NBQ3pCO0lBQ0wsQ0FBQztDQUNKO0FBekRELDhDQXlEQzs7Ozs7Ozs7Ozs7Ozs7QUM5REQsNkZBQTZDO0FBRTdDLE1BQXFCLG9CQUFvQjtJQUlyQztRQUNJLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO1lBQzlDLEtBQUssTUFBTSxNQUFNLElBQUksT0FBTyxFQUFFO2dCQUMxQixJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssWUFBWSxFQUFFO29CQUM5QixJQUFJLE1BQU0sQ0FBQyxhQUFhLEtBQUssT0FBTyxFQUFFO3dCQUNsQyxJQUFJLE1BQU0sQ0FBQyxNQUFNLFlBQVksV0FBVyxFQUFFOzRCQUN0QyxlQUFNLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUM7NEJBQy9CLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0NBQ2pDLElBQUksWUFBWSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dDQUN2RCxJQUFJLFdBQVcsR0FBRyxLQUFLLENBQUM7Z0NBQ3hCLElBQUksTUFBTSxDQUFDLFFBQVEsRUFBRTtvQ0FDakIsSUFBSSxZQUFZLElBQUksWUFBWSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUU7d0NBQ3hELFdBQVcsR0FBRyxJQUFJLENBQUM7cUNBQ3RCO2lDQUNKO3FDQUFNO29DQUNILElBQUksWUFBWSxFQUFFO3dDQUNkLFdBQVcsR0FBRyxJQUFJLENBQUM7cUNBQ3RCO2lDQUNKO2dDQUNELElBQUksV0FBVyxFQUFHO29DQUNkLGVBQU0sQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7b0NBQzdCLElBQUksS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLGlCQUFpQixFQUFDLEVBQUMsT0FBTyxFQUFDLElBQUksRUFBQyxDQUFDLENBQUM7b0NBQ3hELE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO2lDQUN0Qzs2QkFDSjt5QkFDSjtxQkFDSjtpQkFDSjthQUNKO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDSCxNQUFNLE1BQU0sR0FBRyxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxpQkFBaUIsRUFBRSxJQUFJLEVBQUMsQ0FBQztRQUMzRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzlDLGVBQU0sQ0FBQyxJQUFJLENBQUMsb0NBQW9DLENBQUMsQ0FBQztJQUN0RCxDQUFDO0NBRUo7QUF2Q0QsMENBdUNDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pDRCxxSEFBNEM7QUFHNUMsTUFBcUIsaUJBQWtCLFNBQVEsdUJBQWE7SUFDeEQ7UUFDSSxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDckIsQ0FBQztJQUVELHFCQUFxQjtRQUNqQixPQUFPLElBQUksQ0FBQyxpQ0FBaUMsRUFBRSxDQUFDO0lBQ3BELENBQUM7Q0FDSjtBQVJELHVDQVFDOzs7Ozs7Ozs7Ozs7OztBQ1ZELDZGQUEyQztBQUUzQyxNQUE4QixhQUFhO0lBS3ZDLFlBQVksT0FBNEI7UUFDcEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7UUFDeEIsSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7UUFDcEMsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7SUFDMUMsQ0FBQztJQUVELEdBQUcsQ0FBQyxJQUFXO1FBQ1gsSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUMvRyxNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7U0FDaEU7UUFDRCxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDVixJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ3hDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQzthQUM3QztZQUNELElBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzNELElBQUksY0FBYyxFQUFFO2dCQUNoQixjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzdCO1NBQ0o7UUFDRCxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDWixJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQzVDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQzthQUNqRDtZQUNELElBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQy9ELElBQUksY0FBYyxFQUFFO2dCQUNoQixjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQzdCO1NBQ0o7SUFDTCxDQUFDO0lBSVMsaUNBQWlDLENBQUMsT0FBaUM7UUFDekUsTUFBTSxjQUFjLEdBQXlDLElBQUksR0FBRyxFQUFFLENBQUM7UUFDdkUsS0FBSyxNQUFNLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtZQUNyRCxJQUFJLGFBQWtELENBQUM7WUFDdkQsSUFBSSxPQUFPLEVBQUU7Z0JBQ1QsYUFBYSxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUN0RDtpQkFBTTtnQkFDSCxhQUFhLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ3ZEO1lBQ0QsYUFBYSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDNUIsSUFBSSxhQUFhLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDaEQsSUFBSSxDQUFDLGFBQWEsRUFBRTtvQkFDaEIsYUFBYSxHQUFHLEVBQUUsQ0FBQztvQkFDbkIsY0FBYyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDLENBQUM7aUJBQzlDO2dCQUNELGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQztZQUNqQyxDQUFDLENBQUM7U0FDTDtRQUNELEtBQUssTUFBTSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsb0JBQW9CLEVBQUU7WUFDdkQsSUFBSSxVQUFVLENBQUM7WUFDZixJQUFJLGdCQUFnQixDQUFDO1lBRXJCLElBQUk7Z0JBQ0EsSUFBSSxPQUFPLEVBQUU7b0JBQ1QsVUFBVSxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztpQkFDdkY7cUJBQU07b0JBQ0gsVUFBVSxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztpQkFDeEY7YUFDSjtZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNSLGVBQU0sQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFDLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDL0M7WUFFRCxJQUFJLFVBQVUsRUFBRTtnQkFDWixnQkFBZ0IsR0FBRyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUM7Z0JBRTVDLE9BQU8sZ0JBQWdCLEVBQUU7b0JBQ3JCLElBQUksZ0JBQWdCLFlBQVksV0FBVyxJQUFJLGdCQUFnQixZQUFZLFVBQVUsRUFBRTt3QkFDbkYsSUFBSSxTQUFTLEdBQUcsQ0FBRSxPQUFPLENBQUM7d0JBQzFCLElBQUksZUFBZSxHQUFHLE9BQU8sSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLENBQUM7d0JBQ3BFLElBQUksU0FBUyxJQUFJLGVBQWUsRUFBRTs0QkFDOUIsSUFBSSxhQUFhLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDOzRCQUN6RCxJQUFJLENBQUMsYUFBYSxFQUFFO2dDQUNoQixhQUFhLEdBQUcsRUFBRSxDQUFDO2dDQUNuQixjQUFjLENBQUMsR0FBRyxDQUFDLGdCQUFnQixFQUFFLGFBQWEsQ0FBQyxDQUFDOzZCQUN2RDs0QkFDRCxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUM7eUJBQ2hDO3FCQUNKO29CQUNELGdCQUFnQixHQUFHLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztpQkFDL0M7YUFDSjtTQUNKO1FBQ0QsT0FBTyxjQUFjLENBQUM7SUFDMUIsQ0FBQztDQUNKO0FBM0ZELG1DQTJGQzs7Ozs7Ozs7Ozs7Ozs7QUM1RkQsNkZBQTZDO0FBRTdDLE1BQXFCLGFBQWE7SUFLOUIsWUFBWSxXQUF3QjtRQUNoQyxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVc7UUFDL0IsSUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVELEtBQUs7UUFDRCxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUM1RCxlQUFNLENBQUMsS0FBSyxDQUFDLDRCQUE0QixJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sbUJBQW1CLENBQUMsQ0FBQztRQUN4RixJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFlBQVksRUFBRSxFQUFFO1lBQ3pDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUM7UUFDdEYsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQsV0FBVyxDQUFDLGdCQUEyQztRQUNuRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFTyxtQkFBbUIsQ0FBQyxLQUFZO1FBQ3BDLElBQUksV0FBVyxHQUFRLEtBQUssQ0FBQztRQUM3QixJQUFJLFdBQVcsQ0FBQyxTQUFTLEVBQUU7WUFDdkIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUU7Z0JBQ3ZCLFdBQVcsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO2dCQUM1QixlQUFNLENBQUMsS0FBSyxDQUFDLHdCQUF3QixXQUFXLENBQUMsSUFBSSxtQkFBbUIsQ0FBQyxDQUFDO2dCQUMxRSxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDdEQsSUFBSSxJQUFJLEVBQUU7b0JBQ04sTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDdEMsSUFBSSxNQUFNLEVBQUU7d0JBQ1IsZUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUM7d0JBQzdDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7NEJBQ2pDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDckIsQ0FBQyxDQUFDLENBQUM7cUJBQ047eUJBQU07d0JBQ0gsZUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztxQkFDN0I7aUJBQ0o7YUFDSjtTQUNKO0lBQ0wsQ0FBQztDQUVKO0FBN0NELG1DQTZDQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqREQsZ0dBQThCO0FBQzlCLDRHQUFzQztBQUV0QyxNQUFxQixTQUFVLFNBQVEsb0JBQVU7SUFDN0MsWUFBWSxNQUFjLEVBQUUsTUFBMEIsRUFBRSxLQUFhLEVBQUUsR0FBdUIsRUFBRSxLQUF5QixFQUNySCxJQUF3QixFQUFFLEdBQXVCLEVBQUUsVUFBOEIsRUFBRSxVQUE4QixFQUFFLFlBQWdDLEVBQUUsV0FBbUI7UUFDeEssS0FBSyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxXQUFXLENBQUMsQ0FBQztJQUMzRyxDQUFDO0lBRUQsVUFBVSxDQUFDLEtBQWE7UUFDcEIsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUNwRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQzlDLElBQUksY0FBYyxHQUFHLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLEVBQXFDLEVBQUUsQ0FBQyxNQUFNLFlBQVksV0FBVyxJQUFJLE1BQU0sWUFBWSxVQUFVLENBQUMsQ0FBQztZQUMvSixJQUFJLGNBQWMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDOUUsT0FBTyxJQUFJLGdCQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQzthQUNoRDtTQUNKO0lBQ0wsQ0FBQztJQUVELGdCQUFnQixDQUFDLE1BQWM7UUFDM0IsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDL0IsT0FBTyxFQUFFLENBQUM7U0FDYjtRQUNELElBQUcsTUFBTSxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDNUIsT0FBTyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDekM7UUFDRCxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztRQUMxQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUU1QyxJQUFJLEtBQUssS0FBSyxTQUFTLElBQUksSUFBSSxFQUFFO1lBQzdCLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxLQUFLLEVBQUU7Z0JBQ3pCLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQzthQUM1QjtpQkFBTTtnQkFDSCxPQUFPLEVBQUUsQ0FBQzthQUNiO1NBQ0o7YUFBTTtZQUNILE9BQU8sUUFBUSxDQUFDO1NBQ25CO0lBQ0wsQ0FBQztDQUNKO0FBcENELCtCQW9DQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2Q0QsZ0dBQThCO0FBQzlCLDRHQUFzQztBQUV0QyxNQUFxQixhQUFjLFNBQVEsb0JBQVU7SUFDakQsWUFBWSxNQUFjLEVBQUUsTUFBMEIsRUFBRSxLQUFhLEVBQUUsR0FBdUIsRUFBRSxLQUF5QixFQUNySCxJQUF3QixFQUFFLEdBQXVCLEVBQUUsVUFBOEIsRUFBRSxVQUE4QixFQUFFLFlBQWdDLEVBQUUsV0FBbUI7UUFDeEssS0FBSyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxXQUFXLENBQUMsQ0FBQztJQUMzRyxDQUFDO0lBRUQsVUFBVSxDQUFDLEtBQVU7UUFDakIsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ25ELElBQUksT0FBTyxFQUFFO1lBQ1QsSUFBSSxPQUFPLFlBQVksV0FBVyxFQUFFO2dCQUNoQyxPQUFPLElBQUksZ0JBQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQzthQUM1RDtpQkFBTTtnQkFDSCxPQUFPLElBQUksZ0JBQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3pDO1NBQ0o7SUFDTCxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsTUFBYztRQUMzQixJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUMvQixPQUFPLEVBQUUsQ0FBQztTQUNiO1FBQ0QsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLFNBQVMsRUFBRTtZQUM3QixPQUFPLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUN6QzthQUFNO1lBQ0gsSUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztZQUMzQixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztZQUM1QyxPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUU7Z0JBQ2hDLElBQUksVUFBVSxZQUFZLFdBQVcsRUFBRTtvQkFDbkMsT0FBTyxVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztpQkFDeEQ7cUJBQU0sSUFBSSxVQUFVLFlBQVksVUFBVSxFQUFFO29CQUN6QyxPQUFPLEtBQUssS0FBSyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7aUJBQ2xDO3FCQUFNO29CQUNILE9BQU8sS0FBSyxDQUFDO2lCQUNoQjtZQUNMLENBQUMsQ0FBQyxDQUFDO1NBQ047SUFDTCxDQUFDO0NBQ0o7QUFyQ0QsbUNBcUNDOzs7Ozs7Ozs7Ozs7OztBQ3hDRCxNQUFNLHNCQUFzQixHQUFHLElBQUksQ0FBQztBQUNwQyxNQUFNLE9BQU8sR0FBRyxDQUFDLHdCQUF3QixFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBR3hELE1BQXFCLG1CQUFtQjtJQVVwQyxZQUFZLGNBQTBCO1FBQ2xDLElBQUksQ0FBQyxjQUFjLEdBQUcsY0FBYztRQUNwQyxJQUFJLENBQUMsWUFBWSxHQUFHLEtBQUssQ0FBQztRQUMxQixJQUFJLENBQUMsa0JBQWtCLEdBQUcsS0FBSyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO0lBQzdCLENBQUM7SUFFRCxJQUFJO1FBQ0EsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGdCQUFnQixDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7WUFDN0MsSUFBSSxxQkFBcUIsR0FBRyxLQUFLLENBQUM7WUFDbEMsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLEVBQUU7Z0JBQzFCLElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxXQUFXLEVBQUU7b0JBQzdCLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFFLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUU7d0JBQ2pHLHFCQUFxQixHQUFHLElBQUksQ0FBQztxQkFDaEM7aUJBQ0o7YUFDSjtZQUNELElBQUkscUJBQXFCLEVBQUU7Z0JBQ3ZCLElBQUksQ0FBRSxJQUFJLENBQUMsWUFBWSxFQUFFO29CQUNyQixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztvQkFDekIsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO29CQUN0QixVQUFVLENBQUMsR0FBRyxFQUFFO3dCQUNaLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO29CQUM5QixDQUFDLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztpQkFDOUI7cUJBQU07b0JBQ0gsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7d0JBQ25CLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO3dCQUN4QixNQUFNLHFCQUFxQixHQUFHLENBQUMsQ0FBQzt3QkFFaEMsVUFBVSxDQUFDLEdBQUcsRUFBRTs0QkFDWixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQzs0QkFDekIsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDOzRCQUN0QixVQUFVLENBQUMsR0FBRyxFQUFFO2dDQUNaLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO2dDQUMxQixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQzs0QkFDN0IsQ0FBQyxFQUFFLHNCQUFzQixDQUFDLENBQUM7d0JBQy9CLENBQUMsRUFBRSxxQkFBcUIsR0FBRyxzQkFBc0IsQ0FBQyxDQUFDO3FCQUN0RDtpQkFDSjthQUVKO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDSCxNQUFNLE1BQU0sR0FBRyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUMsQ0FBQztRQUMxRixJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFTyxpQkFBaUIsQ0FBQyxRQUFtQjtRQUN6QyxJQUFJLFNBQVMsR0FBYSxLQUFLLENBQUM7UUFDaEMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNwQixJQUFJLElBQUksWUFBWSxXQUFXLEVBQUU7Z0JBQzdCLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxRQUFRLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxRQUFRLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxLQUFLLEVBQUU7b0JBQ2xGLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFO3dCQUNiLFNBQVMsR0FBRyxJQUFJLENBQUM7cUJBQ3BCO29CQUNELElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRTt3QkFDckIsU0FBUyxHQUFHLElBQUksQ0FBQztxQkFDcEI7b0JBQ0QsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sS0FBSyxNQUFNLEVBQUU7d0JBQy9CLFNBQVMsR0FBRyxJQUFJLENBQUM7cUJBQ3BCO2lCQUNKO2FBQ0o7UUFDTCxDQUFDLENBQUM7UUFDRixPQUFPLFNBQVMsQ0FBQztJQUNyQixDQUFDO0lBRU8sd0JBQXdCLENBQUMsUUFBbUI7UUFFaEQsTUFBTSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sRUFBMEIsRUFBRSxDQUFDLE9BQU8sS0FBSyxJQUFJLENBQUMsQ0FBQztRQUN0SSxJQUFJLFVBQVUsR0FBYSxJQUFJLENBQUM7UUFDaEMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNwQixJQUFJLElBQUksWUFBWSxXQUFXLEVBQUU7Z0JBQzdCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRTtvQkFDckMsT0FBTyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNwQyxDQUFDLENBQUMsRUFBRTtvQkFDQSxVQUFVLEdBQUcsS0FBSyxDQUFDO2lCQUN0QjthQUNKO1FBQ0wsQ0FBQyxDQUFDO1FBQ0YsT0FBTyxVQUFVLENBQUM7SUFDdEIsQ0FBQztDQUNKO0FBNUZELHlDQTRGQzs7Ozs7Ozs7Ozs7Ozs7QUNoR0QsOEpBQWlFO0FBR2pFLE1BQThCLElBQUk7SUFjOUIsWUFBWSxNQUFjLEVBQUUsTUFBMEIsRUFBRSxLQUFhLEVBQUUsR0FBdUIsRUFBRSxLQUF5QixFQUNySCxJQUF3QixFQUFFLEdBQXVCLEVBQUUsVUFBOEIsRUFBRSxVQUE4QixFQUFFLFlBQWdDLEVBQUUsV0FBbUI7UUFFeEssSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBQzdCLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1FBQzdCLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQ25DLENBQUM7SUFFRCxLQUFLLENBQUMsS0FBYTtRQUNmLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQzNCLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsSUFBSSxLQUFLLFlBQVksYUFBYSxFQUFFO1lBQ2hDLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxPQUFPLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxTQUFTLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxVQUFVLEVBQUU7Z0JBQ2pGLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxJQUFJLEVBQUU7b0JBQ3ZDLE9BQU8sS0FBSztpQkFDZjtnQkFDRCxJQUFJLElBQUksQ0FBQyxHQUFHLElBQUksS0FBSyxDQUFDLEdBQUcsS0FBSyxJQUFJLENBQUMsR0FBRyxFQUFFO29CQUNwQyxPQUFPLEtBQUs7aUJBQ2Y7YUFDSjtZQUNELE9BQU8sSUFBSSxDQUFDO1NBQ2Y7YUFBTTtZQUNILE9BQU8sSUFBSSxDQUFDO1NBQ2Y7SUFFTCxDQUFDO0lBT0Qsc0JBQXNCLENBQUMsS0FBWTtRQUMvQixNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkMsSUFBSSxNQUFNLFlBQVksV0FBVyxJQUFJLE1BQU0sWUFBWSxVQUFVLEVBQUU7WUFDL0QsSUFBSSxNQUFNLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxFQUFFO2dCQUNwQyxPQUFPLE1BQU0sQ0FBQzthQUNqQjtpQkFBTTtnQkFDSCxJQUFJLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDO2dCQUM5QyxJQUFJLE9BQU8sSUFBSSxDQUFDLE9BQU8sWUFBWSxXQUFXLElBQUksT0FBTyxZQUFZLFVBQVUsQ0FBQyxFQUFFO29CQUM5RSxPQUFPLE9BQU8sQ0FBQztpQkFDbEI7YUFDSjtTQUNKO0lBQ0wsQ0FBQztJQUVELG1CQUFtQjtRQUNmLElBQUksT0FBTyxDQUFDO1FBRVosSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ25CLElBQUk7Z0JBQ0EsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDaEcsT0FBTyxHQUFHLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQzthQUNsQztZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNSLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDcEI7WUFDRCxJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUNWLE9BQU8sRUFBRSxDQUFDO2FBQ2I7U0FDSjtRQUNELElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNqQixPQUFPLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbEQsSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDVixPQUFPLEVBQUUsQ0FBQzthQUNiO1NBQ0o7UUFFRCxJQUFJLFFBQVEsR0FBRyxFQUFFLENBQUM7UUFDbEIsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1osSUFBSTtnQkFDQSxJQUFJLE1BQU0sQ0FBQztnQkFDWCxJQUFJLE9BQU8sRUFBRTtvQkFDVCxNQUFNLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztpQkFDckY7cUJBQU07b0JBQ0gsTUFBTSxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7aUJBQ3RGO2dCQUNELElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQztnQkFDaEMsT0FBTyxJQUFJLEVBQUU7b0JBQ1QsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDcEIsSUFBSSxHQUFHLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQztpQkFDL0I7YUFDSjtZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNSLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDcEI7U0FDSjtRQUNELElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNWLElBQUksT0FBTyxFQUFFO2dCQUNULFFBQVEsR0FBRyxvREFBb0IsRUFBQyxJQUFJLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBQ3REO2lCQUFNO2dCQUNILFFBQVEsR0FBRyxvREFBb0IsRUFBQyxJQUFJLENBQUMsR0FBRyxDQUFDO2FBQzVDO1NBQ0o7UUFDRCxPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFjLEVBQXVDLEVBQUUsQ0FBQyxPQUFPLFlBQVksV0FBVyxJQUFJLE9BQU8sWUFBWSxVQUFVLENBQUMsQ0FBQztJQUNySixDQUFDO0NBRUo7QUF2SEQsMEJBdUhDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3hIRCw4SEFBa0Q7QUFDbEQsb0lBQXNEO0FBQ3RELGlJQUFvRDtBQUNwRCw4SEFBa0Q7QUFHbEQsTUFBcUIsVUFBVTtJQVMzQixZQUFZLEtBQWM7UUFDdEIsSUFBSSxDQUFDLHlCQUF5QixHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7UUFDM0MsSUFBSSxDQUFDLDJCQUEyQixHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7UUFDN0MsSUFBSSxDQUFDLHlCQUF5QixHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7UUFDM0MsSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksMkJBQWlCLEVBQUUsQ0FBQztRQUNsRCxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLENBQUM7UUFDeEIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFFbkIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNqQixJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdkQsSUFBSSxDQUFFLFlBQVksRUFBRTtnQkFDaEIsWUFBWSxHQUFHLEVBQUUsQ0FBQztnQkFDbEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBQyxZQUFZLENBQUMsQ0FBQzthQUNwRDtZQUNELFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFeEIsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDMUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3ZDO1lBRUQsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNqQixJQUFJLHdCQUF3QixHQUFHLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUNuRixJQUFJLENBQUMsd0JBQXdCLEVBQUU7b0JBQzNCLHdCQUF3QixHQUFHLElBQUksMEJBQWdCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztvQkFDaEUsSUFBSSxDQUFDLHlCQUF5QixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLHdCQUF3QixDQUFDLENBQUM7aUJBQ2pGO2dCQUNELHdCQUF3QixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUN0QztpQkFBTSxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQzFCLElBQUksMEJBQTBCLEdBQUcsSUFBSSxDQUFDLDJCQUEyQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7Z0JBQ3pGLElBQUksQ0FBQywwQkFBMEIsRUFBRTtvQkFDN0IsMEJBQTBCLEdBQUcsSUFBSSw0QkFBa0IsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7b0JBQ3ZFLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSwwQkFBMEIsQ0FBQyxDQUFDO2lCQUN2RjtnQkFDRCwwQkFBMEIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDeEM7aUJBQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUN4QixJQUFJLHVCQUF1QixHQUFHLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUNsRixJQUFJLENBQUMsdUJBQXVCLEVBQUU7b0JBQzFCLHVCQUF1QixHQUFHLElBQUksMEJBQWdCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO29CQUNoRSxJQUFJLENBQUMseUJBQXlCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztpQkFDaEY7Z0JBQ0QsdUJBQXVCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3JDO2lCQUFNO2dCQUNILElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDckM7UUFDTCxDQUFDLENBQUM7SUFDTixDQUFDO0lBRUQsV0FBVztRQUNQLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFFRCxtQkFBbUIsQ0FBQyxNQUFlO1FBQy9CLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2xELElBQUksWUFBWSxFQUFFO1lBQ2QsT0FBTyxZQUFZLENBQUM7U0FDdkI7YUFBTTtZQUNILE9BQU8sRUFBRSxDQUFDO1NBQ2I7SUFDTCxDQUFDO0lBRUQsSUFBSSxZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQzlCLENBQUM7SUFFRCxxQkFBcUI7UUFDakIsTUFBTSxNQUFNLEdBQXlDLElBQUksR0FBRyxFQUFFLENBQUM7UUFDL0QsS0FBSyxNQUFNLE1BQU0sSUFBSSxJQUFJLENBQUMseUJBQXlCLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDMUQsS0FBSyxNQUFNLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSxFQUFFO2dCQUMzRCxJQUFJLGFBQWEsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUN4QyxJQUFJLENBQUMsYUFBYSxFQUFFO29CQUNoQixhQUFhLEdBQUcsRUFBRTtvQkFDbEIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUMsYUFBYSxDQUFDLENBQUM7aUJBQ3JDO2dCQUNELGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQzthQUNoQztTQUNKO1FBQ0QsS0FBSyxNQUFNLE1BQU0sSUFBSSxJQUFJLENBQUMseUJBQXlCLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDMUQsS0FBSyxNQUFNLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSxFQUFFO2dCQUMzRCxJQUFJLGFBQWEsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUN4QyxJQUFJLENBQUMsYUFBYSxFQUFFO29CQUNoQixhQUFhLEdBQUcsRUFBRTtvQkFDbEIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUMsYUFBYSxDQUFDLENBQUM7aUJBQ3JDO2dCQUNELGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQzthQUNoQztTQUNKO1FBQ0QsS0FBSyxNQUFNLE1BQU0sSUFBSSxJQUFJLENBQUMsMkJBQTJCLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDNUQsS0FBSyxNQUFNLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSxFQUFFO2dCQUMzRCxJQUFJLGFBQWEsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUN4QyxJQUFJLENBQUMsYUFBYSxFQUFFO29CQUNoQixhQUFhLEdBQUcsRUFBRTtvQkFDbEIsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUMsYUFBYSxDQUFDLENBQUM7aUJBQ3JDO2dCQUNELGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQzthQUNoQztTQUNKO1FBQ0QsS0FBSyxNQUFNLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxxQkFBcUIsRUFBRSxFQUFFO1lBQzVFLElBQUksYUFBYSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDeEMsSUFBSSxDQUFDLGFBQWEsRUFBRTtnQkFDaEIsYUFBYSxHQUFHLEVBQUU7Z0JBQ2xCLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO1NBQ2hDO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztDQUVKO0FBckhELGdDQXFIQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzSEQsNEdBQXNDO0FBQ3RDLHlHQUFvQztBQUNwQyxxSEFBNEM7QUFDNUMseUdBQW9DO0FBQ3BDLDRHQUFzQztBQUN0QywySEFBZ0Q7QUFDaEQsb0lBQXNEO0FBQ3RELHNKQUFrRTtBQUVsRSxNQUFxQixXQUFXO0lBSTVCO1FBQ0ksSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQzlCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxvQkFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRCxJQUFJLHdCQUF3QjtRQUN4QixPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUMvQyxDQUFDO0lBRUQsaUJBQWlCO1FBQ2IsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQztJQUN6QyxDQUFDO0lBRUQsU0FBUyxDQUFDLEtBQWM7UUFDcEIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLG9CQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVELGtCQUFrQjtRQUNkLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBQ2pFLENBQUM7SUFFRCxlQUFlLENBQUMsS0FBYTtRQUN6QixJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsWUFBWSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFzQyxFQUFFLENBQUMsTUFBTSxZQUFZLFdBQVcsSUFBSSxNQUFNLFlBQVksVUFBVSxDQUFDLENBQUM7UUFDMUosS0FBSyxNQUFNLE9BQU8sSUFBSSxRQUFRLEVBQUU7WUFDNUIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDN0MsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO2dCQUNyQixNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUM1RCxJQUFJLFlBQVksRUFBRTtvQkFDZCxPQUFPLFlBQVksQ0FBQztpQkFDdkI7YUFDSjtTQUNKO0lBQ0wsQ0FBQztJQUVELG1CQUFtQixDQUFDLE1BQWM7UUFDOUIsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQsOEJBQThCLENBQUMsTUFBYztRQUN6QyxNQUFNLFFBQVEsR0FBaUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUN6RCxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUMzQixNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUN6RCxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDakUsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQsVUFBVSxDQUFDLElBbUJWOztRQUNHLFFBQVEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDeEIsS0FBSyxXQUFXO2dCQUNaLE9BQU8sSUFBSSx1QkFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFDLFVBQUksQ0FBQyxNQUFNLDBDQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxVQUFJLENBQUMsS0FBSywwQ0FBRSxHQUFHLEVBQUUsVUFBSSxDQUFDLEtBQUssMENBQUUsS0FBSyxFQUFFLFVBQUksQ0FBQyxLQUFLLDBDQUFFLElBQUksRUFBRSxVQUFJLENBQUMsS0FBSywwQ0FBRSxHQUFHLEVBQUUsVUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE9BQU8sMENBQUUsR0FBRyxFQUFFLFVBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxPQUFPLDBDQUFFLEdBQUcsRUFBRSxVQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsT0FBTywwQ0FBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzlPLEtBQUssT0FBTztnQkFDUixPQUFPLElBQUksbUJBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxVQUFJLENBQUMsS0FBSywwQ0FBRSxHQUFHLEVBQUUsVUFBSSxDQUFDLEtBQUssMENBQUUsS0FBSyxFQUFFLFVBQUksQ0FBQyxLQUFLLDBDQUFFLElBQUksRUFBRSxVQUFJLENBQUMsS0FBSywwQ0FBRSxHQUFHLEVBQUUsVUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE9BQU8sMENBQUUsR0FBRyxFQUFFLFVBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxPQUFPLDBDQUFFLEdBQUcsRUFBRSxVQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsT0FBTywwQ0FBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3pPLEtBQUssT0FBTztnQkFDUixPQUFPLElBQUksbUJBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxVQUFJLENBQUMsS0FBSywwQ0FBRSxHQUFHLEVBQUUsVUFBSSxDQUFDLEtBQUssMENBQUUsS0FBSyxFQUFFLFVBQUksQ0FBQyxLQUFLLDBDQUFFLElBQUksRUFBRSxVQUFJLENBQUMsS0FBSywwQ0FBRSxHQUFHLEVBQUUsVUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE9BQU8sMENBQUUsR0FBRyxFQUFFLFVBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxPQUFPLDBDQUFFLEdBQUcsRUFBRSxVQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsT0FBTywwQ0FBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3pPLEtBQUssYUFBYTtnQkFDZCxPQUFPLElBQUkseUJBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxVQUFJLENBQUMsS0FBSywwQ0FBRSxHQUFHLEVBQUUsVUFBSSxDQUFDLEtBQUssMENBQUUsS0FBSyxFQUFFLFVBQUksQ0FBQyxLQUFLLDBDQUFFLElBQUksRUFBRSxVQUFJLENBQUMsS0FBSywwQ0FBRSxHQUFHLEVBQUUsVUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE9BQU8sMENBQUUsR0FBRyxFQUFFLFVBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxPQUFPLDBDQUFFLEdBQUcsRUFBRSxVQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsT0FBTywwQ0FBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQy9PLEtBQUssc0JBQXNCO2dCQUN2QixPQUFPLElBQUksa0NBQXdCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsVUFBSSxDQUFDLEtBQUssMENBQUUsR0FBRyxFQUFFLFVBQUksQ0FBQyxLQUFLLDBDQUFFLEtBQUssRUFBRSxVQUFJLENBQUMsS0FBSywwQ0FBRSxJQUFJLEVBQUUsVUFBSSxDQUFDLEtBQUssMENBQUUsR0FBRyxFQUFFLFVBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxPQUFPLDBDQUFFLEdBQUcsRUFBRSxXQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsT0FBTyw0Q0FBRSxHQUFHLEVBQUUsV0FBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE9BQU8sNENBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUN4UCxLQUFLLGdCQUFnQjtnQkFDakIsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsS0FBSyxTQUFTLEVBQUU7b0JBQ3hDLE9BQU8sSUFBSSxvQkFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLFdBQUksQ0FBQyxLQUFLLDRDQUFFLEdBQUcsRUFBRSxXQUFJLENBQUMsS0FBSyw0Q0FBRSxLQUFLLEVBQUUsV0FBSSxDQUFDLEtBQUssNENBQUUsSUFBSSxFQUFFLFdBQUksQ0FBQyxLQUFLLDRDQUFFLEdBQUcsRUFBRSxXQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsT0FBTyw0Q0FBRSxHQUFHLEVBQUUsV0FBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE9BQU8sNENBQUUsR0FBRyxFQUFFLFdBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxPQUFPLDRDQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7aUJBQ3pPO3FCQUFNO29CQUNILE9BQU8sSUFBSSw0QkFBa0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxXQUFJLENBQUMsS0FBSyw0Q0FBRSxHQUFHLEVBQUUsV0FBSSxDQUFDLEtBQUssNENBQUUsS0FBSyxFQUFFLFdBQUksQ0FBQyxLQUFLLDRDQUFFLElBQUksRUFBRSxXQUFJLENBQUMsS0FBSyw0Q0FBRSxHQUFHLEVBQUUsV0FBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE9BQU8sNENBQUUsR0FBRyxFQUFFLFdBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxPQUFPLDRDQUFFLEdBQUcsRUFBRSxXQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsT0FBTyw0Q0FBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO2lCQUMzUTtZQUNMO2dCQUNJLE9BQU8sSUFBSSxvQkFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLFdBQUksQ0FBQyxLQUFLLDRDQUFFLEdBQUcsRUFBRSxXQUFJLENBQUMsS0FBSyw0Q0FBRSxLQUFLLEVBQUUsV0FBSSxDQUFDLEtBQUssNENBQUUsSUFBSSxFQUFFLFdBQUksQ0FBQyxLQUFLLDRDQUFFLEdBQUcsRUFBRSxXQUFJLGFBQUosSUFBSSx1QkFBSixJQUFJLENBQUUsT0FBTyw0Q0FBRSxHQUFHLEVBQUUsV0FBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLE9BQU8sNENBQUUsR0FBRyxFQUFFLFdBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxPQUFPLDRDQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDN087SUFFTCxDQUFDO0NBR0o7QUEvRkQsaUNBK0ZDOzs7Ozs7Ozs7Ozs7OztBQ3ZHRCxNQUFxQixPQUFPO0lBU3hCLFlBQVksRUFBVSxFQUFFLFNBQWlCLEVBQUUsT0FBMEIsRUFBRSxJQUFhLEVBQUUsV0FBb0IsRUFBRSxXQUF3QixFQUFFLGFBQTRCO1FBQzlKLElBQUksRUFBRSxLQUFLLElBQUksSUFBSSxFQUFFLEtBQUssU0FBUyxFQUFFO1lBQ2pDLE1BQU0sSUFBSSxLQUFLLENBQUMsa0NBQWtDLENBQUMsQ0FBQztTQUN2RDtRQUNELElBQUksU0FBUyxLQUFLLElBQUksSUFBSSxTQUFTLEtBQUssU0FBUyxFQUFFO1lBQy9DLE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLENBQUMsQ0FBQztTQUM5RDtRQUNELElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFDM0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDdkIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDL0IsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDL0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7SUFDdkMsQ0FBQztDQUVKO0FBekJELDZCQXlCQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QkQsZ0dBQThCO0FBQzlCLDBGQUEwQjtBQUUxQixNQUFxQixVQUFXLFNBQVEsY0FBSTtJQUN4QyxZQUFZLE1BQWMsRUFBRSxNQUEwQixFQUFFLEtBQWEsRUFBRSxHQUF1QixFQUFFLEtBQXlCLEVBQ3JILElBQXdCLEVBQUUsR0FBdUIsRUFBRSxVQUE4QixFQUFFLFVBQThCLEVBQUUsWUFBZ0MsRUFBRSxXQUFtQjtRQUN4SyxLQUFLLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzNHLENBQUM7SUFFRCxVQUFVLENBQUMsS0FBYTtRQUNwQixPQUFPLElBQUksZ0JBQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVELGdCQUFnQixDQUFDLE1BQWM7UUFDM0IsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDL0IsT0FBTyxFQUFFLENBQUM7U0FDYjtRQUNELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1FBQzVDLE9BQU8sUUFBUSxDQUFDO0lBQ3BCLENBQUM7Q0FDSjtBQWpCRCxnQ0FpQkM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEJELHFIQUE0QztBQUc1QyxNQUFxQixnQkFBaUIsU0FBUSx1QkFBYTtJQUN2RCxZQUFZLE9BQWdCO1FBQ3hCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBRUQscUJBQXFCO1FBQ2pCLElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDekQsT0FBTyxJQUFJLENBQUMsaUNBQWlDLEVBQUUsQ0FBQztTQUNuRDthQUFNO1lBQ0gsT0FBTyxJQUFJLEdBQUcsRUFBRSxDQUFDO1NBQ3BCO0lBQ0wsQ0FBQztDQUNKO0FBWkQsc0NBWUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZkQsZ0dBQThCO0FBQzlCLDRHQUFzQztBQUV0QyxNQUFxQixTQUFVLFNBQVEsb0JBQVU7SUFDN0MsWUFBWSxNQUFjLEVBQUUsTUFBMEIsRUFBRSxLQUFhLEVBQUUsR0FBdUIsRUFBRSxLQUF5QixFQUNySCxJQUF3QixFQUFFLEdBQXVCLEVBQUUsVUFBOEIsRUFBRSxVQUE4QixFQUFFLFlBQWdDLEVBQUUsV0FBbUI7UUFDeEssS0FBSyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxXQUFXLENBQUMsQ0FBQztJQUMzRyxDQUFDO0lBRUQsVUFBVSxDQUFDLEtBQWE7UUFDcEIsSUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUMxQixJQUFJLE1BQU0sRUFBRTtZQUNSLElBQUksTUFBTSxZQUFZLGdCQUFnQixFQUFFO2dCQUNwQyxPQUFPLElBQUksZ0JBQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNoRDtpQkFBTSxJQUFJLE1BQU0sWUFBWSxpQkFBaUIsRUFBRTtnQkFDNUMsT0FBTyxJQUFJLGdCQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN6QztTQUNKO0lBQ0wsQ0FBQztJQUVELGdCQUFnQixDQUFDLE1BQWM7UUFDM0IsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDL0IsT0FBTyxFQUFFLENBQUM7U0FDYjtRQUNELElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxTQUFTLEVBQUU7WUFDN0IsT0FBTyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDekM7UUFDRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUM1QyxPQUFPLFFBQVEsQ0FBQztJQUNwQixDQUFDO0NBQ0o7QUEzQkQsK0JBMkJDOzs7Ozs7Ozs7Ozs7OztBQzlCRCxNQUFxQixPQUFPO0lBS3hCLFlBQVksRUFBVSxFQUFFLElBQVksRUFBRSxXQUE2RDtRQUMvRixJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQztRQUNiLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQ25DLENBQUM7Q0FDSjtBQVZELDZCQVVDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZELHFIQUE0QztBQUc1QyxNQUFxQixrQkFBbUIsU0FBUSx1QkFBYTtJQUN6RCxZQUFZLE9BQWdCO1FBQ3hCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNuQixDQUFDO0lBRUQscUJBQXFCO1FBQ2pCLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUVmLE1BQU0sZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUN0RyxNQUFNLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUMvQyxJQUFJLE9BQU8sWUFBWSxXQUFXLElBQUksT0FBTyxZQUFZLFVBQVUsRUFBRTtnQkFDakUsT0FBTyxJQUFJLENBQUMsaUNBQWlDLEVBQUUsQ0FBQzthQUNuRDtpQkFBTTtnQkFDSCxPQUFPLElBQUksR0FBRyxFQUFFLENBQUM7YUFDcEI7U0FDSjthQUFNO1lBQ0gsT0FBTyxJQUFJLEdBQUcsRUFBRSxDQUFDO1NBQ3BCO0lBQ0wsQ0FBQztDQUNKO0FBbkJELHdDQW1CQzs7Ozs7Ozs7Ozs7Ozs7O0FDdEJELG9KQUFpSDtBQUtqSCxJQUFJLFFBQVEsQ0FBQztBQUViLFFBQU8sYUFBb0IsRUFBRTtJQUN6QixLQUFLLFlBQVk7UUFDYixRQUFRLEdBQUcsNkJBQVEsQ0FBQyxLQUFLLENBQUM7UUFDMUIsTUFBTTtJQUNWLEtBQUssYUFBYTtRQUNkLFFBQVEsR0FBRyw2QkFBUSxDQUFDLEtBQUssQ0FBQztRQUMxQixNQUFNO0lBQ1YsS0FBSyxRQUFRO1FBQ1QsUUFBUSxHQUFHLDZCQUFRLENBQUMsS0FBSyxDQUFDO1FBQzFCLE1BQU07SUFDVjtRQUNJLFFBQVEsR0FBRyw2QkFBUSxDQUFDLEtBQUs7Q0FDaEM7QUFFRCwyQ0FBc0IsQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLDBDQUFxQixDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFHdkUsY0FBTSxHQUFHLElBQUksNkJBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QmhELDRIQUFtRDtBQUNuRCw0RkFBMEM7QUFDMUMscUlBQXlEO0FBRXpELHlLQUFpRjtBQUVqRixlQUFNLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLENBQUM7QUFFeEMsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUN0RCxJQUFJLFlBQVksRUFBRTtJQUNkLGVBQU0sQ0FBQyxJQUFJLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztJQUM5QyxNQUFNLGFBQWEsR0FBRyxZQUFZLENBQUMsWUFBWSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ2pFLElBQUksYUFBYSxFQUFFO1FBQ2YsZUFBTSxDQUFDLElBQUksQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO1FBQ3JELElBQUk7WUFDQSxNQUFNLFNBQVMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNsRCxJQUFJLFNBQVMsR0FBRyxTQUFTLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUN4RCxJQUFJLFNBQVMsRUFBRTtnQkFDRixlQUFNLENBQUMsSUFBSSxDQUFDLDJCQUEyQixDQUFDLENBQUM7Z0JBQ3pDLE1BQU0sYUFBYSxHQUFHLElBQUksMEJBQWdCLEVBQUUsQ0FBQztnQkFDN0MsTUFBTSxlQUFlLEdBQUcsSUFBSSxzQ0FBNEIsRUFBRSxDQUFDO2dCQUMzRCxNQUFNLGNBQWMsR0FBRyxJQUFJLHVCQUFhLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLGFBQWEsRUFBRSxlQUFlLENBQUMsQ0FBQztnQkFDakgsY0FBYyxDQUFDLEtBQUssRUFBRSxDQUFDO2FBQ25DO1NBQ0s7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNSLGVBQU0sQ0FBQyxLQUFLLENBQUMsdUJBQXVCLEVBQUUsSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxDQUFDO1NBQzdFO0tBQ0o7Q0FDSjtLQUFNO0lBQ0gsZUFBTSxDQUFDLEtBQUssQ0FBQyxvQ0FBb0MsRUFBRSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDLENBQUM7Q0FDdkc7Ozs7Ozs7Ozs7OztBQzlCWTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsbUJBQU8sQ0FBQyx3SEFBaUM7QUFDakUsc0JBQXNCLG1CQUFPLENBQUMsa0dBQXNCO0FBQ3BELHVCQUF1QixtQkFBTyxDQUFDLHdHQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNEZBQTRGO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsOEVBQThFO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHNEQUFzRCwwR0FBMEcsaURBQWlELDJFQUEyRSxxSUFBcUk7QUFDdmU7QUFDQSxDQUFDO0FBQ0Qsa0NBQWtDO0FBQ2xDOzs7Ozs7Ozs7OztBQ2hLYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsbUJBQU8sQ0FBQyxrR0FBc0I7QUFDcEQsa0JBQWtCLG1CQUFPLENBQUMsNEdBQTJCO0FBQ3JELHVCQUF1QixtQkFBTyxDQUFDLHdHQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0NBQW9DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9DQUFvQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGdEQUFnRCx3QkFBd0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLG1DQUFtQyxtRUFBbUUsOENBQThDLGdFQUFnRSxnSEFBZ0g7QUFDeFk7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7O0FDbk5hO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixtQkFBTyxDQUFDLHdIQUFpQztBQUNqRSxzQkFBc0IsbUJBQU8sQ0FBQyxrR0FBc0I7QUFDcEQscUJBQXFCLG1CQUFPLENBQUMsb0dBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpRkFBaUY7QUFDN0g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCO0FBQ3ZCOzs7Ozs7Ozs7OztBQ3ZNYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0MsZ0JBQWdCLEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQyxnQkFBZ0IsS0FBSztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDLGtCQUFrQixLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEMsc0JBQXNCLEtBQUs7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEMsc0JBQXNCLEtBQUs7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHdDQUF3QztBQUN4Qyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHdDQUF3QztBQUN4QywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUI7QUFDekI7Ozs7Ozs7Ozs7O0FDN1BhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixtQkFBTyxDQUFDLDJHQUE0QjtBQUMzRCxxQkFBcUIsbUJBQU8sQ0FBQyx1R0FBMEI7QUFDdkQsc0JBQXNCLG1CQUFPLENBQUMsOEZBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJB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U0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNCQUFzQjtBQUN0Qjs7Ozs7Ozs7Ozs7QUMzUWE7QUFDYjtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Is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QkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOzs7Ozs7Ozs7OztBQ3hFYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELDBCQUEwQjtBQUMxQjs7Ozs7O1VDL0xBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztVRU5BO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1zZWxlY3Rvci1nZW5lcmF0b3IvYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Vycm9yLXN0YWNrLXBhcnNlci9lcnJvci1zdGFjay1wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5LXNlbGVjdG9yLXNoYWRvdy1kb20vc3JjL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnktc2VsZWN0b3Itc2hhZG93LWRvbS9zcmMvcXVlcnlTZWxlY3RvckRlZXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3F1aWNrLXNvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtY29uc3VtZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2Utbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdGFjay1nZW5lcmF0b3Ivbm9kZV9tb2R1bGVzL3N0YWNrZnJhbWUvc3RhY2tmcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RhY2stZ2VuZXJhdG9yL3N0YWNrLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RhY2tmcmFtZS9zdGFja2ZyYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdGFja3RyYWNlLWdwcy9zdGFja3RyYWNlLWdwcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RhY2t0cmFjZS1qcy9zdGFja3RyYWNlLmpzIiwid2VicGFjazovLy8uL3NyYy9faW5mcmEvQWlmZXhTZXJ2aWNlSFRUUC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvX2luZnJhL0Jyb3dzZXJTZXJ2aWNlU2Vzc2lvblN0b3JhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9BY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9BaWZleFBsdWdpbkluZm8udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9BdHRyaWJ1dGVWYWx1ZVJ1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9Ccm93c2VyU2NyaXB0LnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vQ1NTQ29udGV4dE1hcHBlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL0NTU1NlbGVjdG9yUnVsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL0NTU1NlbGVjdG9yV2l0aFZhbHVlUnVsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL0NsYXNzTXV0YXRpb25IYW5kbGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vQ29udGV4dExlc3NNYXBwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9Db250ZXh0TWFwcGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vRXZlbnRMaXN0ZW5lci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL0luZGV4UnVsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL0lubmVyVGV4dFJ1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9QYWdlTXV0YXRpb25IYW5kbGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vUnVsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL1J1bGVNYXBwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9SdWxlU2VydmljZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL1Nlc3Npb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9TaW1wbGVSdWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9kb21haW4vVVJMQ29udGV4dE1hcHBlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL1ZhbHVlUnVsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZG9tYWluL1dlYnNpdGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RvbWFpbi9YUGF0aENvbnRleHRNYXBwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9Mb2dnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9jb250cm9sL0NhdGVnb3J5U2VydmljZUNvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2NvbnRyb2wvTG9nR3JvdXBDb250cm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9leHRlbnNpb24vRXh0ZW5zaW9uSGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvTG9nZ2VyT3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0Fic3RyYWN0Q2F0ZWdvcnlMb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9jYXRlZ29yeS9DYXRlZ29yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5Q29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5Q29uc29sZUxvZ2dlckltcGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9jYXRlZ29yeS9DYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5TWVzc2FnZUJ1ZmZlckltcGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9jYXRlZ29yeS9DYXRlZ29yeVJ1bnRpbWVTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5U2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL2NhdGVnb3J5L0NhdGVnb3J5U2VydmljZUZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9zdGFuZGFyZC9BYnN0cmFjdExvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL3N0YW5kYXJkL0NvbnNvbGVMb2dnZXJJbXBsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvc3RhbmRhcmQvTEZTZXJ2aWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvc3RhbmRhcmQvTG9nR3JvdXBSdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvc3RhbmRhcmQvTG9nR3JvdXBSdW50aW1lU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL2xvZy9zdGFuZGFyZC9Mb2dnZXJGYWN0b3J5SW1wbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvbG9nL3N0YW5kYXJkL0xvZ2dlckZhY3RvcnlPcHRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxvZ2dpbmcvZGlzdC9jb21tb25qcy9sb2cvc3RhbmRhcmQvTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL3R5cGVzY3JpcHQtbG9nZ2luZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1sb2dnaW5nL2Rpc3QvY29tbW9uanMvdXRpbHMvRGF0YVN0cnVjdHVyZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL3V0aWxzL0pTT05IZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbG9nZ2luZy9kaXN0L2NvbW1vbmpzL3V0aWxzL01lc3NhZ2VVdGlscy5qcyIsIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly8vd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly8vd2VicGFjay9zdGFydHVwIiwid2VicGFjazovLy93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sZSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5Dc3NTZWxlY3RvckdlbmVyYXRvcj1lKCk6dC5Dc3NTZWxlY3RvckdlbmVyYXRvcj1lKCl9KHNlbGYsKGZ1bmN0aW9uKCl7cmV0dXJuKCgpPT57dmFyIHQ9ezQyNjoodCxlLG4pPT57dmFyIHI9big1MjkpO2Z1bmN0aW9uIG8odCxlLG4pe0FycmF5LmlzQXJyYXkodCk/dC5wdXNoKGUpOnRbbl09ZX10LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGUsbixpLHU9W107aWYoQXJyYXkuaXNBcnJheSh0KSluPVtdLGU9dC5sZW5ndGgtMTtlbHNle2lmKFwib2JqZWN0XCIhPXR5cGVvZiB0fHxudWxsPT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0aW5nIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgYnV0IGBcIisobnVsbD09PXQ/XCJudWxsXCI6dHlwZW9mIHQpK1wiYCBwcm92aWRlZC5cIik7bj17fSxpPU9iamVjdC5rZXlzKHQpLGU9aS5sZW5ndGgtMX1yZXR1cm4gZnVuY3Rpb24gbihjLHMpe3ZhciBhLGwsZixwO2ZvcihsPWk/aVtzXTpzLEFycmF5LmlzQXJyYXkodFtsXSl8fCh2b2lkIDA9PT10W2xdP3RbbF09W106dFtsXT1bdFtsXV0pLGE9MDthPHRbbF0ubGVuZ3RoO2ErKylvKChwPWMsZj1BcnJheS5pc0FycmF5KHApP1tdLmNvbmNhdChwKTpyKHApKSx0W2xdW2FdLGwpLHM+PWU/dS5wdXNoKGYpOm4oZixzKzEpfShuLDApLHV9fSw1Mjk6dD0+e3QuZXhwb3J0cz1mdW5jdGlvbigpe2Zvcih2YXIgdD17fSxuPTA7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl7dmFyIHI9YXJndW1lbnRzW25dO2Zvcih2YXIgbyBpbiByKWUuY2FsbChyLG8pJiYodFtvXT1yW29dKX1yZXR1cm4gdH07dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eX19LGU9e307ZnVuY3Rpb24gbihyKXt2YXIgbz1lW3JdO2lmKHZvaWQgMCE9PW8pcmV0dXJuIG8uZXhwb3J0czt2YXIgaT1lW3JdPXtleHBvcnRzOnt9fTtyZXR1cm4gdFtyXShpLGkuZXhwb3J0cyxuKSxpLmV4cG9ydHN9bi5uPXQ9Pnt2YXIgZT10JiZ0Ll9fZXNNb2R1bGU/KCk9PnQuZGVmYXVsdDooKT0+dDtyZXR1cm4gbi5kKGUse2E6ZX0pLGV9LG4uZD0odCxlKT0+e2Zvcih2YXIgciBpbiBlKW4ubyhlLHIpJiYhbi5vKHQscikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIse2VudW1lcmFibGU6ITAsZ2V0OmVbcl19KX0sbi5vPSh0LGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSxuLnI9dD0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9O3ZhciByPXt9O3JldHVybigoKT0+e1widXNlIHN0cmljdFwiO24ucihyKSxuLmQocix7ZGVmYXVsdDooKT0+VyxnZXRDc3NTZWxlY3RvcjooKT0+Qn0pO3ZhciB0PVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2w/XCJzeW1ib2xcIjp0eXBlb2YgdH07ZnVuY3Rpb24gZShlKXtyZXR1cm4gbnVsbCE9ZSYmXCJvYmplY3RcIj09PSh2b2lkIDA9PT1lP1widW5kZWZpbmVkXCI6dChlKSkmJjE9PT1lLm5vZGVUeXBlJiZcIm9iamVjdFwiPT09dChlLnN0eWxlKSYmXCJvYmplY3RcIj09PXQoZS5vd25lckRvY3VtZW50KX1mdW5jdGlvbiBvKHQ9W10pe2NvbnN0W2U9W10sLi4ubl09dDtyZXR1cm4gMD09PW4ubGVuZ3RoP2U6bi5yZWR1Y2UoKCh0LGUpPT50LmZpbHRlcigodD0+ZS5pbmNsdWRlcyh0KSkpKSxlKX1mdW5jdGlvbiBpKHQ9W10pe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gbmV3IFJlZ0V4cChcIi5eXCIpO2NvbnN0IGU9dC5tYXAoKHQ9Plwic3RyaW5nXCI9PXR5cGVvZiB0P1wiXlwiK3QucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCs/Ll0vZyxcIlxcXFwkJlwiKS5yZXBsYWNlKC9cXCovZyxcIi4rXCIpK1wiJFwiOnQuc291cmNlKSkuam9pbihcInxcIik7cmV0dXJuIG5ldyBSZWdFeHAoZSl9ZnVuY3Rpb24gdSh0LGUsbj1kb2N1bWVudCl7Y29uc3Qgcj1BcnJheS5mcm9tKG4ucXVlcnlTZWxlY3RvckFsbChlKSk7cmV0dXJuIHIubGVuZ3RoPT09dC5sZW5ndGgmJnQuZXZlcnkoKHQ9PnIuaW5jbHVkZXModCkpKX1mdW5jdGlvbiBjKHQsbil7cmV0dXJuIG49bnVsbCE9bj9uOnRbMF0ub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiOnJvb3RcIiksbyh0Lm1hcCgodD0+ZnVuY3Rpb24odCxuKXtjb25zdCByPVtdO2xldCBvPXQ7Zm9yKDtlKG8pJiZvIT09bjspci5wdXNoKG8pLG89by5wYXJlbnRFbGVtZW50O3JldHVybiByfSh0LG4pKSkpfWZ1bmN0aW9uIHModCl7Y29uc3Qgbj10LnBhcmVudE5vZGU7aWYobil7Y29uc3Qgcj1BcnJheS5mcm9tKG4uY2hpbGROb2RlcykuZmlsdGVyKGUpLmluZGV4T2YodCk7aWYocj4tMSlyZXR1cm5bYDpudGgtY2hpbGQoJHtyKzF9KWBdfXJldHVybltdfWZ1bmN0aW9uIGEodCl7cmV0dXJuIG8odC5tYXAocykpfWNvbnN0IGw9bmV3IFJlZ0V4cChbXCJeJFwiLFwiXFxcXHNcIixcIl5cXFxcZFwiXS5qb2luKFwifFwiKSksZj1uZXcgUmVnRXhwKFtcIl4kXCIsXCJeXFxcXGRcIl0uam9pbihcInxcIikpLHA9W1wiaWRcIixcImNsYXNzXCIsXCJ0YWdcIixcImF0dHJpYnV0ZVwiLFwibnRoY2hpbGRcIixcIm50aG9mdHlwZVwiXSxkPVtcIm50aG9mdHlwZVwiLFwidGFnXCIsXCJpZFwiLFwiY2xhc3NcIixcImF0dHJpYnV0ZVwiLFwibnRoY2hpbGRcIl07ZnVuY3Rpb24gbSh0KXtyZXR1cm5bXCI6cm9vdFwiLC4uLmMoW3RdKS5tYXAoKHQ9PmEoW3RdKVswXSkpLnJldmVyc2UoKV0uam9pbihcIiA+IFwiKX1jb25zdCB5PXtzZWxlY3RvcnM6W1wiaWRcIixcImNsYXNzXCIsXCJ0YWdcIixcImF0dHJpYnV0ZVwiXSxpbmNsdWRlVGFnOiExLHdoaXRlbGlzdDpbXSxibGFja2xpc3Q6W10sY29tYmluZVdpdGhpblNlbGVjdG9yOiEwLGNvbWJpbmVCZXR3ZWVuU2VsZWN0b3JzOiEwLHJvb3Q6ZG9jdW1lbnQsbWF4Q29tYmluYXRpb25zOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSxtYXhDYW5kaWRhdGVzOk51bWJlci5QT1NJVElWRV9JTkZJTklUWX07ZnVuY3Rpb24gZyh0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdHx8ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBSZWdFeHB9KHQpfWZ1bmN0aW9uIGIodCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/dC5maWx0ZXIoZyk6W119ZnVuY3Rpb24gaCh0LGUpe3JldHVybiBmdW5jdGlvbih0KXtjb25zdCBlPVtOb2RlLkRPQ1VNRU5UX05PREUsTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFLE5vZGUuRUxFTUVOVF9OT0RFXTtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBOb2RlfSh0KSYmZS5pbmNsdWRlcyh0Lm5vZGVUeXBlKX0odCk/dDplLm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIjpyb290XCIpfWZ1bmN0aW9uIFModCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQ/dDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9dmFyIHY9big0MjYpLHg9bi5uKHYpO2NvbnN0IE49aShbXCJjbGFzc1wiLFwiaWRcIixcIm5nLSpcIl0pO2Z1bmN0aW9uIEEoe25vZGVOYW1lOnR9KXtyZXR1cm5gWyR7dH1dYH1mdW5jdGlvbiBqKHtub2RlTmFtZTp0LG5vZGVWYWx1ZTplfSl7cmV0dXJuYFske3R9PScke1IoZSl9J11gfWZ1bmN0aW9uIHcoe25vZGVOYW1lOnR9KXtyZXR1cm4hTi50ZXN0KHQpfWZ1bmN0aW9uIEUodCl7Y29uc3QgZT1BcnJheS5mcm9tKHQuYXR0cmlidXRlcykuZmlsdGVyKHcpO3JldHVyblsuLi5lLm1hcChBKSwuLi5lLm1hcChqKV19ZnVuY3Rpb24gTyh0KXtyZXR1cm4odC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKXx8XCJcIikudHJpbSgpLnNwbGl0KC9cXHMrLykuZmlsdGVyKCh0PT4hZi50ZXN0KHQpKSkubWFwKCh0PT5gLiR7Uih0KX1gKSl9ZnVuY3Rpb24gVCh0KXtjb25zdCBlPVsuLi5uZXcgU2V0KHQubWFwKCh0PT5SKHQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSkpKV07cmV0dXJuIDA9PT1lLmxlbmd0aHx8ZS5sZW5ndGg+MT9bXTpbZVswXV19ZnVuY3Rpb24gQyh0KXtjb25zdCBlPVQoW3RdKVswXSxuPXQucGFyZW50RWxlbWVudDtpZihuKXtjb25zdCByPUFycmF5LmZyb20obi5jaGlsZHJlbikuZmlsdGVyKCh0PT50LnRhZ05hbWUudG9Mb3dlckNhc2UoKT09PWUpKS5pbmRleE9mKHQpO2lmKHI+LTEpcmV0dXJuW2Ake2V9Om50aC1vZi10eXBlKCR7cisxfSlgXX1yZXR1cm5bXX1mdW5jdGlvbiBJKHQ9W10se21heFJlc3VsdHM6ZT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFl9PXt9KXtjb25zdCBuPVtdO2xldCByPTAsbz1fKDEpO2Zvcig7by5sZW5ndGg8PXQubGVuZ3RoJiZyPGU7KXIrPTEsbi5wdXNoKG8ubWFwKChlPT50W2VdKSkpLG89JChvLHQubGVuZ3RoLTEpO3JldHVybiBufWZ1bmN0aW9uICQodD1bXSxlPTApe2NvbnN0IG49dC5sZW5ndGg7aWYoMD09PW4pcmV0dXJuW107Y29uc3Qgcj1bLi4udF07cltuLTFdKz0xO2ZvcihsZXQgdD1uLTE7dD49MDt0LS0paWYoclt0XT5lKXtpZigwPT09dClyZXR1cm4gXyhuKzEpO3JbdC0xXSsrLHJbdF09clt0LTFdKzF9cmV0dXJuIHJbbi0xXT5lP18obisxKTpyfWZ1bmN0aW9uIF8odD0xKXtyZXR1cm4gQXJyYXkuZnJvbShBcnJheSh0KS5rZXlzKCkpfWNvbnN0IEQ9XCI6XCIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSxQPS9bICFcIiMkJSYnKClcXFtcXF17fH08PiorLC4vOz0/QF5gflxcXFxdLztmdW5jdGlvbiBSKHQ9XCJcIil7dmFyIGUsbjtyZXR1cm4gbnVsbCE9PShuPW51bGw9PT0oZT1udWxsPT09Q1NTfHx2b2lkIDA9PT1DU1M/dm9pZCAwOkNTUy5lc2NhcGUpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmNhbGwoQ1NTLHQpKSYmdm9pZCAwIT09bj9uOmZ1bmN0aW9uKHQ9XCJcIil7cmV0dXJuIHQuc3BsaXQoXCJcIikubWFwKCh0PT5cIjpcIj09PXQ/YFxcXFwke0R9IGA6UC50ZXN0KHQpP2BcXFxcJHt0fWA6ZXNjYXBlKHQpLnJlcGxhY2UoLyUvZyxcIlxcXFxcIikpKS5qb2luKFwiXCIpfSh0KX1jb25zdCBNPXt0YWc6VCxpZDpmdW5jdGlvbih0KXtpZigwPT09dC5sZW5ndGh8fHQubGVuZ3RoPjEpcmV0dXJuW107Y29uc3QgZT10WzBdLG49ZS5nZXRBdHRyaWJ1dGUoXCJpZFwiKXx8XCJcIixyPWAjJHtSKG4pfWA7cmV0dXJuIWwudGVzdChuKSYmdShbZV0scixlLm93bmVyRG9jdW1lbnQpP1tyXTpbXX0sY2xhc3M6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5tYXAoTykpfSxhdHRyaWJ1dGU6ZnVuY3Rpb24odCl7cmV0dXJuIG8odC5tYXAoRSkpfSxudGhjaGlsZDphLG50aG9mdHlwZTpmdW5jdGlvbih0KXtyZXR1cm4gbyh0Lm1hcChDKSl9fTtmdW5jdGlvbiBrKHQpe3JldHVybiB0LmluY2x1ZGVzKFwidGFnXCIpfHx0LmluY2x1ZGVzKFwibnRob2Z0eXBlXCIpP1suLi50XTpbLi4udCxcInRhZ1wiXX1mdW5jdGlvbiBGKHQ9e30pe2NvbnN0IGU9Wy4uLmRdO3JldHVybiB0LnRhZyYmdC5udGhvZnR5cGUmJmUuc3BsaWNlKGUuaW5kZXhPZihcInRhZ1wiKSwxKSxlLm1hcCgoZT0+e3JldHVybihyPXQpW249ZV0/cltuXS5qb2luKFwiXCIpOlwiXCI7dmFyIG4scn0pKS5qb2luKFwiXCIpfWZ1bmN0aW9uIFYodCxlLG49XCJcIixyKXtjb25zdCBvPWZ1bmN0aW9uKHQsZSl7cmV0dXJuXCJcIj09PWU/dDpmdW5jdGlvbih0LGUpe3JldHVyblsuLi50Lm1hcCgodD0+ZStcIiBcIit0KSksLi4udC5tYXAoKHQ9PmUrXCIgPiBcIit0KSldfSh0LGUpfShmdW5jdGlvbih0LGUsbil7Y29uc3Qgcj0obz1mdW5jdGlvbih0LGUpe3JldHVybiBmdW5jdGlvbih0KXtjb25zdHtzZWxlY3RvcnM6ZSxjb21iaW5lQmV0d2VlblNlbGVjdG9yczpuLGluY2x1ZGVUYWc6cixtYXhDYW5kaWRhdGVzOm99PXQsaT1uP0koZSx7bWF4UmVzdWx0czpvfSk6ZS5tYXAoKHQ9Plt0XSkpO3JldHVybiByP2kubWFwKGspOml9KGUpLm1hcCgoZT0+ZnVuY3Rpb24odCxlKXtjb25zdCBuPXt9O3JldHVybiB0LmZvckVhY2goKHQ9Pntjb25zdCByPWVbdF07ci5sZW5ndGg+MCYmKG5bdF09cil9KSkseCgpKG4pLm1hcChGKX0oZSx0KSkpLmZpbHRlcigodD0+dC5sZW5ndGg+MCkpfShmdW5jdGlvbih0LGUpe2NvbnN0e2JsYWNrbGlzdDpuLHdoaXRlbGlzdDpyLGNvbWJpbmVXaXRoaW5TZWxlY3RvcjpvLG1heENvbWJpbmF0aW9uczp1fT1lLGM9aShuKSxzPWkocik7cmV0dXJuIGZ1bmN0aW9uKHQpe2NvbnN0e3NlbGVjdG9yczplLGluY2x1ZGVUYWc6bn09dCxyPVtdLmNvbmNhdChlKTtyZXR1cm4gbiYmIXIuaW5jbHVkZXMoXCJ0YWdcIikmJnIucHVzaChcInRhZ1wiKSxyfShlKS5yZWR1Y2UoKChlLG4pPT57Y29uc3Qgcj1mdW5jdGlvbih0PVtdLGUpe3JldHVybiB0LnNvcnQoKCh0LG4pPT57Y29uc3Qgcj1lLnRlc3QodCksbz1lLnRlc3Qobik7cmV0dXJuIHImJiFvPy0xOiFyJiZvPzE6MH0pKX0oZnVuY3Rpb24odD1bXSxlLG4pe3JldHVybiB0LmZpbHRlcigodD0+bi50ZXN0KHQpfHwhZS50ZXN0KHQpKSl9KGZ1bmN0aW9uKHQsZSl7dmFyIG47cmV0dXJuKG51bGwhPT0obj1NW2VdKSYmdm9pZCAwIT09bj9uOigpPT5bXSkodCl9KHQsbiksYyxzKSxzKTtyZXR1cm4gZVtuXT1vP0kocix7bWF4UmVzdWx0czp1fSk6ci5tYXAoKHQ9Plt0XSkpLGV9KSx7fSl9KHQsbiksbiksW10uY29uY2F0KC4uLm8pKTt2YXIgbztyZXR1cm5bLi4ubmV3IFNldChyKV19KHQsci5yb290LHIpLG4pO2Zvcihjb25zdCBlIG9mIG8paWYodSh0LGUsci5yb290KSlyZXR1cm4gZTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBCKHQsbj17fSl7Y29uc3Qgcj1mdW5jdGlvbih0KXtjb25zdCBuPShBcnJheS5pc0FycmF5KHQpP3Q6W3RdKS5maWx0ZXIoZSk7cmV0dXJuWy4uLm5ldyBTZXQobildfSh0KSxvPWZ1bmN0aW9uKHQsZT17fSl7Y29uc3Qgbj1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30seSksZSk7cmV0dXJue3NlbGVjdG9yczoocj1uLnNlbGVjdG9ycyxBcnJheS5pc0FycmF5KHIpP3IuZmlsdGVyKCh0PT5wLmluY2x1ZGVzKHQpKSk6W10pLHdoaXRlbGlzdDpiKG4ud2hpdGVsaXN0KSxibGFja2xpc3Q6YihuLmJsYWNrbGlzdCkscm9vdDpoKG4ucm9vdCx0KSxjb21iaW5lV2l0aGluU2VsZWN0b3I6ISFuLmNvbWJpbmVXaXRoaW5TZWxlY3Rvcixjb21iaW5lQmV0d2VlblNlbGVjdG9yczohIW4uY29tYmluZUJldHdlZW5TZWxlY3RvcnMsaW5jbHVkZVRhZzohIW4uaW5jbHVkZVRhZyxtYXhDb21iaW5hdGlvbnM6UyhuLm1heENvbWJpbmF0aW9ucyksbWF4Q2FuZGlkYXRlczpTKG4ubWF4Q2FuZGlkYXRlcyl9O3ZhciByfShyWzBdLG4pO2xldCBpPVwiXCIscz1vLnJvb3Q7ZnVuY3Rpb24gYSgpe3JldHVybiBmdW5jdGlvbih0LGUsbj1cIlwiLHIpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gbnVsbDtjb25zdCBvPVt0Lmxlbmd0aD4xP3Q6W10sLi4uYyh0LGUpLm1hcCgodD0+W3RdKSldO2Zvcihjb25zdCB0IG9mIG8pe2NvbnN0IGU9Vih0LDAsbixyKTtpZihlKXJldHVybntmb3VuZEVsZW1lbnRzOnQsc2VsZWN0b3I6ZX19cmV0dXJuIG51bGx9KHIscyxpLG8pfWxldCBsPWEoKTtmb3IoO2w7KXtjb25zdHtmb3VuZEVsZW1lbnRzOnQsc2VsZWN0b3I6ZX09bDtpZih1KHIsZSxvLnJvb3QpKXJldHVybiBlO3M9dFswXSxpPWUsbD1hKCl9cmV0dXJuIHIubGVuZ3RoPjE/ci5tYXAoKHQ9PkIodCxvKSkpLmpvaW4oXCIsIFwiKTpmdW5jdGlvbih0KXtyZXR1cm4gdC5tYXAobSkuam9pbihcIiwgXCIpfShyKX1jb25zdCBXPUJ9KSgpLHJ9KSgpfSkpOyIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ2Vycm9yLXN0YWNrLXBhcnNlcicsIFsnc3RhY2tmcmFtZSddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnc3RhY2tmcmFtZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LkVycm9yU3RhY2tQYXJzZXIgPSBmYWN0b3J5KHJvb3QuU3RhY2tGcmFtZSk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyKFN0YWNrRnJhbWUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQID0gLyhefEApXFxTK1xcOlxcZCsvO1xuICAgIHZhciBDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQID0gL15cXHMqYXQgLiooXFxTK1xcOlxcZCt8XFwobmF0aXZlXFwpKS9tO1xuICAgIHZhciBTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQID0gL14oZXZhbEApPyhcXFtuYXRpdmUgY29kZVxcXSk/JC87XG5cbiAgICBmdW5jdGlvbiBfbWFwKGFycmF5LCBmbiwgdGhpc0FyZykge1xuICAgICAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZS5tYXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5tYXAoZm4sIHRoaXNBcmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9IG5ldyBBcnJheShhcnJheS5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dFtpXSA9IGZuLmNhbGwodGhpc0FyZywgYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9maWx0ZXIoYXJyYXksIGZuLCB0aGlzQXJnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5LmZpbHRlcihmbiwgdGhpc0FyZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuLmNhbGwodGhpc0FyZywgYXJyYXlbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2luZGV4T2YoYXJyYXksIHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih0YXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhbiBFcnJvciBvYmplY3QsIGV4dHJhY3QgdGhlIG1vc3QgaW5mb3JtYXRpb24gZnJvbSBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3Igb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBvZiBTdGFja0ZyYW1lc1xuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yLnN0YWNrdHJhY2UgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBlcnJvclsnb3BlcmEjc291cmNlbG9jJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYShlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrICYmIGVycm9yLnN0YWNrLm1hdGNoKENIUk9NRV9JRV9TVEFDS19SRUdFWFApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWOE9ySUUoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRkZPclNhZmFyaShlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIGdpdmVuIEVycm9yIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFNlcGFyYXRlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzIGZyb20gYSBzdHJpbmcgb2YgdGhlIGZvcm06IChVUkk6TGluZTpDb2x1bW4pXG4gICAgICAgIGV4dHJhY3RMb2NhdGlvbjogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkZXh0cmFjdExvY2F0aW9uKHVybExpa2UpIHtcbiAgICAgICAgICAgIC8vIEZhaWwtZmFzdCBidXQgcmV0dXJuIGxvY2F0aW9ucyBsaWtlIFwiKG5hdGl2ZSlcIlxuICAgICAgICAgICAgaWYgKHVybExpa2UuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdXJsTGlrZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWdFeHAgPSAvKC4rPykoPzpcXDooXFxkKykpPyg/OlxcOihcXGQrKSk/JC87XG4gICAgICAgICAgICB2YXIgcGFydHMgPSByZWdFeHAuZXhlYyh1cmxMaWtlLnJlcGxhY2UoL1tcXChcXCldL2csICcnKSk7XG4gICAgICAgICAgICByZXR1cm4gW3BhcnRzWzFdLCBwYXJ0c1syXSB8fCB1bmRlZmluZWQsIHBhcnRzWzNdIHx8IHVuZGVmaW5lZF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VWOE9ySUU6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlVjhPcklFKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBfZmlsdGVyKGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goQ0hST01FX0lFX1NUQUNLX1JFR0VYUCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIF9tYXAoZmlsdGVyZWQsIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCcoZXZhbCAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGF3YXkgZXZhbCBpbmZvcm1hdGlvbiB1bnRpbCB3ZSBpbXBsZW1lbnQgc3RhY2t0cmFjZS5qcy9zdGFja2ZyYW1lIzhcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvZXZhbCBjb2RlL2csICdldmFsJykucmVwbGFjZSgvKFxcKGV2YWwgYXQgW15cXCgpXSopfChcXClcXCwuKiQpL2csICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IGxpbmUucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFwoZXZhbCBjb2RlL2csICcoJykuc3BsaXQoL1xccysvKS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRva2Vucy5qb2luKCcgJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IF9pbmRleE9mKFsnZXZhbCcsICc8YW5vbnltb3VzPiddLCBsb2NhdGlvblBhcnRzWzBdKSA+IC0xID8gdW5kZWZpbmVkIDogbG9jYXRpb25QYXJ0c1swXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZShmdW5jdGlvbk5hbWUsIHVuZGVmaW5lZCwgZmlsZU5hbWUsIGxvY2F0aW9uUGFydHNbMV0sIGxvY2F0aW9uUGFydHNbMl0sIGxpbmUpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VGRk9yU2FmYXJpOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZUZGT3JTYWZhcmkoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IF9maWx0ZXIoZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFsaW5lLm1hdGNoKFNBRkFSSV9OQVRJVkVfQ09ERV9SRUdFWFApO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBfbWFwKGZpbHRlcmVkLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgYXdheSBldmFsIGluZm9ybWF0aW9uIHVudGlsIHdlIGltcGxlbWVudCBzdGFja3RyYWNlLmpzL3N0YWNrZnJhbWUjOFxuICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyA+IGV2YWwnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsXFw6XFxkK1xcOlxcZCsvZywgJzokMScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJ0AnKSA9PT0gLTEgJiYgbGluZS5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSBldmFsIGZyYW1lcyBvbmx5IGhhdmUgZnVuY3Rpb24gbmFtZXMgYW5kIG5vdGhpbmcgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUobGluZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IGxpbmUuc3BsaXQoJ0AnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbih0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdG9rZW5zLmpvaW4oJ0AnKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZShmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvblBhcnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZU9wZXJhOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhKGUpIHtcbiAgICAgICAgICAgIGlmICghZS5zdGFja3RyYWNlIHx8IChlLm1lc3NhZ2UuaW5kZXhPZignXFxuJykgPiAtMSAmJlxuICAgICAgICAgICAgICAgIGUubWVzc2FnZS5zcGxpdCgnXFxuJykubGVuZ3RoID4gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTkoZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFlLnN0YWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTEwKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhMTEoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFyc2VPcGVyYTk6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmE5KGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKS9pO1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gZS5tZXNzYWdlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDIsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU3RhY2tGcmFtZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWF0Y2hbMl0sIG1hdGNoWzFdLCB1bmRlZmluZWQsIGxpbmVzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmExMDogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTEwKGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKSg/OjogSW4gZnVuY3Rpb24gKFxcUyspKT8kL2k7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFN0YWNrRnJhbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbM10gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gT3BlcmEgMTAuNjUrIEVycm9yLnN0YWNrIHZlcnkgc2ltaWxhciB0byBGRi9TYWZhcmlcbiAgICAgICAgcGFyc2VPcGVyYTExOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZU9wZXJhMTEoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IF9maWx0ZXIoZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFApICYmICFsaW5lLm1hdGNoKC9eRXJyb3IgY3JlYXRlZCBhdC8pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBfbWFwKGZpbHRlcmVkLCBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IGxpbmUuc3BsaXQoJ0AnKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKHRva2Vucy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uQ2FsbCA9ICh0b2tlbnMuc2hpZnQoKSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uQ2FsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLzxhbm9ueW1vdXMgZnVuY3Rpb24oOiAoXFx3KykpPz4vLCAnJDInKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKFteXFwpXSpcXCkvZywgJycpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgYXJnc1JhdztcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsLm1hdGNoKC9cXCgoW15cXCldKilcXCkvKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzUmF3ID0gZnVuY3Rpb25DYWxsLnJlcGxhY2UoL15bXlxcKF0rXFwoKFteXFwpXSopXFwpJC8sICckMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IChhcmdzUmF3ID09PSB1bmRlZmluZWQgfHwgYXJnc1JhdyA9PT0gJ1thcmd1bWVudHMgbm90IGF2YWlsYWJsZV0nKSA/XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6IGFyZ3NSYXcuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25QYXJ0c1swXSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICAgICAgICAgICAgbGluZSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG59KSk7XG5cbiIsIi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG5cblxuLy8gbm9ybWFsaXplLXNlbGVjdG9yLXJldi0wMi5qc1xuLypcbiAgYXV0aG9yOiBreWxlIHNpbXBzb24gKEBnZXRpZnkpXG4gIG9yaWdpbmFsIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ2V0aWZ5Lzk2NzkzODBcblxuICBtb2RpZmllZCBmb3IgdGVzdHMgYnkgZGF2aWQga2F5ZSAoQGRma2F5ZSlcbiAgMjEgbWFyY2ggMjAxNFxuXG4gIHJldi0wMiBpbmNvcnBvcmF0ZSBreWxlJ3MgY2hhbmdlcyAzLzIvNDIwMTRcbiovXG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTZWxlY3RvcihzZWwpIHtcbiAgLy8gc2F2ZSB1bm1hdGNoZWQgdGV4dCwgaWYgYW55XG4gIGZ1bmN0aW9uIHNhdmVVbm1hdGNoZWQoKSB7XG4gICAgaWYgKHVubWF0Y2hlZCkge1xuICAgICAgLy8gd2hpdGVzcGFjZSBuZWVkZWQgYWZ0ZXIgY29tYmluYXRvcj9cbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJiAvXlt+Kz5dJC8udGVzdCh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICB0b2tlbnMucHVzaChcIiBcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIHNhdmUgdW5tYXRjaGVkIHRleHRcbiAgICAgIHRva2Vucy5wdXNoKHVubWF0Y2hlZCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRva2VucyA9IFtdLFxuICAgIG1hdGNoLFxuICAgIHVubWF0Y2hlZCxcbiAgICByZWdleCxcbiAgICBzdGF0ZSA9IFswXSxcbiAgICBuZXh0X21hdGNoX2lkeCA9IDAsXG4gICAgcHJldl9tYXRjaF9pZHgsXG4gICAgbm90X2VzY2FwZWRfcGF0dGVybiA9IC8oPzpbXlxcXFxdfCg/Ol58W15cXFxcXSkoPzpcXFxcXFxcXCkrKSQvLFxuICAgIHdoaXRlc3BhY2VfcGF0dGVybiA9IC9eXFxzKyQvLFxuICAgIHN0YXRlX3BhdHRlcm5zID0gW1xuICAgICAgL1xccyt8XFwvXFwqfFtcIic+fitbKF0vZywgLy8gZ2VuZXJhbFxuICAgICAgL1xccyt8XFwvXFwqfFtcIidbXFxdKCldL2csIC8vIFsuLl0gc2V0XG4gICAgICAvXFxzK3xcXC9cXCp8W1wiJ1tcXF0oKV0vZywgLy8gKC4uKSBzZXRcbiAgICAgIG51bGwsIC8vIHN0cmluZyBsaXRlcmFsIChwbGFjZWhvbGRlcilcbiAgICAgIC9cXCpcXC8vZywgLy8gY29tbWVudFxuICAgIF07XG4gIHNlbCA9IHNlbC50cmltKCk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHVubWF0Y2hlZCA9IFwiXCI7XG5cbiAgICByZWdleCA9IHN0YXRlX3BhdHRlcm5zW3N0YXRlW3N0YXRlLmxlbmd0aCAtIDFdXTtcblxuICAgIHJlZ2V4Lmxhc3RJbmRleCA9IG5leHRfbWF0Y2hfaWR4O1xuICAgIG1hdGNoID0gcmVnZXguZXhlYyhzZWwpO1xuXG4gICAgLy8gbWF0Y2hlZCB0ZXh0IHRvIHByb2Nlc3M/XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBwcmV2X21hdGNoX2lkeCA9IG5leHRfbWF0Y2hfaWR4O1xuICAgICAgbmV4dF9tYXRjaF9pZHggPSByZWdleC5sYXN0SW5kZXg7XG5cbiAgICAgIC8vIGNvbGxlY3QgdGhlIHByZXZpb3VzIHN0cmluZyBjaHVuayBub3QgbWF0Y2hlZCBiZWZvcmUgdGhpcyB0b2tlblxuICAgICAgaWYgKHByZXZfbWF0Y2hfaWR4IDwgbmV4dF9tYXRjaF9pZHggLSBtYXRjaFswXS5sZW5ndGgpIHtcbiAgICAgICAgdW5tYXRjaGVkID0gc2VsLnN1YnN0cmluZyhcbiAgICAgICAgICBwcmV2X21hdGNoX2lkeCxcbiAgICAgICAgICBuZXh0X21hdGNoX2lkeCAtIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBnZW5lcmFsLCBbIF0gcGFpciwgKCApIHBhaXI/XG4gICAgICBpZiAoc3RhdGVbc3RhdGUubGVuZ3RoIC0gMV0gPCAzKSB7XG4gICAgICAgIHNhdmVVbm1hdGNoZWQoKTtcblxuICAgICAgICAvLyBzdGFydGluZyBhIFsgXSBwYWlyP1xuICAgICAgICBpZiAobWF0Y2hbMF0gPT09IFwiW1wiKSB7XG4gICAgICAgICAgc3RhdGUucHVzaCgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzdGFydGluZyBhICggKSBwYWlyP1xuICAgICAgICBlbHNlIGlmIChtYXRjaFswXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICBzdGF0ZS5wdXNoKDIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0YXJ0aW5nIGEgc3RyaW5nIGxpdGVyYWw/XG4gICAgICAgIGVsc2UgaWYgKC9eW1wiJ10kLy50ZXN0KG1hdGNoWzBdKSkge1xuICAgICAgICAgIHN0YXRlLnB1c2goMyk7XG4gICAgICAgICAgc3RhdGVfcGF0dGVybnNbM10gPSBuZXcgUmVnRXhwKG1hdGNoWzBdLCBcImdcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RhcnRpbmcgYSBjb21tZW50P1xuICAgICAgICBlbHNlIGlmIChtYXRjaFswXSA9PT0gXCIvKlwiKSB7XG4gICAgICAgICAgc3RhdGUucHVzaCg0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbmRpbmcgYSBbIF0gb3IgKCApIHBhaXI/XG4gICAgICAgIGVsc2UgaWYgKC9eW1xcXSldJC8udGVzdChtYXRjaFswXSkgJiYgc3RhdGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0YXRlLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsaW5nIHdoaXRlc3BhY2Ugb3IgYSBjb21iaW5hdG9yP1xuICAgICAgICBlbHNlIGlmICgvXig/Olxccyt8W34rPl0pJC8udGVzdChtYXRjaFswXSkpIHtcbiAgICAgICAgICAvLyBuZWVkIHRvIGluc2VydCB3aGl0ZXNwYWNlIGJlZm9yZT9cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0b2tlbnMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgIXdoaXRlc3BhY2VfcGF0dGVybi50ZXN0KHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pICYmXG4gICAgICAgICAgICBzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXSA9PT0gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gYWRkIG5vcm1hbGl6ZWQgd2hpdGVzcGFjZVxuICAgICAgICAgICAgdG9rZW5zLnB1c2goXCIgXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUgYXR0cmlidXRlIHNlbGVjdG9yIENTUyBMNFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHN0YXRlW3N0YXRlLmxlbmd0aCAtIDFdID09PSAxICYmXG4gICAgICAgICAgICB0b2tlbnMubGVuZ3RoID09PSA1ICYmXG4gICAgICAgICAgICB0b2tlbnNbMl0uY2hhckF0KHRva2Vuc1syXS5sZW5ndGggLSAxKSA9PT0gXCI9XCJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRva2Vuc1s0XSA9IFwiIFwiICsgdG9rZW5zWzRdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHdoaXRlc3BhY2UgdG9rZW4gd2UgY2FuIHNraXA/XG4gICAgICAgICAgaWYgKHdoaXRlc3BhY2VfcGF0dGVybi50ZXN0KG1hdGNoWzBdKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2F2ZSBtYXRjaGVkIHRleHRcbiAgICAgICAgdG9rZW5zLnB1c2gobWF0Y2hbMF0pO1xuICAgICAgfVxuICAgICAgLy8gb3RoZXJ3aXNlLCBzdHJpbmcgbGl0ZXJhbCBvciBjb21tZW50XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gc2F2ZSB1bm1hdGNoZWQgdGV4dFxuICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdICs9IHVubWF0Y2hlZDtcblxuICAgICAgICAvLyB1bmVzY2FwZWQgdGVybWluYXRvciB0byBzdHJpbmcgbGl0ZXJhbCBvciBjb21tZW50P1xuICAgICAgICBpZiAobm90X2VzY2FwZWRfcGF0dGVybi50ZXN0KHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgLy8gY29tbWVudCB0ZXJtaW5hdG9yP1xuICAgICAgICAgIGlmIChzdGF0ZVtzdGF0ZS5sZW5ndGggLSAxXSA9PT0gNCkge1xuICAgICAgICAgICAgLy8gb2sgdG8gZHJvcCBjb21tZW50P1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0b2tlbnMubGVuZ3RoIDwgMiB8fFxuICAgICAgICAgICAgICB3aGl0ZXNwYWNlX3BhdHRlcm4udGVzdCh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDJdKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgdHVybiBjb21tZW50IGludG8gd2hpdGVzcGFjZVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0gPSBcIiBcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaGFuZGxlZCBhbHJlYWR5XG4gICAgICAgICAgICBtYXRjaFswXSA9IFwiXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhdGUucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBlbmQgbWF0Y2hlZCB0ZXh0IHRvIGV4aXN0aW5nIHRva2VuXG4gICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0gKz0gbWF0Y2hbMF07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSwgZW5kIG9mIHByb2Nlc3NpbmcgKG5vIG1vcmUgbWF0Y2hlcylcbiAgICBlbHNlIHtcbiAgICAgIHVubWF0Y2hlZCA9IHNlbC5zdWJzdHIobmV4dF9tYXRjaF9pZHgpO1xuICAgICAgc2F2ZVVubWF0Y2hlZCgpO1xuXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG9rZW5zLmpvaW4oXCJcIikudHJpbSgpO1xufVxuIiwiLyoqXG4gKiBAYXV0aG9yIEdlb3JnZWdyaWZmQCAoR2VvcmdlIEdyaWZmaXRocylcbiAqIExpY2Vuc2UgQXBhY2hlLTIuMFxuICovXG5cbmltcG9ydCB7IG5vcm1hbGl6ZVNlbGVjdG9yIH0gZnJvbSAnLi9ub3JtYWxpemUnO1xuXG4vKipcbiogRmluZHMgZmlyc3QgbWF0Y2hpbmcgZWxlbWVudHMgb24gdGhlIHBhZ2UgdGhhdCBtYXkgYmUgaW4gYSBzaGFkb3cgcm9vdCB1c2luZyBhIGNvbXBsZXggc2VsZWN0b3Igb2Ygbi1kZXB0aFxuKlxuKiBEb24ndCBoYXZlIHRvIHNwZWNpZnkgYWxsIHNoYWRvdyByb290cyB0byBidXR0b24sIHRyZWUgaXMgdHJhdmVyZWQgdG8gZmluZCB0aGUgY29ycmVjdCBlbGVtZW50XG4qXG4qIEV4YW1wbGUgcXVlcnlTZWxlY3RvckFsbERlZXAoJ2Rvd25sb2Fkcy1pdGVtOm50aC1jaGlsZCg0KSAjcmVtb3ZlJyk7XG4qXG4qIEV4YW1wbGUgc2hvdWxkIHdvcmsgb24gY2hyb21lOi8vZG93bmxvYWRzIG91dHB1dHRpbmcgdGhlIHJlbW92ZSBidXR0b24gaW5zaWRlIG9mIGEgZG93bmxvYWQgY2FyZCBjb21wb25lbnRcbipcbiogRXhhbXBsZSBmaW5kIGZpcnN0IGFjdGl2ZSBkb3dubG9hZCBsaW5rIGVsZW1lbnQgcXVlcnlTZWxlY3RvckRlZXAoJyNkb3dubG9hZHMtbGlzdCAuaXMtYWN0aXZlIGFbaHJlZl49XCJodHRwczovL1wiXScpO1xuKlxuKiBBbm90aGVyIGV4YW1wbGUgcXVlcnlTZWxlY3RvckFsbERlZXAoJyNkb3dubG9hZHMtbGlzdCBkaXYjdGl0bGUtYXJlYSArIGEnKTtcbmUuZy5cbiovXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlTZWxlY3RvckFsbERlZXAoc2VsZWN0b3IsIHJvb3QgPSBkb2N1bWVudCwgYWxsRWxlbWVudHMgPSBudWxsKSB7XG4gICAgcmV0dXJuIF9xdWVyeVNlbGVjdG9yRGVlcChzZWxlY3RvciwgdHJ1ZSwgcm9vdCwgYWxsRWxlbWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVlcnlTZWxlY3RvckRlZXAoc2VsZWN0b3IsIHJvb3QgPSBkb2N1bWVudCwgYWxsRWxlbWVudHMgPSBudWxsKSB7XG4gICAgcmV0dXJuIF9xdWVyeVNlbGVjdG9yRGVlcChzZWxlY3RvciwgZmFsc2UsIHJvb3QsIGFsbEVsZW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3F1ZXJ5U2VsZWN0b3JEZWVwKHNlbGVjdG9yLCBmaW5kTWFueSwgcm9vdCwgYWxsRWxlbWVudHMgPSBudWxsKSB7XG4gICAgc2VsZWN0b3IgPSBub3JtYWxpemVTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgbGV0IGxpZ2h0RWxlbWVudCA9IHJvb3QucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cbiAgICBpZiAoZG9jdW1lbnQuaGVhZC5jcmVhdGVTaGFkb3dSb290IHx8IGRvY3VtZW50LmhlYWQuYXR0YWNoU2hhZG93KSB7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gZG8gYW55IHNwZWNpYWwgaWYgc2VsZWN0b3IgbWF0Y2hlcyBzb21ldGhpbmcgc3BlY2lmaWMgaW4gbGlnaHQtZG9tXG4gICAgICAgIGlmICghZmluZE1hbnkgJiYgbGlnaHRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbGlnaHRFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3BsaXQgb24gY29tbWFzIGJlY2F1c2UgdGhvc2UgYXJlIGEgbG9naWNhbCBkaXZpZGUgaW4gdGhlIG9wZXJhdGlvblxuICAgICAgICBjb25zdCBzZWxlY3Rpb25zVG9NYWtlID0gc3BsaXRCeUNoYXJhY3RlclVubGVzc1F1b3RlZChzZWxlY3RvciwgJywnKTtcblxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uc1RvTWFrZS5yZWR1Y2UoKGFjYywgbWluaW1hbFNlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICAvLyBpZiBub3QgZmluZGluZyBtYW55IGp1c3QgcmVkdWNlIHRoZSBmaXJzdCBtYXRjaFxuICAgICAgICAgICAgaWYgKCFmaW5kTWFueSAmJiBhY2MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG8gYmVzdCB0byBzdXBwb3J0IGNvbXBsZXggc2VsZWN0b3JzIGFuZCBzcGxpdCB0aGUgcXVlcnlcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0U2VsZWN0b3IgPSBzcGxpdEJ5Q2hhcmFjdGVyVW5sZXNzUXVvdGVkKG1pbmltYWxTZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSB3aGl0ZSBzcGFjZSBhdCBzdGFydCBvZiBzZWxlY3RvclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlxccysvZywgJycpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqKFs+K35dKylcXHMqL2csICckMScpLCAnICcpXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgZW50cnkgd2hpdGUgc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiAhIWVudHJ5KVxuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IFwiYSA+IGJcIiB0byBbXCJhXCIsIFwiYlwiXVxuICAgICAgICAgICAgICAgICAgICAubWFwKChlbnRyeSkgPT4gc3BsaXRCeUNoYXJhY3RlclVubGVzc1F1b3RlZChlbnRyeSwgJz4nKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlRWxlbWVudHNJbmRleCA9IHNwbGl0U2VsZWN0b3IubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RTcGxpdFBhcnQgPSBzcGxpdFNlbGVjdG9yW3Bvc3NpYmxlRWxlbWVudHNJbmRleF1bc3BsaXRTZWxlY3Rvcltwb3NzaWJsZUVsZW1lbnRzSW5kZXhdLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgcG9zc2libGVFbGVtZW50cyA9IGNvbGxlY3RBbGxFbGVtZW50c0RlZXAobGFzdFNwbGl0UGFydCwgcm9vdCwgYWxsRWxlbWVudHMpO1xuICAgICAgICAgICAgY29uc3QgZmluZEVsZW1lbnRzID0gZmluZE1hdGNoaW5nRWxlbWVudChzcGxpdFNlbGVjdG9yLCBwb3NzaWJsZUVsZW1lbnRzSW5kZXgsIHJvb3QpO1xuICAgICAgICAgICAgaWYgKGZpbmRNYW55KSB7XG4gICAgICAgICAgICAgICAgYWNjID0gYWNjLmNvbmNhdChwb3NzaWJsZUVsZW1lbnRzLmZpbHRlcihmaW5kRWxlbWVudHMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY2MgPSBwb3NzaWJsZUVsZW1lbnRzLmZpbmQoZmluZEVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZpbmRNYW55ID8gW10gOiBudWxsKTtcblxuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFmaW5kTWFueSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpZ2h0RWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGZpbmRNYXRjaGluZ0VsZW1lbnQoc3BsaXRTZWxlY3RvciwgcG9zc2libGVFbGVtZW50c0luZGV4LCByb290KSB7XG4gICAgcmV0dXJuIChlbGVtZW50KSA9PiB7XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IHBvc3NpYmxlRWxlbWVudHNJbmRleDtcbiAgICAgICAgbGV0IHBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIGxldCBmb3VuZEVsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiAhaXNEb2N1bWVudE5vZGUocGFyZW50KSkge1xuICAgICAgICAgICAgbGV0IGZvdW5kTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHNwbGl0U2VsZWN0b3JbcG9zaXRpb25dLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZvdW5kTWF0Y2ggPSBwYXJlbnQubWF0Y2hlcyhzcGxpdFNlbGVjdG9yW3Bvc2l0aW9uXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9yIGlzIGluIHRoZSBmb3JtYXQgXCJhID4gYlwiXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGEgZmV3IHBhcmVudHMgbWF0Y2ggaW4gb3JkZXJcbiAgICAgICAgICAgICAgICBjb25zdCByZXZlcnNlZFBhcnRzID0gKFtdKS5jb25jYXQoc3BsaXRTZWxlY3Rvcltwb3NpdGlvbl0pLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3UGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiByZXZlcnNlZFBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3UGFyZW50IHx8ICFuZXdQYXJlbnQubWF0Y2hlcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3UGFyZW50ID0gZmluZFBhcmVudE9ySG9zdChuZXdQYXJlbnQsIHJvb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvdW5kTWF0Y2ggJiYgcG9zaXRpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICBmb3VuZEVsZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gZmluZFBhcmVudE9ySG9zdChwYXJlbnQsIHJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZEVsZW1lbnQ7XG4gICAgfTtcblxufVxuXG5mdW5jdGlvbiBzcGxpdEJ5Q2hhcmFjdGVyVW5sZXNzUXVvdGVkKHNlbGVjdG9yLCBjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IubWF0Y2goL1xcXFw/LnxeJC9nKS5yZWR1Y2UoKHAsIGMpID0+IHtcbiAgICAgICAgaWYgKGMgPT09ICdcIicgJiYgIXAuc1F1b3RlKSB7XG4gICAgICAgICAgICBwLnF1b3RlIF49IDE7XG4gICAgICAgICAgICBwLmFbcC5hLmxlbmd0aCAtIDFdICs9IGM7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJ1xcJycgJiYgIXAucXVvdGUpIHtcbiAgICAgICAgICAgIHAuc1F1b3RlIF49IDE7XG4gICAgICAgICAgICBwLmFbcC5hLmxlbmd0aCAtIDFdICs9IGM7XG5cbiAgICAgICAgfSBlbHNlIGlmICghcC5xdW90ZSAmJiAhcC5zUXVvdGUgJiYgYyA9PT0gY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICBwLmEucHVzaCgnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwLmFbcC5hLmxlbmd0aCAtIDFdICs9IGM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSwgeyBhOiBbJyddIH0pLmE7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBub2RlIGlzIGEgZG9jdW1lbnQgbm9kZSBvciBub3QuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEByZXR1cm5zIHtub2RlIGlzIERvY3VtZW50IHwgRG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFO1xufVxuXG5mdW5jdGlvbiBmaW5kUGFyZW50T3JIb3N0KGVsZW1lbnQsIHJvb3QpIHtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIHJldHVybiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmhvc3QgJiYgcGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMTEpID8gcGFyZW50Tm9kZS5ob3N0IDogcGFyZW50Tm9kZSA9PT0gcm9vdCA/IG51bGwgOiBwYXJlbnROb2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIGFsbCBlbGVtZW50cyBvbiB0aGUgcGFnZSwgaW5jbHVzaXZlIG9mIHRob3NlIHdpdGhpbiBzaGFkb3cgcm9vdHMuXG4gKiBAcGFyYW0ge3N0cmluZz19IHNlbGVjdG9yIFNpbXBsZSBzZWxlY3RvciB0byBmaWx0ZXIgdGhlIGVsZW1lbnRzIGJ5LiBlLmcuICdhJywgJ2Rpdi5tYWluJ1xuICogQHJldHVybiB7IUFycmF5PHN0cmluZz59IExpc3Qgb2YgYW5jaG9yIGhyZWZzLlxuICogQGF1dGhvciBlYmlkZWxAIChFcmljIEJpZGVsbWFuKVxuICogTGljZW5zZSBBcGFjaGUtMi4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0QWxsRWxlbWVudHNEZWVwKHNlbGVjdG9yID0gbnVsbCwgcm9vdCwgY2FjaGVkRWxlbWVudHMgPSBudWxsKSB7XG4gICAgbGV0IGFsbEVsZW1lbnRzID0gW107XG5cbiAgICBpZiAoY2FjaGVkRWxlbWVudHMpIHtcbiAgICAgICAgYWxsRWxlbWVudHMgPSBjYWNoZWRFbGVtZW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmaW5kQWxsRWxlbWVudHMgPSBmdW5jdGlvbihub2Rlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgYWxsRWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgc2hhZG93IHJvb3QsIGRpZyBkZWVwZXIuXG4gICAgICAgICAgICAgICAgaWYgKGVsLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluZEFsbEVsZW1lbnRzKGVsLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnKicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmKHJvb3Quc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgZmluZEFsbEVsZW1lbnRzKHJvb3Quc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmRBbGxFbGVtZW50cyhyb290LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdG9yID8gYWxsRWxlbWVudHMuZmlsdGVyKGVsID0+IGVsLm1hdGNoZXMoc2VsZWN0b3IpKSA6IGFsbEVsZW1lbnRzO1x0fVxuXG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICovXG5mdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAqL1xuQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhvdyBtYW55IHVuaXF1ZSBpdGVtcyBhcmUgaW4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9zZXQpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gIH1cbiAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgfVxufTtcblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICByZXR1cm4gaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgaWYgKGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cikpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0W3NTdHJdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gKlxuICogQHBhcmFtIE51bWJlciBhSWR4XG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICovXG5BcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xufTtcblxuZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxuLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4vLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbi8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4vL1xuLy8gICBDb250aW51YXRpb25cbi8vICAgfCAgICBTaWduXG4vLyAgIHwgICAgfFxuLy8gICBWICAgIFZcbi8vICAgMTAxMDExXG5cbnZhciBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4vLyBiaW5hcnk6IDAxMTExMVxudmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuLyoqXG4gKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICovXG5mdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICovXG5mdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSkge1xuICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICA/IC1zaGlmdGVkXG4gICAgOiBzaGlmdGVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICB2YXIgZGlnaXQ7XG5cbiAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgZG8ge1xuICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICBpZiAodmxxID4gMCkge1xuICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICB9XG4gICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9kZWNvZGUoYVN0ciwgYUluZGV4LCBhT3V0UGFyYW0pIHtcbiAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gMDtcbiAgdmFyIHNoaWZ0ID0gMDtcbiAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgZG8ge1xuICAgIGlmIChhSW5kZXggPj0gc3RyTGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgfVxuXG4gICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckNvZGVBdChhSW5kZXgrKykpO1xuICAgIGlmIChkaWdpdCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGRpZ2l0OiBcIiArIGFTdHIuY2hhckF0KGFJbmRleCAtIDEpKTtcbiAgICB9XG5cbiAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgIHJlc3VsdCA9IHJlc3VsdCArIChkaWdpdCA8PCBzaGlmdCk7XG4gICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgYU91dFBhcmFtLnZhbHVlID0gZnJvbVZMUVNpZ25lZChyZXN1bHQpO1xuICBhT3V0UGFyYW0ucmVzdCA9IGFJbmRleDtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBpbnRUb0NoYXJNYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycuc3BsaXQoJycpO1xuXG4vKipcbiAqIEVuY29kZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSBvZiAwIHRvIDYzIHRvIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bWJlcikge1xuICBpZiAoMCA8PSBudW1iZXIgJiYgbnVtYmVyIDwgaW50VG9DaGFyTWFwLmxlbmd0aCkge1xuICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIG51bWJlcik7XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGNoYXJhY3RlciBjb2RlIGRpZ2l0IHRvIGFuIGludGVnZXIuIFJldHVybnMgLTEgb25cbiAqIGZhaWx1cmUuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gIHZhciBiaWdBID0gNjU7ICAgICAvLyAnQSdcbiAgdmFyIGJpZ1ogPSA5MDsgICAgIC8vICdaJ1xuXG4gIHZhciBsaXR0bGVBID0gOTc7ICAvLyAnYSdcbiAgdmFyIGxpdHRsZVogPSAxMjI7IC8vICd6J1xuXG4gIHZhciB6ZXJvID0gNDg7ICAgICAvLyAnMCdcbiAgdmFyIG5pbmUgPSA1NzsgICAgIC8vICc5J1xuXG4gIHZhciBwbHVzID0gNDM7ICAgICAvLyAnKydcbiAgdmFyIHNsYXNoID0gNDc7ICAgIC8vICcvJ1xuXG4gIHZhciBsaXR0bGVPZmZzZXQgPSAyNjtcbiAgdmFyIG51bWJlck9mZnNldCA9IDUyO1xuXG4gIC8vIDAgLSAyNTogQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcbiAgaWYgKGJpZ0EgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gYmlnWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBiaWdBKTtcbiAgfVxuXG4gIC8vIDI2IC0gNTE6IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XG4gIGlmIChsaXR0bGVBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGxpdHRsZVopIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gbGl0dGxlQSArIGxpdHRsZU9mZnNldCk7XG4gIH1cblxuICAvLyA1MiAtIDYxOiAwMTIzNDU2Nzg5XG4gIGlmICh6ZXJvIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IG5pbmUpIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gemVybyArIG51bWJlck9mZnNldCk7XG4gIH1cblxuICAvLyA2MjogK1xuICBpZiAoY2hhckNvZGUgPT0gcGx1cykge1xuICAgIHJldHVybiA2MjtcbiAgfVxuXG4gIC8vIDYzOiAvXG4gIGlmIChjaGFyQ29kZSA9PSBzbGFzaCkge1xuICAgIHJldHVybiA2MztcbiAgfVxuXG4gIC8vIEludmFsaWQgYmFzZTY0IGRpZ2l0LlxuICByZXR1cm4gLTE7XG59O1xuIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG5leHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EID0gMTtcbmV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZSBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoLlxuICpcbiAqIEBwYXJhbSBhTG93IEluZGljZXMgaGVyZSBhbmQgbG93ZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhSGlnaCBJbmRpY2VzIGhlcmUgYW5kIGhpZ2hlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgYmVpbmcgc2VhcmNoZWQgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgbm9uLWVtcHR5IGFycmF5IGJlaW5nIHNlYXJjaGVkLlxuICogQHBhcmFtIGFDb21wYXJlIEZ1bmN0aW9uIHdoaWNoIHRha2VzIHR3byBlbGVtZW50cyBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gcmVjdXJzaXZlU2VhcmNoKGFMb3csIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIHRlcm1pbmF0ZXMgd2hlbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlOlxuICAvL1xuICAvLyAgIDEuIFdlIGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAvL1xuICAvLyAgIDIuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYnV0IHdlIGNhbiByZXR1cm4gdGhlIGluZGV4IG9mXG4gIC8vICAgICAgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50LlxuICAvL1xuICAvLyAgIDMuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYW5kIHRoZXJlIGlzIG5vIG5leHQtY2xvc2VzdFxuICAvLyAgICAgIGVsZW1lbnQgdGhhbiB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCBzbyB3ZSByZXR1cm4gLTEuXG4gIHZhciBtaWQgPSBNYXRoLmZsb29yKChhSGlnaCAtIGFMb3cpIC8gMikgKyBhTG93O1xuICB2YXIgY21wID0gYUNvbXBhcmUoYU5lZWRsZSwgYUhheXN0YWNrW21pZF0sIHRydWUpO1xuICBpZiAoY21wID09PSAwKSB7XG4gICAgLy8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIHJldHVybiBtaWQ7XG4gIH1cbiAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgIC8vIE91ciBuZWVkbGUgaXMgZ3JlYXRlciB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgIGlmIChhSGlnaCAtIG1pZCA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIGFIaWdoIDwgYUhheXN0YWNrLmxlbmd0aCA/IGFIaWdoIDogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIC8vIE91ciBuZWVkbGUgaXMgbGVzcyB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgIGlmIChtaWQgLSBhTG93ID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxvd2VyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKGFMb3csIG1pZCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhTG93IDwgMCA/IC0xIDogYUxvdztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2ggd2hpY2ggd2lsbCBhbHdheXMgdHJ5IGFuZCByZXR1cm5cbiAqIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBlbGVtZW50IGlmIHRoZXJlIGlzIG5vIGV4YWN0IGhpdC4gVGhpcyBpcyBiZWNhdXNlXG4gKiBtYXBwaW5ncyBiZXR3ZWVuIG9yaWdpbmFsIGFuZCBnZW5lcmF0ZWQgbGluZS9jb2wgcGFpcnMgYXJlIHNpbmdsZSBwb2ludHMsXG4gKiBhbmQgdGhlcmUgaXMgYW4gaW1wbGljaXQgcmVnaW9uIGJldHdlZW4gZWFjaCBvZiB0aGVtLCBzbyBhIG1pc3MganVzdCBtZWFuc1xuICogdGhhdCB5b3UgYXJlbid0IG9uIHRoZSB2ZXJ5IHN0YXJ0IG9mIGEgcmVnaW9uLlxuICpcbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IHlvdSBhcmUgbG9va2luZyBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBhcnJheSB0aGF0IGlzIGJlaW5nIHNlYXJjaGVkLlxuICogQHBhcmFtIGFDb21wYXJlIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIG5lZWRsZSBhbmQgYW4gZWxlbWVudCBpbiB0aGVcbiAqICAgICBhcnJheSBhbmQgcmV0dXJucyAtMSwgMCwgb3IgMSBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgbmVlZGxlIGlzIGxlc3NcbiAqICAgICB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIHRoZSBlbGVtZW50LCByZXNwZWN0aXZlbHkuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKi9cbmV4cG9ydHMuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIGlmIChhSGF5c3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gcmVjdXJzaXZlU2VhcmNoKC0xLCBhSGF5c3RhY2subGVuZ3RoLCBhTmVlZGxlLCBhSGF5c3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29tcGFyZSwgYUJpYXMgfHwgZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBXZSBoYXZlIGZvdW5kIGVpdGhlciB0aGUgZXhhY3QgZWxlbWVudCwgb3IgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50IHRoYW5cbiAgLy8gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci4gSG93ZXZlciwgdGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgc3VjaFxuICAvLyBlbGVtZW50LiBNYWtlIHN1cmUgd2UgYWx3YXlzIHJldHVybiB0aGUgc21hbGxlc3Qgb2YgdGhlc2UuXG4gIHdoaWxlIChpbmRleCAtIDEgPj0gMCkge1xuICAgIGlmIChhQ29tcGFyZShhSGF5c3RhY2tbaW5kZXhdLCBhSGF5c3RhY2tbaW5kZXggLSAxXSwgdHJ1ZSkgIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAtLWluZGV4O1xuICB9XG5cbiAgcmV0dXJuIGluZGV4O1xufTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbn1cblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICpcbiAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICB9O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gKlxuICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheTtcbn07XG5cbmV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLy8gSXQgdHVybnMgb3V0IHRoYXQgc29tZSAobW9zdD8pIEphdmFTY3JpcHQgZW5naW5lcyBkb24ndCBzZWxmLWhvc3Rcbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4vLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuLy8gY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24sIGNhbGxpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgVk0ncyBDKysgYW5kXG4vLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4vLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuLy8gZmFjdCwgd2hlbiBzb3J0aW5nIHdpdGggYSBjb21wYXJhdG9yLCB0aGVzZSBjb3N0cyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgb2Zcbi8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4vLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgVGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0uXG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHN3YXAoYXJ5LCB4LCB5KSB7XG4gIHZhciB0ZW1wID0gYXJ5W3hdO1xuICBhcnlbeF0gPSBhcnlbeV07XG4gIGFyeVt5XSA9IHRlbXA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgYGxvdyAuLiBoaWdoYCBpbmNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xuICogICAgICAgIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaFxuICogICAgICAgIFRoZSB1cHBlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LCBoaWdoKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGxvdyArIChNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpKSk7XG59XG5cbi8qKlxuICogVGhlIFF1aWNrIFNvcnQgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSByXG4gKiAgICAgICAgRW5kIGluZGV4IG9mIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHIpIHtcbiAgLy8gSWYgb3VyIGxvd2VyIGJvdW5kIGlzIGxlc3MgdGhhbiBvdXIgdXBwZXIgYm91bmQsIHdlICgxKSBwYXJ0aXRpb24gdGhlXG4gIC8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbiAgLy8gdGhlIGVtcHR5IGFycmF5IGFuZCBvdXIgYmFzZSBjYXNlLlxuXG4gIGlmIChwIDwgcikge1xuICAgIC8vICgxKSBQYXJ0aXRpb25pbmcuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFydGl0aW9uaW5nIGNob29zZXMgYSBwaXZvdCBiZXR3ZWVuIGBwYCBhbmQgYHJgIGFuZCBtb3ZlcyBhbGxcbiAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuICAgIC8vIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGl0IGFmdGVyIGl0LiBUaGUgZWZmZWN0IGlzIHRoYXRcbiAgICAvLyBvbmNlIHBhcnRpdGlvbiBpcyBkb25lLCB0aGUgcGl2b3QgaXMgaW4gdGhlIGV4YWN0IHBsYWNlIGl0IHdpbGwgYmUgd2hlblxuICAgIC8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuICAgIC8vIGFnYWluLiBUaGlzIHJ1bnMgaW4gTyhuKSB0aW1lLlxuXG4gICAgLy8gQWx3YXlzIGNob29zZSBhIHJhbmRvbSBwaXZvdCBzbyB0aGF0IGFuIGlucHV0IGFycmF5IHdoaWNoIGlzIHJldmVyc2VcbiAgICAvLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbiAgICB2YXIgcGl2b3RJbmRleCA9IHJhbmRvbUludEluUmFuZ2UocCwgcik7XG4gICAgdmFyIGkgPSBwIC0gMTtcblxuICAgIHN3YXAoYXJ5LCBwaXZvdEluZGV4LCByKTtcbiAgICB2YXIgcGl2b3QgPSBhcnlbcl07XG5cbiAgICAvLyBJbW1lZGlhdGVseSBhZnRlciBgamAgaXMgaW5jcmVtZW50ZWQgaW4gdGhpcyBsb29wLCB0aGUgZm9sbG93aW5nIGhvbGRcbiAgICAvLyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtwIC4uIGldYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90LlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbiAgICBmb3IgKHZhciBqID0gcDsgaiA8IHI7IGorKykge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJ5W2pdLCBwaXZvdCkgPD0gMCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIHN3YXAoYXJ5LCBpLCBqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2FwKGFyeSwgaSArIDEsIGopO1xuICAgIHZhciBxID0gaSArIDE7XG5cbiAgICAvLyAoMikgUmVjdXJzZSBvbiBlYWNoIGhhbGYuXG5cbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHEgLSAxKTtcbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHEgKyAxLCByKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKi9cbmV4cG9ydHMucXVpY2tTb3J0ID0gZnVuY3Rpb24gKGFyeSwgY29tcGFyYXRvcikge1xuICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIDAsIGFyeS5sZW5ndGggLSAxKTtcbn07XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXApIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2Zcbi8vICAgICAgICAgICAgIGNvZGUuXG4vLyAgICAgfVxuLy9cbi8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbi8vIGBudWxsYC5cbi8vXG4vLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuLy9cbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICB9O1xuICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgIHZhciBsaW5lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyk7XG5cbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGV4YWN0IG1hdGNoLCBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeVxuICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuICAgIC8vIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicsIDApXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhuZWVkbGUuc291cmNlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG5lZWRsZS5zb3VyY2UpO1xuXG4gICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2VcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSB3ZXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbGluZSAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9PSBvcmlnaW5hbENvbHVtbikge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ3M7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKlxuICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAqXG4gKiAgICAge1xuICogICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICogICAgIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBzb3VyY2VzID0gc291cmNlc1xuICAgIC5tYXAoU3RyaW5nKVxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICAubWFwKHV0aWwubm9ybWFsaXplKVxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCBhYnNvbHV0ZSBzb3VyY2VzIGFyZSBpbnRlcm5hbGx5IHN0b3JlZCByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuICAgIC8vIGJlIHBhcnRpY3VsYXJseSBwcm9ibGVtYXRpYyB3aGVuIHRoZSBzb3VyY2Ugcm9vdCBpcyBhIHByZWZpeCBvZiB0aGVcbiAgICAvLyBzb3VyY2UgKHZhbGlkLCBidXQgd2h5Pz8pLiBTZWUgZ2l0aHViIGlzc3VlICMxOTkgYW5kIGJ1Z3ppbC5sYS8xMTg4OTgyLlxuICAgIC5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZVJvb3QgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZVJvb3QpICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2UpXG4gICAgICAgID8gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2UpXG4gICAgICAgIDogc291cmNlO1xuICAgIH0pO1xuXG4gIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbiAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gIHRoaXMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KG5hbWVzLm1hcChTdHJpbmcpLCB0cnVlKTtcbiAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gIHRoaXMuZmlsZSA9IGZpbGU7XG59XG5cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ICE9IG51bGwgPyB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzKSA6IHM7XG4gICAgfSwgdGhpcyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgIHZhciB0ZW1wID0ge307XG4gICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAqIGluY2x1c2l2ZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuYXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBuYW1lOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJlxuICAgICAgIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbiAoc2MpIHsgcmV0dXJuIHNjID09IG51bGw7IH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIGFTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgYVNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKGFTb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoYVNvdXJjZSldO1xuICAgIH1cblxuICAgIHZhciB1cmw7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsXG4gICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gYVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgYVNvdXJjZSldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSBmcm9tXG4gICAgLy8gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbiAgICAvLyByZXR1cm4gbnVsbCwgc28gd2UgcHJvdmlkZSBhIGZsYWcgdG8gZXhpdCBncmFjZWZ1bGx5LlxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0XG4gKi9cbmZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICBsaW5lOiAtMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy51cmwpIHtcbiAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cbiAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgfSxcbiAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpKVxuICAgIH1cbiAgfSk7XG59XG5cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VzLmluZGV4T2YodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICB2YXIgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIE1hcHBpbmdMaXN0ID0gcmVxdWlyZSgnLi9tYXBwaW5nLWxpc3QnKS5NYXBwaW5nTGlzdDtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gKiBiZWluZyBidWlsdCBpbmNyZW1lbnRhbGx5LiBZb3UgbWF5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICogcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZmlsZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIHNvdXJjZVJvb3Q6IEEgcm9vdCBmb3IgYWxsIHJlbGF0aXZlIFVSTHMgaW4gdGhpcyBzb3VyY2UgbWFwLlxuICovXG5mdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpIHtcbiAgaWYgKCFhQXJncykge1xuICAgIGFBcmdzID0ge307XG4gIH1cbiAgdGhpcy5fZmlsZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZmlsZScsIG51bGwpO1xuICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHRoaXMuX3NraXBWYWxpZGF0aW9uID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdza2lwVmFsaWRhdGlvbicsIGZhbHNlKTtcbiAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICB0aGlzLl9tYXBwaW5ncyA9IG5ldyBNYXBwaW5nTGlzdCgpO1xuICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xufVxuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lcikge1xuICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgdmFyIGdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdNYXBwaW5nLm9yaWdpbmFsID0ge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5ld01hcHBpbmcubmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5lcmF0b3IuYWRkTWFwcGluZyhuZXdNYXBwaW5nKTtcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9O1xuXG4vKipcbiAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gZm9yIHRoaXMgc291cmNlIG1hcCBiZWluZyBjcmVhdGVkLiBUaGUgbWFwcGluZ1xuICogb2JqZWN0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gZ2VuZXJhdGVkOiBBbiBvYmplY3Qgd2l0aCB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gb3JpZ2luYWw6IEFuIG9iamVjdCB3aXRoIHRoZSBvcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gKiAgIC0gbmFtZTogQW4gb3B0aW9uYWwgb3JpZ2luYWwgdG9rZW4gbmFtZSBmb3IgdGhpcyBtYXBwaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYWRkTWFwcGluZyhhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB1dGlsLmdldEFyZyhhQXJncywgJ2dlbmVyYXRlZCcpO1xuICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnLCBudWxsKTtcbiAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbmFtZScsIG51bGwpO1xuXG4gICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5fdmFsaWRhdGVNYXBwaW5nKGdlbmVyYXRlZCwgb3JpZ2luYWwsIHNvdXJjZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSBTdHJpbmcoc291cmNlKTtcbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICBpZiAoIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwcGluZ3MuYWRkKHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uLFxuICAgICAgb3JpZ2luYWxMaW5lOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG5hbWU6IG5hbWVcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnNldFNvdXJjZUNvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB2YXIgc291cmNlID0gYVNvdXJjZUZpbGU7XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cblxuICAgIGlmIChhU291cmNlQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBfc291cmNlc0NvbnRlbnRzIG1hcCBpZiB0aGUgcHJvcGVydHkgaXMgbnVsbC5cbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gSWYgdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwIGlzIGVtcHR5LCBzZXQgdGhlIHByb3BlcnR5IHRvIG51bGwuXG4gICAgICBkZWxldGUgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV07XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAqIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkLiBFYWNoIG1hcHBpbmcgdG8gdGhlIHN1cHBsaWVkIHNvdXJjZSBmaWxlIGlzXG4gKiByZXdyaXR0ZW4gdXNpbmcgdGhlIHN1cHBsaWVkIHNvdXJjZSBtYXAuIE5vdGU6IFRoZSByZXNvbHV0aW9uIGZvciB0aGVcbiAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkLlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICogICAgICAgIElmIG9taXR0ZWQsIFNvdXJjZU1hcENvbnN1bWVyJ3MgZmlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVzZWQuXG4gKiBAcGFyYW0gYVNvdXJjZU1hcFBhdGggT3B0aW9uYWwuIFRoZSBkaXJuYW1lIG9mIHRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgbWFwXG4gKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAqICAgICAgICBUaGlzIHBhcmFtZXRlciBpcyBuZWVkZWQgd2hlbiB0aGUgdHdvIHNvdXJjZSBtYXBzIGFyZW4ndCBpbiB0aGUgc2FtZVxuICogICAgICAgIGRpcmVjdG9yeSwgYW5kIHRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQgY29udGFpbnMgcmVsYXRpdmUgc291cmNlXG4gKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAqICAgICAgICByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FwcGx5U291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lciwgYVNvdXJjZUZpbGUsIGFTb3VyY2VNYXBQYXRoKSB7XG4gICAgdmFyIHNvdXJjZUZpbGUgPSBhU291cmNlRmlsZTtcbiAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgaWYgKGFTb3VyY2VGaWxlID09IG51bGwpIHtcbiAgICAgIGlmIChhU291cmNlTWFwQ29uc3VtZXIuZmlsZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCByZXF1aXJlcyBlaXRoZXIgYW4gZXhwbGljaXQgc291cmNlIGZpbGUsICcgK1xuICAgICAgICAgICdvciB0aGUgc291cmNlIG1hcFxcJ3MgXCJmaWxlXCIgcHJvcGVydHkuIEJvdGggd2VyZSBvbWl0dGVkLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZUZpbGUgPSBhU291cmNlTWFwQ29uc3VtZXIuZmlsZTtcbiAgICB9XG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIC8vIE1ha2UgXCJzb3VyY2VGaWxlXCIgcmVsYXRpdmUgaWYgYW4gYWJzb2x1dGUgVXJsIGlzIHBhc3NlZC5cbiAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICB9XG4gICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAvLyB0aGUgbmFtZXMgYXJyYXkuXG4gICAgdmFyIG5ld1NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgIC8vIEZpbmQgbWFwcGluZ3MgZm9yIHRoZSBcInNvdXJjZUZpbGVcIlxuICAgIHRoaXMuX21hcHBpbmdzLnVuc29ydGVkRm9yRWFjaChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIG1hcHBlZCBieSB0aGUgc291cmNlIG1hcCwgdGhlbiB1cGRhdGUgdGhlIG1hcHBpbmcuXG4gICAgICAgIHZhciBvcmlnaW5hbCA9IGFTb3VyY2VNYXBDb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvcHkgbWFwcGluZ1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2UgPSBtYXBwaW5nLnNvdXJjZTtcbiAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiAhbmV3U291cmNlcy5oYXMoc291cmNlKSkge1xuICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IG1hcHBpbmcubmFtZTtcbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICBuZXdOYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3U291cmNlcztcbiAgICB0aGlzLl9uYW1lcyA9IG5ld05hbWVzO1xuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICB9O1xuXG4vKipcbiAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICpcbiAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgMy4gR2VuZXJhdGVkIGFuZCBvcmlnaW5hbCBwb3NpdGlvbiwgb3JpZ2luYWwgc291cmNlLCBhcyB3ZWxsIGFzIGEgbmFtZVxuICogICAgICB0b2tlbi5cbiAqXG4gKiBUbyBtYWludGFpbiBjb25zaXN0ZW5jeSwgd2UgdmFsaWRhdGUgdGhhdCBhbnkgbmV3IG1hcHBpbmcgYmVpbmcgYWRkZWQgZmFsbHNcbiAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0ZU1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdmFsaWRhdGVNYXBwaW5nKGFHZW5lcmF0ZWQsIGFPcmlnaW5hbCwgYVNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAvLyBDYXNlIDEuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgbWFwcGluZztcbiAgICB2YXIgbmFtZUlkeDtcbiAgICB2YXIgc291cmNlSWR4O1xuXG4gICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgbmV4dCA9ICcnXG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5leHQgKz0gJzsnO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlSWR4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgcHJldmlvdXNTb3VyY2UgPSBzb3VyY2VJZHg7XG5cbiAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuYW1lSWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShuYW1lSWR4IC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICBwcmV2aW91c05hbWUgPSBuYW1lSWR4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cywga2V5KVxuICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgIDogbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgIHZhciBtYXAgPSB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICB9O1xuICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG4iLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbi8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbnZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbi8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xudmFyIE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4vLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4vLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuLy8gdmVyc2lvbnMhXG52YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuLyoqXG4gKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICB0aGlzLmxpbmUgPSBhTGluZSA9PSBudWxsID8gbnVsbCA6IGFMaW5lO1xuICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICB0aGlzLm5hbWUgPSBhTmFtZSA9PSBudWxsID8gbnVsbCA6IGFOYW1lO1xuICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICpcbiAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAqL1xuU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAvLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4gICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoaXMgYXJyYXksIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgIHZhciBzaGlmdE5leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUNvbnRlbnRzID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKTtcbiAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgIHZhciBuZXdMaW5lID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG4gICAgfTtcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIHBvc2l0aW9uIG9mIFwicmVtYWluaW5nTGluZXNcIlxuICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgLy8gVGhlIGdlbmVyYXRlIFNvdXJjZU5vZGVzIHdlIG5lZWQgYSBjb2RlIHJhbmdlLlxuICAgIC8vIFRvIGV4dHJhY3QgaXQgY3VycmVudCBhbmQgbGFzdCBtYXBwaW5nIGlzIHVzZWQuXG4gICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgIHZhciBsYXN0TWFwcGluZyA9IG51bGw7XG5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBhZGQgdGhlIGNvZGUgZnJvbSBcImxhc3RNYXBwaW5nXCIgdG8gXCJtYXBwaW5nXCI6XG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZXJlIGlzIGEgbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgLy8gQXNzb2NpYXRlIGZpcnN0IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgYWRkZWQgd2l0aG91dCBtYXBwaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV3IGxpbmUgaW4gYmV0d2Vlbi5cbiAgICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIGNvZGUgYmV0d2VlbiBcImxhc3RHZW5lcmF0ZWRDb2x1bW5cIiBhbmRcbiAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgICB2YXIgY29kZSA9IG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIGNvZGUpO1xuICAgICAgICAgIC8vIE5vIG1vcmUgcmVtYWluaW5nIGNvZGUsIGNvbnRpbnVlXG4gICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2UgYWRkIHRoZSBnZW5lcmF0ZWQgY29kZSB1bnRpbCB0aGUgZmlyc3QgbWFwcGluZ1xuICAgICAgLy8gdG8gdGhlIFNvdXJjZU5vZGUgd2l0aG91dCBhbnkgbWFwcGluZy5cbiAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICB3aGlsZSAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgbm9kZS5hZGQoc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0R2VuZXJhdGVkQ29sdW1uIDwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pIHtcbiAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgIG5vZGUuYWRkKG5leHRMaW5lLnN1YnN0cigwLCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikpO1xuICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgIH1cbiAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICB9LCB0aGlzKTtcbiAgICAvLyBXZSBoYXZlIHByb2Nlc3NlZCBhbGwgbWFwcGluZ3MuXG4gICAgaWYgKHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAvLyBBc3NvY2lhdGUgdGhlIHJlbWFpbmluZyBjb2RlIGluIHRoZSBjdXJyZW50IGxpbmUgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgfVxuICAgICAgLy8gYW5kIGFkZCB0aGUgcmVtYWluaW5nIGxpbmVzIHdpdGhvdXQgYW55IG1hcHBpbmdcbiAgICAgIG5vZGUuYWRkKHJlbWFpbmluZ0xpbmVzLmpvaW4oXCJcIikpO1xuICAgIH1cblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFSZWxhdGl2ZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG5cbiAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChhQ2h1bmspIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gIHZhciBjaHVuaztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgdmFyIG5ld0NoaWxkcmVuO1xuICB2YXIgaTtcbiAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAobGVuID4gMCkge1xuICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgIH1cbiAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICpcbiAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0Q2hpbGRbaXNTb3VyY2VOb2RlXSkge1xuICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICB9O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBzdHIgKz0gY2h1bms7XG4gIH0pO1xuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gKiBtYXAuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgY29kZTogXCJcIixcbiAgICBsaW5lOiAxLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgaWYobGFzdE9yaWdpbmFsU291cmNlICE9PSBvcmlnaW5hbC5zb3VyY2VcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxOYW1lICE9PSBvcmlnaW5hbC5uYW1lKSB7XG4gICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgbGFzdE9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICBnZW5lcmF0ZWQubGluZSsrO1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgLy8gTWFwcGluZ3MgZW5kIGF0IGVvbFxuICAgICAgICBpZiAoaWR4ICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gIH0pO1xuXG4gIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xufTtcblxuZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcbiIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHBhcmFtZXRlci9vcHRpb25zXG4gKiBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBhcmdzIFRoZSBvYmplY3Qgd2UgYXJlIGV4dHJhY3RpbmcgdmFsdWVzIGZyb21cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gKiBmcm9tIHRoZSBvYmplY3QuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBhbmQgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmcsIGFuXG4gKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZnVuY3Rpb24gZ2V0QXJnKGFBcmdzLCBhTmFtZSwgYURlZmF1bHRWYWx1ZSkge1xuICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFOYW1lICsgJ1wiIGlzIGEgcmVxdWlyZWQgYXJndW1lbnQuJyk7XG4gIH1cbn1cbmV4cG9ydHMuZ2V0QXJnID0gZ2V0QXJnO1xuXG52YXIgdXJsUmVnZXhwID0gL14oPzooW1xcdytcXC0uXSspOik/XFwvXFwvKD86KFxcdys6XFx3KylAKT8oW1xcdy5dKikoPzo6KFxcZCspKT8oXFxTKikkLztcbnZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgaG9zdDogbWF0Y2hbM10sXG4gICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgcGF0aDogbWF0Y2hbNV1cbiAgfTtcbn1cbmV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICB2YXIgdXJsID0gJyc7XG4gIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgfVxuICB1cmwgKz0gJy8vJztcbiAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5leHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gKlxuICogLSBSZXBsYWNlcyBjb25zZWN1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICpcbiAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgdmFyIHBhdGggPSBhUGF0aDtcbiAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgaWYgKHVybCkge1xuICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG4gICAgcGF0aCA9IHVybC5wYXRoO1xuICB9XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO1xuXG4gIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICB1cCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgIHVwLS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgdXJsLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbi8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICBhUGF0aCA9IFwiLlwiO1xuICB9XG4gIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICB9XG5cbiAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgfVxuXG4gIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgIHJldHVybiBhUGF0aDtcbiAgfVxuXG4gIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuXG4gIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cbiAgcmV0dXJuIGpvaW5lZDtcbn1cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgISFhUGF0aC5tYXRjaCh1cmxSZWdleHApO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuXG4gIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgdmFyIGxldmVsID0gMDtcbiAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgKytsZXZlbDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG59XG5leHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbnZhciBzdXBwb3J0c051bGxQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gISgnX19wcm90b19fJyBpbiBvYmopO1xufSgpKTtcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMudG9TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogdG9TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiBhU3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLmZyb21TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogZnJvbVNldFN0cmluZztcblxuZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOSAvKiBcIl9fcHJvdG9fX1wiLmxlbmd0aCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAyKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDMpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNCkgIT09IDExNiAvKiAndCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA1KSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDYpICE9PSAxMTQgLyogJ3InICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNykgIT09IDExMiAvKiAncCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA4KSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDkpICE9PSA5NSAgLyogJ18nICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDEwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoaSkgIT09IDM2IC8qICckJyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xufVxuZXhwb3J0cy5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyA9IGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zO1xuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICogc291cmNlL25hbWUvb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGFcbiAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5zb3VyY2UgLSBtYXBwaW5nQi5zb3VyY2U7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO1xuXG5mdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuIiwiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3RhY2tmcmFtZScsIFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LlN0YWNrRnJhbWUgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gX2lzTnVtYmVyKG4pIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2dldHRlcihwKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3BdO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBib29sZWFuUHJvcHMgPSBbJ2lzQ29uc3RydWN0b3InLCAnaXNFdmFsJywgJ2lzTmF0aXZlJywgJ2lzVG9wbGV2ZWwnXTtcbiAgICB2YXIgbnVtZXJpY1Byb3BzID0gWydjb2x1bW5OdW1iZXInLCAnbGluZU51bWJlciddO1xuICAgIHZhciBzdHJpbmdQcm9wcyA9IFsnZmlsZU5hbWUnLCAnZnVuY3Rpb25OYW1lJywgJ3NvdXJjZSddO1xuICAgIHZhciBhcnJheVByb3BzID0gWydhcmdzJ107XG4gICAgdmFyIG9iamVjdFByb3BzID0gWydldmFsT3JpZ2luJ107XG5cbiAgICB2YXIgcHJvcHMgPSBib29sZWFuUHJvcHMuY29uY2F0KG51bWVyaWNQcm9wcywgc3RyaW5nUHJvcHMsIGFycmF5UHJvcHMsIG9iamVjdFByb3BzKTtcblxuICAgIGZ1bmN0aW9uIFN0YWNrRnJhbWUob2JqKSB7XG4gICAgICAgIGlmICghb2JqKSByZXR1cm47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvYmpbcHJvcHNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzWydzZXQnICsgX2NhcGl0YWxpemUocHJvcHNbaV0pXShvYmpbcHJvcHNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIFN0YWNrRnJhbWUucHJvdG90eXBlID0ge1xuICAgICAgICBnZXRBcmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEFyZ3M6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmdzIG11c3QgYmUgYW4gQXJyYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXJncyA9IHY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RXZhbE9yaWdpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmFsT3JpZ2luO1xuICAgICAgICB9LFxuICAgICAgICBzZXRFdmFsT3JpZ2luOiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIFN0YWNrRnJhbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2YWxPcmlnaW4gPSB2O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmFsT3JpZ2luID0gbmV3IFN0YWNrRnJhbWUodik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V2YWwgT3JpZ2luIG11c3QgYmUgYW4gT2JqZWN0IG9yIFN0YWNrRnJhbWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKCkgfHwgJyc7XG4gICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHRoaXMuZ2V0TGluZU51bWJlcigpIHx8ICcnO1xuICAgICAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHRoaXMuZ2V0Q29sdW1uTnVtYmVyKCkgfHwgJyc7XG4gICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5nZXRGdW5jdGlvbk5hbWUoKSB8fCAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLmdldElzRXZhbCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnW2V2YWxdICgnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyICsgJyknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ1tldmFsXTonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25OYW1lICsgJyAoJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICc6JyArIGNvbHVtbk51bWJlciArICcpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU3RhY2tGcmFtZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gU3RhY2tGcmFtZSQkZnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgdmFyIGFyZ3NTdGFydEluZGV4ID0gc3RyLmluZGV4T2YoJygnKTtcbiAgICAgICAgdmFyIGFyZ3NFbmRJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignKScpO1xuXG4gICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBzdHIuc3Vic3RyaW5nKDAsIGFyZ3NTdGFydEluZGV4KTtcbiAgICAgICAgdmFyIGFyZ3MgPSBzdHIuc3Vic3RyaW5nKGFyZ3NTdGFydEluZGV4ICsgMSwgYXJnc0VuZEluZGV4KS5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgbG9jYXRpb25TdHJpbmcgPSBzdHIuc3Vic3RyaW5nKGFyZ3NFbmRJbmRleCArIDEpO1xuXG4gICAgICAgIGlmIChsb2NhdGlvblN0cmluZy5pbmRleE9mKCdAJykgPT09IDApIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IC9AKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLy5leGVjKGxvY2F0aW9uU3RyaW5nLCAnJyk7XG4gICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgIHZhciBsaW5lTnVtYmVyID0gcGFydHNbMl07XG4gICAgICAgICAgICB2YXIgY29sdW1uTnVtYmVyID0gcGFydHNbM107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICBhcmdzOiBhcmdzIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBjb2x1bW5OdW1iZXIgfHwgdW5kZWZpbmVkXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2xlYW5Qcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldID0gX2dldHRlcihib29sZWFuUHJvcHNbaV0pO1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldID0gKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgdGhpc1twXSA9IEJvb2xlYW4odik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KShib29sZWFuUHJvcHNbaV0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtZXJpY1Byb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydnZXQnICsgX2NhcGl0YWxpemUobnVtZXJpY1Byb3BzW2pdKV0gPSBfZ2V0dGVyKG51bWVyaWNQcm9wc1tqXSk7XG4gICAgICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUobnVtZXJpY1Byb3BzW2pdKV0gPSAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pc051bWJlcih2KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHAgKyAnIG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc1twXSA9IE51bWJlcih2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKG51bWVyaWNQcm9wc1tqXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJpbmdQcm9wcy5sZW5ndGg7IGsrKykge1xuICAgICAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV0gPSBfZ2V0dGVyKHN0cmluZ1Byb3BzW2tdKTtcbiAgICAgICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShzdHJpbmdQcm9wc1trXSldID0gKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgdGhpc1twXSA9IFN0cmluZyh2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKHN0cmluZ1Byb3BzW2tdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RhY2tGcmFtZTtcbn0pKTtcbiIsIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdzdGFjay1nZW5lcmF0b3InLCBbJ3N0YWNrZnJhbWUnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3N0YWNrZnJhbWUnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5TdGFja0dlbmVyYXRvciA9IGZhY3Rvcnkocm9vdC5TdGFja0ZyYW1lKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIChTdGFja0ZyYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFja3RyYWNlOiBmdW5jdGlvbiBTdGFja0dlbmVyYXRvciQkYmFja3RyYWNlKG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgICAgICAgdmFyIG1heFN0YWNrU2l6ZSA9IDEwO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcHRzLm1heFN0YWNrU2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBtYXhTdGFja1NpemUgPSBvcHRzLm1heFN0YWNrU2l6ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnIgPSBhcmd1bWVudHMuY2FsbGVlO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnIgJiYgc3RhY2subGVuZ3RoIDwgbWF4U3RhY2tTaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgVjggb3B0aW1pemF0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGN1cnJbJ2FyZ3VtZW50cyddLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGN1cnJbJ2FyZ3VtZW50cyddW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoL2Z1bmN0aW9uKD86XFxzKyhbXFx3JF0rKSkrXFxzKlxcKC8udGVzdChjdXJyLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3IFN0YWNrRnJhbWUoe2Z1bmN0aW9uTmFtZTogUmVnRXhwLiQxIHx8IHVuZGVmaW5lZCwgYXJnczogYXJnc30pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5ldyBTdGFja0ZyYW1lKHthcmdzOiBhcmdzfSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyLmNhbGxlcjtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgfVxuICAgIH07XG59KSk7XG4iLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnc3RhY2tmcmFtZScsIFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LlN0YWNrRnJhbWUgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGZ1bmN0aW9uIF9pc051bWJlcihuKSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gU3RhY2tGcmFtZShmdW5jdGlvbk5hbWUsIGFyZ3MsIGZpbGVOYW1lLCBsaW5lTnVtYmVyLCBjb2x1bW5OdW1iZXIsIHNvdXJjZSkge1xuICAgICAgICBpZiAoZnVuY3Rpb25OYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RnVuY3Rpb25OYW1lKGZ1bmN0aW9uTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBcmdzKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZpbGVOYW1lKGZpbGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZU51bWJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldExpbmVOdW1iZXIobGluZU51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbHVtbk51bWJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbHVtbk51bWJlcihjb2x1bW5OdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFN0YWNrRnJhbWUucHJvdG90eXBlID0ge1xuICAgICAgICBnZXRGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uTmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0RnVuY3Rpb25OYW1lOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5mdW5jdGlvbk5hbWUgPSBTdHJpbmcodik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QXJnczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXJncztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0QXJnczogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmdzIG11c3QgYmUgYW4gQXJyYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXJncyA9IHY7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gTk9URTogUHJvcGVydHkgbmFtZSBtYXkgYmUgbWlzbGVhZGluZyBhcyBpdCBpbmNsdWRlcyB0aGUgcGF0aCxcbiAgICAgICAgLy8gYnV0IGl0IHNvbWV3aGF0IG1pcnJvcnMgVjgncyBKYXZhU2NyaXB0U3RhY2tUcmFjZUFwaVxuICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L3dpa2kvSmF2YVNjcmlwdFN0YWNrVHJhY2VBcGkgYW5kIEdlY2tvJ3NcbiAgICAgICAgLy8gaHR0cDovL214ci5tb3ppbGxhLm9yZy9tb3ppbGxhLWNlbnRyYWwvc291cmNlL3hwY29tL2Jhc2UvbnNJRXhjZXB0aW9uLmlkbCMxNFxuICAgICAgICBnZXRGaWxlTmFtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZU5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEZpbGVOYW1lOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5maWxlTmFtZSA9IFN0cmluZyh2KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRMaW5lTnVtYmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5lTnVtYmVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXRMaW5lTnVtYmVyOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKCFfaXNOdW1iZXIodikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIE51bWJlciBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSBOdW1iZXIodik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q29sdW1uTnVtYmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5OdW1iZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENvbHVtbk51bWJlcjogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICghX2lzTnVtYmVyKHYpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIE51bWJlciBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbHVtbk51bWJlciA9IE51bWJlcih2KTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTb3VyY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U291cmNlOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBTdHJpbmcodik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRoaXMuZ2V0RnVuY3Rpb25OYW1lKCkgfHwgJ3thbm9ueW1vdXN9JztcbiAgICAgICAgICAgIHZhciBhcmdzID0gJygnICsgKHRoaXMuZ2V0QXJncygpIHx8IFtdKS5qb2luKCcsJykgKyAnKSc7XG4gICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSB0aGlzLmdldEZpbGVOYW1lKCkgPyAoJ0AnICsgdGhpcy5nZXRGaWxlTmFtZSgpKSA6ICcnO1xuICAgICAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSBfaXNOdW1iZXIodGhpcy5nZXRMaW5lTnVtYmVyKCkpID8gKCc6JyArIHRoaXMuZ2V0TGluZU51bWJlcigpKSA6ICcnO1xuICAgICAgICAgICAgdmFyIGNvbHVtbk51bWJlciA9IF9pc051bWJlcih0aGlzLmdldENvbHVtbk51bWJlcigpKSA/ICgnOicgKyB0aGlzLmdldENvbHVtbk51bWJlcigpKSA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uTmFtZSArIGFyZ3MgKyBmaWxlTmFtZSArIGxpbmVOdW1iZXIgKyBjb2x1bW5OdW1iZXI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIFN0YWNrRnJhbWU7XG59KSk7XG4iLCIoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKCdzdGFja3RyYWNlLWdwcycsIFsnc291cmNlLW1hcCcsICdzdGFja2ZyYW1lJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdzb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJyksIHJlcXVpcmUoJ3N0YWNrZnJhbWUnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5TdGFja1RyYWNlR1BTID0gZmFjdG9yeShyb290LlNvdXJjZU1hcCB8fCByb290LnNvdXJjZU1hcCwgcm9vdC5TdGFja0ZyYW1lKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uKFNvdXJjZU1hcCwgU3RhY2tGcmFtZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIE1ha2UgYSBYLURvbWFpbiByZXF1ZXN0IHRvIHVybCBhbmQgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IHdpdGggcmVzcG9uc2UgdGV4dCBpZiBmdWxmaWxsZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfeGRyKHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXEub3BlbignZ2V0JywgdXJsKTtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIG9ucmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPj0gMjAwICYmIHJlcS5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdIVFRQIHN0YXR1czogJyArIHJlcS5zdGF0dXMgKyAnIHJldHJpZXZpbmcgJyArIHVybCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5zZW5kKCk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIEJhc2U2NC1lbmNvZGVkIHN0cmluZyBpbnRvIGl0cyBvcmlnaW5hbCByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBVc2VkIGZvciBpbmxpbmUgc291cmNlbWFwcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiNjRzdHIgQmFzZS02NCBlbmNvZGVkIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IG9yaWdpbmFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2F0b2IoYjY0c3RyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYXRvYikge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5hdG9iKGI2NHN0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhIHBvbHlmaWxsIGZvciB3aW5kb3cuYXRvYiBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcGFyc2VKc29uKHN0cmluZykge1xuICAgICAgICBpZiAodHlwZW9mIEpTT04gIT09ICd1bmRlZmluZWQnICYmIEpTT04ucGFyc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0cmluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHN1cHBseSBhIHBvbHlmaWxsIGZvciBKU09OLnBhcnNlIGluIHRoaXMgZW52aXJvbm1lbnQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9maW5kRnVuY3Rpb25OYW1lKHNvdXJjZSwgbGluZU51bWJlci8qLCBjb2x1bW5OdW1iZXIqLykge1xuICAgICAgICAvLyBmdW5jdGlvbiB7bmFtZX0oe2FyZ3N9KSBtWzFdPW5hbWUgbVsyXT1hcmdzXG4gICAgICAgIHZhciByZUZ1bmN0aW9uRGVjbGFyYXRpb24gPSAvZnVuY3Rpb25cXHMrKFteKF0qPylcXHMqXFwoKFteKV0qKVxcKS87XG4gICAgICAgIC8vIHtuYW1lfSA9IGZ1bmN0aW9uICh7YXJnc30pIFRPRE8gYXJncyBjYXB0dXJlXG4gICAgICAgIHZhciByZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IC9bJ1wiXT8oWyRfQS1aYS16XVskX0EtWmEtejAtOV0qKVsnXCJdP1xccypbOj1dXFxzKmZ1bmN0aW9uXFxiLztcbiAgICAgICAgLy8ge25hbWV9ID0gZXZhbCgpXG4gICAgICAgIHZhciByZUZ1bmN0aW9uRXZhbHVhdGlvbiA9IC9bJ1wiXT8oWyRfQS1aYS16XVskX0EtWmEtejAtOV0qKVsnXCJdP1xccypbOj1dXFxzKig/OmV2YWx8bmV3IEZ1bmN0aW9uKVxcYi87XG4gICAgICAgIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgnXFxuJyk7XG5cbiAgICAgICAgLy8gV2FsayBiYWNrd2FyZHMgaW4gdGhlIHNvdXJjZSBsaW5lcyB1bnRpbCB3ZSBmaW5kIHRoZSBsaW5lIHdoaWNoIG1hdGNoZXMgb25lIG9mIHRoZSBwYXR0ZXJucyBhYm92ZVxuICAgICAgICB2YXIgY29kZSA9ICcnO1xuICAgICAgICB2YXIgbWF4TGluZXMgPSBNYXRoLm1pbihsaW5lTnVtYmVyLCAyMCk7XG4gICAgICAgIHZhciBtO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heExpbmVzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGxpbmVObyBpcyAxLWJhc2VkLCBzb3VyY2VbXSBpcyAwLWJhc2VkXG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xpbmVOdW1iZXIgLSBpIC0gMV07XG4gICAgICAgICAgICB2YXIgY29tbWVudFBvcyA9IGxpbmUuaW5kZXhPZignLy8nKTtcbiAgICAgICAgICAgIGlmIChjb21tZW50UG9zID49IDApIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHIoMCwgY29tbWVudFBvcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGxpbmUgKyBjb2RlO1xuICAgICAgICAgICAgICAgIG0gPSByZUZ1bmN0aW9uRXhwcmVzc2lvbi5leGVjKGNvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1bMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0gPSByZUZ1bmN0aW9uRGVjbGFyYXRpb24uZXhlYyhjb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtID0gcmVGdW5jdGlvbkV2YWx1YXRpb24uZXhlYyhjb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lbnN1cmVTdXBwb3J0ZWRFbnZpcm9ubWVudCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIE9iamVjdC5jcmVhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNvbnN1bWUgc291cmNlIG1hcHMgaW4gb2xkZXIgYnJvd3NlcnMnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9lbnN1cmVTdGFja0ZyYW1lSXNMZWdpdChzdGFja2ZyYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2tmcmFtZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dpdmVuIFN0YWNrRnJhbWUgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGFja2ZyYW1lLmZpbGVOYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR2l2ZW4gZmlsZSBuYW1lIGlzIG5vdCBhIFN0cmluZycpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGFja2ZyYW1lLmxpbmVOdW1iZXIgIT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBzdGFja2ZyYW1lLmxpbmVOdW1iZXIgJSAxICE9PSAwIHx8XG4gICAgICAgICAgICBzdGFja2ZyYW1lLmxpbmVOdW1iZXIgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHaXZlbiBsaW5lIG51bWJlciBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdGFja2ZyYW1lLmNvbHVtbk51bWJlciAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIHN0YWNrZnJhbWUuY29sdW1uTnVtYmVyICUgMSAhPT0gMCB8fFxuICAgICAgICAgICAgc3RhY2tmcmFtZS5jb2x1bW5OdW1iZXIgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHaXZlbiBjb2x1bW4gbnVtYmVyIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9maW5kU291cmNlTWFwcGluZ1VSTChzb3VyY2UpIHtcbiAgICAgICAgdmFyIG0gPSAvXFwvXFwvWyNAXSA/c291cmNlTWFwcGluZ1VSTD0oW15cXHMnXCJdKylcXHMqJC8uZXhlYyhzb3VyY2UpO1xuICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gbVsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlTWFwcGluZ1VSTCBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9leHRyYWN0TG9jYXRpb25JbmZvRnJvbVNvdXJjZU1hcChzdGFja2ZyYW1lLCByYXdTb3VyY2VNYXAsIHNvdXJjZUNhY2hlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBtYXBDb25zdW1lciA9IG5ldyBTb3VyY2VNYXAuU291cmNlTWFwQ29uc3VtZXIocmF3U291cmNlTWFwKTtcblxuICAgICAgICAgICAgdmFyIGxvYyA9IG1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgICAgIGxpbmU6IHN0YWNrZnJhbWUubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBjb2x1bW46IHN0YWNrZnJhbWUuY29sdW1uTnVtYmVyXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGxvYy5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwcGVkU291cmNlID0gbWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihsb2Muc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUNhY2hlW2xvYy5zb3VyY2VdID0gbWFwcGVkU291cmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgICAgICBuZXcgU3RhY2tGcmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5uYW1lIHx8IHN0YWNrZnJhbWUuZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tmcmFtZS5hcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLmNvbHVtbikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IG9yaWdpbmFsIHNvdXJjZSBmb3IgZ2l2ZW4gc3RhY2tmcmFtZSBhbmQgc291cmNlIG1hcCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiAgICAgIG9wdHMuc291cmNlQ2FjaGUgPSB7dXJsOiBcIlNvdXJjZSBTdHJpbmdcIn0gPT4gcHJlbG9hZCBzb3VyY2UgY2FjaGVcbiAgICAgKiAgICAgIG9wdHMub2ZmbGluZSA9IFRydWUgdG8gcHJldmVudCBuZXR3b3JrIHJlcXVlc3RzLlxuICAgICAqICAgICAgICAgICAgICBCZXN0IGVmZm9ydCB3aXRob3V0IHNvdXJjZXMgb3Igc291cmNlIG1hcHMuXG4gICAgICogICAgICBvcHRzLmFqYXggPSBQcm9taXNlIHJldHVybmluZyBmdW5jdGlvbiB0byBtYWtlIFgtRG9tYWluIHJlcXVlc3RzXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIFN0YWNrVHJhY2VHUFMob3B0cykge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RhY2tUcmFjZUdQUykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tUcmFjZUdQUyhvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICB0aGlzLnNvdXJjZUNhY2hlID0gb3B0cy5zb3VyY2VDYWNoZSB8fCB7fTtcblxuICAgICAgICB0aGlzLmFqYXggPSBvcHRzLmFqYXggfHwgX3hkcjtcblxuICAgICAgICB0aGlzLl9hdG9iID0gb3B0cy5hdG9iIHx8IF9hdG9iO1xuXG4gICAgICAgIHRoaXMuX2dldCA9IGZ1bmN0aW9uIF9nZXQobG9jYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNEYXRhVXJsID0gbG9jYXRpb24uc3Vic3RyKDAsIDUpID09PSAnZGF0YTonO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZUNhY2hlW2xvY2F0aW9uXSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuc291cmNlQ2FjaGVbbG9jYXRpb25dKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMub2ZmbGluZSAmJiAhaXNEYXRhVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0Nhbm5vdCBtYWtlIG5ldHdvcmsgcmVxdWVzdHMgaW4gb2ZmbGluZSBtb2RlJykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RhdGFVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRhdGEgVVJMcyBjYW4gaGF2ZSBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIzOTdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdXBwb3J0ZWRFbmNvZGluZ1JlZ2V4cCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjsoW1xcdz06XCItXSs7KSpiYXNlNjQsLztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGxvY2F0aW9uLm1hdGNoKHN1cHBvcnRlZEVuY29kaW5nUmVnZXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VNYXBTdGFydCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5jb2RlZFNvdXJjZSA9IGxvY2F0aW9uLnN1YnN0cihzb3VyY2VNYXBTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuX2F0b2IoZW5jb2RlZFNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VDYWNoZVtsb2NhdGlvbl0gPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaGUgZW5jb2Rpbmcgb2YgdGhlIGlubGluZSBzb3VyY2VtYXAgaXMgbm90IHN1cHBvcnRlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4aHJQcm9taXNlID0gdGhpcy5hamF4KGxvY2F0aW9uLCB7bWV0aG9kOiAnZ2V0J30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIFByb21pc2UgdG8gcHJldmVudCBkdXBsaWNhdGUgaW4tZmxpZ2h0IHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZUNhY2hlW2xvY2F0aW9uXSA9IHhoclByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHJQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgU3RhY2tGcmFtZSwgZW5oYW5jZSBmdW5jdGlvbiBuYW1lIGFuZCB1c2Ugc291cmNlIG1hcHMgZm9yIGFcbiAgICAgICAgICogYmV0dGVyIFN0YWNrRnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7U3RhY2tGcmFtZX0gc3RhY2tmcmFtZSBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgd2l0aCB3aXRoIHNvdXJjZS1tYXBwZWQgU3RhY2tGcmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5waW5wb2ludCA9IGZ1bmN0aW9uIFN0YWNrVHJhY2VHUFMkJHBpbnBvaW50KHN0YWNrZnJhbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldE1hcHBlZExvY2F0aW9uKHN0YWNrZnJhbWUpLnRoZW4oZnVuY3Rpb24obWFwcGVkU3RhY2tGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlTWFwcGVkU3RhY2tGcmFtZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWFwcGVkU3RhY2tGcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRGdW5jdGlvbk5hbWUobWFwcGVkU3RhY2tGcmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc29sdmUsIHJlc29sdmVNYXBwZWRTdGFja0ZyYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgWydjYXRjaCddKHJlc29sdmVNYXBwZWRTdGFja0ZyYW1lKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIHJlamVjdCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIFN0YWNrRnJhbWUsIGd1ZXNzIGZ1bmN0aW9uIG5hbWUgZnJvbSBsb2NhdGlvbiBpbmZvcm1hdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdGFja0ZyYW1lfSBzdGFja2ZyYW1lXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHJlc29sdmVzIHdpdGggZW5oYW5jZWQgU3RhY2tGcmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmluZEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uIFN0YWNrVHJhY2VHUFMkJGZpbmRGdW5jdGlvbk5hbWUoc3RhY2tmcmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIF9lbnN1cmVTdGFja0ZyYW1lSXNMZWdpdChzdGFja2ZyYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXQoc3RhY2tmcmFtZS5maWxlTmFtZSkudGhlbihmdW5jdGlvbiBnZXRTb3VyY2VDYWxsYmFjayhzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzdGFja2ZyYW1lLmxpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBzdGFja2ZyYW1lLmNvbHVtbk51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGd1ZXNzZWRGdW5jdGlvbk5hbWUgPSBfZmluZEZ1bmN0aW9uTmFtZShzb3VyY2UsIGxpbmVOdW1iZXIsIGNvbHVtbk51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVwbGFjZSBmdW5jdGlvbk5hbWUgaWYgd2UgZm91bmQgc29tZXRoaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChndWVzc2VkRnVuY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBTdGFja0ZyYW1lKGd1ZXNzZWRGdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tmcmFtZS5hcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrZnJhbWUuZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc3RhY2tmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCByZWplY3QpWydjYXRjaCddKHJlamVjdCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIFN0YWNrRnJhbWUsIHNlZWsgc291cmNlLW1hcHBlZCBsb2NhdGlvbiBhbmQgcmV0dXJuIG5ldyBlbmhhbmNlZCBTdGFja0ZyYW1lLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge1N0YWNrRnJhbWV9IHN0YWNrZnJhbWVcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgd2l0aCBlbmhhbmNlZCBTdGFja0ZyYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRNYXBwZWRMb2NhdGlvbiA9IGZ1bmN0aW9uIFN0YWNrVHJhY2VHUFMkJGdldE1hcHBlZExvY2F0aW9uKHN0YWNrZnJhbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBfZW5zdXJlU3VwcG9ydGVkRW52aXJvbm1lbnQoKTtcbiAgICAgICAgICAgICAgICBfZW5zdXJlU3RhY2tGcmFtZUlzTGVnaXQoc3RhY2tmcmFtZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc291cmNlQ2FjaGUgPSB0aGlzLnNvdXJjZUNhY2hlO1xuICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZSA9IHN0YWNrZnJhbWUuZmlsZU5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0KGZpbGVOYW1lKS50aGVuKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlTWFwcGluZ1VSTCA9IF9maW5kU291cmNlTWFwcGluZ1VSTChzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNEYXRhVXJsID0gc291cmNlTWFwcGluZ1VSTC5zdWJzdHIoMCwgNSkgPT09ICdkYXRhOic7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlID0gZmlsZU5hbWUuc3Vic3RyaW5nKDAsIGZpbGVOYW1lLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlTWFwcGluZ1VSTFswXSAhPT0gJy8nICYmICFpc0RhdGFVcmwgJiYgISgvXmh0dHBzPzpcXC9cXC98XlxcL1xcLy9pKS50ZXN0KHNvdXJjZU1hcHBpbmdVUkwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VNYXBwaW5nVVJMID0gYmFzZSArIHNvdXJjZU1hcHBpbmdVUkw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXQoc291cmNlTWFwcGluZ1VSTCkudGhlbihmdW5jdGlvbihzb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU1hcCA9IF9wYXJzZUpzb24oc291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlTWFwLnNvdXJjZVJvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTWFwLnNvdXJjZVJvb3QgPSBiYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfZXh0cmFjdExvY2F0aW9uSW5mb0Zyb21Tb3VyY2VNYXAoc3RhY2tmcmFtZSwgc291cmNlTWFwLCBzb3VyY2VDYWNoZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNvbHZlKVsnY2F0Y2gnXShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0YWNrZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHJlamVjdClbJ2NhdGNoJ10ocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIHJlamVjdClbJ2NhdGNoJ10ocmVqZWN0KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbn0pKTtcbiIsIihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIFVuaXZlcnNhbCBNb2R1bGUgRGVmaW5pdGlvbiAoVU1EKSB0byBzdXBwb3J0IEFNRCwgQ29tbW9uSlMvTm9kZS5qcywgUmhpbm8sIGFuZCBicm93c2Vycy5cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoJ3N0YWNrdHJhY2UnLCBbJ2Vycm9yLXN0YWNrLXBhcnNlcicsICdzdGFjay1nZW5lcmF0b3InLCAnc3RhY2t0cmFjZS1ncHMnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2Vycm9yLXN0YWNrLXBhcnNlcicpLCByZXF1aXJlKCdzdGFjay1nZW5lcmF0b3InKSwgcmVxdWlyZSgnc3RhY2t0cmFjZS1ncHMnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5TdGFja1RyYWNlID0gZmFjdG9yeShyb290LkVycm9yU3RhY2tQYXJzZXIsIHJvb3QuU3RhY2tHZW5lcmF0b3IsIHJvb3QuU3RhY2tUcmFjZUdQUyk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiBTdGFja1RyYWNlKEVycm9yU3RhY2tQYXJzZXIsIFN0YWNrR2VuZXJhdG9yLCBTdGFja1RyYWNlR1BTKSB7XG4gICAgdmFyIF9vcHRpb25zID0ge1xuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKHN0YWNrZnJhbWUpIHtcbiAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgc3RhY2tmcmFtZXMgZm9yIHRoaXMgbGlicmFyeSBieSBkZWZhdWx0XG4gICAgICAgICAgICByZXR1cm4gKHN0YWNrZnJhbWUuZnVuY3Rpb25OYW1lIHx8ICcnKS5pbmRleE9mKCdTdGFja1RyYWNlJCQnKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAoc3RhY2tmcmFtZS5mdW5jdGlvbk5hbWUgfHwgJycpLmluZGV4T2YoJ0Vycm9yU3RhY2tQYXJzZXIkJCcpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIChzdGFja2ZyYW1lLmZ1bmN0aW9uTmFtZSB8fCAnJykuaW5kZXhPZignU3RhY2tUcmFjZUdQUyQkJykgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgKHN0YWNrZnJhbWUuZnVuY3Rpb25OYW1lIHx8ICcnKS5pbmRleE9mKCdTdGFja0dlbmVyYXRvciQkJykgPT09IC0xO1xuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VDYWNoZToge31cbiAgICB9O1xuXG4gICAgdmFyIF9nZW5lcmF0ZUVycm9yID0gZnVuY3Rpb24gU3RhY2tUcmFjZSQkR2VuZXJhdGVFcnJvcigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEVycm9yIG11c3QgYmUgdGhyb3duIHRvIGdldCBzdGFjayBpbiBJRVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZSAyIGdpdmVuIE9iamVjdHMuIElmIGEgY29uZmxpY3Qgb2NjdXJzIHRoZSBzZWNvbmQgb2JqZWN0IHdpbnMuXG4gICAgICogRG9lcyBub3QgZG8gZGVlcCBtZXJnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlyc3QgYmFzZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2Vjb25kIG92ZXJyaWRlc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IG1lcmdlZCBmaXJzdCBhbmQgc2Vjb25kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfbWVyZ2UoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgICAgICAgW2ZpcnN0LCBzZWNvbmRdLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2lzU2hhcGVkTGlrZVBhcnNhYmxlRXJyb3IoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnIuc3RhY2sgfHwgZXJyWydvcGVyYSNzb3VyY2Vsb2MnXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZmlsdGVyZWQoc3RhY2tmcmFtZXMsIGZpbHRlcikge1xuICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrZnJhbWVzLmZpbHRlcihmaWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFja2ZyYW1lcztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgYmFja3RyYWNlIGZyb20gaW52b2NhdGlvbiBwb2ludC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fSBvZiBTdGFja0ZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIFN0YWNrVHJhY2UkJGdldChvcHRzKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gX2dlbmVyYXRlRXJyb3IoKTtcbiAgICAgICAgICAgIHJldHVybiBfaXNTaGFwZWRMaWtlUGFyc2FibGVFcnJvcihlcnIpID8gdGhpcy5mcm9tRXJyb3IoZXJyLCBvcHRzKSA6IHRoaXMuZ2VuZXJhdGVBcnRpZmljaWFsbHkob3B0cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIGJhY2t0cmFjZSBmcm9tIGludm9jYXRpb24gcG9pbnQuXG4gICAgICAgICAqIElNUE9SVEFOVDogRG9lcyBub3QgaGFuZGxlIHNvdXJjZSBtYXBzIG9yIGd1ZXNzIGZ1bmN0aW9uIG5hbWVzIVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IG9mIFN0YWNrRnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIGdldFN5bmM6IGZ1bmN0aW9uIFN0YWNrVHJhY2UkJGdldFN5bmMob3B0cykge1xuICAgICAgICAgICAgb3B0cyA9IF9tZXJnZShfb3B0aW9ucywgb3B0cyk7XG4gICAgICAgICAgICB2YXIgZXJyID0gX2dlbmVyYXRlRXJyb3IoKTtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IF9pc1NoYXBlZExpa2VQYXJzYWJsZUVycm9yKGVycikgPyBFcnJvclN0YWNrUGFyc2VyLnBhcnNlKGVycikgOiBTdGFja0dlbmVyYXRvci5iYWNrdHJhY2Uob3B0cyk7XG4gICAgICAgICAgICByZXR1cm4gX2ZpbHRlcmVkKHN0YWNrLCBvcHRzLmZpbHRlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGFuIGVycm9yIG9iamVjdCwgcGFyc2UgaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gZm9yIEFycmF5W1N0YWNrRnJhbWV9XG4gICAgICAgICAqL1xuICAgICAgICBmcm9tRXJyb3I6IGZ1bmN0aW9uIFN0YWNrVHJhY2UkJGZyb21FcnJvcihlcnJvciwgb3B0cykge1xuICAgICAgICAgICAgb3B0cyA9IF9tZXJnZShfb3B0aW9ucywgb3B0cyk7XG4gICAgICAgICAgICB2YXIgZ3BzID0gbmV3IFN0YWNrVHJhY2VHUFMob3B0cyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFja2ZyYW1lcyA9IF9maWx0ZXJlZChFcnJvclN0YWNrUGFyc2VyLnBhcnNlKGVycm9yKSwgb3B0cy5maWx0ZXIpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoUHJvbWlzZS5hbGwoc3RhY2tmcmFtZXMubWFwKGZ1bmN0aW9uKHNmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlT3JpZ2luYWwoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdwcy5waW5wb2ludChzZikudGhlbihyZXNvbHZlLCByZXNvbHZlT3JpZ2luYWwpWydjYXRjaCddKHJlc29sdmVPcmlnaW5hbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgU3RhY2tHZW5lcmF0b3IgdG8gZ2VuZXJhdGUgYSBiYWNrdHJhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBvZiBBcnJheVtTdGFja0ZyYW1lXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2VuZXJhdGVBcnRpZmljaWFsbHk6IGZ1bmN0aW9uIFN0YWNrVHJhY2UkJGdlbmVyYXRlQXJ0aWZpY2lhbGx5KG9wdHMpIHtcbiAgICAgICAgICAgIG9wdHMgPSBfbWVyZ2UoX29wdGlvbnMsIG9wdHMpO1xuICAgICAgICAgICAgdmFyIHN0YWNrRnJhbWVzID0gU3RhY2tHZW5lcmF0b3IuYmFja3RyYWNlKG9wdHMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHN0YWNrRnJhbWVzID0gc3RhY2tGcmFtZXMuZmlsdGVyKG9wdHMuZmlsdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3RhY2tGcmFtZXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIGZ1bmN0aW9uLCB3cmFwIGl0IHN1Y2ggdGhhdCBpbnZvY2F0aW9ucyB0cmlnZ2VyIGEgY2FsbGJhY2sgdGhhdFxuICAgICAgICAgKiBpcyBjYWxsZWQgd2l0aCBhIHN0YWNrIHRyYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0byBiZSBpbnN0cnVtZW50ZWRcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIGEgc3RhY2sgdHJhY2Ugb24gaW52b2NhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJiYWNrIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGNhbGwgd2l0aCBlcnJvciBpZiB1bmFibGUgdG8gZ2V0IHN0YWNrIHRyYWNlLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBvcHRpb25hbCBjb250ZXh0IG9iamVjdCAoZS5nLiB3aW5kb3cpXG4gICAgICAgICAqL1xuICAgICAgICBpbnN0cnVtZW50OiBmdW5jdGlvbiBTdGFja1RyYWNlJCRpbnN0cnVtZW50KGZuLCBjYWxsYmFjaywgZXJyYmFjaywgdGhpc0FyZykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGluc3RydW1lbnQgbm9uLWZ1bmN0aW9uIG9iamVjdCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm4uX19zdGFja3RyYWNlT3JpZ2luYWxGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgaW5zdHJ1bWVudGVkLCByZXR1cm4gZ2l2ZW4gRnVuY3Rpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbnN0cnVtZW50ZWQgPSBmdW5jdGlvbiBTdGFja1RyYWNlJCRpbnN0cnVtZW50ZWQoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXQoKS50aGVuKGNhbGxiYWNrLCBlcnJiYWNrKVsnY2F0Y2gnXShlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcgfHwgdGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNTaGFwZWRMaWtlUGFyc2FibGVFcnJvcihlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mcm9tRXJyb3IoZSkudGhlbihjYWxsYmFjaywgZXJyYmFjaylbJ2NhdGNoJ10oZXJyYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgICAgICBpbnN0cnVtZW50ZWQuX19zdGFja3RyYWNlT3JpZ2luYWxGbiA9IGZuO1xuXG4gICAgICAgICAgICByZXR1cm4gaW5zdHJ1bWVudGVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhIGZ1bmN0aW9uIHRoYXQgaGFzIGJlZW4gaW5zdHJ1bWVudGVkLFxuICAgICAgICAgKiByZXZlcnQgdGhlIGZ1bmN0aW9uIHRvIGl0J3Mgb3JpZ2luYWwgKG5vbi1pbnN0cnVtZW50ZWQpIHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0byBkZS1pbnN0cnVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBkZWluc3RydW1lbnQ6IGZ1bmN0aW9uIFN0YWNrVHJhY2UkJGRlaW5zdHJ1bWVudChmbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlLWluc3RydW1lbnQgbm9uLWZ1bmN0aW9uIG9iamVjdCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm4uX19zdGFja3RyYWNlT3JpZ2luYWxGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5fX3N0YWNrdHJhY2VPcmlnaW5hbEZuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBub3QgaW5zdHJ1bWVudGVkLCByZXR1cm4gb3JpZ2luYWxcbiAgICAgICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGFuIGVycm9yIG1lc3NhZ2UgYW5kIEFycmF5IG9mIFN0YWNrRnJhbWVzLCBzZXJpYWxpemUgYW5kIFBPU1QgdG8gZ2l2ZW4gVVJMLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBzdGFja2ZyYW1lc1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvck1zZ1xuICAgICAgICAgKi9cbiAgICAgICAgcmVwb3J0OiBmdW5jdGlvbiBTdGFja1RyYWNlJCRyZXBvcnQoc3RhY2tmcmFtZXMsIHVybCwgZXJyb3JNc2cpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIG9ucmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA+PSAyMDAgJiYgcmVxLnN0YXR1cyA8IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1BPU1QgdG8gJyArIHVybCArICcgZmFpbGVkIHdpdGggc3RhdHVzOiAnICsgcmVxLnN0YXR1cykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXEub3BlbigncG9zdCcsIHVybCk7XG4gICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVwb3J0UGF5bG9hZCA9IHtzdGFjazogc3RhY2tmcmFtZXN9O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvck1zZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydFBheWxvYWQubWVzc2FnZSA9IGVycm9yTXNnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcS5zZW5kKEpTT04uc3RyaW5naWZ5KHJlcG9ydFBheWxvYWQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pKTtcbiIsImltcG9ydCBBY3Rpb24gZnJvbSBcIi4uL2RvbWFpbi9BY3Rpb25cIjtcbmltcG9ydCBBaWZleFNlcnZpY2UgZnJvbSBcIi4uL2RvbWFpbi9BaWZleFNlcnZpY2VcIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vZG9tYWluL1Rva2VuXCI7XG5pbXBvcnQgV2ViU2l0ZSBmcm9tIFwiLi4vZG9tYWluL1dlYnNpdGVcIjtcbmltcG9ydCBTZXNzaW9uIGZyb20gXCIuLi9kb21haW4vU2Vzc2lvblwiO1xuaW1wb3J0IEFpZmV4UGx1Z2luSW5mbyBmcm9tIFwiLi4vZG9tYWluL0FpZmV4UGx1Z2luSW5mb1wiO1xuY29uc3QgT0tfU1RBVFVTID0gMjAwO1xuY29uc3QgSU5WQUxJRF9QQVJBTUVURVJTX1NUQVRVUyA9IDQwMDtcbmNvbnN0IEZPUkJJRERFTl9TVEFUVVMgPSA0MDM7XG5jb25zdCBOT1RfRk9VTkRfU1RBVFVTID0gNDA0O1xuY29uc3QgSU5URVJOQUxfU0VSVkVSX0VSUk9SX1NUQVRVUyA9IDUwMDtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFpZmV4U2VydmljZUhUVFAgaW1wbGVtZW50cyBBaWZleFNlcnZpY2Uge1xuXG5cdHBpbmcoc2VydmVyVVJMOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRyZXR1cm4gZmV0Y2goYCR7c2VydmVyVVJMfS9hcGkvcGluZ2AsIHtcblx0XHRcdG1ldGhvZDogXCJHRVRcIixcblx0XHRcdGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcblx0XHR9KVxuXHRcdFx0LnRoZW4ocmVzcG9uc2UgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhyZXNwb25zZSk7XG5cdFx0XHRcdGlmIChyZXNwb25zZS5vaykge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdvaycpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnZXJyb3InKTtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdH1cblxuXHRnZXRQbHVnaW5JbmZvKHNlcnZlclVSTDogc3RyaW5nKTogUHJvbWlzZTxBaWZleFBsdWdpbkluZm8+IHtcblx0XHRjb25zdCBvcHRpb24gPSB7XG5cdFx0XHRtZXRob2Q6IFwiR0VUXCIsXG5cdFx0XHRoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG5cdFx0fTtcblx0XHRyZXR1cm4gZmV0Y2goYCR7c2VydmVyVVJMfS9hcGkvcGx1Z2luLWluZm9gLCBvcHRpb24pXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiB7XG5cdFx0XHRcdGlmICghcmVzcG9uc2Uub2spIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcblx0XHRcdH0pXG5cdFx0XHQudGhlbihkZXRhaWxzID0+IHtcblx0XHRcdFx0ZGV0YWlscy51cmwgPSBgJHtzZXJ2ZXJVUkx9L2Rvd25sb2FkYFxuXHRcdFx0XHRyZXR1cm4gbmV3IEFpZmV4UGx1Z2luSW5mbyhkZXRhaWxzLnZlcnNpb24sIGRldGFpbHMubmFtZSwgZGV0YWlscy5kZXNjcmlwdGlvbiwgZGV0YWlscy51cmwpO1xuXHRcdFx0fSlcblx0fVxuXG5cdGdldFNlc3Npb24oc2VydmVyVVJMOiBzdHJpbmcsIHNlc3Npb25JZDogc3RyaW5nLCB0b2tlbjogVG9rZW4gfCB1bmRlZmluZWQpOiBQcm9taXNlPFNlc3Npb24gfCB1bmRlZmluZWQgfCBcIlVuYXV0aG9yaXplZFwiPiB7XG5cdFx0Y29uc3QgU0VTU0lPTl9VUkwgPSBzZXJ2ZXJVUkwgKyAnL2FwaS9zZXNzaW9ucy8nICsgc2Vzc2lvbklkO1xuXHRcdHJldHVybiBmZXRjaChTRVNTSU9OX1VSTCwge1xuXHRcdFx0bWV0aG9kOiAnR0VUJyxcblx0XHRcdGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHt0b2tlbj8udG9rZW59YCB9LFxuXHRcdH0pXG5cdFx0XHQudGhlbigocmVzcG9uc2UpID0+IHtcblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gT0tfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlXG5cdFx0XHRcdFx0XHQuanNvbigpXG5cdFx0XHRcdFx0XHQudGhlbigoc2Vzc2lvbjoge1xuXHRcdFx0XHRcdFx0XHRpZDogc3RyaW5nLFxuXHRcdFx0XHRcdFx0XHR3ZWJTaXRlOiB7IGlkOiBzdHJpbmcgfSxcblx0XHRcdFx0XHRcdFx0YmFzZVVSTDogc3RyaW5nLFxuXHRcdFx0XHRcdFx0XHRuYW1lOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHRcdGRlc2NyaXB0aW9uOiBzdHJpbmcsXG5cdFx0XHRcdFx0XHRcdG92ZXJsYXlUeXBlOiBcInJhaW5ib3dcIiB8IFwiYmx1ZXNreVwiIHwgXCJzaGFkb3dcIixcblx0XHRcdFx0XHRcdFx0cmVjb3JkaW5nTW9kZTogXCJieWV4cGxvcmF0aW9uXCIgfCBcImJ5aW50ZXJhY3Rpb25cIlxuXG5cdFx0XHRcdFx0XHR9KSA9PiB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgU2Vzc2lvbihzZXNzaW9uLmlkLCBzZXNzaW9uLndlYlNpdGUuaWQsIHNlc3Npb24uYmFzZVVSTCwgc2Vzc2lvbi5uYW1lLCBzZXNzaW9uLmRlc2NyaXB0aW9uLCBzZXNzaW9uLm92ZXJsYXlUeXBlLCBzZXNzaW9uLnJlY29yZGluZ01vZGUpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gSU5WQUxJRF9QQVJBTUVURVJTX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gTk9UX0ZPVU5EX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gRk9SQklEREVOX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiBcIlVuYXV0aG9yaXplZFwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IElOVEVSTkFMX1NFUlZFUl9FUlJPUl9TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoYHNlcnZlciBlcnJvcmApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHR9XG5cblx0Z2V0V2ViU2l0ZShzZXJ2ZXJVUkw6IHN0cmluZywgd2ViU2l0ZUlkOiBzdHJpbmcsIHRva2VuOiBUb2tlbiB8IHVuZGVmaW5lZCk6IFByb21pc2U8V2ViU2l0ZSB8IHVuZGVmaW5lZCB8IFwiVW5hdXRob3JpemVkXCI+IHtcblx0XHRyZXR1cm4gZmV0Y2goYCR7c2VydmVyVVJMfS9hcGkvd2Vic2l0ZXMvJHt3ZWJTaXRlSWR9YCwge1xuXHRcdFx0bWV0aG9kOiAnR0VUJyxcblx0XHRcdGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywgXCJBdXRob3JpemF0aW9uXCI6IGBCZWFyZXIgJHt0b2tlbj8udG9rZW59YCB9LFxuXHRcdH0pXG5cdFx0XHQudGhlbigocmVzcG9uc2UpID0+IHtcblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gT0tfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlXG5cdFx0XHRcdFx0XHQuanNvbigpXG5cdFx0XHRcdFx0XHQudGhlbih3ZWJzaXRlRGF0YSA9PiB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBuZXcgV2ViU2l0ZSh3ZWJzaXRlRGF0YS5pZCwgd2Vic2l0ZURhdGEubmFtZSwgd2Vic2l0ZURhdGEubWFwcGluZ0xpc3QpO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBJTlZBTElEX1BBUkFNRVRFUlNfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGBzZXNzaW9uSWQgaXMgbWFsZm9ybWVkYCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gTk9UX0ZPVU5EX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBJTlRFUk5BTF9TRVJWRVJfRVJST1JfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGBzZXJ2ZXIgZXJyb3JgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblxuXHR9XG5cblx0Y3JlYXRlRW1wdHlFeHBsb3JhdGlvbih0ZXN0ZXJOYW1lOiBzdHJpbmcsIHNlcnZlclVSTDogc3RyaW5nLCBzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG5cdFx0Y29uc3QgYm9keSA9IHtcblx0XHRcdHRlc3Rlck5hbWUsXG5cdFx0XHRpbnRlcmFjdGlvbkxpc3Q6IFtdLFxuXHRcdH07XG5cdFx0Y29uc3Qgb3B0aW9uID0ge1xuXHRcdFx0bWV0aG9kOiBcIlBPU1RcIixcblx0XHRcdGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuXHRcdFx0aGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuXHRcdH07XG5cdFx0cmV0dXJuIGZldGNoKFxuXHRcdFx0YCR7c2VydmVyVVJMfS9hcGkvc2Vzc2lvbnMvJHtzZXNzaW9uSWR9L2V4cGxvcmF0aW9uc2AsXG5cdFx0XHRvcHRpb25cblx0XHQpXG5cdFx0XHQudGhlbigocmVzcG9uc2UpID0+IHtcblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gT0tfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmpzb24oKS50aGVuKGRhdGEgPT4ge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGEuZXhwbG9yYXRpb25OdW1iZXJcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IE5PVF9GT1VORF9TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBubyBzZXNzaW9uIG5vdCBmb3VuZCBmb3IgSWRgKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gSU5WQUxJRF9QQVJBTUVURVJTX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYHNlc3Npb25JZCBhbmQvb3IgZXhwbG9yYXRpb24gaXMgbWFsZm9ybWVkYCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IElOVEVSTkFMX1NFUlZFUl9FUlJPUl9TVEFUVVMpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBzZXJ2ZXIgZXJyb3JgKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cblx0fVxuXG5cdHNlbmRBY3Rpb24oZXhwbG9yYXRpb25OdW1iZXI6IG51bWJlciwgYWN0aW9uOiBBY3Rpb24sIHNlcnZlclVSTDogc3RyaW5nLCBzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuXG5cdFx0Y29uc3QgYm9keSA9IHtcblx0XHRcdGludGVyYWN0aW9uTGlzdDogW3tcblx0XHRcdFx0Y29uY3JldGVUeXBlOiBhY3Rpb24uZ2V0Q29uY3JldGVUeXBlKCksXG5cdFx0XHRcdGtpbmQ6IGFjdGlvbi5wcmVmaXgsXG5cdFx0XHRcdHZhbHVlOiBhY3Rpb24uc3VmZml4LFxuXHRcdFx0XHRkYXRlOiBhY3Rpb24uZGF0ZVxuXHRcdFx0fV1cblx0XHR9XG5cdFx0Y29uc3Qgb3B0aW9uID0ge1xuXHRcdFx0bWV0aG9kOiBcIlBPU1RcIixcblx0XHRcdGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuXHRcdFx0aGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuXHRcdH07XG5cdFx0cmV0dXJuIGZldGNoKFxuXHRcdFx0YCR7c2VydmVyVVJMfS9hcGkvc2Vzc2lvbnMvJHtzZXNzaW9uSWR9L2V4cGxvcmF0aW9ucy8ke2V4cGxvcmF0aW9uTnVtYmVyfS9pbnRlcmFjdGlvbnNgLFxuXHRcdFx0b3B0aW9uKVxuXHRcdFx0LnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXMgPT09IE9LX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBOT1RfRk9VTkRfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgc2Vzc2lvbklkIG5vdCBmb3VuZGApKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSBJTlZBTElEX1BBUkFNRVRFUlNfU1RBVFVTKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgc2Vzc2lvbklkIGFuZC9vciBleHBsb3JhdGlvbiBpcyBtYWxmb3JtZWRgKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gSU5URVJOQUxfU0VSVkVSX0VSUk9SX1NUQVRVUykge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYHNlcnZlciBlcnJvcmApKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkuY2F0Y2goZXJyb3IgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKGVycm9yKTtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiU2VydmljZSBGYWlsZWQgdG8gcHVzaCBuZXcgYWN0aW9uXCIpO1xuXHRcdFx0fSlcblxuXHR9XG59XG4iLCJpbXBvcnQgQnJvd3NlclNlcnZpY2UgZnJvbSBcIi4uL2RvbWFpbi9Ccm93c2VyU2VydmljZVwiO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwiLi4vZnJhbWV3b3JrL0xvZ2dlclwiO1xyXG5cclxuY29uc3QgRVhQTE9SQVRJT05fTlVNQkVSX0tFWSA9ICdFWFBMT1JBVElPTl9OVU1CRVJfS0VZJztcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZSBpbXBsZW1lbnRzIEJyb3dzZXJTZXJ2aWNlIHtcclxuXHRnZXRFeHBsb3JhdGlvbk51bWJlcigpOiBudW1iZXIgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkJyb3dzZXJTZXJ2aWNlU2Vzc2lvblN0b3JhZ2UuZ2V0RXhwbG9yYXRpb25OdW1iZXJcIik7XHJcbiAgICAgICAgY29uc3QgZXhwbG9yYXRpb25OdW1iZXJJdGVtID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShFWFBMT1JBVElPTl9OVU1CRVJfS0VZKTtcclxuICAgICAgICBpZiAoZXhwbG9yYXRpb25OdW1iZXJJdGVtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE51bWJlciA9IHBhcnNlSW50KGV4cGxvcmF0aW9uTnVtYmVySXRlbSk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihwYXJzZWROdW1iZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJCcm93c2VyU2VydmljZVNlc3Npb25TdG9yYWdlLmdldEV4cGxvcmF0aW9uTnVtYmVyOiBOYU5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZS5nZXRFeHBsb3JhdGlvbk51bWJlcjogXCIgKyBwYXJzZWROdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZE51bWJlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsb2dnZXIuZGVidWcoXCJCcm93c2VyU2VydmljZVNlc3Npb25TdG9yYWdlLmdldEV4cGxvcmF0aW9uTnVtYmVyOiB1bmRlZmluZWRcIik7XHJcbiAgICB9XHJcblxyXG5cdHNhdmVFeHBsb3JhdGlvbk51bWJlcihleHBsb3JhdGlvbk51bWJlcjogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZS5zYXZlRXhwbG9yYXRpb25OdW1iZXI6IFwiICsgZXhwbG9yYXRpb25OdW1iZXIpO1xyXG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oRVhQTE9SQVRJT05fTlVNQkVSX0tFWSwgZXhwbG9yYXRpb25OdW1iZXIudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgUnVsZSBmcm9tIFwiLi9SdWxlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjdGlvbiB7XG5cbiAgICBwdWJsaWMgcHJlZml4OiBzdHJpbmc7XG4gICAgcHVibGljIHN1ZmZpeDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHB1YmxpYyBydWxlTGlzdDogUnVsZVtdO1xuICAgIHB1YmxpYyBodG1sRWxlbWVudExpc3Q6IChIVE1MRWxlbWVudHxTVkdFbGVtZW50KVtdO1xuICAgIHB1YmxpYyBkYXRlOiBEYXRlO1xuXG4gICAgY29uc3RydWN0b3IocHJlZml4OiBzdHJpbmcsIHN1ZmZpeD86IHN0cmluZywgcnVsZUxpc3Q6IFJ1bGVbXSA9IFtdLCBodG1sRWxlbWVudExpc3Q6IEhUTUxFbGVtZW50W109IFtdKSB7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdGhpcy5ydWxlTGlzdCA9IHJ1bGVMaXN0O1xuICAgICAgICB0aGlzLmh0bWxFbGVtZW50TGlzdCA9IGh0bWxFbGVtZW50TGlzdDtcbiAgICAgICAgdGhpcy5kYXRlID0gbmV3IERhdGUoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0UnVsZUxpc3QocnVsZUxpc3Q6IFJ1bGVbXSk6IHZvaWQge1xuICAgICAgICB0aGlzLnJ1bGVMaXN0ID0gcnVsZUxpc3Q7XG4gICAgfVxuXG4gICAgcHVibGljIGdldENvbmNyZXRlVHlwZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gXCJBY3Rpb25cIjtcbiAgICB9XG5cbiAgICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRoaXMuc3VmZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5wcmVmaXh9JCR7dGhpcy5zdWZmaXh9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZWZpeDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBlcXVhbHMoYWN0aW9uOiBBY3Rpb24pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5wcmVmaXggPT09IGFjdGlvbi5wcmVmaXgpICYmICh0aGlzLnN1ZmZpeCA9PT0gYWN0aW9uLnN1ZmZpeCkpXG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlQWN0aW9uKGFjdGlvblRleHQ6IHN0cmluZyk6IEFjdGlvbiB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gYWN0aW9uVGV4dC5zcGxpdChcIiRcIik7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uKHBhcnRzWzBdKVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tbWFnaWMtbnVtYmVyc1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24ocGFydHNbMF0sIHBhcnRzWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBhY3Rpb24gOiBcIiArIGFjdGlvblRleHQpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn0iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBBaWZleFBsdWdpbkluZm8ge1xuICAgIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcbiAgICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICByZWFkb25seSB1cmw6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHZlcnNpb246IHN0cmluZywgbmFtZTogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nLCB1cmw6IHN0cmluZykge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgIH1cbn0iLCJpbXBvcnQgQWN0aW9uIGZyb20gJy4vQWN0aW9uJztcbmltcG9ydCBTaW1wbGVSdWxlIGZyb20gJy4vU2ltcGxlUnVsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF0dHJpYnV0ZVZhbHVlUnVsZSBleHRlbmRzIFNpbXBsZVJ1bGUge1xuXG4gICAgcHVibGljIGF0dHJpYnV0ZU5hbWU6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHByZWZpeDogc3RyaW5nLCBcbiAgICAgICAgc3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQsIFxuICAgICAgICBldmVudDogc3RyaW5nLCBjc3M6IHN0cmluZyB8IHVuZGVmaW5lZCwgXG4gICAgICAgIHhwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCwgXG4gICAgICAgIGtleTogc3RyaW5nIHwgdW5kZWZpbmVkLCBcbiAgICAgICAgY29udGV4dFVSTDogc3RyaW5nIHwgdW5kZWZpbmVkLCBcbiAgICAgICAgY29udGV4dENTUzogc3RyaW5nIHwgdW5kZWZpbmVkLCBcbiAgICAgICAgY29udGV4dFhQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIFxuICAgICAgICBkZXNjcmlwdGlvbjogc3RyaW5nLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBzdHJpbmcsXG4gICAgICAgICkge1xuICAgICAgICBzdXBlcihwcmVmaXgsIHN1ZmZpeCwgZXZlbnQsIGNzcywgeHBhdGgsIGNvZGUsIGtleSwgY29udGV4dFVSTCwgY29udGV4dENTUywgY29udGV4dFhQYXRoLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWVcbiAgICB9XG5cbiAgICBtYWtlQWN0aW9uKGV2ZW50IDogRXZlbnQpOiBBY3Rpb24gfCB1bmRlZmluZWQge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5maW5kQWN0aW9uTWFwcGVkVGFyZ2V0KGV2ZW50KTtcblxuICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgYXR0cmlidXRlVmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSh0aGlzLmF0dHJpYnV0ZU5hbWUpXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGlvbih0aGlzLnByZWZpeCwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWN0aW9uKHRoaXMucHJlZml4KTtcbiAgICB9XG5cblxuICAgIGFjdGlvblRvRWxlbWVudHMoYWN0aW9uOiBBY3Rpb24pOiAoSFRNTEVsZW1lbnR8IFNWR0VsZW1lbnQpW10ge1xuICAgICAgICBpZiAoYWN0aW9uLnByZWZpeCAhPT0gdGhpcy5wcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uLnN1ZmZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuYWN0aW9uVG9FbGVtZW50cyhhY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IGFjdGlvbi5zdWZmaXg7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZmluZE1hdGNoZWRFbGVtZW50cygpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcihkb21FbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb21FbGVtZW50LmdldEF0dHJpYnV0ZSh0aGlzLmF0dHJpYnV0ZU5hbWUpID09PSBzdWZmaXg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIi4uL2ZyYW1ld29yay9Mb2dnZXJcIjtcbmltcG9ydCBBY3Rpb24gZnJvbSBcIi4vQWN0aW9uXCI7XG5pbXBvcnQgQWlmZXhTZXJ2aWNlIGZyb20gXCIuL0FpZmV4U2VydmljZVwiO1xuaW1wb3J0IEJyb3dzZXJTZXJ2aWNlIGZyb20gXCIuL0Jyb3dzZXJTZXJ2aWNlXCI7XG5pbXBvcnQgQ2xhc3NNdXRhdGlvbkhhbmRsZXIgZnJvbSBcIi4vQ2xhc3NNdXRhdGlvbkhhbmRsZXJcIjtcbmltcG9ydCBFdmVudExpc3RlbmVyIGZyb20gXCIuL0V2ZW50TGlzdGVuZXJcIjtcbmltcG9ydCBQYWdlTXV0YXRpb25IYW5kbGVyIGZyb20gXCIuL1BhZ2VNdXRhdGlvbkhhbmRsZXJcIjtcbmltcG9ydCBSdWxlU2VydmljZSBmcm9tIFwiLi9SdWxlU2VydmljZVwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuL1Rva2VuXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnJvd3NlclNjcmlwdCB7XG5cbiAgICBwcml2YXRlIF9zZXJ2ZXJVUkw6IHN0cmluZztcblx0cHJpdmF0ZSBfc2Vzc2lvbklkOiBzdHJpbmc7XG5cdHByaXZhdGUgX3dlYlNpdGVJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXHRwcml2YXRlIF90b2tlbjogVG9rZW4gfCB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBfcnVsZVNlcnZpY2UgOiBSdWxlU2VydmljZTtcbiAgICBwcml2YXRlIF9ldmVudExpc3RlbmVyIDogRXZlbnRMaXN0ZW5lcjtcbiAgICBwcml2YXRlIF9haWZleFNlcnZpY2UgOiBBaWZleFNlcnZpY2U7XG4gICAgcHJpdmF0ZSBfYnJvd3NlclNlcnZpY2UgOiBCcm93c2VyU2VydmljZTtcbiAgICBwcml2YXRlIF9wYWdlTXV0YXRpb25IYW5kbGVyIDogUGFnZU11dGF0aW9uSGFuZGxlcjtcbiAgICBwcml2YXRlIF9leHBsb3JhdGlvbk51bWJlcjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgXG4gICAgY29uc3RydWN0b3Ioc2VydmVyVVJMOiBzdHJpbmcsIHNlc3Npb25JZDogc3RyaW5nLCB0b2tlbjogVG9rZW4gfCB1bmRlZmluZWQsIGFpZmV4U2VydmljZTogQWlmZXhTZXJ2aWNlLCBicm93c2VyU2VydmljZTogQnJvd3NlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fc2VydmVyVVJMID0gc2VydmVyVVJMO1xuICAgICAgICB0aGlzLl9zZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gICAgICAgIHRoaXMuX3Rva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMuX2FpZmV4U2VydmljZSA9IGFpZmV4U2VydmljZTtcbiAgICAgICAgdGhpcy5fYnJvd3NlclNlcnZpY2UgPSBicm93c2VyU2VydmljZTtcbiAgICAgICAgdGhpcy5fcnVsZVNlcnZpY2UgPSBuZXcgUnVsZVNlcnZpY2UoKTtcbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lciA9IG5ldyBFdmVudExpc3RlbmVyKHRoaXMuX3J1bGVTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lci5hZGRPYnNlcnZlcih0aGlzLnByb2Nlc3NOZXdBY3Rpb24uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgbmV3IENsYXNzTXV0YXRpb25IYW5kbGVyKCk7XG5cbiAgICAgICAgdGhpcy5fcGFnZU11dGF0aW9uSGFuZGxlciA9IG5ldyBQYWdlTXV0YXRpb25IYW5kbGVyKHRoaXMub25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fcGFnZU11dGF0aW9uSGFuZGxlci5pbml0KCk7XG4gICAgfVxuXG4gICAgc3RhcnQoKSA6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWlmZXhTZXJ2aWNlLmdldFNlc3Npb24odGhpcy5fc2VydmVyVVJMLCB0aGlzLl9zZXNzaW9uSWQsIHVuZGVmaW5lZClcbiAgICAgICAgICAgIC50aGVuKChzZXNzaW9uUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25SZXN1bHQgJiYgc2Vzc2lvblJlc3VsdCAhPT0gXCJVbmF1dGhvcml6ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93ZWJTaXRlSWQgPSBzZXNzaW9uUmVzdWx0LndlYlNpdGVJZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWlmZXhTZXJ2aWNlLmdldFdlYlNpdGUodGhpcy5fc2VydmVyVVJMLCB0aGlzLl93ZWJTaXRlSWQsIHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCh3ZWJTaXRlUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlYlNpdGVSZXN1bHQgJiYgd2ViU2l0ZVJlc3VsdCAhPT0gJ1VuYXV0aG9yaXplZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVsZXMgPSB3ZWJTaXRlUmVzdWx0Lm1hcHBpbmdMaXN0Lm1hcCgocnUgOiBhbnkpID0+IHRoaXMuX3J1bGVTZXJ2aWNlLmNyZWF0ZVJ1bGUocnUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcnVsZVNlcnZpY2UubG9hZFJ1bGVzKHJ1bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcnVsZVNlcnZpY2UubWFwUnVsZXNUb0VsZW1lbnRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgUnVsZXMgbG9hZGVkIDogJHtydWxlcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRFeHBsb3JhdGlvbk51bWJlciA9IHRoaXMuX2Jyb3dzZXJTZXJ2aWNlLmdldEV4cGxvcmF0aW9uTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFeHBsb3JhdGlvbk51bWJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cGxvcmF0aW9uTnVtYmVyID0gY3VycmVudEV4cGxvcmF0aW9uTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FpZmV4U2VydmljZS5jcmVhdGVFbXB0eUV4cGxvcmF0aW9uKFwiQlJPV1NFUl9TQ1JJUFRcIiwgdGhpcy5fc2VydmVyVVJMLCB0aGlzLl9zZXNzaW9uSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChleHBsb3JhdGlvbk51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwbG9yYXRpb25OdW1iZXIgPSBleHBsb3JhdGlvbk51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jyb3dzZXJTZXJ2aWNlLnNhdmVFeHBsb3JhdGlvbk51bWJlcih0aGlzLl9leHBsb3JhdGlvbk51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc05ld0FjdGlvbihuZXcgQWN0aW9uKFwic3RhcnRcIiwgdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIHByb2Nlc3NOZXdBY3Rpb24oYWN0aW9uOiBBY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2V4cGxvcmF0aW9uTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBleHBsb3JhdGlvbiBoYXMgbm90IGJlZW4gY29ycmVjdGx5IHN0YXJ0ZWRcIilcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9haWZleFNlcnZpY2Uuc2VuZEFjdGlvbih0aGlzLl9leHBsb3JhdGlvbk51bWJlciwgYWN0aW9uLCB0aGlzLl9zZXJ2ZXJVUkwsIHRoaXMuX3Nlc3Npb25JZCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbk11dGF0aW9uKCkgOnZvaWR7XG4gICAgICAgIHRoaXMuX3J1bGVTZXJ2aWNlLm1hcFJ1bGVzVG9FbGVtZW50cygpO1xuICAgIH1cblxufSIsImltcG9ydCBDb250ZXh0TWFwcGVyIGZyb20gXCIuL0NvbnRleHRNYXBwZXJcIjtcbmltcG9ydCBSdWxlIGZyb20gXCIuL1J1bGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ1NTQ29udGV4dE1hcHBlciBleHRlbmRzIENvbnRleHRNYXBwZXIge1xuXG4gICAgY29uc3RydWN0b3IoY29udGV4dCA6IHN0cmluZykge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICB9XG5cbiAgICBidWlsZEVsZW1lbnRUb1J1bGVNYXAoKSA6IE1hcDxIVE1MRWxlbWVudHxTVkdFbGVtZW50LCBSdWxlW10+IHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNzc1F1ZXJ5UmVzdWx0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLl9jb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChjc3NRdWVyeVJlc3VsdCAmJiBjc3NRdWVyeVJlc3VsdCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRFbGVtZW50VG9SdWxlTWFwRm9yU2VsZWN0b3JzKGNzc1F1ZXJ5UmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG59IiwiaW1wb3J0IEFjdGlvbiBmcm9tICcuL0FjdGlvbic7XG5pbXBvcnQgUnVsZSBmcm9tICcuL1J1bGUnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gXCIuLi9mcmFtZXdvcmsvTG9nZ2VyXCI7XG5pbXBvcnQgZ2V0Q3NzU2VsZWN0b3IgZnJvbSAnY3NzLXNlbGVjdG9yLWdlbmVyYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENTU1NlbGVjdG9yUnVsZSBleHRlbmRzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeDogc3RyaW5nLCBzdWZmaXg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IHN0cmluZywgY3NzOiBzdHJpbmcgfCB1bmRlZmluZWQsIHhwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCwga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRVUkw6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dENTUzogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0WFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgICAgICBzdXBlcihwcmVmaXgsIHN1ZmZpeCwgZXZlbnQsIGNzcywgeHBhdGgsIGNvZGUsIGtleSwgY29udGV4dFVSTCwgY29udGV4dENTUywgY29udGV4dFhQYXRoLCBkZXNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgbWFrZUFjdGlvbihldmVudCA6IEV2ZW50KTogQWN0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCkge1xuICAgICAgICAgICAgbGV0IHN1ZmZpeDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3VmZml4ID0gZ2V0Q3NzU2VsZWN0b3IoZXZlbnQudGFyZ2V0LCB7c2VsZWN0b3JzOiBbJ2lkJywgJ3RhZyddfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBleGNlcHRpb25gLG5ldyBFcnJvcignY3NzIGV4Y2VwdGlvbicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uKHRoaXMucHJlZml4LCBzdWZmaXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWN0aW9uVG9FbGVtZW50cyhhY3Rpb246IEFjdGlvbik6IChIVE1MRWxlbWVudHxTVkdFbGVtZW50KVtdIHtcbiAgICAgICAgaWYgKGFjdGlvbi5wcmVmaXggIT09IHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uLnN1ZmZpeCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgOiAoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudClbXSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudHMgPSB0aGlzLmZpbmRNYXRjaGVkRWxlbWVudHMoKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYWN0aW9uLnN1ZmZpeCkuZm9yRWFjaCggKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50RWxlbWVudHMuc29tZSgocGFyZW50KSA9PiBwYXJlbnQuY29udGFpbnMoZWxlbWVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBBY3Rpb24gZnJvbSAnLi9BY3Rpb24nO1xuaW1wb3J0IFJ1bGUgZnJvbSAnLi9SdWxlJztcbmltcG9ydCBnZXRDc3NTZWxlY3RvciBmcm9tICdjc3Mtc2VsZWN0b3ItZ2VuZXJhdG9yJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tIFwiLi4vZnJhbWV3b3JrL0xvZ2dlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDU1NTZWxlY3RvcldpdGhWYWx1ZVJ1bGUgZXh0ZW5kcyBSdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXg6IHN0cmluZywgc3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQsIGV2ZW50OiBzdHJpbmcsIGNzczogc3RyaW5nIHwgdW5kZWZpbmVkLCB4cGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgICAgICBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGtleTogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0VVJMOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRDU1M6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dFhQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIocHJlZml4LCBzdWZmaXgsIGV2ZW50LCBjc3MsIHhwYXRoLCBjb2RlLCBrZXksIGNvbnRleHRVUkwsIGNvbnRleHRDU1MsIGNvbnRleHRYUGF0aCwgZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIG1ha2VBY3Rpb24oZXZlbnQgOiBFdmVudCk6IEFjdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7IFxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBsZXQgc3VmZml4O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IGdldENzc1NlbGVjdG9yKGV2ZW50LnRhcmdldCwge3NlbGVjdG9yczogWydpZCcsICd0YWcnXX0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBleGNlcHRpb25gLG5ldyBFcnJvcignY3NzIGV4Y2VwdGlvbicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ICs9IGA/JHt2YWx1ZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGlvbih0aGlzLnByZWZpeCwgc3VmZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFjdGlvblRvRWxlbWVudHMoYWN0aW9uOiBBY3Rpb24pOiAoSFRNTEVsZW1lbnR8U1ZHRWxlbWVudClbXSB7XG4gICAgICAgIGlmIChhY3Rpb24ucHJlZml4ICE9PSB0aGlzLnByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbi5zdWZmaXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzIDogKEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpW10gPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnRzID0gdGhpcy5maW5kTWF0Y2hlZEVsZW1lbnRzKCk7XG4gICAgICAgICAgICBsZXQgc2hhcnBDaGFySW5kZXggPSBhY3Rpb24uc3VmZml4LmluZGV4T2YoJz8nKTtcbiAgICAgICAgICAgIGxldCBjc3NTZWxlY3RvciA9IHNoYXJwQ2hhckluZGV4ID09PSAtMSA/IGFjdGlvbi5zdWZmaXggOiBhY3Rpb24uc3VmZml4LnN1YnN0cmluZygwLCBzaGFycENoYXJJbmRleCk7XG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGNzc1NlbGVjdG9yKS5mb3JFYWNoKCAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRFbGVtZW50cy5zb21lKChwYXJlbnQpID0+IHBhcmVudC5jb250YWlucyhlbGVtZW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBlbGVtZW50IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VmFsdWUoZWxlbWVudDogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC52YWx1ZTtcbiAgICAgICAgfSBcblxuICAgICAgICBjb25zdCB2YWx1ZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICBpZiAodmFsdWVBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZUF0dHJpYnV0ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCIuLi9mcmFtZXdvcmsvTG9nZ2VyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsYXNzTXV0YXRpb25IYW5kbGVyIHtcblxuICAgIHByaXZhdGUgX29ic2VydmVyOiBNdXRhdGlvbk9ic2VydmVyO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKHJlY29yZHMpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbGFzcyBtdXRhdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQudGFyZ2V0Lm1hdGNoZXMoJzpob3ZlcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q2xhc3MgPSByZWNvcmQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNyZWF0ZUV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQub2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2xhc3MgJiYgY3VycmVudENsYXNzLmluY2x1ZGVzKHJlY29yZC5vbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFdmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGVFdmVudCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnY3JlYXRlIGV2ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSBuZXcgRXZlbnQoJ2Nzcy1jbGFzcy1hZGRlZCcse2J1YmJsZXM6dHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLnRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUsIHN1YnRyZWU6IHRydWUsIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlfTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCBjb25maWcpO1xuICAgICAgICBsb2dnZXIuaW5mbygnY2xhc3MgbXV0YXRpb24gaGFuZGxlciBpbml0aWFsaXplZCcpO1xuICAgIH1cblxufSIsImltcG9ydCBDb250ZXh0TWFwcGVyIGZyb20gXCIuL0NvbnRleHRNYXBwZXJcIjtcbmltcG9ydCBSdWxlIGZyb20gXCIuL1J1bGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGV4dExlc3NNYXBwZXIgZXh0ZW5kcyBDb250ZXh0TWFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIodW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBidWlsZEVsZW1lbnRUb1J1bGVNYXAoKSA6IE1hcDxIVE1MRWxlbWVudHxTVkdFbGVtZW50LCBSdWxlW10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRFbGVtZW50VG9SdWxlTWFwRm9yU2VsZWN0b3JzKCk7XG4gICAgfVxufSIsImltcG9ydCBSdWxlIGZyb20gXCIuL1J1bGVcIjtcbmltcG9ydCB7bG9nZ2VyfSBmcm9tIFwiLi4vZnJhbWV3b3JrL0xvZ2dlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBDb250ZXh0TWFwcGVyIHtcbiAgICBwcm90ZWN0ZWQgX2NvbnRleHQgOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgcHJvdGVjdGVkIF9jc3NTZWxlY3RvcjJSdWxlcyA6IE1hcDxzdHJpbmcsIFJ1bGVbXT47XG4gICAgcHJvdGVjdGVkIF94cGF0aFNlbGVjdG9yMlJ1bGVzIDogTWFwPHN0cmluZywgUnVsZVtdPjtcblxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQgOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX2Nzc1NlbGVjdG9yMlJ1bGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl94cGF0aFNlbGVjdG9yMlJ1bGVzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIGFkZChydWxlIDogUnVsZSk6IHZvaWQge1xuICAgICAgICBpZiAocnVsZS5jb250ZXh0Q1NTICE9PSB0aGlzLl9jb250ZXh0ICYmIHJ1bGUuY29udGV4dFVSTCAhPT0gdGhpcy5fY29udGV4dCAmJiBydWxlLmNvbnRleHRYUGF0aCAhPT0gdGhpcy5fY29udGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgYWRkIHJ1bGUgd2l0aCBhIGRpZmZlcmVudCBjb250ZXh0ICcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydWxlLmNzcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jc3NTZWxlY3RvcjJSdWxlcy5oYXMocnVsZS5jc3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3NzU2VsZWN0b3IyUnVsZXMuc2V0KHJ1bGUuY3NzLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcnVsZXM0U2VsZWN0b3IgPSB0aGlzLl9jc3NTZWxlY3RvcjJSdWxlcy5nZXQocnVsZS5jc3MpO1xuICAgICAgICAgICAgaWYgKHJ1bGVzNFNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcnVsZXM0U2VsZWN0b3IucHVzaChydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocnVsZS54cGF0aCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl94cGF0aFNlbGVjdG9yMlJ1bGVzLmhhcyhydWxlLnhwYXRoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3hwYXRoU2VsZWN0b3IyUnVsZXMuc2V0KHJ1bGUueHBhdGgsIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBydWxlczRTZWxlY3RvciA9IHRoaXMuX3hwYXRoU2VsZWN0b3IyUnVsZXMuZ2V0KHJ1bGUueHBhdGgpO1xuICAgICAgICAgICAgaWYgKHJ1bGVzNFNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcnVsZXM0U2VsZWN0b3IucHVzaChydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFic3RyYWN0IGJ1aWxkRWxlbWVudFRvUnVsZU1hcCgpIDogTWFwPEhUTUxFbGVtZW50fFNWR0VsZW1lbnQsIFJ1bGVbXT47XG5cbiAgICBwcm90ZWN0ZWQgYnVpbGRFbGVtZW50VG9SdWxlTWFwRm9yU2VsZWN0b3JzKGNvbnRleHQ/IDogSFRNTEVsZW1lbnR8U1ZHRWxlbWVudCkgOiBNYXA8SFRNTEVsZW1lbnR8U1ZHRWxlbWVudCwgUnVsZVtdPiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRUb1J1bGVzIDogTWFwPEhUTUxFbGVtZW50fFNWR0VsZW1lbnQsIFJ1bGVbXT4gPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW3NlbGVjdG9yLCBydWxlc10gb2YgdGhpcy5fY3NzU2VsZWN0b3IyUnVsZXMpIHtcbiAgICAgICAgICAgIGxldCBxdWVyeVNlbGVjdG9yIDogTm9kZUxpc3RPZjxIVE1MRWxlbWVudHxTVkdFbGVtZW50PjtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcXVlcnlTZWxlY3RvciA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXJ5U2VsZWN0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXJ5U2VsZWN0b3IuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXM0RWxlbWVudCA9IGVsZW1lbnRUb1J1bGVzLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGVzNEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM0RWxlbWVudCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50VG9SdWxlcy5zZXQoZWxlbWVudCwgcnVsZXM0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bGVzNEVsZW1lbnQucHVzaCguLi5ydWxlcyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3NlbGVjdG9yLCBydWxlc10gb2YgdGhpcy5feHBhdGhTZWxlY3RvcjJSdWxlcykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5WHBhdGg7XG4gICAgICAgICAgICBsZXQgcXVlcnlYcGF0aFJlc3VsdDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVhwYXRoID0gZG9jdW1lbnQuZXZhbHVhdGUoc2VsZWN0b3IsIGNvbnRleHQsIG51bGwsIFhQYXRoUmVzdWx0LkFOWV9UWVBFLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVhwYXRoID0gZG9jdW1lbnQuZXZhbHVhdGUoc2VsZWN0b3IsIGRvY3VtZW50LCBudWxsLCBYUGF0aFJlc3VsdC5BTllfVFlQRSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignWFBhdGggRXJyb3I6JyxuZXcgRXJyb3IoXCJlXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHF1ZXJ5WHBhdGgpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVhwYXRoUmVzdWx0ID0gcXVlcnlYcGF0aC5pdGVyYXRlTmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHF1ZXJ5WHBhdGhSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXJ5WHBhdGhSZXN1bHQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBxdWVyeVhwYXRoUmVzdWx0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vQ29udGV4dCA9ICEgY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRJbkNvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQuY29udGFpbnMocXVlcnlYcGF0aFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9Db250ZXh0IHx8IHJlc3VsdEluQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBydWxlczRFbGVtZW50ID0gZWxlbWVudFRvUnVsZXMuZ2V0KHF1ZXJ5WHBhdGhSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnVsZXM0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlczRFbGVtZW50ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRUb1J1bGVzLnNldChxdWVyeVhwYXRoUmVzdWx0LCBydWxlczRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXM0RWxlbWVudC5wdXNoKC4uLnJ1bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBxdWVyeVhwYXRoUmVzdWx0ID0gcXVlcnlYcGF0aC5pdGVyYXRlTmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudFRvUnVsZXM7XG4gICAgfVxufSIsImltcG9ydCBSdWxlU2VydmljZSBmcm9tIFwiLi9SdWxlU2VydmljZVwiO1xuaW1wb3J0IEFjdGlvbiBmcm9tIFwiLi9BY3Rpb25cIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCIuLi9mcmFtZXdvcmsvTG9nZ2VyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50TGlzdGVuZXIge1xuICAgIHByaXZhdGUgX3J1bGVTZXJ2aWNlOiBSdWxlU2VydmljZTtcbiAgICBwcml2YXRlIF9oYW5kbGVkRXZlbnRzOiBzdHJpbmdbXTtcbiAgICBwcml2YXRlIF9vYnNlcnZlcnM6ICgoYWN0aW9uOiBBY3Rpb24pID0+IHZvaWQpW107XG5cbiAgICBjb25zdHJ1Y3RvcihydWxlU2VydmljZTogUnVsZVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fcnVsZVNlcnZpY2UgPSBydWxlU2VydmljZVxuICAgICAgICB0aGlzLl9oYW5kbGVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuX29ic2VydmVycyA9IFtdO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVkRXZlbnRzID0gdGhpcy5fcnVsZVNlcnZpY2UuZ2V0RXZlbnRzVG9IYW5kbGUoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBFdmVudExpc3RlbmVyOiB0aGVyZSBhcmUgJHt0aGlzLl9oYW5kbGVkRXZlbnRzLmxlbmd0aH0gZXZlbnRzIHRvIGhhbmRsZWApO1xuICAgICAgICB0aGlzLl9oYW5kbGVkRXZlbnRzLmZvckVhY2goKGhhbmRsZWRFdmVudCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihoYW5kbGVkRXZlbnQsIHRoaXMuZXhwbG9yYXRvcnlMaXN0ZW5lci5iaW5kKHRoaXMpLCB0cnVlKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRPYnNlcnZlcihvYnNlcnZlckZ1bmN0aW9uIDogKGFjdGlvbjogQWN0aW9uKSA9PiB2b2lkKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVycy5wdXNoKG9ic2VydmVyRnVuY3Rpb24pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZXhwbG9yYXRvcnlMaXN0ZW5lcihldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgbGV0IHVuc2FmZUV2ZW50OiBhbnkgPSBldmVudDtcbiAgICAgICAgaWYgKHVuc2FmZUV2ZW50LmlzVHJ1c3RlZCkge1xuICAgICAgICAgICAgaWYgKCF1bnNhZmVFdmVudC5leHBsb3JlZCkge1xuICAgICAgICAgICAgICAgIHVuc2FmZUV2ZW50LmV4cGxvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYEV2ZW50TGlzdGVuZXI6IGV2ZW50ICR7dW5zYWZlRXZlbnQudHlwZX0gaXMgYmVpbmcgaGFuZGxlZGApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSB0aGlzLl9ydWxlU2VydmljZS5nZXRNYXRjaGluZ1J1bGUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChydWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHJ1bGUubWFrZUFjdGlvbihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBhY3Rpb24gOiAke2FjdGlvbi50b1N0cmluZygpfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmZvckVhY2goKG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdubyBhY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiaW1wb3J0IEFjdGlvbiBmcm9tICcuL0FjdGlvbic7XG5pbXBvcnQgU2ltcGxlUnVsZSBmcm9tICcuL1NpbXBsZVJ1bGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbmRleFJ1bGUgZXh0ZW5kcyBTaW1wbGVSdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXg6IHN0cmluZywgc3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQsIGV2ZW50OiBzdHJpbmcsIGNzczogc3RyaW5nIHwgdW5kZWZpbmVkLCB4cGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgICAgICBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGtleTogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0VVJMOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRDU1M6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dFhQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIocHJlZml4LCBzdWZmaXgsIGV2ZW50LCBjc3MsIHhwYXRoLCBjb2RlLCBrZXksIGNvbnRleHRVUkwsIGNvbnRleHRDU1MsIGNvbnRleHRYUGF0aCwgZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIG1ha2VBY3Rpb24oZXZlbnQgOiBFdmVudCk6IEFjdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nRWxlbWVudHMgPSB0aGlzLmZpbmRNYXRjaGVkRWxlbWVudHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGluZ0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0RWxlbWVudHMgPSBldmVudC5jb21wb3NlZFBhdGgoKS5maWx0ZXIoKHRhcmdldCk6dGFyZ2V0IGlzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCA9PiB0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50cy5sZW5ndGggPiAwICYmIG1hdGNoaW5nRWxlbWVudHNbaV0uY29udGFpbnModGFyZ2V0RWxlbWVudHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24odGhpcy5wcmVmaXgsIGkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3Rpb25Ub0VsZW1lbnRzKGFjdGlvbjogQWN0aW9uKTogKEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudClbXSB7XG4gICAgICAgIGlmIChhY3Rpb24ucHJlZml4ICE9PSB0aGlzLnByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmKGFjdGlvbi5zdWZmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmFjdGlvblRvRWxlbWVudHMoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IHBhcnNlSW50KGFjdGlvbi5zdWZmaXgsIDEwKTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmZpbmRNYXRjaGVkRWxlbWVudHMoKTtcbiAgICAgICAgLy8gSGFwcGVucyBpZiBhIHByZXZpb3VzIHJ1bGVzIHdhcyBub3QgdXNpbmcgdGhlIGluZGV4IHN1ZmZpeFxuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCB8fMKgbnVsbCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlbGVtZW50c1tpbmRleF1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgQWN0aW9uIGZyb20gJy4vQWN0aW9uJztcbmltcG9ydCBTaW1wbGVSdWxlIGZyb20gJy4vU2ltcGxlUnVsZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElubmVyVGV4dFJ1bGUgZXh0ZW5kcyBTaW1wbGVSdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXg6IHN0cmluZywgc3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQsIGV2ZW50OiBzdHJpbmcsIGNzczogc3RyaW5nIHwgdW5kZWZpbmVkLCB4cGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgICAgICBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGtleTogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0VVJMOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRDU1M6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dFhQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIocHJlZml4LCBzdWZmaXgsIGV2ZW50LCBjc3MsIHhwYXRoLCBjb2RlLCBrZXksIGNvbnRleHRVUkwsIGNvbnRleHRDU1MsIGNvbnRleHRYUGF0aCwgZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIG1ha2VBY3Rpb24oZXZlbnQ6IGFueSk6IEFjdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmZpbmRBY3Rpb25NYXBwZWRUYXJnZXQoZXZlbnQpO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aW9uKHRoaXMucHJlZml4LCBlbGVtZW50LmlubmVyVGV4dC50cmltKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFjdGlvbih0aGlzLnByZWZpeCwgXCJzdmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhY3Rpb25Ub0VsZW1lbnRzKGFjdGlvbjogQWN0aW9uKTogKEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpW10ge1xuICAgICAgICBpZiAoYWN0aW9uLnByZWZpeCAhPT0gdGhpcy5wcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uLnN1ZmZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuYWN0aW9uVG9FbGVtZW50cyhhY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IGFjdGlvbi5zdWZmaXg7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZmluZE1hdGNoZWRFbGVtZW50cygpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcihkb21FbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb21FbGVtZW50LmlubmVyVGV4dC50cmltKCkgPT09IHN1ZmZpeC50cmltKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb21FbGVtZW50IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdmdcIiA9PT0gc3VmZml4LnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiY29uc3QgTVVUQVRJT05fUkVGUkVTSF9DSEVDSyA9IDEwMDA7XG5jb25zdCBET01fSURTID0gW1wiQUlGRVhfcHJvYmFiaWxpdHlQb3B1cFwiLCBcIkFJRkVYX3RhYlwiXTtcbmltcG9ydCB7bG9nZ2VyfSBmcm9tIFwiLi4vZnJhbWV3b3JrL0xvZ2dlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYWdlTXV0YXRpb25IYW5kbGVyIHtcblxuICAgIGxhc3RNdXRhdGlvbjogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIG9ic2VydmVyOiBNdXRhdGlvbk9ic2VydmVyIHwgdW5kZWZpbmVkO1xuICAgIG11dGF0aW9uSGFzT2NjdXJlZDogYm9vbGVhbjtcbiAgICBiZVJlZnJlc2hpbmcgOiBib29sZWFuO1xuICAgIHdpbGxSZWZyZXNoIDogYm9vbGVhbjtcblxuICAgIG9uUGFnZU11dGF0aW9uOiAoKSA9PiB2b2lkO1xuXG4gICAgY29uc3RydWN0b3Iob25QYWdlTXV0YXRpb246ICgpID0+IHZvaWQpIHtcbiAgICAgICAgdGhpcy5vblBhZ2VNdXRhdGlvbiA9IG9uUGFnZU11dGF0aW9uXG4gICAgICAgIHRoaXMuYmVSZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMubXV0YXRpb25IYXNPY2N1cmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2lsbFJlZnJlc2ggPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmxhc3RNdXRhdGlvbiA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigocmVjb3JkcykgPT4ge1xuICAgICAgICAgICAgbGV0IHdhdGNoZWRQYWdlSGFzTXV0YXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1dhdGNoZWROb2RlTGlzdChyZWNvcmQuYWRkZWROb2RlcykgJiYgISB0aGlzLmlzSW5jbHVkZWRJbkFJRkVYRWxlbWVudChyZWNvcmQuYWRkZWROb2RlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoZWRQYWdlSGFzTXV0YXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2F0Y2hlZFBhZ2VIYXNNdXRhdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEgdGhpcy5iZVJlZnJlc2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iZVJlZnJlc2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUGFnZU11dGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iZVJlZnJlc2hpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgTVVUQVRJT05fUkVGUkVTSF9DSEVDSyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLndpbGxSZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndpbGxSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFRJTUVfQ0hFQ0tfTVVMVElQTElFUiA9IDI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmVSZWZyZXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUGFnZU11dGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmVSZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMud2lsbFJlZnJlc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBNVVRBVElPTl9SRUZSRVNIX0NIRUNLKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFRJTUVfQ0hFQ0tfTVVMVElQTElFUiAqIE1VVEFUSU9OX1JFRlJFU0hfQ0hFQ0spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7IGF0dHJpYnV0ZXM6IGZhbHNlLCBjaGlsZExpc3Q6IHRydWUsIGNoYXJhY3RlckRhdGE6IGZhbHNlLCBzdWJ0cmVlOiB0cnVlfTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmJvZHksIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc1dhdGNoZWROb2RlTGlzdChub2RlTGlzdCA6IE5vZGVMaXN0KSA6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgaXNXYXRjaGVkIDogYm9vbGVhbiA9IGZhbHNlO1xuICAgICAgICBub2RlTGlzdC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnRhZ05hbWUgIT09IFwiU0NSSVBUXCIgJiYgbm9kZS50YWdOYW1lICE9PSBcIklGUkFNRVwiICYmIG5vZGUudGFnTmFtZSAhPT0gXCJJTUdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzV2F0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnN0eWxlLmRpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzV2F0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3R5bGUuZGlzcGxheSAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzV2F0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBpc1dhdGNoZWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0luY2x1ZGVkSW5BSUZFWEVsZW1lbnQobm9kZUxpc3QgOiBOb2RlTGlzdCkgOiBib29sZWFuIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiB2YXJpYWJsZS1uYW1lXG4gICAgICAgIGNvbnN0IEFJRkVYRWxlbWVudExpc3QgPSBET01fSURTLm1hcChpZCA9PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkpLmZpbHRlcigoZWxlbWVudCk6IGVsZW1lbnQgaXMgSFRNTEVsZW1lbnQgPT4gZWxlbWVudCAhPT0gbnVsbCk7XG4gICAgICAgIGxldCBpc0luY2x1ZGVkIDogYm9vbGVhbiA9IHRydWU7XG4gICAgICAgIG5vZGVMaXN0LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBSUZFWEVsZW1lbnRMaXN0LnNvbWUoKGFpZmV4Tm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWlmZXhOb2RlLmNvbnRhaW5zKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzSW5jbHVkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBpc0luY2x1ZGVkO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBxdWVyeVNlbGVjdG9yQWxsRGVlcCB9IGZyb20gJ3F1ZXJ5LXNlbGVjdG9yLXNoYWRvdy1kb20nO1xuaW1wb3J0IEFjdGlvbiBmcm9tIFwiLi9BY3Rpb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgUnVsZSB7XG5cbiAgICBldmVudDogc3RyaW5nO1xuICAgIGNzczogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHhwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgcHJlZml4OiBzdHJpbmc7XG4gICAgc3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGNvbnRleHRVUkw6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBjb250ZXh0Q1NTOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgY29udGV4dFhQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHByZWZpeDogc3RyaW5nLCBzdWZmaXg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IHN0cmluZywgY3NzOiBzdHJpbmcgfCB1bmRlZmluZWQsIHhwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCwga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRVUkw6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dENTUzogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0WFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246IHN0cmluZykge1xuXG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5jc3MgPSBjc3M7XG4gICAgICAgIHRoaXMueHBhdGggPSB4cGF0aDtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5jb250ZXh0VVJMID0gY29udGV4dFVSTDtcbiAgICAgICAgdGhpcy5jb250ZXh0Q1NTID0gY29udGV4dENTUztcbiAgICAgICAgdGhpcy5jb250ZXh0WFBhdGggPSBjb250ZXh0WFBhdGg7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICBtYXRjaChldmVudCA6IEV2ZW50KSA6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoZXZlbnQudHlwZSAhPT0gdGhpcy5ldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnQgPT09IFwia2V5dXBcIiB8fCB0aGlzLmV2ZW50ID09PSBcImtleWRvd25cIiB8fCB0aGlzLmV2ZW50ID09PSBcImtleXByZXNzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2RlICYmIGV2ZW50LmNvZGUgIT09IHRoaXMuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMua2V5ICYmIGV2ZW50LmtleSAhPT0gdGhpcy5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cblxuICAgIGFic3RyYWN0IG1ha2VBY3Rpb24oZXZlbnQgOiBFdmVudCk6IEFjdGlvbiB8IHVuZGVmaW5lZDtcblxuICAgIGFic3RyYWN0IGFjdGlvblRvRWxlbWVudHMoYWN0aW9uOiBBY3Rpb24pOiAoSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50KVtdIDtcblxuICAgIGZpbmRBY3Rpb25NYXBwZWRUYXJnZXQoZXZlbnQ6IEV2ZW50KTogSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCB0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShcImFpZmV4X3N0eWxlXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNsb3Nlc3QgPSB0YXJnZXQuY2xvc2VzdChcIlthaWZleF9zdHlsZV1cIik7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3QgJiYgKGNsb3Nlc3QgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBjbG9zZXN0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmluZE1hdGNoZWRFbGVtZW50cygpIDogKEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpW117XG4gICAgICAgIGxldCBjb250ZXh0O1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHRYUGF0aCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkb2N1bWVudC5ldmFsdWF0ZSh0aGlzLmNvbnRleHRYUGF0aCwgZG9jdW1lbnQsIG51bGwsIFhQYXRoUmVzdWx0LkFOWV9UWVBFLCBudWxsKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gcmVzdWx0Lml0ZXJhdGVOZXh0KCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb250ZXh0Q1NTKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmNvbnRleHRDU1MpO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVsZW1lbnRzID0gW107XG4gICAgICAgIGlmICh0aGlzLnhwYXRoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZG9jdW1lbnQuZXZhbHVhdGUodGhpcy54cGF0aCwgY29udGV4dCwgbnVsbCwgWFBhdGhSZXN1bHQuQU5ZX1RZUEUsIG51bGwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRvY3VtZW50LmV2YWx1YXRlKHRoaXMueHBhdGgsIGRvY3VtZW50LCBudWxsLCBYUGF0aFJlc3VsdC5BTllfVFlQRSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBub2RlID0gcmVzdWx0Lml0ZXJhdGVOZXh0KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHJlc3VsdC5pdGVyYXRlTmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICBpZiAodGhpcy5jc3MpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSBxdWVyeVNlbGVjdG9yQWxsRGVlcCh0aGlzLmNzcywgY29udGV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gcXVlcnlTZWxlY3RvckFsbERlZXAodGhpcy5jc3MpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcigoZWxlbWVudCA6IE5vZGUpOiBlbGVtZW50IGlzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCA9PiBlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgZWxlbWVudCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xuICAgIH1cblxufSIsImltcG9ydCBDb250ZXh0TWFwcGVyIGZyb20gXCIuL0NvbnRleHRNYXBwZXJcIjtcbmltcG9ydCBSdWxlIGZyb20gXCIuL1J1bGVcIjtcbmltcG9ydCBVUkxDb250ZXh0TWFwcGVyIGZyb20gXCIuL1VSTENvbnRleHRNYXBwZXJcIjtcbmltcG9ydCBYUGF0aENvbnRleHRNYXBwZXIgZnJvbSBcIi4vWFBhdGhDb250ZXh0TWFwcGVyXCI7XG5pbXBvcnQgQ29udGV4dExlc3NNYXBwZXIgZnJvbSBcIi4vQ29udGV4dExlc3NNYXBwZXJcIjtcbmltcG9ydCBDU1NDb250ZXh0TWFwcGVyIGZyb20gXCIuL0NTU0NvbnRleHRNYXBwZXJcIjtcbmltcG9ydCB7bG9nZ2VyfSBmcm9tIFwiLi4vZnJhbWV3b3JrL0xvZ2dlclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlTWFwcGVyIHtcbiAgICBwcml2YXRlIF9jc3NDb250ZXh0MkNvbnRleHRNYXBwZXIgOiBNYXA8c3RyaW5nLCBDb250ZXh0TWFwcGVyPjtcbiAgICBwcml2YXRlIF94cGF0aENvbnRleHQyQ29udGV4dE1hcHBlciA6IE1hcDxzdHJpbmcsIENvbnRleHRNYXBwZXI+O1xuICAgIHByaXZhdGUgX3VybENvbnRleHQyQ29udGV4dE1hcHBlciA6IE1hcDxzdHJpbmcsIENvbnRleHRNYXBwZXI+O1xuICAgIHByaXZhdGUgX2NvbnRleHRMZXNzTWFwcGVyIDogQ29udGV4dExlc3NNYXBwZXI7XG4gICAgcHJpdmF0ZSBfcHJlZml4MlJ1bGVzIDogTWFwPHN0cmluZywgUnVsZVtdPjtcbiAgICBwcml2YXRlIF9ldmVudEluUnVsZXMgOiBzdHJpbmdbXTtcbiAgICBwdWJsaWMgcnVsZXM6IFJ1bGVbXTtcblxuICAgIGNvbnN0cnVjdG9yKHJ1bGVzIDogUnVsZVtdKSB7XG4gICAgICAgIHRoaXMuX2Nzc0NvbnRleHQyQ29udGV4dE1hcHBlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5feHBhdGhDb250ZXh0MkNvbnRleHRNYXBwZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3VybENvbnRleHQyQ29udGV4dE1hcHBlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY29udGV4dExlc3NNYXBwZXIgPSBuZXcgQ29udGV4dExlc3NNYXBwZXIoKTtcbiAgICAgICAgdGhpcy5fcHJlZml4MlJ1bGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ldmVudEluUnVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuXG4gICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICBsZXQgcnVsZXM0UHJlZml4ID0gdGhpcy5fcHJlZml4MlJ1bGVzLmdldChydWxlLnByZWZpeCk7XG4gICAgICAgICAgICBpZiAoISBydWxlczRQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBydWxlczRQcmVmaXggPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVmaXgyUnVsZXMuc2V0KHJ1bGUucHJlZml4LHJ1bGVzNFByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydWxlczRQcmVmaXgucHVzaChydWxlKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ldmVudEluUnVsZXMuaW5jbHVkZXMocnVsZS5ldmVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEluUnVsZXMucHVzaChydWxlLmV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJ1bGUuY29udGV4dENTUykge1xuICAgICAgICAgICAgICAgIGxldCBjb250ZXh0TWFwcGVyNENzc0NvbnRleHQgPSB0aGlzLl9jc3NDb250ZXh0MkNvbnRleHRNYXBwZXIuZ2V0KHJ1bGUuY29udGV4dENTUyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0TWFwcGVyNENzc0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dE1hcHBlcjRDc3NDb250ZXh0ID0gbmV3IENTU0NvbnRleHRNYXBwZXIocnVsZS5jb250ZXh0Q1NTKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jc3NDb250ZXh0MkNvbnRleHRNYXBwZXIuc2V0KHJ1bGUuY29udGV4dENTUywgY29udGV4dE1hcHBlcjRDc3NDb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGV4dE1hcHBlcjRDc3NDb250ZXh0LmFkZChydWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocnVsZS5jb250ZXh0WFBhdGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29udGV4dE1hcHBlcjRYcGF0aENvbnRleHQgPSB0aGlzLl94cGF0aENvbnRleHQyQ29udGV4dE1hcHBlci5nZXQocnVsZS5jb250ZXh0WFBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICghY29udGV4dE1hcHBlcjRYcGF0aENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dE1hcHBlcjRYcGF0aENvbnRleHQgPSBuZXcgWFBhdGhDb250ZXh0TWFwcGVyKHJ1bGUuY29udGV4dFhQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feHBhdGhDb250ZXh0MkNvbnRleHRNYXBwZXIuc2V0KHJ1bGUuY29udGV4dFhQYXRoLCBjb250ZXh0TWFwcGVyNFhwYXRoQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRleHRNYXBwZXI0WHBhdGhDb250ZXh0LmFkZChydWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocnVsZS5jb250ZXh0VVJMKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRleE1hcHBlcjRVUkxDb250ZXh0ID0gdGhpcy5fdXJsQ29udGV4dDJDb250ZXh0TWFwcGVyLmdldChydWxlLmNvbnRleHRVUkwpO1xuICAgICAgICAgICAgICAgIGlmICghY29udGV4TWFwcGVyNFVSTENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4TWFwcGVyNFVSTENvbnRleHQgPSBuZXcgVVJMQ29udGV4dE1hcHBlcihydWxlLmNvbnRleHRVUkwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cmxDb250ZXh0MkNvbnRleHRNYXBwZXIuc2V0KHJ1bGUuY29udGV4dFVSTCwgY29udGV4TWFwcGVyNFVSTENvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXhNYXBwZXI0VVJMQ29udGV4dC5hZGQocnVsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRMZXNzTWFwcGVyLmFkZChydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBnZXRJc0xvYWRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWZpeDJSdWxlcy5zaXplID4gMDtcbiAgICB9XG5cbiAgICBnZXRSdWxlTGlzdEJ5UHJlZml4KHByZWZpeCA6IHN0cmluZykgOiBSdWxlW10ge1xuICAgICAgICBsZXQgcnVsZXM0cHJlZmlzID0gdGhpcy5fcHJlZml4MlJ1bGVzLmdldChwcmVmaXgpO1xuICAgICAgICBpZiAocnVsZXM0cHJlZmlzKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVsZXM0cHJlZmlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGV2ZW50SW5SdWxlcygpOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudEluUnVsZXM7XG4gICAgfVxuXG4gICAgYnVpbGRFbGVtZW50VG9SdWxlTWFwKCk6IE1hcDxIVE1MRWxlbWVudHxTVkdFbGVtZW50LCBSdWxlW10+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0IDogTWFwPEhUTUxFbGVtZW50fFNWR0VsZW1lbnQsIFJ1bGVbXT4gPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgbWFwcGVyIG9mIHRoaXMuX3VybENvbnRleHQyQ29udGV4dE1hcHBlci52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZWxlbWVudCwgcnVsZXNdIG9mIG1hcHBlci5idWlsZEVsZW1lbnRUb1J1bGVNYXAoKSkge1xuICAgICAgICAgICAgICAgIGxldCBydWxlczRlbGVtZW50ID0gcmVzdWx0LmdldChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGVzNGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZXM0ZWxlbWVudCA9IFtdXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoZWxlbWVudCxydWxlczRlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVsZXM0ZWxlbWVudC5wdXNoKC4uLnJ1bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG1hcHBlciBvZiB0aGlzLl9jc3NDb250ZXh0MkNvbnRleHRNYXBwZXIudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2VsZW1lbnQsIHJ1bGVzXSBvZiBtYXBwZXIuYnVpbGRFbGVtZW50VG9SdWxlTWFwKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXM0ZWxlbWVudCA9IHJlc3VsdC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFydWxlczRlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzNGVsZW1lbnQgPSBbXVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGVsZW1lbnQscnVsZXM0ZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bGVzNGVsZW1lbnQucHVzaCguLi5ydWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBtYXBwZXIgb2YgdGhpcy5feHBhdGhDb250ZXh0MkNvbnRleHRNYXBwZXIudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2VsZW1lbnQsIHJ1bGVzXSBvZiBtYXBwZXIuYnVpbGRFbGVtZW50VG9SdWxlTWFwKCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZXM0ZWxlbWVudCA9IHJlc3VsdC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFydWxlczRlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzNGVsZW1lbnQgPSBbXVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGVsZW1lbnQscnVsZXM0ZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bGVzNGVsZW1lbnQucHVzaCguLi5ydWxlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbZWxlbWVudCwgcnVsZXNdIG9mIHRoaXMuX2NvbnRleHRMZXNzTWFwcGVyLmJ1aWxkRWxlbWVudFRvUnVsZU1hcCgpKSB7XG4gICAgICAgICAgICBsZXQgcnVsZXM0ZWxlbWVudCA9IHJlc3VsdC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoIXJ1bGVzNGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBydWxlczRlbGVtZW50ID0gW11cbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGVsZW1lbnQscnVsZXM0ZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydWxlczRlbGVtZW50LnB1c2goLi4ucnVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG59IiwiaW1wb3J0IFJ1bGUgZnJvbSBcIi4vUnVsZVwiO1xuaW1wb3J0IEFjdGlvbiBmcm9tIFwiLi9BY3Rpb25cIjtcbmltcG9ydCBSdWxlTWFwcGVyIGZyb20gXCIuL1J1bGVNYXBwZXJcIjtcbmltcG9ydCBJbmRleFJ1bGUgZnJvbSBcIi4vSW5kZXhSdWxlXCI7XG5pbXBvcnQgSW5uZXJUZXh0UnVsZSBmcm9tIFwiLi9Jbm5lclRleHRSdWxlXCI7XG5pbXBvcnQgVmFsdWVSdWxlIGZyb20gXCIuL1ZhbHVlUnVsZVwiO1xuaW1wb3J0IFNpbXBsZVJ1bGUgZnJvbSBcIi4vU2ltcGxlUnVsZVwiO1xuaW1wb3J0IENTU1NlbGVjdG9yUnVsZSBmcm9tIFwiLi9DU1NTZWxlY3RvclJ1bGVcIjtcbmltcG9ydCBBdHRyaWJ1dGVWYWx1ZVJ1bGUgZnJvbSBcIi4vQXR0cmlidXRlVmFsdWVSdWxlXCI7XG5pbXBvcnQgQ1NTU2VsZWN0b3JXaXRoVmFsdWVSdWxlIGZyb20gXCIuL0NTU1NlbGVjdG9yV2l0aFZhbHVlUnVsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSdWxlU2VydmljZSB7XG4gICAgZWxlbWVudFJ1bGVzOiBNYXA8SFRNTEVsZW1lbnR8U1ZHRWxlbWVudCwgUnVsZVtdPjtcbiAgICBwcml2YXRlIF9ydWxlTWFwcGVyIDogUnVsZU1hcHBlcjtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRSdWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcnVsZU1hcHBlciA9IG5ldyBSdWxlTWFwcGVyKFtdKTtcbiAgICB9XG5cbiAgICBnZXQgZWxlbWVudExpc3RNYXRjaGVkQnlSdWxlKCk6IChIVE1MRWxlbWVudHxTVkdFbGVtZW50KVtdIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbGVtZW50UnVsZXMua2V5cygpKVxuICAgIH1cblxuICAgIGdldEV2ZW50c1RvSGFuZGxlKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVNYXBwZXIuZXZlbnRJblJ1bGVzO1xuICAgIH1cblxuICAgIGxvYWRSdWxlcyhydWxlcyA6IFJ1bGVbXSk6dm9pZCB7XG4gICAgICAgIHRoaXMuX3J1bGVNYXBwZXIgPSBuZXcgUnVsZU1hcHBlcihydWxlcyk7XG4gICAgfVxuXG4gICAgbWFwUnVsZXNUb0VsZW1lbnRzKCk6dm9pZCB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJ1bGVzID0gdGhpcy5fcnVsZU1hcHBlci5idWlsZEVsZW1lbnRUb1J1bGVNYXAoKTtcbiAgICB9XG5cbiAgICBnZXRNYXRjaGluZ1J1bGUoZXZlbnQgOiBFdmVudCApOiBSdWxlIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gZXZlbnQuY29tcG9zZWRQYXRoKCkuZmlsdGVyKCh0YXJnZXQpOiB0YXJnZXQgaXMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50ID0+IHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHRhcmdldCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gdGhpcy5lbGVtZW50UnVsZXMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHJ1bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ1J1bGUgPSBydWxlcy5maW5kKChydWxlKSA9PiBydWxlLm1hdGNoKGV2ZW50KSlcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdSdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1J1bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UnVsZUxpc3RCeUFjdGlvbihhY3Rpb246IEFjdGlvbik6IFJ1bGVbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydWxlTWFwcGVyLmdldFJ1bGVMaXN0QnlQcmVmaXgoYWN0aW9uLnByZWZpeCk7XG4gICAgfVxuXG4gICAgZ2V0SFRNTEVsZW1lbnRzTWF0Y2hlZEJ5QWN0aW9uKGFjdGlvbjogQWN0aW9uKTogKEhUTUxFbGVtZW50fFNWR0VsZW1lbnQpW10ge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA6IFNldDxIVE1MRWxlbWVudHxTVkdFbGVtZW50PiA9IG5ldyBTZXQoKTtcbiAgICAgICAgYWN0aW9uLnJ1bGVMaXN0LmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50TGlzdEZvclJ1bGUgPSBydWxlLmFjdGlvblRvRWxlbWVudHMoYWN0aW9uKTtcbiAgICAgICAgICAgIGVsZW1lbnRMaXN0Rm9yUnVsZS5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudHMuYWRkKGVsZW1lbnQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbLi4uZWxlbWVudHMudmFsdWVzKCldO1xuICAgIH1cblxuICAgIGNyZWF0ZVJ1bGUoZGF0YSA6IHtcbiAgICAgICAgb3V0cHV0IDoge1xuICAgICAgICAgICAgcHJlZml4IDogc3RyaW5nLFxuICAgICAgICAgICAgc3VmZml4PyA6IHN0cmluZyxcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2ggOiB7XG4gICAgICAgICAgICBldmVudCA6IHN0cmluZyxcbiAgICAgICAgICAgIGNzcz8gOiBzdHJpbmcsXG4gICAgICAgICAgICB4cGF0aD8gOiBzdHJpbmcsXG4gICAgICAgICAgICBjb2RlPyA6IHN0cmluZyxcbiAgICAgICAgICAgIGtleT8gOiBzdHJpbmcsXG4gICAgICAgICAgICBhdHRyaWJ1dGVOYW1lPzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRleHQ/IDoge1xuICAgICAgICAgICAgdXJsPyA6IHN0cmluZyxcbiAgICAgICAgICAgIGNzcz8gOiBzdHJpbmcsXG4gICAgICAgICAgICB4cGF0aD8gOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgZGVzY3JpcHRpb24gOiBzdHJpbmdcbiAgICB9KSA6IFJ1bGUge1xuICAgICAgICBzd2l0Y2ggKGRhdGEub3V0cHV0LnN1ZmZpeCkge1xuICAgICAgICAgICAgY2FzZSBcImlubmVyVGV4dFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW5uZXJUZXh0UnVsZShkYXRhLm91dHB1dC5wcmVmaXgsZGF0YS5vdXRwdXQ/LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgY2FzZSBcImluZGV4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmRleFJ1bGUoZGF0YS5vdXRwdXQucHJlZml4LGRhdGEub3V0cHV0LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZVJ1bGUoZGF0YS5vdXRwdXQucHJlZml4LGRhdGEub3V0cHV0LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgY2FzZSBcImNzc1NlbGVjdG9yXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDU1NTZWxlY3RvclJ1bGUoZGF0YS5vdXRwdXQucHJlZml4LGRhdGEub3V0cHV0LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgY2FzZSBcImNzc1NlbGVjdG9yV2l0aFZhbHVlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDU1NTZWxlY3RvcldpdGhWYWx1ZVJ1bGUoZGF0YS5vdXRwdXQucHJlZml4LGRhdGEub3V0cHV0LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgY2FzZSBcImF0dHJpYnV0ZVZhbHVlXCI6XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubWF0Y2guYXR0cmlidXRlTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU2ltcGxlUnVsZShkYXRhLm91dHB1dC5wcmVmaXgsZGF0YS5vdXRwdXQuc3VmZml4LCBkYXRhLm1hdGNoLmV2ZW50LCBkYXRhLm1hdGNoPy5jc3MsIGRhdGEubWF0Y2g/LnhwYXRoLCBkYXRhLm1hdGNoPy5jb2RlLCBkYXRhLm1hdGNoPy5rZXksIGRhdGE/LmNvbnRleHQ/LnVybCwgZGF0YT8uY29udGV4dD8uY3NzLCBkYXRhPy5jb250ZXh0Py54cGF0aCwgZGF0YS5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVWYWx1ZVJ1bGUoZGF0YS5vdXRwdXQucHJlZml4LGRhdGEub3V0cHV0LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24sIGRhdGEubWF0Y2guYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVJ1bGUoZGF0YS5vdXRwdXQucHJlZml4LGRhdGEub3V0cHV0LnN1ZmZpeCwgZGF0YS5tYXRjaC5ldmVudCwgZGF0YS5tYXRjaD8uY3NzLCBkYXRhLm1hdGNoPy54cGF0aCwgZGF0YS5tYXRjaD8uY29kZSwgZGF0YS5tYXRjaD8ua2V5LCBkYXRhPy5jb250ZXh0Py51cmwsIGRhdGE/LmNvbnRleHQ/LmNzcywgZGF0YT8uY29udGV4dD8ueHBhdGgsIGRhdGEuZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG5cbiAgICB9XG5cblxufSIsIlxuZXhwb3J0IHR5cGUgT3ZlcmxheVR5cGUgPSBcInJhaW5ib3dcIiB8IFwiYmx1ZXNreVwiIHwgXCJzaGFkb3dcIjtcbmV4cG9ydCB0eXBlIFJlY29yZGluZ01vZGUgPSBcImJ5ZXhwbG9yYXRpb25cIiB8IFwiYnlpbnRlcmFjdGlvblwiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Vzc2lvbiB7XG4gICAgcmVhZG9ubHkgaWQgOiBzdHJpbmc7XG4gICAgcmVhZG9ubHkgd2ViU2l0ZUlkIDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IGJhc2VVUkw6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICByZWFkb25seSBuYW1lIDogc3RyaW5nO1xuICAgIHJlYWRvbmx5IGRlc2NyaXB0aW9uIDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHJlYWRvbmx5IG92ZXJsYXlUeXBlOiBPdmVybGF5VHlwZTtcbiAgICByZWFkb25seSByZWNvcmRpbmdNb2RlOiBSZWNvcmRpbmdNb2RlO1xuXG4gICAgY29uc3RydWN0b3IoaWQ6IHN0cmluZywgd2ViU2l0ZUlkOiBzdHJpbmcsIGJhc2VVUkw6c3RyaW5nIHwgdW5kZWZpbmVkLCBuYW1lIDogc3RyaW5nLCBkZXNjcmlwdGlvbiA6IHN0cmluZywgb3ZlcmxheVR5cGU6IE92ZXJsYXlUeXBlLCByZWNvcmRpbmdNb2RlOiBSZWNvcmRpbmdNb2RlKSB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCB8fCBpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjcmVhdGUgU2Vzc2lvbiB3aXRob3V0IGlkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlYlNpdGVJZCA9PT0gbnVsbCB8fCB3ZWJTaXRlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY3JlYXRlIFNlc3Npb24gd2l0aG91dCB3ZWJTaXRlSWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMud2ViU2l0ZUlkID0gd2ViU2l0ZUlkO1xuICAgICAgICB0aGlzLmJhc2VVUkwgPSBiYXNlVVJMO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMub3ZlcmxheVR5cGUgPSBvdmVybGF5VHlwZTsgICAgICAgIFxuICAgICAgICB0aGlzLnJlY29yZGluZ01vZGUgPSByZWNvcmRpbmdNb2RlO1xuICAgIH1cblxufSIsImltcG9ydCBBY3Rpb24gZnJvbSAnLi9BY3Rpb24nO1xuaW1wb3J0IFJ1bGUgZnJvbSAnLi9SdWxlJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2ltcGxlUnVsZSBleHRlbmRzIFJ1bGUge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeDogc3RyaW5nLCBzdWZmaXg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZXZlbnQ6IHN0cmluZywgY3NzOiBzdHJpbmcgfCB1bmRlZmluZWQsIHhwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgIGNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZCwga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRVUkw6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dENTUzogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0WFBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246IHN0cmluZykge1xuICAgICAgICBzdXBlcihwcmVmaXgsIHN1ZmZpeCwgZXZlbnQsIGNzcywgeHBhdGgsIGNvZGUsIGtleSwgY29udGV4dFVSTCwgY29udGV4dENTUywgY29udGV4dFhQYXRoLCBkZXNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgbWFrZUFjdGlvbihldmVudCA6IEV2ZW50KTogQWN0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24odGhpcy5wcmVmaXgpO1xuICAgIH1cblxuICAgIGFjdGlvblRvRWxlbWVudHMoYWN0aW9uOiBBY3Rpb24pOiAoSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50KVtdIHtcbiAgICAgICAgaWYgKGFjdGlvbi5wcmVmaXggIT09IHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmZpbmRNYXRjaGVkRWxlbWVudHMoKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cbn1cbiIsImltcG9ydCBDb250ZXh0TWFwcGVyIGZyb20gXCIuL0NvbnRleHRNYXBwZXJcIjtcbmltcG9ydCBSdWxlIGZyb20gXCIuL1J1bGVcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVVJMQ29udGV4dE1hcHBlciBleHRlbmRzIENvbnRleHRNYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQgOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgfVxuXG4gICAgYnVpbGRFbGVtZW50VG9SdWxlTWFwKCkgOiBNYXA8SFRNTEVsZW1lbnR8U1ZHRWxlbWVudCwgUnVsZVtdPiB7XG4gICAgICAgIGlmICh0aGlzLl9jb250ZXh0ICYmIGRvY3VtZW50LlVSTC5zdGFydHNXaXRoKHRoaXMuX2NvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWlsZEVsZW1lbnRUb1J1bGVNYXBGb3JTZWxlY3RvcnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IEFjdGlvbiBmcm9tICcuL0FjdGlvbic7XG5pbXBvcnQgU2ltcGxlUnVsZSBmcm9tICcuL1NpbXBsZVJ1bGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWYWx1ZVJ1bGUgZXh0ZW5kcyBTaW1wbGVSdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmVmaXg6IHN0cmluZywgc3VmZml4OiBzdHJpbmcgfCB1bmRlZmluZWQsIGV2ZW50OiBzdHJpbmcsIGNzczogc3RyaW5nIHwgdW5kZWZpbmVkLCB4cGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgICAgICBjb2RlOiBzdHJpbmcgfCB1bmRlZmluZWQsIGtleTogc3RyaW5nIHwgdW5kZWZpbmVkLCBjb250ZXh0VVJMOiBzdHJpbmcgfCB1bmRlZmluZWQsIGNvbnRleHRDU1M6IHN0cmluZyB8IHVuZGVmaW5lZCwgY29udGV4dFhQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQsIGRlc2NyaXB0aW9uOiBzdHJpbmcpIHtcbiAgICAgICAgc3VwZXIocHJlZml4LCBzdWZmaXgsIGV2ZW50LCBjc3MsIHhwYXRoLCBjb2RlLCBrZXksIGNvbnRleHRVUkwsIGNvbnRleHRDU1MsIGNvbnRleHRYUGF0aCwgZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIG1ha2VBY3Rpb24oZXZlbnQgOiBFdmVudCk6IEFjdGlvbiB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24odGhpcy5wcmVmaXgsIHRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3Rpb24odGhpcy5wcmVmaXgsIFwic3ZnXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWN0aW9uVG9FbGVtZW50cyhhY3Rpb246IEFjdGlvbik6IChIVE1MRWxlbWVudHxTVkdFbGVtZW50KVtdIHtcbiAgICAgICAgaWYgKGFjdGlvbi5wcmVmaXggIT09IHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbi5zdWZmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmFjdGlvblRvRWxlbWVudHMoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuZmluZE1hdGNoZWRFbGVtZW50cygpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViU2l0ZSB7XG4gICAgcHVibGljIGlkOiBzdHJpbmc7XG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcbiAgICBwdWJsaWMgbWFwcGluZ0xpc3Q6IHttYXRjaDogYW55LCBvdXRwdXQ6IGFueSwgZGVzY3JpcHRpb246IHN0cmluZ31bXTtcblxuICAgIGNvbnN0cnVjdG9yKGlkOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgbWFwcGluZ0xpc3Q6IHttYXRjaDogYW55LCBvdXRwdXQ6IGFueSwgZGVzY3JpcHRpb246IHN0cmluZ31bXSkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubWFwcGluZ0xpc3QgPSBtYXBwaW5nTGlzdDtcbiAgICB9XG59IiwiaW1wb3J0IENvbnRleHRNYXBwZXIgZnJvbSBcIi4vQ29udGV4dE1hcHBlclwiO1xuaW1wb3J0IFJ1bGUgZnJvbSBcIi4vUnVsZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBYUGF0aENvbnRleHRNYXBwZXIgZXh0ZW5kcyBDb250ZXh0TWFwcGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0IDogc3RyaW5nKSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgIH1cblxuICAgIGJ1aWxkRWxlbWVudFRvUnVsZU1hcCgpIDogTWFwPEhUTUxFbGVtZW50fFNWR0VsZW1lbnQsIFJ1bGVbXT4ge1xuICAgICAgICBpZiAodGhpcy5fY29udGV4dCkge1xuXG4gICAgICAgICAgICBjb25zdCB4cGF0aFF1ZXJ5UmVzdWx0ID0gZG9jdW1lbnQuZXZhbHVhdGUodGhpcy5fY29udGV4dCwgZG9jdW1lbnQsIG51bGwsIFhQYXRoUmVzdWx0LkFOWV9UWVBFLCBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB4cGF0aFF1ZXJ5UmVzdWx0Lml0ZXJhdGVOZXh0KCk7XG4gICAgICAgICAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IGNvbnRleHQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRFbGVtZW50VG9SdWxlTWFwRm9yU2VsZWN0b3JzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgICB9ICAgXG4gICAgfVxufSIsImltcG9ydCB7Q2F0ZWdvcnksQ2F0ZWdvcnlMb2dnZXIsQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeSxDYXRlZ29yeUNvbmZpZ3VyYXRpb24sTG9nTGV2ZWx9IGZyb20gXCJ0eXBlc2NyaXB0LWxvZ2dpbmdcIjtcbiBcbi8vIE9wdGlvbmFsbHkgY2hhbmdlIGRlZmF1bHQgc2V0dGluZ3MsIGluIHRoaXMgZXhhbXBsZSBzZXQgZGVmYXVsdCBsb2dnaW5nIHRvIEluZm8uXG4vLyBXaXRob3V0IGNoYW5naW5nIGNvbmZpZ3VyYXRpb24sIGNhdGVnb3JpZXMgd2lsbCBsb2cgdG8gRXJyb3IuXG5cbmxldCBsb2dMZXZlbDtcblxuc3dpdGNoKHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgY2FzZSAncHJvZHVjdGlvbic6XG4gICAgICAgIGxvZ0xldmVsID0gTG9nTGV2ZWwuRXJyb3I7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldmVsb3BtZW50JzogXG4gICAgICAgIGxvZ0xldmVsID0gTG9nTGV2ZWwuRGVidWc7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2dpdGh1Yic6XG4gICAgICAgIGxvZ0xldmVsID0gTG9nTGV2ZWwuRXJyb3I7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IFxuICAgICAgICBsb2dMZXZlbCA9IExvZ0xldmVsLkVycm9yXG59XG5cbkNhdGVnb3J5U2VydmljZUZhY3Rvcnkuc2V0RGVmYXVsdENvbmZpZ3VyYXRpb24obmV3IENhdGVnb3J5Q29uZmlndXJhdGlvbihsb2dMZXZlbCkpO1xuIFxuLy8gQ3JlYXRlIGNhdGVnb3JpZXMsIHRoZXkgd2lsbCBhdXRvcmVnaXN0ZXIgdGhlbXNlbHZlcywgb25lIGNhdGVnb3J5IHdpdGhvdXQgcGFyZW50IChyb290KSBhbmQgYSBjaGlsZCBjYXRlZ29yeS5cbmV4cG9ydCBjb25zdCBsb2dnZXIgPSBuZXcgQ2F0ZWdvcnkoXCJUYWJTY3JpcHRcIik7XG4iLCJpbXBvcnQgQnJvd3NlclNjcmlwdCBmcm9tIFwiLi9kb21haW4vQnJvd3NlclNjcmlwdFwiO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gXCIuL2ZyYW1ld29yay9Mb2dnZXJcIjtcbmltcG9ydCBBaWZleFNlcnZpY2VIVFRQIGZyb20gXCIuL19pbmZyYS9BaWZleFNlcnZpY2VIVFRQXCI7XG5pbXBvcnQgQnJvd3NlclNlcnZpY2VMb2NhbFN0b3JhZ2UgZnJvbSBcIi4vX2luZnJhL0Jyb3dzZXJTZXJ2aWNlTG9jYWxTdG9yYWdlXCI7XG5pbXBvcnQgQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZSBmcm9tIFwiLi9faW5mcmEvQnJvd3NlclNlcnZpY2VTZXNzaW9uU3RvcmFnZVwiO1xuXG5sb2dnZXIuaW5mbyhcIkFJRkVYIHNjcmlwdCBpcyBydW5uaW5nLlwiKTtcblxuY29uc3QgQUlGRVhfU0NSSVBUID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJBSUZFWFwiKTtcbmlmIChBSUZFWF9TQ1JJUFQpIHtcbiAgICBsb2dnZXIuaW5mbyhcIkFJRkVYIFNDUklQVCBFbGVtZW50IGlzIGZvdW5kLlwiKTtcbiAgICBjb25zdCBDT05ORVhJT05fVVJMID0gQUlGRVhfU0NSSVBULmdldEF0dHJpYnV0ZShcImNvbm5leGlvbi11cmxcIik7XG4gICAgaWYgKENPTk5FWElPTl9VUkwpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oXCJBSUZFWCBjb25uZXhpb24tdXJsIEVsZW1lbnQgaXMgZm91bmQuXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgQUlGRVhfVVJMID0gbmV3IFVSTChDT05ORVhJT05fVVJMKTtcblx0XHRcdGxldCBzZXNzaW9uSWQgPSBBSUZFWF9VUkwuc2VhcmNoUGFyYW1zLmdldCgnc2Vzc2lvbklkJyk7XG5cdFx0XHRpZiAoc2Vzc2lvbklkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJBSUZFWCBzZXNzaW9uSWQgaXMgZm91bmQuXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEFJRkVYX1NFUlZJQ0UgPSBuZXcgQWlmZXhTZXJ2aWNlSFRUUCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEJST1dTRVJfU0VSVklDRSA9IG5ldyBCcm93c2VyU2VydmljZVNlc3Npb25TdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgQlJPV1NFUl9TQ1JJUFQgPSBuZXcgQnJvd3NlclNjcmlwdChBSUZFWF9VUkwub3JpZ2luLCBzZXNzaW9uSWQsIHVuZGVmaW5lZCwgQUlGRVhfU0VSVklDRSwgQlJPV1NFUl9TRVJWSUNFKTtcbiAgICAgICAgICAgICAgICBCUk9XU0VSX1NDUklQVC5zdGFydCgpO1x0XG5cdFx0XHR9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgY29ubmV4aW9uIFVSTFwiLCBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvbm5leGlvbiBVUkxcIikpO1xuICAgICAgICB9XG4gICAgfVxufSBlbHNlIHtcbiAgICBsb2dnZXIuZXJyb3IoXCJBSUZFWCBTQ1JJUFQgRWxlbWVudCBpcyBub3QgZm91bmQuXCIsIG5ldyBFcnJvcihcIkFJRkVYIFNDUklQVCBFbGVtZW50IGlzIG5vdCBmb3VuZC5cIikpO1xufVxuXG4vLyA8c2NyaXB0IGlkPVwiQUlGRVhcIiBjb25uZXhpb24tdXJsPVwiaHR0cHM6Ly9haWZleC5jb20vYWlmZXgvY29ubmV4aW9uP3Nlc3Npb25JZD1hMWIyYzNkNGU1ZjZnN2g4aTlqMFwiIHNyYz1cImh0dHBzOi8vYWlmZXguY29tL2FpZmV4L3NjcmlwdC9haWZleC5qc1wiPjwvc2NyaXB0PiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENhdGVnb3J5U2VydmljZV8xID0gcmVxdWlyZShcIi4uL2xvZy9jYXRlZ29yeS9DYXRlZ29yeVNlcnZpY2VcIik7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL2xvZy9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIERhdGFTdHJ1Y3R1cmVzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvRGF0YVN0cnVjdHVyZXNcIik7XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIGNsYXNzIGZvciBDYXRlZ29yeVNlcnZpY2VDb250cm9sLlxuICovXG52YXIgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsKCkge1xuICAgIH1cbiAgICBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5wcm90b3R5cGUuaGVscCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmxvZyhDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5faGVscCk7XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwucHJvdG90eXBlLmV4YW1wbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2coQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2V4YW1wbGUpO1xuICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLnByb3RvdHlwZS5zaG93U2V0dGluZ3MgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSB2b2lkIDApIHsgaWQgPSBcImFsbFwiOyB9XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIHZhciBzZXJ2aWNlID0gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2dldENhdGVnb3J5U2VydmljZSgpO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9nZXRDYXRlZ29yaWVzKGlkKTtcbiAgICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICAgICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX3Byb2Nlc3NDYXRlZ29yeShzZXJ2aWNlLCBjYXRlZ29yeSwgcmVzdWx0LCAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0LnRvU3RyaW5nKCkpO1xuICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLnByb3RvdHlwZS5jaGFuZ2UgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIHNlcnZpY2UgPSBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fZ2V0Q2F0ZWdvcnlTZXJ2aWNlKCk7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2dldENhdGVnb3JpZXMoc2V0dGluZ3MuY2F0ZWdvcnkpO1xuICAgICAgICB2YXIgbG9nTGV2ZWwgPSBudWxsO1xuICAgICAgICB2YXIgZm9ybWF0RW51bSA9IG51bGw7XG4gICAgICAgIHZhciBzaG93Q2F0ZWdvcnlOYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIHNob3dUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdmFyIGFkZFJlc3VsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiwgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFkZFJlc3VsdChcInJlY3Vyc2l2ZT1cIiArIHNldHRpbmdzLnJlY3Vyc2l2ZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MubG9nTGV2ZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxvZ0xldmVsID0gTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLmZyb21TdHJpbmcoc2V0dGluZ3MubG9nTGV2ZWwpO1xuICAgICAgICAgICAgYWRkUmVzdWx0KFwibG9nTGV2ZWw9XCIgKyBzZXR0aW5ncy5sb2dMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5sb2dGb3JtYXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdEVudW0gPSBMb2dnZXJPcHRpb25zXzEuRGF0ZUZvcm1hdEVudW0uZnJvbVN0cmluZyhzZXR0aW5ncy5sb2dGb3JtYXQpO1xuICAgICAgICAgICAgYWRkUmVzdWx0KFwibG9nRm9ybWF0PVwiICsgc2V0dGluZ3MubG9nRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnNob3dDYXRlZ29yeU5hbWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBzaG93Q2F0ZWdvcnlOYW1lID0gc2V0dGluZ3Muc2hvd0NhdGVnb3J5TmFtZTtcbiAgICAgICAgICAgIGFkZFJlc3VsdChcInNob3dDYXRlZ29yeU5hbWU9XCIgKyBzZXR0aW5ncy5zaG93Q2F0ZWdvcnlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnNob3dUaW1lc3RhbXAgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBzaG93VGltZXN0YW1wID0gc2V0dGluZ3Muc2hvd1RpbWVzdGFtcDtcbiAgICAgICAgICAgIGFkZFJlc3VsdChcInNob3dUaW1lc3RhbXA9XCIgKyBzZXR0aW5ncy5zaG93VGltZXN0YW1wKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXBwbHlDaGFuZ2VzID0gZnVuY3Rpb24gKGNhdCkge1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5U2V0dGluZ3MgPSBzZXJ2aWNlLmdldENhdGVnb3J5U2V0dGluZ3MoY2F0KTtcbiAgICAgICAgICAgIC8vIFNob3VsZCBub3QgaGFwcGVuIGJ1dCBtYWtlIHRzbGludCBoYXBweVxuICAgICAgICAgICAgaWYgKGNhdGVnb3J5U2V0dGluZ3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9nTGV2ZWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlTZXR0aW5ncy5sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0RW51bSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeVNldHRpbmdzLmxvZ0Zvcm1hdC5kYXRlRm9ybWF0LmZvcm1hdEVudW0gPSBmb3JtYXRFbnVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvd1RpbWVzdGFtcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeVNldHRpbmdzLmxvZ0Zvcm1hdC5zaG93VGltZVN0YW1wID0gc2hvd1RpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNob3dDYXRlZ29yeU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlTZXR0aW5ncy5sb2dGb3JtYXQuc2hvd0NhdGVnb3J5TmFtZSA9IHNob3dDYXRlZ29yeU5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjYXRlZ29yaWVzLmZvckVhY2goZnVuY3Rpb24gKGNhdCkgeyByZXR1cm4gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2FwcGx5VG9DYXRlZ29yeShjYXQsIHNldHRpbmdzLnJlY3Vyc2l2ZSwgYXBwbHlDaGFuZ2VzKTsgfSk7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2coXCJBcHBsaWVkIGNoYW5nZXM6IFwiICsgcmVzdWx0ICsgXCIgdG8gY2F0ZWdvcmllcyAnXCIgKyBzZXR0aW5ncy5jYXRlZ29yeSArIFwiJy5cIik7XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gdm9pZCAwKSB7IGlkID0gXCJhbGxcIjsgfVxuICAgICAgICB2YXIgc2VydmljZSA9IENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9nZXRDYXRlZ29yeVNlcnZpY2UoKTtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fZ2V0Q2F0ZWdvcmllcyhpZCk7XG4gICAgICAgIHZhciBhcHBseUNoYW5nZXMgPSBmdW5jdGlvbiAoY2F0KSB7XG4gICAgICAgICAgICB2YXIgY2F0ZWdvcnlTZXR0aW5ncyA9IHNlcnZpY2UuZ2V0Q2F0ZWdvcnlTZXR0aW5ncyhjYXQpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gc2VydmljZS5nZXRPcmlnaW5hbENhdGVnb3J5U2V0dGluZ3MoY2F0KTtcbiAgICAgICAgICAgIC8vIFNob3VsZCBub3QgaGFwcGVuIGJ1dCBtYWtlIHRzbGludCBoYXBweVxuICAgICAgICAgICAgaWYgKGNhdGVnb3J5U2V0dGluZ3MgIT09IG51bGwgJiYgb3JpZ2luYWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeVNldHRpbmdzLmxvZ0xldmVsID0gb3JpZ2luYWwubG9nTGV2ZWw7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlTZXR0aW5ncy5sb2dGb3JtYXQuZGF0ZUZvcm1hdC5mb3JtYXRFbnVtID0gb3JpZ2luYWwubG9nRm9ybWF0LmRhdGVGb3JtYXQuZm9ybWF0RW51bTtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeVNldHRpbmdzLmxvZ0Zvcm1hdC5zaG93VGltZVN0YW1wID0gb3JpZ2luYWwubG9nRm9ybWF0LnNob3dUaW1lU3RhbXA7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcnlTZXR0aW5ncy5sb2dGb3JtYXQuc2hvd0NhdGVnb3J5TmFtZSA9IG9yaWdpbmFsLmxvZ0Zvcm1hdC5zaG93Q2F0ZWdvcnlOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjYXRlZ29yaWVzLmZvckVhY2goZnVuY3Rpb24gKGNhdCkgeyByZXR1cm4gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2FwcGx5VG9DYXRlZ29yeShjYXQsIHRydWUsIGFwcGx5Q2hhbmdlcyk7IH0pO1xuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXBwbGllZCByZXNldCB0byBjYXRlZ29yeTogXCIgKyBpZCArIFwiLlwiKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fcHJvY2Vzc0NhdGVnb3J5ID0gZnVuY3Rpb24gKHNlcnZpY2UsIGNhdGVnb3J5LCByZXN1bHQsIGluZGVudCkge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBzZXJ2aWNlLmdldENhdGVnb3J5U2V0dGluZ3MoY2F0ZWdvcnkpO1xuICAgICAgICBpZiAoc2V0dGluZ3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoXCIgIFwiICsgY2F0ZWdvcnkuaWQgKyBcIjogXCIpO1xuICAgICAgICAgICAgaWYgKGluZGVudCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGVudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoXCIgIFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKGNhdGVnb3J5Lm5hbWUgKyBcIiAoXCIgKyBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWxbc2V0dGluZ3MubG9nTGV2ZWxdLnRvU3RyaW5nKCkgKyBcIkBcIiArIExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlW3NldHRpbmdzLmxvZ2dlclR5cGVdLnRvU3RyaW5nKCkgKyBcIilcXG5cIik7XG4gICAgICAgICAgICBpZiAoY2F0ZWdvcnkuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9wcm9jZXNzQ2F0ZWdvcnkoc2VydmljZSwgY2hpbGQsIHJlc3VsdCwgaW5kZW50ICsgMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9hcHBseVRvQ2F0ZWdvcnkgPSBmdW5jdGlvbiAoY2F0ZWdvcnksIHJlY3Vyc2l2ZSwgYXBwbHkpIHtcbiAgICAgICAgYXBwbHkoY2F0ZWdvcnkpO1xuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgICAgICBjYXRlZ29yeS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9hcHBseVRvQ2F0ZWdvcnkoY2hpbGQsIHJlY3Vyc2l2ZSwgYXBwbHkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9nZXRDYXRlZ29yeVNlcnZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBDYXRlZ29yeVNlcnZpY2VfMS5DYXRlZ29yeVNlcnZpY2VJbXBsLmdldEluc3RhbmNlKCk7XG4gICAgfTtcbiAgICBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbC5fZ2V0Q2F0ZWdvcmllcyA9IGZ1bmN0aW9uIChpZENhdGVnb3J5KSB7XG4gICAgICAgIHZhciBzZXJ2aWNlID0gQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2dldENhdGVnb3J5U2VydmljZSgpO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBpZiAoaWRDYXRlZ29yeSA9PT0gXCJhbGxcIikge1xuICAgICAgICAgICAgY2F0ZWdvcmllcyA9IHNlcnZpY2UuZ2V0Um9vdENhdGVnb3JpZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYXRlZ29yeSA9IHNlcnZpY2UuZ2V0Q2F0ZWdvcnlCeUlkKGlkQ2F0ZWdvcnkpO1xuICAgICAgICAgICAgaWYgKGNhdGVnb3J5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZpbmQgY2F0ZWdvcnkgd2l0aCBpZCBcIiArIGlkQ2F0ZWdvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0ZWdvcmllcy5wdXNoKGNhdGVnb3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2F0ZWdvcmllcztcbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsLl9oZWxwID0gXCJcXG4gIGhlbHAoKTogdm9pZFxcbiAgICAqKiBTaG93cyB0aGlzIGhlbHAuXFxuXFxuICBleGFtcGxlKCk6IHZvaWRcXG4gICAgKiogU2hvd3MgYW4gZXhhbXBsZSBvbiBob3cgdG8gdXNlIHRoaXMuXFxuXFxuICBzaG93U2V0dGluZ3MoaWQ6IG51bWJlciB8IFxcXCJhbGxcXFwiID0gXFxcImFsbFxcXCIpOiB2b2lkXFxuICAgICoqIFNob3dzIHNldHRpbmdzIGZvciBhIHNwZWNpZmljIGNhdGVnb3J5LCBvciBmb3IgYWxsLiBUaGUgaWQgb2YgY2F0ZWdvcmllcyBjYW4gYmUgZm91bmQgYnkgY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRob3V0IHBhcmFtZXRlci5cXG5cXG4gIGNoYW5nZShzZXR0aW5nczogQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbFNldHRpbmdzKTogdm9pZFxcbiAgICAqKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHNldHRpbmdzIGZvciBvbmUgb3IgYWxsIGNhdGVnb3JpZXMuXFxuICAgICoqXFxuICAgICAgIENhdGVnb3J5U2VydmljZUNvbnRyb2xTZXR0aW5ncywgcHJvcGVydGllcyBvZiBvYmplY3Q6XFxuICAgICAgICAgY2F0ZWdvcnk6IG51bWJlciB8IFxcXCJhbGxcXFwiXFxuICAgICAgICAgICAqKiBBcHBseSB0byBzcGVjaWZpYyBjYXRlZ29yeSwgb3IgXFxcImFsbFxcXCIuXFxuICAgICAgICAgICAqKiBSZXF1aXJlZFxcblxcbiAgICAgICAgIHJlY3Vyc2l2ZTogYm9vbGVhblxcbiAgICAgICAgICAgKiogQXBwbHkgdG8gY2hpbGQgY2F0ZWdvcmllcyAodHJ1ZSkgb3Igbm90LlxcbiAgICAgICAgICAgKiogUmVxdWlyZWRcXG5cXG4gICAgICAgICBsb2dMZXZlbDogXFxcIkZhdGFsXFxcIiB8IFxcXCJFcnJvclxcXCIgfCBcXFwiV2FyblxcXCIgfCBcXFwiSW5mb1xcXCIgfCBcXFwiRGVidWdcXFwiIHwgXFxcIlRyYWNlXFxcIiB8IHVuZGVmaW5lZFxcbiAgICAgICAgICAgKiogU2V0IGxvZyBsZXZlbCwgdW5kZWZpbmVkIHdpbGwgbm90IGNoYW5nZSB0aGUgc2V0dGluZy5cXG4gICAgICAgICAgICoqIE9wdGlvbmFsXFxuXFxuICAgICAgICAgbG9nRm9ybWF0OiBcXFwiRGVmYXVsdFxcXCIgfCBcXFwiWWVhck1vbnRoRGF5VGltZVxcXCIgfCBcXFwiWWVhckRheU1vbnRoV2l0aEZ1bGxUaW1lXFxcIiB8IFxcXCJZZWFyRGF5TW9udGhUaW1lXFxcIiB8IHVuZGVmaW5lZFxcbiAgICAgICAgICAgKiogU2V0IHRoZSBsb2cgZm9ybWF0LCB1bmRlZmluZWQgd2lsbCBub3QgY2hhbmdlIHRoZSBzZXR0aW5nLlxcbiAgICAgICAgICAgKiogT3B0aW9uYWxcXG5cXG4gICAgICAgICBzaG93VGltZXN0YW1wOiBib29sZWFuIHwgdW5kZWZpbmVkXFxuICAgICAgICAgICAqKiBXaGV0aGVyIHRvIHNob3cgdGltZXN0YW1wLCB1bmRlZmluZWQgd2lsbCBub3QgY2hhbmdlIHRoZSBzZXR0aW5nLlxcbiAgICAgICAgICAgKiogT3B0aW9uYWxcXG5cXG4gICAgICAgICBzaG93Q2F0ZWdvcnlOYW1lOiBib29sZWFuIHwgdW5kZWZpbmVkXFxuICAgICAgICAgICAqKiBXaGV0aGVyIHRvIHNob3cgdGhlIGNhdGVnb3J5IG5hbWUsIHVuZGVmaW5lZCB3aWxsIG5vdCBjaGFuZ2UgdGhlIHNldHRpbmcuXFxuICAgICAgICAgICAqKiBPcHRpb25hbFxcblxcbiAgIHJlc2V0KGlkOiBudW1iZXIgfCBcXFwiYWxsXFxcIik6IHZvaWRcXG4gICAgICoqIFJlc2V0cyBldmVyeXRoaW5nIHRvIG9yaWdpbmFsIHZhbHVlcywgZm9yIG9uZSBzcGVjaWZpYyBvciBmb3IgYWxsIGNhdGVnb3JpZXMuXFxuXCI7XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwuX2V4YW1wbGUgPSBcIlxcbiAgRXhhbXBsZXM6XFxuICAgIGNoYW5nZSh7Y2F0ZWdvcnk6IFxcXCJhbGxcXFwiLCByZWN1cnNpdmU6dHJ1ZSwgbG9nTGV2ZWw6IFxcXCJJbmZvXFxcIn0pXFxuICAgICAgKiogQ2hhbmdlIGxvZ2xldmVsIHRvIEluZm8gZm9yIGFsbCBjYXRlZ29yaWVzLCBhcHBseSB0byBjaGlsZCBjYXRlZ29yaWVzIGFzIHdlbGwuXFxuXFxuICAgIGNoYW5nZSh7Y2F0ZWdvcnk6IDEsIHJlY3Vyc2l2ZTpmYWxzZSwgbG9nTGV2ZWw6IFxcXCJXYXJuXFxcIn0pXFxuICAgICAgKiogQ2hhbmdlIGxvZ0xldmVsIGZvciBjYXRlZ29yeSAxLCBkbyBub3QgcmVjdXJzZS5cXG5cXG4gICAgY2hhbmdlKHtjYXRlZ29yeTogXFxcImFsbFxcXCIsIHJlY3Vyc2l2ZTp0cnVlLCBsb2dMZXZlbDogXFxcIkRlYnVnXFxcIiwgbG9nRm9ybWF0OiBcXFwiWWVhckRheU1vbnRoVGltZVxcXCIsIHNob3dUaW1lc3RhbXA6ZmFsc2UsIHNob3dDYXRlZ29yeU5hbWU6ZmFsc2V9KVxcbiAgICAgICoqIENoYW5nZSBsb2dsZXZlbCB0byBEZWJ1ZyBmb3IgYWxsIGNhdGVnb3JpZXMsIGFwcGx5IGZvcm1hdCwgZG8gbm90IHNob3cgdGltZXN0YW1wIGFuZCBjYXRlZ29yeSBuYW1lcyAtIHJlY3Vyc2l2ZWx5IHRvIGNoaWxkIGNhdGVnb3JpZXMuXFxuXFxuXCI7XG4gICAgcmV0dXJuIENhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsO1xufSgpKTtcbmV4cG9ydHMuQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbEltcGwgPSBDYXRlZ29yeVNlcnZpY2VDb250cm9sSW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhdGVnb3J5U2VydmljZUNvbnRyb2wuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL2xvZy9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIExGU2VydmljZV8xID0gcmVxdWlyZShcIi4uL2xvZy9zdGFuZGFyZC9MRlNlcnZpY2VcIik7XG52YXIgRGF0YVN0cnVjdHVyZXNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9EYXRhU3RydWN0dXJlc1wiKTtcbnZhciBMb2dnZXJDb250cm9sSW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9nZ2VyQ29udHJvbEltcGwoKSB7XG4gICAgfVxuICAgIExvZ2dlckNvbnRyb2xJbXBsLnByb3RvdHlwZS5oZWxwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgIGNvbnNvbGUubG9nKExvZ2dlckNvbnRyb2xJbXBsLl9oZWxwKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBMb2dnZXJDb250cm9sSW1wbC5wcm90b3R5cGUubGlzdEZhY3RvcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJ0U2V0dGluZ3NGYWN0b3JpZXMgPSBMb2dnZXJDb250cm9sSW1wbC5fZ2V0UnVudGltZVNldHRpbmdzTG9nZ2VyRmFjdG9yaWVzKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIHJlc3VsdC5hcHBlbmRMaW5lKFwiUmVnaXN0ZXJlZCBMb2dnZXJGYWN0b3JpZXMgKGluZGV4IC8gbmFtZSlcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnRTZXR0aW5nc0ZhY3Rvcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJ0U2V0dGluZ3NGYWN0b3J5ID0gcnRTZXR0aW5nc0ZhY3Rvcmllc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoXCIgIFwiICsgaSkuYXBwZW5kKFwiOiBcIiArIHJ0U2V0dGluZ3NGYWN0b3J5LmdldE5hbWUoKSArIFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0LnRvU3RyaW5nKCkpO1xuICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICB9O1xuICAgIExvZ2dlckNvbnRyb2xJbXBsLnByb3RvdHlwZS5zaG93U2V0dGluZ3MgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSB2b2lkIDApIHsgaWQgPSBcImFsbFwiOyB9XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGlkID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgICB2YXIgaWR4XzEgPSAwO1xuICAgICAgICAgICAgTG9nZ2VyQ29udHJvbEltcGwuX2dldFJ1bnRpbWVTZXR0aW5nc0xvZ2dlckZhY3RvcmllcygpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRGF0YVN0cnVjdHVyZXNfMS5UdXBsZVBhaXIoaWR4XzErKywgaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBMb2dnZXJDb250cm9sSW1wbC5fZ2V0UnVudGltZVNldHRpbmdzTG9nZ2VyRmFjdG9yaWVzKCk7XG4gICAgICAgICAgICBpZiAoaWQgPj0gMCAmJiBpZCA8IHNldHRpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEYXRhU3RydWN0dXJlc18xLlR1cGxlUGFpcihpZCwgc2V0dGluZ3NbaWRdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1ZXN0ZWQgbnVtYmVyOiBcIiArIGlkICsgXCIgd2FzIG5vdCBmb3VuZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByZXN1bHRfMSA9IHJlc3VsdDsgX2kgPCByZXN1bHRfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZXR0aW5nID0gcmVzdWx0XzFbX2ldO1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCIgIExvZ2dlckZhY3Rvcnk6IFwiICsgc2V0dGluZy55LmdldE5hbWUoKSArIFwiIChpZD1cIiArIHNldHRpbmcueCArIFwiKVwiKTtcbiAgICAgICAgICAgIHZhciBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyA9IHNldHRpbmcueS5nZXRMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncygpO1xuICAgICAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sZW5ndGg7IGcrKykge1xuICAgICAgICAgICAgICAgIHZhciBncm91cFNldHRpbmcgPSBsb2dHcm91cFJ1bnRpbWVTZXR0aW5nc1tnXTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIiAgICAgTG9nR3JvdXA6IChpZD1cIiArIGcgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIgICAgICAgUmVnRXhwOiBcIiArIGdyb3VwU2V0dGluZy5sb2dHcm91cFJ1bGUucmVnRXhwLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIgICAgICAgTGV2ZWw6IFwiICsgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsW2dyb3VwU2V0dGluZy5sZXZlbF0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIgICAgICAgTG9nZ2VyVHlwZTogXCIgKyBMb2dnZXJPcHRpb25zXzEuTG9nZ2VyVHlwZVtncm91cFNldHRpbmcubG9nZ2VyVHlwZV0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nZ2VyQ29udHJvbEltcGwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGlkRmFjdG9yeSkge1xuICAgICAgICBpZiAoaWRGYWN0b3J5ID09PSB2b2lkIDApIHsgaWRGYWN0b3J5ID0gXCJhbGxcIjsgfVxuICAgICAgICB2YXIgbG9nZ2VyRmFjdG9yaWVzU2V0dGluZ3MgPSBMb2dnZXJDb250cm9sSW1wbC5fZ2V0UnVudGltZVNldHRpbmdzTG9nZ2VyRmFjdG9yaWVzKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGlkRmFjdG9yeSA9PT0gXCJhbGxcIikge1xuICAgICAgICAgICAgcmVzdWx0ID0gbG9nZ2VyRmFjdG9yaWVzU2V0dGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaWRGYWN0b3J5ID49IDAgJiYgaWRGYWN0b3J5IDwgbG9nZ2VyRmFjdG9yaWVzU2V0dGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobG9nZ2VyRmFjdG9yaWVzU2V0dGluZ3NbaWRGYWN0b3J5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHNldHRpbmcpIHtcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVzZXQgYWxsIHNldHRpbmdzIGZvciBmYWN0b3J5IFwiICsgaWRGYWN0b3J5KTtcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSBuZXcgTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsKHNldHRpbmcpO1xuICAgICAgICAgICAgY29udHJvbC5yZXNldCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExvZ2dlckNvbnRyb2xJbXBsLnByb3RvdHlwZS5nZXRMb2dnZXJGYWN0b3J5Q29udHJvbCA9IGZ1bmN0aW9uIChpZEZhY3RvcnkpIHtcbiAgICAgICAgdmFyIGxvZ2dlckZhY3Rvcmllc1NldHRpbmdzID0gTG9nZ2VyQ29udHJvbEltcGwuX2dldFJ1bnRpbWVTZXR0aW5nc0xvZ2dlckZhY3RvcmllcygpO1xuICAgICAgICBpZiAoaWRGYWN0b3J5ID49IDAgJiYgaWRGYWN0b3J5IDwgbG9nZ2VyRmFjdG9yaWVzU2V0dGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZ2dlckZhY3RvcnlDb250cm9sSW1wbChsb2dnZXJGYWN0b3JpZXNTZXR0aW5nc1tpZEZhY3RvcnldKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZEZhY3RvcnkgaXMgaW52YWxpZCAobGVzcyB0aGFuIDApIG9yIG5vbiBleGlzdGluZyBpZC5cIik7XG4gICAgfTtcbiAgICBMb2dnZXJDb250cm9sSW1wbC5fZ2V0UnVudGltZVNldHRpbmdzTG9nZ2VyRmFjdG9yaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTG9nZ2VyQ29udHJvbEltcGwuX2dldFNldHRpbmdzKCkuZ2V0UnVudGltZVNldHRpbmdzRm9yTG9nZ2VyRmFjdG9yaWVzKCk7XG4gICAgfTtcbiAgICBMb2dnZXJDb250cm9sSW1wbC5fZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMRlNlcnZpY2VfMS5MRlNlcnZpY2UuZ2V0UnVudGltZVNldHRpbmdzKCk7XG4gICAgfTtcbiAgICBMb2dnZXJDb250cm9sSW1wbC5faGVscCA9IFwiXFxuICBoZWxwKCk6IHZvaWRcXG4gICAgKiogU2hvd3MgdGhpcyBoZWxwLlxcblxcbiAgbGlzdEZhY3RvcmllcygpOiB2b2lkXFxuICAgICoqIExpc3QgYWxsIHJlZ2lzdGVyZWQgTG9nZ2VyRmFjdG9yaWVzIHdpdGggYXNzb2NpYXRlZCBsb2cgZ3JvdXBzIHdpdGggcmVzcGVjdGl2ZSBpZHMgKGlkcyBjYW4gYmUgdXNlZCB0byB0YXJnZXQgYSBmYWN0b3J5IGFuZC9vciBncm91cCkuXFxuXFxuICBzaG93U2V0dGluZ3MoaWRGYWN0b3J5OiBudW1iZXIgfCBcXFwiYWxsXFxcIik6IHZvaWRcXG4gICAgKiogU2hvdyBsb2cgZ3JvdXAgc2V0dGluZ3MgZm9yIGlkRmFjdG9yeSAodXNlIGxpc3RGYWN0b3JpZXMgdG8gZmluZCBpZCBmb3IgYSBMb2dnZXJGYWN0b3J5KS4gSWYgaWRGYWN0b3J5IGlzIFxcXCJhbGxcXFwiIHNob3dzIGFsbCBmYWN0b3JpZXMuXFxuXFxuICBnZXRMb2dnZXJGYWN0b3J5Q29udHJvbChpZEZhY3Rvcnk6IG51bWJlcik6IExvZ2dlckZhY3RvcnlDb250cm9sXFxuICAgICoqIFJldHVybiBMb2dnZXJGYWN0b3J5Q29udHJvbCB3aGVuIGZvdW5kIGZvciBnaXZlbiBpZEZhY3Rvcnkgb3IgdGhyb3dzIEVycm9yIGlmIGludmFsaWQgb3IgbnVsbCwgZ2V0IHRoZSBpZCBieSB1c2luZyBsaXN0RmFjdG9yaWVzKClcXG5cXG4gIHJlc2V0KGlkRmFjdG9yeTogbnVtYmVyIHwgXFxcImFsbFxcXCIpOiB2b2lkXFxuICAgICoqIFJlc2V0cyBnaXZlbiBmYWN0b3J5IG9yIGFsbCBmYWN0b3JpZXMgYmFjayB0byBvcmlnaW5hbCB2YWx1ZXMuXFxuXCI7XG4gICAgcmV0dXJuIExvZ2dlckNvbnRyb2xJbXBsO1xufSgpKTtcbmV4cG9ydHMuTG9nZ2VyQ29udHJvbEltcGwgPSBMb2dnZXJDb250cm9sSW1wbDtcbnZhciBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlckZhY3RvcnlDb250cm9sSW1wbChzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIH1cbiAgICBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwucHJvdG90eXBlLmhlbHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2coTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLl9oZWxwKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwucHJvdG90eXBlLmV4YW1wbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5sb2coTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLl9leGFtcGxlKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwucHJvdG90eXBlLnNob3dTZXR0aW5ncyA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoaWQgPT09IHZvaWQgMCkgeyBpZCA9IFwiYWxsXCI7IH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRhU3RydWN0dXJlc18xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgdmFyIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzID0gdGhpcy5fc2V0dGluZ3MuZ2V0TG9nR3JvdXBSdW50aW1lU2V0dGluZ3MoKTtcbiAgICAgICAgcmVzdWx0LmFwcGVuZExpbmUoXCJSZWdpc3RlcmVkIExvZ0dyb3VwcyAoaW5kZXggLyBleHByZXNzaW9uKVwiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvZ0dyb3VwUnVudGltZVNldHRpbmcgPSBsb2dHcm91cFJ1bnRpbWVTZXR0aW5nc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmRMaW5lKFwiICBcIiArIGkgKyBcIjogXCIgKyBsb2dHcm91cFJ1bnRpbWVTZXR0aW5nLmxvZ0dyb3VwUnVsZS5yZWdFeHAuc291cmNlICsgXCIsIGxvZ0xldmVsPVwiICtcbiAgICAgICAgICAgICAgICBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWxbbG9nR3JvdXBSdW50aW1lU2V0dGluZy5sZXZlbF0udG9TdHJpbmcoKSArIFwiLCBzaG93VGltZXN0YW1wPVwiICsgbG9nR3JvdXBSdW50aW1lU2V0dGluZy5sb2dGb3JtYXQuc2hvd1RpbWVTdGFtcCArXG4gICAgICAgICAgICAgICAgXCIsIHNob3dMb2dnZXJOYW1lPVwiICsgbG9nR3JvdXBSdW50aW1lU2V0dGluZy5sb2dGb3JtYXQuc2hvd0xvZ2dlck5hbWUgK1xuICAgICAgICAgICAgICAgIFwiLCBmb3JtYXQ9XCIgKyBMb2dnZXJPcHRpb25zXzEuRGF0ZUZvcm1hdEVudW1bbG9nR3JvdXBSdW50aW1lU2V0dGluZy5sb2dGb3JtYXQuZGF0ZUZvcm1hdC5mb3JtYXRFbnVtXS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdC50b1N0cmluZygpKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwucHJvdG90eXBlLmNoYW5nZSA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICB2YXIgbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MgPSB0aGlzLl9nZXRMb2dHcm91cFJ1blRpbWVTZXR0aW5nc0ZvcihzZXR0aW5ncy5ncm91cCk7XG4gICAgICAgIHZhciBsb2dMZXZlbCA9IG51bGw7XG4gICAgICAgIHZhciBmb3JtYXRFbnVtID0gbnVsbDtcbiAgICAgICAgdmFyIHNob3dMb2dnZXJOYW1lID0gbnVsbDtcbiAgICAgICAgdmFyIHNob3dUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdmFyIGFkZFJlc3VsdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiwgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MubG9nTGV2ZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxvZ0xldmVsID0gTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLmZyb21TdHJpbmcoc2V0dGluZ3MubG9nTGV2ZWwpO1xuICAgICAgICAgICAgYWRkUmVzdWx0KFwibG9nTGV2ZWw9XCIgKyBzZXR0aW5ncy5sb2dMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5sb2dGb3JtYXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZvcm1hdEVudW0gPSBMb2dnZXJPcHRpb25zXzEuRGF0ZUZvcm1hdEVudW0uZnJvbVN0cmluZyhzZXR0aW5ncy5sb2dGb3JtYXQpO1xuICAgICAgICAgICAgYWRkUmVzdWx0KFwibG9nRm9ybWF0PVwiICsgc2V0dGluZ3MubG9nRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLnNob3dMb2dnZXJOYW1lID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgc2hvd0xvZ2dlck5hbWUgPSBzZXR0aW5ncy5zaG93TG9nZ2VyTmFtZTtcbiAgICAgICAgICAgIGFkZFJlc3VsdChcInNob3dMb2dnZXJOYW1lPVwiICsgc2V0dGluZ3Muc2hvd0xvZ2dlck5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Muc2hvd1RpbWVzdGFtcCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHNob3dUaW1lc3RhbXAgPSBzZXR0aW5ncy5zaG93VGltZXN0YW1wO1xuICAgICAgICAgICAgYWRkUmVzdWx0KFwic2hvd1RpbWVzdGFtcD1cIiArIHNldHRpbmdzLnNob3dUaW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIGlmIChsb2dMZXZlbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHMubGV2ZWwgPSBsb2dMZXZlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXRFbnVtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcy5sb2dGb3JtYXQuZGF0ZUZvcm1hdC5mb3JtYXRFbnVtID0gZm9ybWF0RW51bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG93VGltZXN0YW1wICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcy5sb2dGb3JtYXQuc2hvd1RpbWVTdGFtcCA9IHNob3dUaW1lc3RhbXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvd0xvZ2dlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzLmxvZ0Zvcm1hdC5zaG93TG9nZ2VyTmFtZSA9IHNob3dMb2dnZXJOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFwcGxpZWQgY2hhbmdlczogXCIgKyByZXN1bHQgKyBcIiB0byBsb2cgZ3JvdXBzICdcIiArIHNldHRpbmdzLmdyb3VwICsgXCInLlwiKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGlkR3JvdXApIHtcbiAgICAgICAgaWYgKGlkR3JvdXAgPT09IHZvaWQgMCkgeyBpZEdyb3VwID0gXCJhbGxcIjsgfVxuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLl9nZXRMb2dHcm91cFJ1blRpbWVTZXR0aW5nc0ZvcihpZEdyb3VwKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZXR0aW5nc18xID0gc2V0dGluZ3M7IF9pIDwgc2V0dGluZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZXR0aW5nID0gc2V0dGluZ3NfMVtfaV07XG4gICAgICAgICAgICBzZXR0aW5nLmxldmVsID0gc2V0dGluZy5sb2dHcm91cFJ1bGUubGV2ZWw7XG4gICAgICAgICAgICBzZXR0aW5nLmxvZ0Zvcm1hdC5zaG93VGltZVN0YW1wID0gc2V0dGluZy5sb2dHcm91cFJ1bGUubG9nRm9ybWF0LnNob3dUaW1lU3RhbXA7XG4gICAgICAgICAgICBzZXR0aW5nLmxvZ0Zvcm1hdC5zaG93TG9nZ2VyTmFtZSA9IHNldHRpbmcubG9nR3JvdXBSdWxlLmxvZ0Zvcm1hdC5zaG93TG9nZ2VyTmFtZTtcbiAgICAgICAgICAgIHNldHRpbmcubG9nRm9ybWF0LmRhdGVGb3JtYXQuZm9ybWF0RW51bSA9IHNldHRpbmcubG9nR3JvdXBSdWxlLmxvZ0Zvcm1hdC5kYXRlRm9ybWF0LmZvcm1hdEVudW07XG4gICAgICAgIH1cbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJlc2V0IGFsbCBzZXR0aW5ncyBmb3IgZ3JvdXAgXCIgKyBpZEdyb3VwKTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5Q29udHJvbEltcGwucHJvdG90eXBlLl9nZXRMb2dHcm91cFJ1blRpbWVTZXR0aW5nc0ZvciA9IGZ1bmN0aW9uIChpZEdyb3VwKSB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IFtdO1xuICAgICAgICBpZiAoaWRHcm91cCA9PT0gXCJhbGxcIikge1xuICAgICAgICAgICAgc2V0dGluZ3MgPSB0aGlzLl9zZXR0aW5ncy5nZXRMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tJbmRleChpZEdyb3VwKTtcbiAgICAgICAgICAgIHNldHRpbmdzLnB1c2godGhpcy5fc2V0dGluZ3MuZ2V0TG9nR3JvdXBSdW50aW1lU2V0dGluZ3MoKVtpZEdyb3VwXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLnByb3RvdHlwZS5fY2hlY2tJbmRleCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuX3NldHRpbmdzLmdldExvZ0dyb3VwUnVudGltZVNldHRpbmdzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGV4LCB1c2UgbGlzdExvZ0dyb3VwcyB0byBmaW5kIG91dCBhIHZhbGlkIG9uZS5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnlDb250cm9sSW1wbC5faGVscCA9IFwiXFxuICBoZWxwKCk6IHZvaWRcXG4gICAgKiogU2hvd3MgdGhpcyBoZWxwLlxcblxcbiAgZXhhbXBsZSgpOiB2b2lkXFxuICAgICoqIFNob3dzIGFuIGV4YW1wbGUgb2YgdXNhZ2UuXFxuXFxuICBzaG93U2V0dGluZ3MoaWQ6IG51bWJlciB8IFxcXCJhbGxcXFwiKTogdm9pZFxcbiAgICAqKiBQcmludHMgc2V0dGluZ3MgZm9yIGdpdmVuIGdyb3VwIGlkLCBcXFwiYWxsXFxcIiBmb3IgYWxsIGdyb3VwLlxcblxcbiAgY2hhbmdlKHNldHRpbmdzOiBMb2dHcm91cENvbnRyb2xTZXR0aW5ncyk6IHZvaWRcXG4gICAgKiogQ2hhbmdlcyB0aGUgY3VycmVudCBzZXR0aW5ncyBmb3Igb25lIG9yIGFsbCBsb2cgZ3JvdXBzLlxcbiAgICAqKlxcbiAgICAgICBMb2dHcm91cENvbnRyb2xTZXR0aW5ncywgcHJvcGVydGllcyBvZiBvYmplY3Q6XFxuICAgICAgICAgZ3JvdXA6IG51bWJlciB8IFxcXCJhbGxcXFwiXFxuICAgICAgICAgICAqKiBBcHBseSB0byBzcGVjaWZpYyBncm91cCwgb3IgXFxcImFsbFxcXCIuXFxuICAgICAgICAgICAqKiBSZXF1aXJlZFxcblxcbiAgICAgICAgIGxvZ0xldmVsOiBcXFwiRmF0YWxcXFwiIHwgXFxcIkVycm9yXFxcIiB8IFxcXCJXYXJuXFxcIiB8IFxcXCJJbmZvXFxcIiB8IFxcXCJEZWJ1Z1xcXCIgfCBcXFwiVHJhY2VcXFwiIHwgdW5kZWZpbmVkXFxuICAgICAgICAgICAqKiBTZXQgbG9nIGxldmVsLCB1bmRlZmluZWQgd2lsbCBub3QgY2hhbmdlIHRoZSBzZXR0aW5nLlxcbiAgICAgICAgICAgKiogT3B0aW9uYWxcXG5cXG4gICAgICAgICBsb2dGb3JtYXQ6IFxcXCJEZWZhdWx0XFxcIiB8IFxcXCJZZWFyTW9udGhEYXlUaW1lXFxcIiB8IFxcXCJZZWFyRGF5TW9udGhXaXRoRnVsbFRpbWVcXFwiIHwgXFxcIlllYXJEYXlNb250aFRpbWVcXFwiIHwgdW5kZWZpbmVkXFxuICAgICAgICAgICAqKiBTZXQgdGhlIGxvZyBmb3JtYXQsIHVuZGVmaW5lZCB3aWxsIG5vdCBjaGFuZ2UgdGhlIHNldHRpbmcuXFxuICAgICAgICAgICAqKiBPcHRpb25hbFxcblxcbiAgICAgICAgIHNob3dUaW1lc3RhbXA6IGJvb2xlYW4gfCB1bmRlZmluZWRcXG4gICAgICAgICAgICoqIFdoZXRoZXIgdG8gc2hvdyB0aW1lc3RhbXAsIHVuZGVmaW5lZCB3aWxsIG5vdCBjaGFuZ2UgdGhlIHNldHRpbmcuXFxuICAgICAgICAgICAqKiBPcHRpb25hbFxcblxcbiAgICAgICAgIHNob3dMb2dnZXJOYW1lOiBib29sZWFuIHwgdW5kZWZpbmVkXFxuICAgICAgICAgICAqKiBXaGV0aGVyIHRvIHNob3cgdGhlIGxvZ2dlciBuYW1lLCB1bmRlZmluZWQgd2lsbCBub3QgY2hhbmdlIHRoZSBzZXR0aW5nLlxcbiAgICAgICAgICAgKiogT3B0aW9uYWxcXG5cXG4gIHJlc2V0KGlkOiBudW1iZXIgfCBcXFwiYWxsXFxcIik6IHZvaWRcXG4gICAgKiogUmVzZXRzIGV2ZXJ5dGhpbmcgdG8gb3JpZ2luYWwgdmFsdWVzLCBmb3Igb25lIHNwZWNpZmljIG9yIGZvciBhbGwgZ3JvdXBzLlxcblxcbiAgaGVscCgpOlxcbiAgICAqKiBTaG93cyB0aGlzIGhlbHAuXFxuXCI7XG4gICAgTG9nZ2VyRmFjdG9yeUNvbnRyb2xJbXBsLl9leGFtcGxlID0gXCJcXG4gIEV4YW1wbGVzOlxcbiAgICBjaGFuZ2Uoe2dyb3VwOiBcXFwiYWxsXFxcIiwgbG9nTGV2ZWw6IFxcXCJJbmZvXFxcIn0pXFxuICAgICAgKiogQ2hhbmdlIGxvZ2xldmVsIHRvIEluZm8gZm9yIGFsbCBncm91cHMuXFxuXFxuICAgIGNoYW5nZSh7Z3JvdXA6IDEsIHJlY3Vyc2l2ZTpmYWxzZSwgbG9nTGV2ZWw6IFxcXCJXYXJuXFxcIn0pXFxuICAgICAgKiogQ2hhbmdlIGxvZ0xldmVsIGZvciBncm91cCAxIHRvIFdhcm4uXFxuXFxuICAgIGNoYW5nZSh7Z3JvdXA6IFxcXCJhbGxcXFwiLCBsb2dMZXZlbDogXFxcIkRlYnVnXFxcIiwgbG9nRm9ybWF0OiBcXFwiWWVhckRheU1vbnRoVGltZVxcXCIsIHNob3dUaW1lc3RhbXA6ZmFsc2UsIHNob3dMb2dnZXJOYW1lOmZhbHNlfSlcXG4gICAgICAqKiBDaGFuZ2UgbG9nbGV2ZWwgdG8gRGVidWcgZm9yIGFsbCBncm91cHMsIGFwcGx5IGZvcm1hdCwgZG8gbm90IHNob3cgdGltZXN0YW1wIGFuZCBsb2dnZXIgbmFtZXMuXFxuXCI7XG4gICAgcmV0dXJuIExvZ2dlckZhY3RvcnlDb250cm9sSW1wbDtcbn0oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2dHcm91cENvbnRyb2wuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2F0ZWdvcnlTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vbG9nL2NhdGVnb3J5L0NhdGVnb3J5U2VydmljZVwiKTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vbG9nL0xvZ2dlck9wdGlvbnNcIik7XG52YXIgTWVzc2FnZVV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvTWVzc2FnZVV0aWxzXCIpO1xudmFyIEV4dGVuc2lvbkhlbHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXh0ZW5zaW9uSGVscGVyKCkge1xuICAgICAgICAvLyBQcml2YXRlIGNvbnN0cnVjdG9yXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHdpbmRvdyBldmVudCBsaXN0ZW5lciB0byBsaXN0ZW4gdG8gbWVzc2FnZXMgKGZyb20gZXh0ZW5zaW9ucykuXG4gICAgICogQ2FuIGJlIHJlZ2lzdGVyZWQvZW5hYmxlZCBvbmx5IG9uY2UuXG4gICAgICovXG4gICAgRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIUV4dGVuc2lvbkhlbHBlci5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IGV2dC5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChtc2cgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgRXh0ZW5zaW9uSGVscGVyLnByb2Nlc3NNZXNzYWdlRnJvbUV4dGVuc2lvbihtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIEV4dGVuc2lvbkhlbHBlci5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXh0ZW5zaW9uSGVscGVyLnByb2Nlc3NNZXNzYWdlRnJvbUV4dGVuc2lvbiA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKCFFeHRlbnNpb25IZWxwZXIucmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgaWYgKG1zZy5mcm9tID09PSBcInRzbC1leHRlbnNpb25cIikge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBtc2cuZGF0YTtcbiAgICAgICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlZ2lzdGVyXCI6XG4gICAgICAgICAgICAgICAgICAgIEV4dGVuc2lvbkhlbHBlci5lbmFibGVFeHRlbnNpb25JbnRlZ3JhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVxdWVzdC1jaGFuZ2UtbG9nbGV2ZWxcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlUmVxdWVzdCA9IGRhdGEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXRzQXBwbGllZCA9IEV4dGVuc2lvbkhlbHBlci5hcHBseUxvZ0xldmVsKHZhbHVlUmVxdWVzdC5jYXRlZ29yeUlkLCB2YWx1ZVJlcXVlc3QubG9nTGV2ZWwsIHZhbHVlUmVxdWVzdC5yZWN1cnNpdmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2F0c0FwcGxpZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VuZCBjaGFuZ2VzIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIEV4dGVuc2lvbkhlbHBlci5zZW5kQ2F0ZWdvcmllc1J1bnRpbWVVcGRhdGVNZXNzYWdlKGNhdHNBcHBsaWVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gY29tbWFuZCB0byBwcm9jZXNzIG1lc3NhZ2UgZnJvbSBleHRlbnNpb24sIGNvbW1hbmQgd2FzOiBcIiArIGRhdGEudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSGVscGVyLnNlbmRDYXRlZ29yeUxvZ01lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmICghRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2F0ZWdvcnlJZHMgPSBtc2cuY2F0ZWdvcmllcy5tYXAoZnVuY3Rpb24gKGNhdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhdC5pZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb250ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJsb2ctbWVzc2FnZVwiLFxuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzOiBjYXRlZ29yeUlkcyxcbiAgICAgICAgICAgICAgICBlcnJvckFzU3RhY2s6IG1zZy5lcnJvckFzU3RhY2ssXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkTWVzc2FnZTogTWVzc2FnZVV0aWxzXzEuTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckRlZmF1bHRNZXNzYWdlKG1zZywgZmFsc2UpLFxuICAgICAgICAgICAgICAgIGxvZ0xldmVsOiBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWxbbXNnLmxldmVsXS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZy5tZXNzYWdlQXNTdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRFcnJvck1lc3NhZ2U6IG1zZy5pc1Jlc29sdmVkRXJyb3JNZXNzYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtZXNzYWdlID0ge1xuICAgICAgICAgICAgZGF0YTogY29udGVudCxcbiAgICAgICAgICAgIGZyb206IFwidHNsLWxvZ2dpbmdcIixcbiAgICAgICAgfTtcbiAgICAgICAgRXh0ZW5zaW9uSGVscGVyLnNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSGVscGVyLnNlbmRDYXRlZ29yaWVzUnVudGltZVVwZGF0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAoY2F0ZWdvcmllcykge1xuICAgICAgICBpZiAoIUV4dGVuc2lvbkhlbHBlci5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlcnZpY2UgPSBDYXRlZ29yeVNlcnZpY2VfMS5DYXRlZ29yeVNlcnZpY2VJbXBsLmdldEluc3RhbmNlKCk7XG4gICAgICAgIHZhciBjYXRMZXZlbHMgPSB7IGNhdGVnb3JpZXM6IEFycmF5KCkgfTtcbiAgICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjYXQpIHtcbiAgICAgICAgICAgIHZhciBjYXRTZXR0aW5ncyA9IHNlcnZpY2UuZ2V0Q2F0ZWdvcnlTZXR0aW5ncyhjYXQpO1xuICAgICAgICAgICAgaWYgKGNhdFNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYXRMZXZlbHMuY2F0ZWdvcmllcy5wdXNoKHsgaWQ6IGNhdC5pZCwgbG9nTGV2ZWw6IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbFtjYXRTZXR0aW5ncy5sb2dMZXZlbF0udG9TdHJpbmcoKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb250ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJjYXRlZ29yaWVzLXJ0LXVwZGF0ZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGNhdExldmVscyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBkYXRhOiBjb250ZW50LFxuICAgICAgICAgICAgZnJvbTogXCJ0c2wtbG9nZ2luZ1wiXG4gICAgICAgIH07XG4gICAgICAgIEV4dGVuc2lvbkhlbHBlci5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIEV4dGVuc2lvbkhlbHBlci5zZW5kUm9vdENhdGVnb3JpZXNUb0V4dGVuc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFFeHRlbnNpb25IZWxwZXIucmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLmdldFJvb3RDYXRlZ29yaWVzKCkubWFwKGZ1bmN0aW9uIChjYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBFeHRlbnNpb25IZWxwZXIuZ2V0Q2F0ZWdvcnlBc0pTT04oY2F0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb250ZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJyb290LWNhdGVnb3JpZXMtdHJlZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGNhdGVnb3JpZXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICBkYXRhOiBjb250ZW50LFxuICAgICAgICAgICAgZnJvbTogXCJ0c2wtbG9nZ2luZ1wiXG4gICAgICAgIH07XG4gICAgICAgIEV4dGVuc2lvbkhlbHBlci5zZW5kTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIGV4dGVuc2lvbiBpbnRlZ3JhdGlvbiBpcyBlbmFibGVkLCB3aWxsIHNlbmQgdGhlIHJvb3QgY2F0ZWdvcmllcyBvdmVyIHRvIHRoZSBleHRlbnNpb24uXG4gICAgICogT3RoZXJ3aXNlIGRvZXMgbm90aGluZy5cbiAgICAgKi9cbiAgICBFeHRlbnNpb25IZWxwZXIuZ2V0Q2F0ZWdvcnlBc0pTT04gPSBmdW5jdGlvbiAoY2F0KSB7XG4gICAgICAgIHZhciBjaGlsZENhdGVnb3JpZXMgPSBjYXQuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIEV4dGVuc2lvbkhlbHBlci5nZXRDYXRlZ29yeUFzSlNPTihjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkQ2F0ZWdvcmllcyxcbiAgICAgICAgICAgIGlkOiBjYXQuaWQsXG4gICAgICAgICAgICBsb2dMZXZlbDogTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsW2NhdC5sb2dMZXZlbF0udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG5hbWU6IGNhdC5uYW1lLFxuICAgICAgICAgICAgcGFyZW50SWQ6IChjYXQucGFyZW50ICE9IG51bGwgPyBjYXQucGFyZW50LmlkIDogbnVsbCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBFeHRlbnNpb25IZWxwZXIuYXBwbHlMb2dMZXZlbCA9IGZ1bmN0aW9uIChjYXRlZ29yeUlkLCBsb2dMZXZlbCwgcmVjdXJzaXZlKSB7XG4gICAgICAgIHZhciBjYXRzID0gW107XG4gICAgICAgIHZhciBjYXRlZ29yeSA9IENhdGVnb3J5U2VydmljZV8xLkNhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKS5nZXRDYXRlZ29yeUJ5SWQoY2F0ZWdvcnlJZCk7XG4gICAgICAgIGlmIChjYXRlZ29yeSAhPSBudWxsKSB7XG4gICAgICAgICAgICBFeHRlbnNpb25IZWxwZXIuX2FwcGx5TG9nTGV2ZWxSZWN1cnNpdmUoY2F0ZWdvcnksIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5mcm9tU3RyaW5nKGxvZ0xldmVsKSwgcmVjdXJzaXZlLCBjYXRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IGNoYW5nZSBsb2cgbGV2ZWwsIGZhaWxlZCB0byBmaW5kIGNhdGVnb3J5IHdpdGggaWQ6IFwiICsgY2F0ZWdvcnlJZCk7XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2F0cztcbiAgICB9O1xuICAgIEV4dGVuc2lvbkhlbHBlci5fYXBwbHlMb2dMZXZlbFJlY3Vyc2l2ZSA9IGZ1bmN0aW9uIChjYXRlZ29yeSwgbG9nTGV2ZWwsIHJlY3Vyc2l2ZSwgY2F0cykge1xuICAgICAgICB2YXIgY2F0ZWdvcnlTZXR0aW5ncyA9IENhdGVnb3J5U2VydmljZV8xLkNhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKS5nZXRDYXRlZ29yeVNldHRpbmdzKGNhdGVnb3J5KTtcbiAgICAgICAgaWYgKGNhdGVnb3J5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2F0ZWdvcnlTZXR0aW5ncy5sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgICAgICAgICAgY2F0cy5wdXNoKGNhdGVnb3J5KTtcbiAgICAgICAgICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBFeHRlbnNpb25IZWxwZXIuX2FwcGx5TG9nTGV2ZWxSZWN1cnNpdmUoY2hpbGQsIGxvZ0xldmVsLCByZWN1cnNpdmUsIGNhdHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFeHRlbnNpb25IZWxwZXIuZ2V0QWxsQ2F0ZWdvcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhdHMgPSBbXTtcbiAgICAgICAgdmFyIGFkZENhdHMgPSBmdW5jdGlvbiAoY2F0LCBhbGxDYXRzKSB7XG4gICAgICAgICAgICBhbGxDYXRzLnB1c2goY2F0KTtcbiAgICAgICAgICAgIGNhdC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjYXRDaGlsZCkge1xuICAgICAgICAgICAgICAgIGFkZENhdHMoY2F0Q2hpbGQsIGFsbENhdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIENhdGVnb3J5U2VydmljZV8xLkNhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKS5nZXRSb290Q2F0ZWdvcmllcygpLmZvckVhY2goZnVuY3Rpb24gKGNhdCkge1xuICAgICAgICAgICAgYWRkQ2F0cyhjYXQsIGNhdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhdHM7XG4gICAgfTtcbiAgICBFeHRlbnNpb25IZWxwZXIuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmICghRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LnBvc3RNZXNzYWdlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UobXNnLCBcIipcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqICBFeHRlbnNpb24gZnJhbWV3b3JrIHdpbGwgY2FsbCB0aGlzIHRvIGVuYWJsZSB0aGUgaW50ZWdyYXRpb24gYmV0d2VlbiB0d28sXG4gICAgICogIGFmdGVyIHRoaXMgY2FsbCB0aGUgZnJhbWV3b3JrIHdpbGwgcmVzcG9uZCB3aXRoIHBvc3RNZXNzYWdlKCkgbWVzc2FnZXMuXG4gICAgICovXG4gICAgRXh0ZW5zaW9uSGVscGVyLmVuYWJsZUV4dGVuc2lvbkludGVncmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIUV4dGVuc2lvbkhlbHBlci5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluc3RhbmNlID0gQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpO1xuICAgICAgICBpbnN0YW5jZS5lbmFibGVFeHRlbnNpb25JbnRlZ3JhdGlvbigpO1xuICAgICAgICAvLyBTZW5kIG92ZXIgYWxsIGNhdGVnb3JpZXNcbiAgICAgICAgRXh0ZW5zaW9uSGVscGVyLnNlbmRSb290Q2F0ZWdvcmllc1RvRXh0ZW5zaW9uKCk7XG4gICAgICAgIC8vIFNlbmQgb3ZlciB0aGUgY3VycmVudCBydW50aW1lIGxldmVsc1xuICAgICAgICB2YXIgY2F0cyA9IEV4dGVuc2lvbkhlbHBlci5nZXRBbGxDYXRlZ29yaWVzKCk7XG4gICAgICAgIEV4dGVuc2lvbkhlbHBlci5zZW5kQ2F0ZWdvcmllc1J1bnRpbWVVcGRhdGVNZXNzYWdlKGNhdHMpO1xuICAgIH07XG4gICAgRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gRXh0ZW5zaW9uSGVscGVyO1xufSgpKTtcbmV4cG9ydHMuRXh0ZW5zaW9uSGVscGVyID0gRXh0ZW5zaW9uSGVscGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXh0ZW5zaW9uSGVscGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBMb2cgbGV2ZWwgZm9yIGEgbG9nZ2VyLlxuICovXG52YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJUcmFjZVwiXSA9IDBdID0gXCJUcmFjZVwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRGVidWdcIl0gPSAxXSA9IFwiRGVidWdcIjtcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkluZm9cIl0gPSAyXSA9IFwiSW5mb1wiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV2FyblwiXSA9IDNdID0gXCJXYXJuXCI7XG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFcnJvclwiXSA9IDRdID0gXCJFcnJvclwiO1xuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRmF0YWxcIl0gPSA1XSA9IFwiRmF0YWxcIjtcbn0pKExvZ0xldmVsID0gZXhwb3J0cy5Mb2dMZXZlbCB8fCAoZXhwb3J0cy5Mb2dMZXZlbCA9IHt9KSk7XG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1uYW1lc3BhY2UgKi9cbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIExvZ0xldmVsIGJhc2VkIG9uIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSB2YWwgVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7TG9nTGV2ZWx9LCBFcnJvciBpcyB0aHJvd24gaWYgaW52YWxpZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0cmFjZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBMb2dMZXZlbC5UcmFjZTtcbiAgICAgICAgICAgIGNhc2UgXCJkZWJ1Z1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBMb2dMZXZlbC5EZWJ1ZztcbiAgICAgICAgICAgIGNhc2UgXCJpbmZvXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvZ0xldmVsLkluZm87XG4gICAgICAgICAgICBjYXNlIFwid2FyblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBMb2dMZXZlbC5XYXJuO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvZ0xldmVsLkVycm9yO1xuICAgICAgICAgICAgY2FzZSBcImZhdGFsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvZ0xldmVsLkZhdGFsO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB2YWx1ZSBmb3IgY29udmVyc2lvbjogXCIgKyB2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIExvZ0xldmVsLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xufSkoTG9nTGV2ZWwgPSBleHBvcnRzLkxvZ0xldmVsIHx8IChleHBvcnRzLkxvZ0xldmVsID0ge30pKTtcbi8qIHRzbGludDpkaXNhYmxlOmVuYWJsZS1uYW1lc3BhY2UgKi9cbi8qKlxuICogV2hlcmUgdG8gbG9nIHRvPyBQaWNrIG9uZSBvZiB0aGUgY29uc3RhbnRzLiBDdXN0b20gcmVxdWlyZXMgYSBjYWxsYmFjayB0byBiZSBwcmVzZW50LCBzZWUgTEZTZXJ2aWNlLmNyZWF0ZUxvZ2dlckZhY3RvcnkoLi4uKVxuICogd2hlcmUgdGhpcyBjb21lcyBpbnRvIHBsYXkuXG4gKi9cbnZhciBMb2dnZXJUeXBlO1xuKGZ1bmN0aW9uIChMb2dnZXJUeXBlKSB7XG4gICAgTG9nZ2VyVHlwZVtMb2dnZXJUeXBlW1wiQ29uc29sZVwiXSA9IDBdID0gXCJDb25zb2xlXCI7XG4gICAgTG9nZ2VyVHlwZVtMb2dnZXJUeXBlW1wiTWVzc2FnZUJ1ZmZlclwiXSA9IDFdID0gXCJNZXNzYWdlQnVmZmVyXCI7XG4gICAgTG9nZ2VyVHlwZVtMb2dnZXJUeXBlW1wiQ3VzdG9tXCJdID0gMl0gPSBcIkN1c3RvbVwiO1xufSkoTG9nZ2VyVHlwZSA9IGV4cG9ydHMuTG9nZ2VyVHlwZSB8fCAoZXhwb3J0cy5Mb2dnZXJUeXBlID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyBzZXZlcmFsIGRhdGUgZW51bXMgdXNlZCBmb3IgZm9ybWF0dGluZyBhIGRhdGUuXG4gKi9cbnZhciBEYXRlRm9ybWF0RW51bTtcbihmdW5jdGlvbiAoRGF0ZUZvcm1hdEVudW0pIHtcbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBhczogeWVhci1tb250aC1kYXkgaG91cjptaW51dGU6c2Vjb25kLG1pbGxpcyAtPiAxOTk5LTAyLTEyIDIzOjU5OjU5LDEyM1xuICAgICAqIE5vdGUgdGhlIGRhdGUgc2VwYXJhdG9yIGNhbiBiZSBzZXQgc2VwYXJhdGVseS5cbiAgICAgKi9cbiAgICBEYXRlRm9ybWF0RW51bVtEYXRlRm9ybWF0RW51bVtcIkRlZmF1bHRcIl0gPSAwXSA9IFwiRGVmYXVsdFwiO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIGFzOiB5ZWFyLW1vbnRoLWRheSBob3VyOm1pbnV0ZTpzZWNvbmQgLT4gMTk5OS0wMi0xMiAyMzo1OTo1OVxuICAgICAqIE5vdGUgdGhlIGRhdGUgc2VwYXJhdG9yIGNhbiBiZSBzZXQgc2VwYXJhdGVseS5cbiAgICAgKi9cbiAgICBEYXRlRm9ybWF0RW51bVtEYXRlRm9ybWF0RW51bVtcIlllYXJNb250aERheVRpbWVcIl0gPSAxXSA9IFwiWWVhck1vbnRoRGF5VGltZVwiO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIGFzOiB5ZWFyLWRheS1tb250aCBob3VyOm1pbnV0ZTpzZWNvbmQsbWlsbGlzIC0+IDE5OTktMTItMDIgMjM6NTk6NTksMTIzXG4gICAgICogTm90ZSB0aGUgZGF0ZSBzZXBhcmF0b3IgY2FuIGJlIHNldCBzZXBhcmF0ZWx5LlxuICAgICAqL1xuICAgIERhdGVGb3JtYXRFbnVtW0RhdGVGb3JtYXRFbnVtW1wiWWVhckRheU1vbnRoV2l0aEZ1bGxUaW1lXCJdID0gMl0gPSBcIlllYXJEYXlNb250aFdpdGhGdWxsVGltZVwiO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXlzIGFzOiB5ZWFyLWRheS1tb250aCBob3VyOm1pbnV0ZTpzZWNvbmQgLT4gMTk5OS0xMi0wMiAyMzo1OTo1OVxuICAgICAqIE5vdGUgdGhlIGRhdGUgc2VwYXJhdG9yIGNhbiBiZSBzZXQgc2VwYXJhdGVseS5cbiAgICAgKi9cbiAgICBEYXRlRm9ybWF0RW51bVtEYXRlRm9ybWF0RW51bVtcIlllYXJEYXlNb250aFRpbWVcIl0gPSAzXSA9IFwiWWVhckRheU1vbnRoVGltZVwiO1xufSkoRGF0ZUZvcm1hdEVudW0gPSBleHBvcnRzLkRhdGVGb3JtYXRFbnVtIHx8IChleHBvcnRzLkRhdGVGb3JtYXRFbnVtID0ge30pKTtcbi8qIHRzbGludDpkaXNhYmxlOm5vLW5hbWVzcGFjZSAqL1xuKGZ1bmN0aW9uIChEYXRlRm9ybWF0RW51bSkge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgTG9nTGV2ZWwgYmFzZWQgb24gc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHBhcmFtIHZhbCBWYWx1ZVxuICAgICAqIEByZXR1cm5zIHtMb2dMZXZlbH0sIEVycm9yIGlzIHRocm93biBpZiBpbnZhbGlkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh2YWwudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZUZvcm1hdEVudW0uRGVmYXVsdDtcbiAgICAgICAgICAgIGNhc2UgXCJ5ZWFybW9udGhkYXlUaW1lXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVGb3JtYXRFbnVtLlllYXJNb250aERheVRpbWU7XG4gICAgICAgICAgICBjYXNlIFwieWVhcmRheW1vbnRod2l0aGZ1bGx0aW1lXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVGb3JtYXRFbnVtLlllYXJEYXlNb250aFdpdGhGdWxsVGltZTtcbiAgICAgICAgICAgIGNhc2UgXCJ5ZWFyZGF5bW9udGh0aW1lXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIERhdGVGb3JtYXRFbnVtLlllYXJEYXlNb250aFRpbWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHZhbHVlIGZvciBjb252ZXJzaW9uOiBcIiArIHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGF0ZUZvcm1hdEVudW0uZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG59KShEYXRlRm9ybWF0RW51bSA9IGV4cG9ydHMuRGF0ZUZvcm1hdEVudW0gfHwgKGV4cG9ydHMuRGF0ZUZvcm1hdEVudW0gPSB7fSkpO1xuLyogdHNsaW50OmRpc2FibGU6ZW5hYmxlLW5hbWVzcGFjZSAqL1xuLyoqXG4gKiBEYXRlRm9ybWF0IGNsYXNzLCBzdG9yZXMgZGF0YSBvbiBob3cgdG8gZm9ybWF0IGEgZGF0ZS5cbiAqL1xudmFyIERhdGVGb3JtYXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIHRvIGRlZmluZSB0aGUgZGF0ZWZvcm1hdCB1c2VkIGZvciBsb2dnaW5nLCBjYW4gYmUgY2FsbGVkIGVtcHR5IGFzIGl0IHVzZXMgZGVmYXVsdHMuXG4gICAgICogQHBhcmFtIGZvcm1hdEVudW0gRGF0ZUZvcm1hdEVudW0sIHVzZSBvbmUgb2YgdGhlIGNvbnN0YW50cyBmcm9tIHRoZSBlbnVtLiBEZWZhdWx0cyB0byBEYXRlRm9ybWF0RW51bS5EZWZhdWx0XG4gICAgICogQHBhcmFtIGRhdGVTZXBhcmF0b3IgU2VwYXJhdG9yIHVzZWQgYmV0d2VlbiBkYXRlcywgZGVmYXVsdHMgdG8gLVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGVGb3JtYXQoZm9ybWF0RW51bSwgZGF0ZVNlcGFyYXRvcikge1xuICAgICAgICBpZiAoZm9ybWF0RW51bSA9PT0gdm9pZCAwKSB7IGZvcm1hdEVudW0gPSBEYXRlRm9ybWF0RW51bS5EZWZhdWx0OyB9XG4gICAgICAgIGlmIChkYXRlU2VwYXJhdG9yID09PSB2b2lkIDApIHsgZGF0ZVNlcGFyYXRvciA9IFwiLVwiOyB9XG4gICAgICAgIHRoaXMuX2Zvcm1hdEVudW0gPSBmb3JtYXRFbnVtO1xuICAgICAgICB0aGlzLl9kYXRlU2VwYXJhdG9yID0gZGF0ZVNlcGFyYXRvcjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGVGb3JtYXQucHJvdG90eXBlLCBcImZvcm1hdEVudW1cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXRFbnVtO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9ybWF0RW51bSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0ZUZvcm1hdC5wcm90b3R5cGUsIFwiZGF0ZVNlcGFyYXRvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGVTZXBhcmF0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRlU2VwYXJhdG9yID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIERhdGVGb3JtYXQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZUZvcm1hdCh0aGlzLl9mb3JtYXRFbnVtLCB0aGlzLl9kYXRlU2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlRm9ybWF0O1xufSgpKTtcbmV4cG9ydHMuRGF0ZUZvcm1hdCA9IERhdGVGb3JtYXQ7XG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBsb2cgZm9ybWF0LCB3aGF0IHdpbGwgYSBsb2cgbGluZSBsb29rIGxpa2U/XG4gKi9cbnZhciBMb2dGb3JtYXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIExvZ0Zvcm1hdC4gQ2FuIGJlIGNyZWF0ZWQgd2l0aG91dCBwYXJhbWV0ZXJzIHdoZXJlIGl0IHdpbGwgdXNlIHNhbmUgZGVmYXVsdHMuXG4gICAgICogQHBhcmFtIGRhdGVGb3JtYXQgRGF0ZUZvcm1hdCAod2hhdCBuZWVkcyB0aGUgZGF0ZSBsb29rIGxpa2UgaW4gdGhlIGxvZyBsaW5lKVxuICAgICAqIEBwYXJhbSBzaG93VGltZVN0YW1wIFNob3cgZGF0ZSB0aW1lc3RhbXAgYXQgYWxsP1xuICAgICAqIEBwYXJhbSBzaG93TG9nZ2VyTmFtZSBTaG93IHRoZSBsb2dnZXIgbmFtZT9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2dGb3JtYXQoZGF0ZUZvcm1hdCwgc2hvd1RpbWVTdGFtcCwgc2hvd0xvZ2dlck5hbWUpIHtcbiAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT09IHZvaWQgMCkgeyBkYXRlRm9ybWF0ID0gbmV3IERhdGVGb3JtYXQoKTsgfVxuICAgICAgICBpZiAoc2hvd1RpbWVTdGFtcCA9PT0gdm9pZCAwKSB7IHNob3dUaW1lU3RhbXAgPSB0cnVlOyB9XG4gICAgICAgIGlmIChzaG93TG9nZ2VyTmFtZSA9PT0gdm9pZCAwKSB7IHNob3dMb2dnZXJOYW1lID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLl9zaG93VGltZVN0YW1wID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2hvd0xvZ2dlck5hbWUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kYXRlRm9ybWF0ID0gZGF0ZUZvcm1hdDtcbiAgICAgICAgdGhpcy5fc2hvd1RpbWVTdGFtcCA9IHNob3dUaW1lU3RhbXA7XG4gICAgICAgIHRoaXMuX3Nob3dMb2dnZXJOYW1lID0gc2hvd0xvZ2dlck5hbWU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dGb3JtYXQucHJvdG90eXBlLCBcImRhdGVGb3JtYXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlRm9ybWF0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nRm9ybWF0LnByb3RvdHlwZSwgXCJzaG93VGltZVN0YW1wXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2hvd1RpbWVTdGFtcDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dUaW1lU3RhbXAgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0Zvcm1hdC5wcm90b3R5cGUsIFwic2hvd0xvZ2dlck5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaG93TG9nZ2VyTmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dMb2dnZXJOYW1lID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBMb2dGb3JtYXQ7XG59KCkpO1xuZXhwb3J0cy5Mb2dGb3JtYXQgPSBMb2dGb3JtYXQ7XG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBsb2cgZm9ybWF0LCB3aGF0IHdpbGwgYSBsb2cgbGluZSBsb29rIGxpa2U/XG4gKi9cbnZhciBDYXRlZ29yeUxvZ0Zvcm1hdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGluc3RhbmNlIGRlZmluaW5nIHRoZSBjYXRlZ29yeSBsb2cgZm9ybWF0IHVzZWQuXG4gICAgICogQHBhcmFtIGRhdGVGb3JtYXQgRGF0ZSBmb3JtYXQgKHVzZXMgZGVmYXVsdCksIGZvciBkZXRhaWxzIHNlZSBEYXRlRm9ybWF0IGNsYXNzLlxuICAgICAqIEBwYXJhbSBzaG93VGltZVN0YW1wIFRydWUgdG8gc2hvdyB0aW1lc3RhbXAgaW4gdGhlIGxvZ2dpbmcsIGRlZmF1bHRzIHRvIHRydWUuXG4gICAgICogQHBhcmFtIHNob3dDYXRlZ29yeU5hbWUgVHJ1ZSB0byBzaG93IGNhdGVnb3J5IG5hbWUgaW4gdGhlIGxvZ2dpbmcsIGRlZmF1bHRzIHRvIHRydWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlMb2dGb3JtYXQoZGF0ZUZvcm1hdCwgc2hvd1RpbWVTdGFtcCwgc2hvd0NhdGVnb3J5TmFtZSkge1xuICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PT0gdm9pZCAwKSB7IGRhdGVGb3JtYXQgPSBuZXcgRGF0ZUZvcm1hdCgpOyB9XG4gICAgICAgIGlmIChzaG93VGltZVN0YW1wID09PSB2b2lkIDApIHsgc2hvd1RpbWVTdGFtcCA9IHRydWU7IH1cbiAgICAgICAgaWYgKHNob3dDYXRlZ29yeU5hbWUgPT09IHZvaWQgMCkgeyBzaG93Q2F0ZWdvcnlOYW1lID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLl9kYXRlRm9ybWF0ID0gZGF0ZUZvcm1hdDtcbiAgICAgICAgdGhpcy5fc2hvd1RpbWVTdGFtcCA9IHNob3dUaW1lU3RhbXA7XG4gICAgICAgIHRoaXMuX3Nob3dDYXRlZ29yeU5hbWUgPSBzaG93Q2F0ZWdvcnlOYW1lO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dGb3JtYXQucHJvdG90eXBlLCBcImRhdGVGb3JtYXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlRm9ybWF0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGF0ZUZvcm1hdCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dGb3JtYXQucHJvdG90eXBlLCBcInNob3dUaW1lU3RhbXBcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaG93VGltZVN0YW1wO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2hvd1RpbWVTdGFtcCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dGb3JtYXQucHJvdG90eXBlLCBcInNob3dDYXRlZ29yeU5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaG93Q2F0ZWdvcnlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2hvd0NhdGVnb3J5TmFtZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDYXRlZ29yeUxvZ0Zvcm1hdC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXRlZ29yeUxvZ0Zvcm1hdCh0aGlzLl9kYXRlRm9ybWF0LmNvcHkoKSwgdGhpcy5fc2hvd1RpbWVTdGFtcCwgdGhpcy5fc2hvd0NhdGVnb3J5TmFtZSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcnlMb2dGb3JtYXQ7XG59KCkpO1xuZXhwb3J0cy5DYXRlZ29yeUxvZ0Zvcm1hdCA9IENhdGVnb3J5TG9nRm9ybWF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nZ2VyT3B0aW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEYXRhU3RydWN0dXJlc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL0RhdGFTdHJ1Y3R1cmVzXCIpO1xudmFyIE1lc3NhZ2VVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL01lc3NhZ2VVdGlsc1wiKTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbnZhciBDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsKG1lc3NhZ2UsIGVycm9yLCBjYXRlZ29yaWVzLCBkYXRlLCBsZXZlbCwgbG9nRm9ybWF0LCByZWFkeSkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlZEVycm9yTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lcnJvckFzU3RhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5fY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXM7XG4gICAgICAgIHRoaXMuX2RhdGUgPSBkYXRlO1xuICAgICAgICB0aGlzLl9sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLl9sb2dGb3JtYXQgPSBsb2dGb3JtYXQ7XG4gICAgICAgIHRoaXMuX3JlYWR5ID0gcmVhZHk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5TG9nTWVzc2FnZUltcGwucHJvdG90eXBlLCBcImVycm9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJjYXRlZ29yaWVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2F0ZWdvcmllcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5TG9nTWVzc2FnZUltcGwucHJvdG90eXBlLCBcImRhdGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUsIFwibGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5TG9nTWVzc2FnZUltcGwucHJvdG90eXBlLCBcImxvZ0Zvcm1hdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0Zvcm1hdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5TG9nTWVzc2FnZUltcGwucHJvdG90eXBlLCBcImlzTWVzc2FnZUxvZ0RhdGFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgKHRoaXMuX21lc3NhZ2UpICE9PSBcInN0cmluZ1wiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUsIFwibWVzc2FnZUFzU3RyaW5nXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLl9tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2UubXNnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUsIFwibG9nRGF0YVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLl9tZXNzYWdlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJpc1Jlc29sdmVkRXJyb3JNZXNzYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWRFcnJvck1lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJlcnJvckFzU3RhY2tcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvckFzU3RhY2s7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvckFzU3RhY2sgPSBzdGFjaztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUuaXNSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5O1xuICAgIH07XG4gICAgQ2F0ZWdvcnlMb2dNZXNzYWdlSW1wbC5wcm90b3R5cGUuc2V0UmVhZHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSB2YWx1ZTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsLnByb3RvdHlwZSwgXCJyZXNvbHZlZEVycm9yTWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkRXJyb3JNZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRFcnJvck1lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIENhdGVnb3J5TG9nTWVzc2FnZUltcGw7XG59KCkpO1xuLyoqXG4gKiBBYnN0cmFjdCBjYXRlZ29yeSBsb2dnZXIsIHVzZSBhcyB5b3VyIGJhc2UgY2xhc3MgZm9yIG5ldyB0eXBlIG9mIGxvZ2dlcnMgKGl0XG4gKiBzYXZlcyB5b3UgYSBsb3Qgb2Ygd29yaykgYW5kIG92ZXJyaWRlIGRvTG9nKENhdGVnb3J5TG9nTWVzc2FnZSkuIFRoZSBtZXNzYWdlIGFyZ3VtZW50XG4gKiBwcm92aWRlcyBmdWxsIGFjY2VzcyB0byBhbnl0aGluZyByZWxhdGVkIHRvIHRoZSBsb2dnaW5nIGV2ZW50LlxuICogSWYgeW91IGp1c3Qgd2FudCB0aGUgc3RhbmRhcmQgbGluZSBvZiBsb2dnaW5nLCBjYWxsOiB0aGlzLmNyZWF0ZURlZmF1bHRMb2dNZXNzYWdlKG1zZykgb25cbiAqIHRoaXMgY2xhc3Mgd2hpY2ggd2lsbCByZXR1cm4geW91IHRoZSBmb3JtYXR0ZWQgbG9nIG1lc3NhZ2UgYXMgc3RyaW5nIChlLmcuIHRoZVxuICogZGVmYXVsdCBsb2dnZXJzIGFsbCB1c2UgdGhpcykuXG4gKi9cbnZhciBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyKHJvb3RDYXRlZ29yeSwgcnVudGltZVNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuYWxsTWVzc2FnZXMgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5MaW5rZWRMaXN0KCk7XG4gICAgICAgIHRoaXMucm9vdENhdGVnb3J5ID0gcm9vdENhdGVnb3J5O1xuICAgICAgICB0aGlzLnJ1bnRpbWVTZXR0aW5ncyA9IHJ1bnRpbWVTZXR0aW5ncztcbiAgICB9XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUudHJhY2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5hcHBseSh0aGlzLCBbTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLlRyYWNlLCBtc2csIG51bGwsIGZhbHNlXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5hcHBseSh0aGlzLCBbTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkRlYnVnLCBtc2csIG51bGwsIGZhbHNlXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nLmFwcGx5KHRoaXMsIFtMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuSW5mbywgbXNnLCBudWxsLCBmYWxzZV0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5hcHBseSh0aGlzLCBbTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLldhcm4sIG1zZywgbnVsbCwgZmFsc2VdLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgfTtcbiAgICBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5hcHBseSh0aGlzLCBbTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yLCBtc2csIGVycm9yLCBmYWxzZV0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLmZhdGFsID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9nLmFwcGx5KHRoaXMsIFtMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRmF0YWwsIG1zZywgZXJyb3IsIGZhbHNlXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUucmVzb2x2ZWQgPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cuYXBwbHkodGhpcywgW0xvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5FcnJvciwgbXNnLCBlcnJvciwgdHJ1ZV0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgbXNnLCBlcnJvcikge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2cuYXBwbHkodGhpcywgW2xldmVsLCBtc2csIGVycm9yLCBmYWxzZV0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLmdldFJvb3RDYXRlZ29yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdENhdGVnb3J5O1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUuY3JlYXRlRGVmYXVsdExvZ01lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHJldHVybiBNZXNzYWdlVXRpbHNfMS5NZXNzYWdlRm9ybWF0VXRpbHMucmVuZGVyRGVmYXVsdE1lc3NhZ2UobXNnLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBvcHRpb25hbCBtZXNzYWdlIGZvcm1hdHRlci4gQWxsIExvZ2dlclR5cGVzIChleGNlcHQgY3VzdG9tKSB3aWxsIHNlZSBpZlxuICAgICAqIHRoZXkgaGF2ZSB0aGlzLCBhbmQgaWYgc28gdXNlIGl0IHRvIGxvZy5cbiAgICAgKiBAcmV0dXJucyB7KChtZXNzYWdlOkNhdGVnb3J5TG9nTWVzc2FnZSk9PnN0cmluZyl8bnVsbH1cbiAgICAgKi9cbiAgICBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyLnByb3RvdHlwZS5fZ2V0TWVzc2FnZUZvcm1hdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhdGVnb3J5U2V0dGluZ3MgPSB0aGlzLnJ1bnRpbWVTZXR0aW5ncy5nZXRDYXRlZ29yeVNldHRpbmdzKHRoaXMucm9vdENhdGVnb3J5KTtcbiAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXBwZW4gYnV0IG1ha2UgdHMgaGFwcHlcbiAgICAgICAgaWYgKGNhdGVnb3J5U2V0dGluZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpZCBub3QgZmluZCBDYXRlZ29yeVNldHRpbmdzIGZvciByb290Q2F0ZWdvcnk6IFwiICsgdGhpcy5yb290Q2F0ZWdvcnkubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhdGVnb3J5U2V0dGluZ3MuZm9ybWF0dGVyTG9nTWVzc2FnZTtcbiAgICB9O1xuICAgIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIucHJvdG90eXBlLl9sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIG1zZywgZXJyb3IsIHJlc29sdmVkKSB7XG4gICAgICAgIGlmIChlcnJvciA9PT0gdm9pZCAwKSB7IGVycm9yID0gbnVsbDsgfVxuICAgICAgICBpZiAocmVzb2x2ZWQgPT09IHZvaWQgMCkgeyByZXNvbHZlZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gNF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMuX2xvZ0ludGVybmFsKGxldmVsLCAoKSA9PiBtc2csICgpID0+IGVycm9yLCByZXNvbHZlZCwgLi4uY2F0ZWdvcmllcyk7XG4gICAgICAgIHZhciBmdW5jdGlvbk1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1zZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZ1bmN0aW9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbG9nSW50ZXJuYWwuYXBwbHkodGhpcywgW2xldmVsLCBmdW5jdGlvbk1lc3NhZ2UsIGZ1bmN0aW9uRXJyb3IsIHJlc29sdmVkXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgIH07XG4gICAgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5wcm90b3R5cGUuX2xvZ0ludGVybmFsID0gZnVuY3Rpb24gKGxldmVsLCBtc2csIGVycm9yLCByZXNvbHZlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDQ7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDRdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9nQ2F0ZWdvcmllcyA9IFt0aGlzLnJvb3RDYXRlZ29yeV07XG4gICAgICAgIC8vIExvZyByb290IGNhdGVnb3J5IGJ5IGRlZmF1bHQgaWYgbm9uZSBwcmVzZW50XG4gICAgICAgIGlmICh0eXBlb2YgY2F0ZWdvcmllcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjYXRlZ29yaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxvZ0NhdGVnb3JpZXMgPSBsb2dDYXRlZ29yaWVzLmNvbmNhdChjYXRlZ29yaWVzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAhPT0gX3RoaXMucm9vdENhdGVnb3J5OyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5ID0gbG9nQ2F0ZWdvcmllc1tpXTtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYXZlIGEgbnVsbCBlbGVtZW50IHdpdGhpbiBjYXRlZ29yaWVzLCBhdCBpbmRleD1cIiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpc18xLnJ1bnRpbWVTZXR0aW5ncy5nZXRDYXRlZ29yeVNldHRpbmdzKGNhdGVnb3J5KTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhdGVnb3J5IHdpdGggcGF0aDogXCIgKyBjYXRlZ29yeS5nZXRDYXRlZ29yeVBhdGgoKSArIFwiIGlzIG5vdCByZWdpc3RlcmVkIHdpdGggdGhpcyBsb2dnZXIsIG1heWJlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ5b3UgcmVnaXN0ZXJlZCBpdCB3aXRoIGEgZGlmZmVyZW50IHJvb3QgbG9nZ2VyP1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5sb2dMZXZlbCA8PSBsZXZlbCkge1xuICAgICAgICAgICAgICAgIHZhciBhY3R1YWxFcnJvciA9IGVycm9yICE9PSBudWxsID8gZXJyb3IoKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGFjdHVhbEVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2dNZXNzYWdlID0gbmV3IENhdGVnb3J5TG9nTWVzc2FnZUltcGwobXNnKCksIGFjdHVhbEVycm9yLCBsb2dDYXRlZ29yaWVzLCBuZXcgRGF0ZSgpLCBsZXZlbCwgc2V0dGluZ3MubG9nRm9ybWF0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nTWVzc2FnZS5yZXNvbHZlZEVycm9yTWVzc2FnZSA9IHJlc29sdmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYWxsTWVzc2FnZXMuYWRkVGFpbChsb2dNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLnByb2Nlc3NNZXNzYWdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvZ01lc3NhZ2VfMSA9IG5ldyBDYXRlZ29yeUxvZ01lc3NhZ2VJbXBsKG1zZygpLCBhY3R1YWxFcnJvciwgbG9nQ2F0ZWdvcmllcywgbmV3IERhdGUoKSwgbGV2ZWwsIHNldHRpbmdzLmxvZ0Zvcm1hdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBsb2dNZXNzYWdlXzEucmVzb2x2ZWRFcnJvck1lc3NhZ2UgPSByZXNvbHZlZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmFsbE1lc3NhZ2VzLmFkZFRhaWwobG9nTWVzc2FnZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgTWVzc2FnZVV0aWxzXzEuTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckVycm9yKGFjdHVhbEVycm9yKS50aGVuKGZ1bmN0aW9uIChzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nTWVzc2FnZV8xLmVycm9yQXNTdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nTWVzc2FnZV8xLnNldFJlYWR5KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc01lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ01lc3NhZ2VfMS5lcnJvckFzU3RhY2sgPSBcIjxVTktOT1dOPiB1bmFibGUgdG8gZ2V0IHN0YWNrLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nTWVzc2FnZV8xLnNldFJlYWR5KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc01lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgLy8gR2V0IHRoZSBydW50aW1lIGxldmVscyBmb3IgZ2l2ZW4gY2F0ZWdvcmllcy4gSWYgdGhlaXIgbGV2ZWwgaXMgbG93ZXIgdGhhbiBnaXZlbiBsZXZlbCwgd2UgbG9nLlxuICAgICAgICAvLyBJbiBhZGRpdGlvbiB3ZSBwYXNzIGFsb25nIHdoaWNoIGNhdGVnb3J5L2NhdGVnb3JpZXMgd2UgbG9nIHRoaXMgc3RhdGVtZW50IGZvci5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dDYXRlZ29yaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEoaSk7XG4gICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyLnByb3RvdHlwZS5wcm9jZXNzTWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJhc2ljYWxseSB3ZSB3YWl0IHVudGlsIGVycm9ycyBhcmUgcmVzb2x2ZWQgKHRob3NlIG1lc3NhZ2VzXG4gICAgICAgIC8vIG1heSBub3QgYmUgcmVhZHkpLlxuICAgICAgICB2YXIgbXNncyA9IHRoaXMuYWxsTWVzc2FnZXM7XG4gICAgICAgIGlmIChtc2dzLmdldFNpemUoKSA+IDApIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gbXNncy5nZXRIZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1zZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbXNnLmlzUmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXNncy5yZW1vdmVIZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9Mb2cobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChtc2dzLmdldFNpemUoKSA+IDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcjtcbn0oKSk7XG5leHBvcnRzLkFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIgPSBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RDYXRlZ29yeUxvZ2dlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbnZhciBDYXRlZ29yeVNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL0NhdGVnb3J5U2VydmljZVwiKTtcbi8qKlxuICogQ2F0ZWdvcnkgZm9yIHVzZSB3aXRoIGNhdGVnb3JpemVkIGxvZ2dpbmcuXG4gKiBBdCBtaW5pbXVtIHlvdSBuZWVkIG9uZSBjYXRlZ29yeSwgd2hpY2ggd2lsbCBzZXJ2ZSBhcyB0aGUgcm9vdCBjYXRlZ29yeS5cbiAqIFlvdSBjYW4gY3JlYXRlIGNoaWxkIGNhdGVnb3JpZXMgKGxpa2UgYSB0cmVlKS4gWW91IGNhbiBoYXZlIG11bHRpcGxlIHJvb3RcbiAqIGNhdGVnb3JpZXMuXG4gKi9cbnZhciBDYXRlZ29yeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnkobmFtZSwgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yO1xuICAgICAgICBpZiAobmFtZS5pbmRleE9mKFwiI1wiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgIyBpbiBhIG5hbWUgb2YgYSBDYXRlZ29yeVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pZCA9IENhdGVnb3J5Lm5leHRJZCgpO1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLnJlZ2lzdGVyQ2F0ZWdvcnkodGhpcyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeS5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnkucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeS5wcm90b3R5cGUsIFwibG9nTGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dMZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2F0ZWdvcnkucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRDYXRlZ29yeUxvZ2dlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLl9sb2dnZXIpLnRyYWNlLmFwcGx5KF9hLCBbbXNnXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBDYXRlZ29yeS5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZENhdGVnb3J5TG9nZ2VyKCk7XG4gICAgICAgIChfYSA9IHRoaXMuX2xvZ2dlcikuZGVidWcuYXBwbHkoX2EsIFttc2ddLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIENhdGVnb3J5LnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRDYXRlZ29yeUxvZ2dlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLl9sb2dnZXIpLmluZm8uYXBwbHkoX2EsIFttc2ddLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIENhdGVnb3J5LnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRDYXRlZ29yeUxvZ2dlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLl9sb2dnZXIpLndhcm4uYXBwbHkoX2EsIFttc2ddLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIENhdGVnb3J5LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZENhdGVnb3J5TG9nZ2VyKCk7XG4gICAgICAgIChfYSA9IHRoaXMuX2xvZ2dlcikuZXJyb3IuYXBwbHkoX2EsIFttc2csIGVycm9yXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBDYXRlZ29yeS5wcm90b3R5cGUuZmF0YWwgPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRDYXRlZ29yeUxvZ2dlcigpO1xuICAgICAgICAoX2EgPSB0aGlzLl9sb2dnZXIpLmZhdGFsLmFwcGx5KF9hLCBbbXNnLCBlcnJvcl0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgQ2F0ZWdvcnkucHJvdG90eXBlLnJlc29sdmVkID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkQ2F0ZWdvcnlMb2dnZXIoKTtcbiAgICAgICAgKF9hID0gdGhpcy5fbG9nZ2VyKS5yZXNvbHZlZC5hcHBseShfYSwgW21zZywgZXJyb3JdLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIENhdGVnb3J5LnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAzXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkQ2F0ZWdvcnlMb2dnZXIoKTtcbiAgICAgICAgKF9hID0gdGhpcy5fbG9nZ2VyKS5sb2cuYXBwbHkoX2EsIFtsZXZlbCwgbXNnLCBlcnJvcl0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgQ2F0ZWdvcnkucHJvdG90eXBlLmdldENhdGVnb3J5UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubmFtZTtcbiAgICAgICAgdmFyIGNhdCA9IHRoaXMucGFyZW50O1xuICAgICAgICB3aGlsZSAoY2F0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhdC5uYW1lICsgXCIjXCIgKyByZXN1bHQ7XG4gICAgICAgICAgICBjYXQgPSBjYXQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnkucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGlkIGZvciB0aGlzIGNhdGVnb3J5ICh0aGlzXG4gICAgICAgICAqIGlzIGZvciBpbnRlcm5hbCBwdXJwb3NlcyBvbmx5KS5cbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gSWRcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDYXRlZ29yeS5wcm90b3R5cGUubG9hZENhdGVnb3J5TG9nZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvZ2dlcikge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyID0gQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLmdldExvZ2dlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2xvZ2dlciA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0aGlzLl9sb2dnZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBsb2FkIGEgbG9nZ2VyIGZvciBjYXRlZ29yeSAoc2hvdWxkIG5vdCBoYXBwZW4pOiBcIiArIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhdGVnb3J5Lm5leHRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIENhdGVnb3J5LmN1cnJlbnRJZCsrO1xuICAgIH07XG4gICAgQ2F0ZWdvcnkuY3VycmVudElkID0gMTtcbiAgICByZXR1cm4gQ2F0ZWdvcnk7XG59KCkpO1xuZXhwb3J0cy5DYXRlZ29yeSA9IENhdGVnb3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2F0ZWdvcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL0xvZ2dlck9wdGlvbnNcIik7XG4vKipcbiAqIERlZmF1bHQgY29uZmlndXJhdGlvbiwgY2FuIGJlIHVzZWQgdG8gaW5pdGlhbGx5IHNldCBhIGRpZmZlcmVudCBkZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAqIG9uIHRoZSBDYXRlZ29yeVNlcnZpY2VGYWN0b3J5LiBUaGlzIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgY2F0ZWdvcmllcyBhbHJlYWR5IHJlZ2lzdGVyZWQgKG9yXG4gKiByZWdpc3RlcmVkIGluIHRoZSBmdXR1cmUpLiBDYW4gYWxzbyBiZSBhcHBsaWVkIHRvIG9uZSBDYXRlZ29yeSAoYW5kIGNoaWxkcykuXG4gKi9cbnZhciBDYXRlZ29yeUNvbmZpZ3VyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBsb2dMZXZlbCBMb2cgbGV2ZWwgZm9yIGFsbCBsb2dnZXJzLCBkZWZhdWx0IGlzIExvZ0xldmVsLkVycm9yXG4gICAgICogQHBhcmFtIGxvZ2dlclR5cGUgV2hlcmUgdG8gbG9nLCBkZWZhdWx0IGlzIExvZ2dlclR5cGUuQ29uc29sZVxuICAgICAqIEBwYXJhbSBsb2dGb3JtYXQgV2hhdCBsb2dnaW5nIGZvcm1hdCB0byB1c2UsIHVzZSBkZWZhdWx0IGluc3RhbmNlLCBmb3IgZGVmYXVsdCB2YWx1ZXMgc2VlIENhdGVnb3J5TG9nRm9ybWF0LlxuICAgICAqIEBwYXJhbSBjYWxsQmFja0xvZ2dlciBPcHRpb25hbCBjYWxsYmFjaywgaWYgTG9nZ2VyVHlwZS5DdXN0b20gaXMgdXNlZCBhcyBsb2dnZXJUeXBlLiBJbiB0aGF0IGNhc2UgbXVzdCByZXR1cm4gYSBuZXcgTG9nZ2VyIGluc3RhbmNlLlxuICAgICAqICAgICAgICAgICAgSXQgaXMgcmVjb21tZW5kZWQgdG8gZXh0ZW5kIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIgdG8gbWFrZSB5b3VyIGN1c3RvbSBsb2dnZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlDb25maWd1cmF0aW9uKGxvZ0xldmVsLCBsb2dnZXJUeXBlLCBsb2dGb3JtYXQsIGNhbGxCYWNrTG9nZ2VyKSB7XG4gICAgICAgIGlmIChsb2dMZXZlbCA9PT0gdm9pZCAwKSB7IGxvZ0xldmVsID0gTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yOyB9XG4gICAgICAgIGlmIChsb2dnZXJUeXBlID09PSB2b2lkIDApIHsgbG9nZ2VyVHlwZSA9IExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkNvbnNvbGU7IH1cbiAgICAgICAgaWYgKGxvZ0Zvcm1hdCA9PT0gdm9pZCAwKSB7IGxvZ0Zvcm1hdCA9IG5ldyBMb2dnZXJPcHRpb25zXzEuQ2F0ZWdvcnlMb2dGb3JtYXQoKTsgfVxuICAgICAgICBpZiAoY2FsbEJhY2tMb2dnZXIgPT09IHZvaWQgMCkgeyBjYWxsQmFja0xvZ2dlciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fZm9ybWF0dGVyTG9nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gbG9nTGV2ZWw7XG4gICAgICAgIHRoaXMuX2xvZ2dlclR5cGUgPSBsb2dnZXJUeXBlO1xuICAgICAgICB0aGlzLl9sb2dGb3JtYXQgPSBsb2dGb3JtYXQ7XG4gICAgICAgIHRoaXMuX2NhbGxCYWNrTG9nZ2VyID0gY2FsbEJhY2tMb2dnZXI7XG4gICAgICAgIGlmICh0aGlzLl9sb2dnZXJUeXBlID09PSBMb2dnZXJPcHRpb25zXzEuTG9nZ2VyVHlwZS5DdXN0b20gJiYgdGhpcy5jYWxsQmFja0xvZ2dlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWYgeW91IHNwZWNpZnkgbG9nZ2VyVHlwZSB0byBiZSBDdXN0b20sIHlvdSBtdXN0IHByb3ZpZGUgdGhlIGNhbGxCYWNrTG9nZ2VyIGFyZ3VtZW50XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLCBcImxvZ0xldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLCBcImxvZ2dlclR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dnZXJUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlDb25maWd1cmF0aW9uLnByb3RvdHlwZSwgXCJsb2dGb3JtYXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dGb3JtYXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLCBcImNhbGxCYWNrTG9nZ2VyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbEJhY2tMb2dnZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeUNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLCBcImZvcm1hdHRlckxvZ01lc3NhZ2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBmb3JtYXR0ZXJMb2dNZXNzYWdlIGZ1bmN0aW9uLCBzZWUgY29tbWVudCBvbiB0aGUgc2V0dGVyLlxuICAgICAgICAgKiBAcmV0dXJucyB7KChtZXNzYWdlOkNhdGVnb3J5TG9nTWVzc2FnZSk9PnN0cmluZyl8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGRlZmF1bHQgZm9ybWF0dGVyTG9nTWVzc2FnZSBmdW5jdGlvbiwgaWYgc2V0IGl0IGlzIGFwcGxpZWQgdG8gYWxsIHR5cGUgb2YgbG9nZ2VycyBleGNlcHQgZm9yIGEgY3VzdG9tIGxvZ2dlci5cbiAgICAgICAgICogQnkgZGVmYXVsdCB0aGlzIGlzIG51bGwgKG5vdCBzZXQpLiBZb3UgY2FuIGFzc2lnbiBhIGZ1bmN0aW9uIHRvIGFsbG93IGN1c3RvbSBmb3JtYXR0aW5nIG9mIGEgbG9nIG1lc3NhZ2UuXG4gICAgICAgICAqIEVhY2ggbG9nIG1lc3NhZ2Ugd2lsbCBjYWxsIHRoaXMgZnVuY3Rpb24gdGhlbiBhbmQgZXhwZWN0cyB5b3VyIGZ1bmN0aW9uIHRvIGZvcm1hdCB0aGUgbWVzc2FnZSBhbmQgcmV0dXJuIGEgc3RyaW5nLlxuICAgICAgICAgKiBXaWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSBhdHRlbXB0IHRvIHNldCBhIGZvcm1hdHRlckxvZ01lc3NhZ2UgaWYgdGhlIExvZ2dlclR5cGUgaXMgY3VzdG9tLlxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGZvcm1hdHRlciBmdW5jdGlvbiwgb3IgbnVsbCB0byByZXNldCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdGhpcy5fbG9nZ2VyVHlwZSA9PT0gTG9nZ2VyT3B0aW9uc18xLkxvZ2dlclR5cGUuQ3VzdG9tKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBzcGVjaWZ5IGEgZm9ybWF0dGVyIGZvciBsb2cgbWVzc2FnZXMgaWYgeW91ciBsb2dnZXJUeXBlIGlzIEN1c3RvbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2F0ZWdvcnlDb25maWd1cmF0aW9uLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29uZmlnID0gbmV3IENhdGVnb3J5Q29uZmlndXJhdGlvbih0aGlzLmxvZ0xldmVsLCB0aGlzLmxvZ2dlclR5cGUsIHRoaXMubG9nRm9ybWF0LmNvcHkoKSwgdGhpcy5jYWxsQmFja0xvZ2dlcik7XG4gICAgICAgIGNvbmZpZy5mb3JtYXR0ZXJMb2dNZXNzYWdlID0gdGhpcy5mb3JtYXR0ZXJMb2dNZXNzYWdlO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgcmV0dXJuIENhdGVnb3J5Q29uZmlndXJhdGlvbjtcbn0oKSk7XG5leHBvcnRzLkNhdGVnb3J5Q29uZmlndXJhdGlvbiA9IENhdGVnb3J5Q29uZmlndXJhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhdGVnb3J5Q29uZmlndXJhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0Q2F0ZWdvcnlMb2dnZXJcIik7XG4vKipcbiAqIFNpbXBsZSBsb2dnZXIsIHRoYXQgbG9ncyB0byB0aGUgY29uc29sZS4gSWYgdGhlIGNvbnNvbGUgaXMgdW5hdmFpbGFibGUgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24uXG4gKi9cbnZhciBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsKHJvb3RDYXRlZ29yeSwgcnVudGltZVNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCByb290Q2F0ZWdvcnksIHJ1bnRpbWVTZXR0aW5ncykgfHwgdGhpcztcbiAgICB9XG4gICAgQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbC5wcm90b3R5cGUuZG9Mb2cgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmIChjb25zb2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRm9ybWF0dGVyID0gdGhpcy5fZ2V0TWVzc2FnZUZvcm1hdHRlcigpO1xuICAgICAgICAgICAgdmFyIGZ1bGxNc2cgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAobWVzc2FnZUZvcm1hdHRlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZ1bGxNc2cgPSB0aGlzLmNyZWF0ZURlZmF1bHRMb2dNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmdWxsTXNnID0gbWVzc2FnZUZvcm1hdHRlcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgICAgICAgICAgc3dpdGNoIChtc2cubGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5UcmFjZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgdHJ5IHRyYWNlIHdlIGRvbid0IHdhbnQgc3RhY2tzXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkRlYnVnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCB0cnksIHRvbyBtdWNoIGRpZmZlcmVuY2VzIG9mIGNvbnNvbGVzLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5JbmZvOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5pbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oZnVsbE1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLldhcm46XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihmdWxsTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRXJyb3I6XG4gICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRmF0YWw6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGZ1bGxNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBsZXZlbDogXCIgKyBtc2cubGV2ZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsb2dnZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmdWxsTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uc29sZSBpcyBub3QgZGVmaW5lZCwgY2Fubm90IGxvZyBtc2c6IFwiICsgbXNnLm1lc3NhZ2VBc1N0cmluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsO1xufShBYnN0cmFjdENhdGVnb3J5TG9nZ2VyXzEuQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcikpO1xuZXhwb3J0cy5DYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsID0gQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhdGVnb3J5Q29uc29sZUxvZ2dlckltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIERlbGVnYXRlIGxvZ2dlciwgZGVsZWdhdGVzIGxvZ2dpbmcgdG8gZ2l2ZW4gbG9nZ2VyIChjb25zdHJ1Y3RvcikuXG4gKi9cbnZhciBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwoZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsLnByb3RvdHlwZSwgXCJkZWxlZ2F0ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwucHJvdG90eXBlLnRyYWNlID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9kZWxlZ2F0ZSkudHJhY2UuYXBwbHkoX2EsIFttc2ddLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLmRlYnVnLmFwcGx5KF9hLCBbbXNnXS5jb25jYXQoY2F0ZWdvcmllcykpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbC5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLmluZm8uYXBwbHkoX2EsIFttc2ddLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9kZWxlZ2F0ZSkud2Fybi5hcHBseShfYSwgW21zZ10uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLmVycm9yLmFwcGx5KF9hLCBbbXNnLCBlcnJvcl0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwucHJvdG90eXBlLmZhdGFsID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLmZhdGFsLmFwcGx5KF9hLCBbbXNnLCBlcnJvcl0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwucHJvdG90eXBlLnJlc29sdmVkID0gZnVuY3Rpb24gKG1zZywgZXJyb3IpIHtcbiAgICAgICAgdmFyIGNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNhdGVnb3JpZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fZGVsZWdhdGUpLnJlc29sdmVkLmFwcGx5KF9hLCBbbXNnLCBlcnJvcl0uY29uY2F0KGNhdGVnb3JpZXMpKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGwucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChsZXZlbCwgbXNnLCBlcnJvcikge1xuICAgICAgICB2YXIgY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY2F0ZWdvcmllc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9kZWxlZ2F0ZSkubG9nLmFwcGx5KF9hLCBbbGV2ZWwsIG1zZywgZXJyb3JdLmNvbmNhdChjYXRlZ29yaWVzKSk7XG4gICAgICAgIHZhciBfYTtcbiAgICB9O1xuICAgIHJldHVybiBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbDtcbn0oKSk7XG5leHBvcnRzLkNhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsID0gQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEV4dGVuc2lvbkhlbHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL2V4dGVuc2lvbi9FeHRlbnNpb25IZWxwZXJcIik7XG52YXIgQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RDYXRlZ29yeUxvZ2dlclwiKTtcbi8qKlxuICogVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHksIGl0IGlzIHVzZWQgZm9yIGNvbW11bmljYXRpb24gd2l0aCB0aGUgZXh0ZW5zaW9uIG9ubHkuXG4gKi9cbnZhciBDYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsKHJvb3RDYXRlZ29yeSwgcnVudGltZVNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCByb290Q2F0ZWdvcnksIHJ1bnRpbWVTZXR0aW5ncykgfHwgdGhpcztcbiAgICB9XG4gICAgQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsLnByb3RvdHlwZS5kb0xvZyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIEV4dGVuc2lvbkhlbHBlcl8xLkV4dGVuc2lvbkhlbHBlci5zZW5kQ2F0ZWdvcnlMb2dNZXNzYWdlKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIndpbmRvdyBpcyBub3QgYXZhaWxhYmxlLCB5b3UgbXVzdCBiZSBydW5uaW5nIGluIGEgYnJvd3NlciBmb3IgdGhpcy4gRHJvcHBlZCBtZXNzYWdlLlwiKTtcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tY29uc29sZSAqL1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsO1xufShBYnN0cmFjdENhdGVnb3J5TG9nZ2VyXzEuQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcikpO1xuZXhwb3J0cy5DYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGwgPSBDYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBYnN0cmFjdENhdGVnb3J5TG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdENhdGVnb3J5TG9nZ2VyXCIpO1xuLyoqXG4gKiBMb2dnZXIgd2hpY2ggYnVmZmVycyBhbGwgbWVzc2FnZXMsIHVzZSB3aXRoIGNhcmUgZHVlIHRvIHBvc3NpYmxlIGhpZ2ggbWVtb3J5IGZvb3RwcmludC5cbiAqIENhbiBiZSBjb252ZW5pZW50IGluIHNvbWUgY2FzZXMuIENhbGwgdG9TdHJpbmcoKSBmb3IgZnVsbCBvdXRwdXQsIG9yIGNhc3QgdG8gdGhpcyBjbGFzc1xuICogYW5kIGNhbGwgZ2V0TWVzc2FnZXMoKSB0byBkbyBzb21ldGhpbmcgd2l0aCBpdCB5b3Vyc2VsZi5cbiAqL1xudmFyIENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYXRlZ29yeU1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwucHJvdG90eXBlLmdldE1lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcztcbiAgICB9O1xuICAgIENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5tYXAoZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICB9O1xuICAgIENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwucHJvdG90eXBlLmRvTG9nID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICB2YXIgbWVzc2FnZUZvcm1hdHRlciA9IHRoaXMuX2dldE1lc3NhZ2VGb3JtYXR0ZXIoKTtcbiAgICAgICAgdmFyIGZ1bGxNc2c7XG4gICAgICAgIGlmIChtZXNzYWdlRm9ybWF0dGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICBmdWxsTXNnID0gdGhpcy5jcmVhdGVEZWZhdWx0TG9nTWVzc2FnZShtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnVsbE1zZyA9IG1lc3NhZ2VGb3JtYXR0ZXIobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2goZnVsbE1zZyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbDtcbn0oQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcl8xLkFic3RyYWN0Q2F0ZWdvcnlMb2dnZXIpKTtcbmV4cG9ydHMuQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbCA9IENhdGVnb3J5TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXRlZ29yeU1lc3NhZ2VCdWZmZXJJbXBsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJPcHRpb25zXCIpO1xuLyoqXG4gKiBSdW50aW1lU2V0dGluZ3MgZm9yIGEgY2F0ZWdvcnksIGF0IHJ1bnRpbWUgdGhlc2UgYXJlIGFzc29jaWF0ZWQgdG8gYSBjYXRlZ29yeS5cbiAqL1xudmFyIENhdGVnb3J5UnVudGltZVNldHRpbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXRlZ29yeVJ1bnRpbWVTZXR0aW5ncyhjYXRlZ29yeSwgbG9nTGV2ZWwsIGxvZ2dlclR5cGUsIGxvZ0Zvcm1hdCwgY2FsbEJhY2tMb2dnZXIsIGZvcm1hdHRlckxvZ01lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGxvZ0xldmVsID09PSB2b2lkIDApIHsgbG9nTGV2ZWwgPSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRXJyb3I7IH1cbiAgICAgICAgaWYgKGxvZ2dlclR5cGUgPT09IHZvaWQgMCkgeyBsb2dnZXJUeXBlID0gTG9nZ2VyT3B0aW9uc18xLkxvZ2dlclR5cGUuQ29uc29sZTsgfVxuICAgICAgICBpZiAobG9nRm9ybWF0ID09PSB2b2lkIDApIHsgbG9nRm9ybWF0ID0gbmV3IExvZ2dlck9wdGlvbnNfMS5DYXRlZ29yeUxvZ0Zvcm1hdCgpOyB9XG4gICAgICAgIGlmIChjYWxsQmFja0xvZ2dlciA9PT0gdm9pZCAwKSB7IGNhbGxCYWNrTG9nZ2VyID0gbnVsbDsgfVxuICAgICAgICBpZiAoZm9ybWF0dGVyTG9nTWVzc2FnZSA9PT0gdm9pZCAwKSB7IGZvcm1hdHRlckxvZ01lc3NhZ2UgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYXRlZ29yeSA9IGNhdGVnb3J5O1xuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgICAgICB0aGlzLl9sb2dnZXJUeXBlID0gbG9nZ2VyVHlwZTtcbiAgICAgICAgdGhpcy5fbG9nRm9ybWF0ID0gbG9nRm9ybWF0O1xuICAgICAgICB0aGlzLl9jYWxsQmFja0xvZ2dlciA9IGNhbGxCYWNrTG9nZ2VyO1xuICAgICAgICB0aGlzLl9mb3JtYXR0ZXJMb2dNZXNzYWdlID0gZm9ybWF0dGVyTG9nTWVzc2FnZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5UnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJjYXRlZ29yeVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhdGVnb3J5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImxvZ0xldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nTGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImxvZ2dlclR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dnZXJUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyVHlwZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImxvZ0Zvcm1hdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0Zvcm1hdDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ0Zvcm1hdCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImNhbGxCYWNrTG9nZ2VyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbEJhY2tMb2dnZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsQmFja0xvZ2dlciA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MucHJvdG90eXBlLCBcImZvcm1hdHRlckxvZ01lc3NhZ2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXR0ZXJMb2dNZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9ybWF0dGVyTG9nTWVzc2FnZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3M7XG59KCkpO1xuZXhwb3J0cy5DYXRlZ29yeVJ1bnRpbWVTZXR0aW5ncyA9IENhdGVnb3J5UnVudGltZVNldHRpbmdzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2F0ZWdvcnlSdW50aW1lU2V0dGluZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGF0YVN0cnVjdHVyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9EYXRhU3RydWN0dXJlc1wiKTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbnZhciBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsXzEgPSByZXF1aXJlKFwiLi9DYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsXCIpO1xudmFyIENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsXzEgPSByZXF1aXJlKFwiLi9DYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbFwiKTtcbnZhciBDYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGxfMSA9IHJlcXVpcmUoXCIuL0NhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbFwiKTtcbnZhciBDYXRlZ29yeU1lc3NhZ2VCdWZmZXJJbXBsXzEgPSByZXF1aXJlKFwiLi9DYXRlZ29yeU1lc3NhZ2VCdWZmZXJJbXBsXCIpO1xudmFyIEV4dGVuc2lvbkhlbHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL2V4dGVuc2lvbi9FeHRlbnNpb25IZWxwZXJcIik7XG52YXIgQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NhdGVnb3J5UnVudGltZVNldHRpbmdzXCIpO1xudmFyIENhdGVnb3J5Q29uZmlndXJhdGlvbl8xID0gcmVxdWlyZShcIi4vQ2F0ZWdvcnlDb25maWd1cmF0aW9uXCIpO1xuLyoqXG4gKiBUaGUgc2VydmljZSAob25seSBhdmFpbGFibGUgYXMgc2luZ2xldG9uKSBmb3IgYWxsIGNhdGVnb3J5IHJlbGF0ZWQgc3R1ZmYgYXNcbiAqIHJldHJpZXZpbmcsIHJlZ2lzdGVyaW5nIGEgbG9nZ2VyLiBZb3Ugc2hvdWxkIG5vcm1hbGx5IE5PVCB1c2UgdGhpcyxcbiAqIGluc3RlYWQgdXNlIENhdGVnb3J5U2VydmljZUZhY3Rvcnkgd2hpY2ggaXMgbWVhbnQgZm9yIGVuZCB1c2Vycy5cbiAqL1xudmFyIENhdGVnb3J5U2VydmljZUltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhdGVnb3J5U2VydmljZUltcGwoKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRDb25maWcgPSBuZXcgQ2F0ZWdvcnlDb25maWd1cmF0aW9uXzEuQ2F0ZWdvcnlDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIHRoaXMuX21hcFN0YXRlID0gbmV3IERhdGFTdHJ1Y3R1cmVzXzEuU2ltcGxlTWFwKCk7XG4gICAgICAgIC8vIFByaXZhdGUgY29uc3RydWN0b3JcbiAgICAgICAgRXh0ZW5zaW9uSGVscGVyXzEuRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyKCk7XG4gICAgfVxuICAgIENhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIExvYWQgb24tZGVtYW5kLCB0byBhc3N1cmUgd2VicGFjayBvcmRlcmluZyBvZiBtb2R1bGUgdXNhZ2UgZG9lc24ndCBzY3JldyB0aGluZ3Mgb3ZlclxuICAgICAgICAvLyBmb3IgdXMgd2hlbiB3ZSBhY2NpZGVudGFsbHkgY2hhbmdlIHRoZSBvcmRlci5cbiAgICAgICAgaWYgKENhdGVnb3J5U2VydmljZUltcGwuX0lOU1RBTkNFID09PSBudWxsKSB7XG4gICAgICAgICAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLl9JTlNUQU5DRSA9IG5ldyBDYXRlZ29yeVNlcnZpY2VJbXBsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENhdGVnb3J5U2VydmljZUltcGwuX0lOU1RBTkNFO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU9yR2V0Q2F0ZWdvcnlTdGF0ZShjYXRlZ29yeSkubG9nZ2VyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGV2ZXJ5dGhpbmcsIGluY2x1ZGluZyBhIGRlZmF1bHQgY29uZmlndXJhdGlvbiB5b3UgbWF5IGhhdmUgc2V0LlxuICAgICAqIEFmdGVyIHRoaXMgeW91IG5lZWQgdG8gcmUtcmVnaXN0ZXIgeW91ciBjYXRlZ29yaWVzIGV0Yy5cbiAgICAgKi9cbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwU3RhdGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5zZXREZWZhdWx0Q29uZmlndXJhdGlvbihuZXcgQ2F0ZWdvcnlDb25maWd1cmF0aW9uXzEuQ2F0ZWdvcnlDb25maWd1cmF0aW9uKCkpO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuZ2V0Q2F0ZWdvcnlTZXR0aW5ncyA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVPckdldENhdGVnb3J5U3RhdGUoY2F0ZWdvcnkpLmN1cnJlbnRSdW50aW1lU2V0dGluZ3M7XG4gICAgfTtcbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5nZXRPcmlnaW5hbENhdGVnb3J5U2V0dGluZ3MgPSBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3JHZXRDYXRlZ29yeVN0YXRlKGNhdGVnb3J5KS5vcmlnaW5hbFJ1bnRpbWVTZXR0aW5ncztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uLiBOZXcgcm9vdCBsb2dnZXJzIGNyZWF0ZWQgZ2V0IHRoaXNcbiAgICAgKiBhcHBsaWVkLiBJZiB5b3Ugd2FudCB0byByZXNldCBhbGwgY3VycmVudCBsb2dnZXJzIHRvIGhhdmUgdGhpc1xuICAgICAqIGFwcGxpZWQgYXMgd2VsbCwgcGFzcyBpbiByZXNldD10cnVlICh0aGUgZGVmYXVsdCBpcyBmYWxzZSkuIEFsbFxuICAgICAqIGNhdGVnb3JpZXMgd2lsbCBiZSByZXNldCB0aGVuIGFzIHdlbGwuXG4gICAgICogQHBhcmFtIGNvbmZpZyBOZXcgY29uZmlnXG4gICAgICogQHBhcmFtIHJlc2V0IERlZmF1bHRzIHRvIHRydWUuIFNldCB0byB0cnVlIHRvIHJlc2V0IGFsbCBsb2dnZXJzIGFuZCBjdXJyZW50IHJ1bnRpbWVzZXR0aW5ncy5cbiAgICAgKi9cbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5zZXREZWZhdWx0Q29uZmlndXJhdGlvbiA9IGZ1bmN0aW9uIChjb25maWcsIHJlc2V0KSB7XG4gICAgICAgIGlmIChyZXNldCA9PT0gdm9pZCAwKSB7IHJlc2V0ID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLl9kZWZhdWx0Q29uZmlnID0gY29uZmlnO1xuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcFN0YXRlLmZvckVhY2hWYWx1ZShmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS51cGRhdGVTZXR0aW5ncyhjb25maWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBuZXcgY29uZmlndXJhdGlvbiBzZXR0aW5ncyBmb3IgYSBjYXRlZ29yeSAoYW5kIHBvc3NpYmx5IGl0cyBjaGlsZCBjYXRlZ29yaWVzKVxuICAgICAqIEBwYXJhbSBjb25maWcgQ29uZmlnXG4gICAgICogQHBhcmFtIGNhdGVnb3J5IENhdGVnb3J5XG4gICAgICogQHBhcmFtIGFwcGx5Q2hpbGRyZW4gVHJ1ZSB0byBhcHBseSB0byBjaGlsZCBjYXRlZ29yaWVzLCBkZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKi9cbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5zZXRDb25maWd1cmF0aW9uQ2F0ZWdvcnkgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXRlZ29yeSwgYXBwbHlDaGlsZHJlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXBwbHlDaGlsZHJlbiA9PT0gdm9pZCAwKSB7IGFwcGx5Q2hpbGRyZW4gPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLmNyZWF0ZU9yR2V0Q2F0ZWdvcnlTdGF0ZShjYXRlZ29yeSkudXBkYXRlU2V0dGluZ3MoY29uZmlnKTtcbiAgICAgICAgLy8gQXBwbHkgdGhlIHNldHRpbmdzIHRvIGNoaWxkcmVuIHJlY3Vyc2l2ZSBpZiByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKGFwcGx5Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNhdGVnb3J5LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgLy8gRmFsc2UgZmxhZywgYSBjaGlsZCBjYW5ub3QgcmVzZXQgYSByb290bG9nZ2VyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0Q29uZmlndXJhdGlvbkNhdGVnb3J5KGNvbmZpZywgY2hpbGQsIGFwcGx5Q2hpbGRyZW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhdGVnb3J5U2VydmljZUltcGwucHJvdG90eXBlLnJlZ2lzdGVyQ2F0ZWdvcnkgPSBmdW5jdGlvbiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09PSBudWxsIHx8IHR5cGVvZiBjYXRlZ29yeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2F0ZWdvcnkgQ0FOTk9UIGJlIG51bGwvdW5kZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tYXBTdGF0ZS5leGlzdHMoQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRDYXRlZ29yeUtleShjYXRlZ29yeSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIHRoaXMgcm9vdCBjYXRlZ29yeSB3aXRoIG5hbWU6IFwiICsgY2F0ZWdvcnkubmFtZSArIFwiLCBpdCBhbHJlYWR5IGV4aXN0cyAoc2FtZSBuYW1lIGluIGhpZXJhcmNoeSkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlT3JHZXRDYXRlZ29yeVN0YXRlKGNhdGVnb3J5KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZW5hYmxlIGludGVncmF0aW9uIHdpdGggY2hyb21lIGV4dGVuc2lvbi4gRG8gbm90IHVzZSBtYW51YWxseSwgdGhlXG4gICAgICogZXh0ZW5zaW9uIGFuZCB0aGUgbG9nZ2VyIGZyYW1ld29yayBkZWFsIHdpdGggdGhpcy5cbiAgICAgKi9cbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5lbmFibGVFeHRlbnNpb25JbnRlZ3JhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbWFwU3RhdGUuZm9yRWFjaFZhbHVlKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuZW5hYmxlRm9yRXh0ZW5zaW9uKF90aGlzKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIHJvb3QgY2F0ZWdvcmllcyBjdXJyZW50bHkgcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5nZXRSb290Q2F0ZWdvcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcFN0YXRlLnZhbHVlcygpLmZpbHRlcihmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLmNhdGVnb3J5LnBhcmVudCA9PSBudWxsOyB9KS5tYXAoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5jYXRlZ29yeTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gQ2F0ZWdvcnkgYnkgaWRcbiAgICAgKiBAcGFyYW0gaWQgVGhlIGlkIG9mIHRoZSBjYXRlZ29yeSB0byBmaW5kXG4gICAgICogQHJldHVybnMge0NhdGVnb3J5fSBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIENhdGVnb3J5U2VydmljZUltcGwucHJvdG90eXBlLmdldENhdGVnb3J5QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fbWFwU3RhdGUudmFsdWVzKCkuZmlsdGVyKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUuY2F0ZWdvcnkuaWQgPT09IGlkOyB9KS5tYXAoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5jYXRlZ29yeTsgfSk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuY3JlYXRlT3JHZXRDYXRlZ29yeVN0YXRlID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgIHZhciBrZXkgPSBDYXRlZ29yeVNlcnZpY2VJbXBsLmdldENhdGVnb3J5S2V5KGNhdGVnb3J5KTtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fbWFwU3RhdGUuZ2V0KGtleSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3U3RhdGUgPSB0aGlzLmNyZWF0ZVN0YXRlKGNhdGVnb3J5KTtcbiAgICAgICAgdGhpcy5fbWFwU3RhdGUucHV0KGtleSwgbmV3U3RhdGUpO1xuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfTtcbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLnByb3RvdHlwZS5jcmVhdGVTdGF0ZSA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IENhdGVnb3J5U3RhdGUoY2F0ZWdvcnksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9kZWZhdWx0Q29uZmlnOyB9LCBmdW5jdGlvbiAoY29uZmlnLCBjYXQpIHsgcmV0dXJuIF90aGlzLmNyZWF0ZUxvZ2dlcihjb25maWcsIGNhdCk7IH0pO1xuICAgIH07XG4gICAgQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5wcm90b3R5cGUuY3JlYXRlTG9nZ2VyID0gZnVuY3Rpb24gKGNvbmZpZywgY2F0ZWdvcnkpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBpcyBhbHdheXMgYSBjb25zb2xlIGxvZ2dlclxuICAgICAgICBzd2l0Y2ggKGNvbmZpZy5sb2dnZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkNvbnNvbGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsXzEuQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbChjYXRlZ29yeSwgdGhpcyk7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLk1lc3NhZ2VCdWZmZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDYXRlZ29yeU1lc3NhZ2VCdWZmZXJJbXBsXzEuQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbChjYXRlZ29yeSwgdGhpcyk7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkN1c3RvbTpcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmNhbGxCYWNrTG9nZ2VyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgY3VzdG9tIGxvZ2dlciwgY3VzdG9tIGNhbGxiYWNrIGlzIG51bGxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLmNhbGxCYWNrTG9nZ2VyKGNhdGVnb3J5LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgYSBMb2dnZXIgZm9yIExvZ2dlclR5cGU6IFwiICsgY29uZmlnLmxvZ2dlclR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYXRlZ29yeVNlcnZpY2VJbXBsLmdldENhdGVnb3J5S2V5ID0gZnVuY3Rpb24gKGNhdGVnb3J5KSB7XG4gICAgICAgIHJldHVybiBjYXRlZ29yeS5nZXRDYXRlZ29yeVBhdGgoKTtcbiAgICB9O1xuICAgIC8vIFNpbmdsZXRvbiBjYXRlZ29yeSBzZXJ2aWNlLCB1c2VkIGJ5IENhdGVnb3J5U2VydmljZUZhY3RvcnkgYXMgd2VsbCBhcyBDYXRlZ29yaWVzLlxuICAgIC8vIExvYWRlZCBvbiBkZW1hbmQuIERvIE5PVCBjaGFuZ2UgYXMgd2VicGFjayBtYXkgcGFjayB0aGluZ3MgaW4gd3Jvbmcgb3JkZXIgb3RoZXJ3aXNlLlxuICAgIENhdGVnb3J5U2VydmljZUltcGwuX0lOU1RBTkNFID0gbnVsbDtcbiAgICByZXR1cm4gQ2F0ZWdvcnlTZXJ2aWNlSW1wbDtcbn0oKSk7XG5leHBvcnRzLkNhdGVnb3J5U2VydmljZUltcGwgPSBDYXRlZ29yeVNlcnZpY2VJbXBsO1xudmFyIENhdGVnb3J5U3RhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhdGVnb3J5U3RhdGUoY2F0ZWdvcnksIGRlZmF1bHRDb25maWcsIGNyZWF0ZUxvZ2dlcikge1xuICAgICAgICB0aGlzLl9jYXRlZ29yeSA9IGNhdGVnb3J5O1xuICAgICAgICB0aGlzLl9sYXp5U3RhdGUgPSBuZXcgTGF6eVN0YXRlKGNhdGVnb3J5LCBkZWZhdWx0Q29uZmlnLCBjcmVhdGVMb2dnZXIpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2F0ZWdvcnlTdGF0ZS5wcm90b3R5cGUsIFwiY2F0ZWdvcnlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXRlZ29yeTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5U3RhdGUucHJvdG90eXBlLCBcImxvZ2dlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhenlTdGF0ZS5nZXRMb2dnZXIoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhdGVnb3J5U3RhdGUucHJvdG90eXBlLCBcIm9yaWdpbmFsUnVudGltZVNldHRpbmdzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF6eVN0YXRlLmdldE9yaWdpbmFsUnVudGltZVNldHRpbmdzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXRlZ29yeVN0YXRlLnByb3RvdHlwZSwgXCJjdXJyZW50UnVudGltZVNldHRpbmdzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF6eVN0YXRlLmdldEN1cnJlbnRSdW50aW1lU2V0dGluZ3MoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2F0ZWdvcnlTdGF0ZS5wcm90b3R5cGUuZW5hYmxlRm9yRXh0ZW5zaW9uID0gZnVuY3Rpb24gKHJ1bnRpbWVTZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9sYXp5U3RhdGUuZW5hYmxlRm9yRXh0ZW5zaW9uKHJ1bnRpbWVTZXR0aW5ncyk7XG4gICAgfTtcbiAgICBDYXRlZ29yeVN0YXRlLnByb3RvdHlwZS51cGRhdGVTZXR0aW5ncyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdGhpcy5fbGF6eVN0YXRlLnVwZGF0ZVNldHRpbmdzKGNvbmZpZyk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0ZWdvcnlTdGF0ZTtcbn0oKSk7XG52YXIgTGF6eVN0YXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXp5U3RhdGUoY2F0ZWdvcnksIGRlZmF1bHRDb25maWcsIGNyZWF0ZUxvZ2dlcikge1xuICAgICAgICB0aGlzLl9jYXRlZ29yeSA9IGNhdGVnb3J5O1xuICAgICAgICB0aGlzLl9kZWZhdWx0Q29uZmlnID0gZGVmYXVsdENvbmZpZztcbiAgICAgICAgdGhpcy5fY3JlYXRlTG9nZ2VyID0gY3JlYXRlTG9nZ2VyO1xuICAgIH1cbiAgICBMYXp5U3RhdGUucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB0aGlzLl9sb2dnZXIgIT09IFwidW5kZWZpbmVkXCIpO1xuICAgIH07XG4gICAgTGF6eVN0YXRlLnByb3RvdHlwZS5nZXRMb2dnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9hZExvZ2dlck9uRGVtYW5kKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZUxvZ2dlcjtcbiAgICB9O1xuICAgIExhenlTdGF0ZS5wcm90b3R5cGUuZ2V0T3JpZ2luYWxSdW50aW1lU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9hZExvZ2dlck9uRGVtYW5kKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbFJ1bnRpbWVTZXR0aW5ncztcbiAgICB9O1xuICAgIExhenlTdGF0ZS5wcm90b3R5cGUuZ2V0Q3VycmVudFJ1bnRpbWVTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2FkTG9nZ2VyT25EZW1hbmQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRSdW50aW1lU2V0dGluZ3M7XG4gICAgfTtcbiAgICBMYXp5U3RhdGUucHJvdG90eXBlLmVuYWJsZUZvckV4dGVuc2lvbiA9IGZ1bmN0aW9uIChydW50aW1lU2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5sb2FkTG9nZ2VyT25EZW1hbmQoKTtcbiAgICAgICAgaWYgKCEodGhpcy5fd3JhcHBlZExvZ2dlciBpbnN0YW5jZW9mIENhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbF8xLkNhdGVnb3J5RXh0ZW5zaW9uTG9nZ2VySW1wbCkpIHtcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVjb25maWd1cmluZyBsb2dnZXIgZm9yIGV4dGVuc2lvbiBmb3IgY2F0ZWdvcnk6IFwiICsgdGhpcy5fY2F0ZWdvcnkubmFtZSk7XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZWRMb2dnZXIgPSBuZXcgQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsXzEuQ2F0ZWdvcnlFeHRlbnNpb25Mb2dnZXJJbXBsKHRoaXMuX2NhdGVnb3J5LCBydW50aW1lU2V0dGluZ3MpO1xuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGVMb2dnZXIuZGVsZWdhdGUgPSB0aGlzLl93cmFwcGVkTG9nZ2VyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXp5U3RhdGUucHJvdG90eXBlLnVwZGF0ZVNldHRpbmdzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBpZiAodGhpcy5pc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UnVudGltZVNldHRpbmdzLmxvZ0xldmVsID0gY29uZmlnLmxvZ0xldmVsO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJ1bnRpbWVTZXR0aW5ncy5sb2dnZXJUeXBlID0gY29uZmlnLmxvZ2dlclR5cGU7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UnVudGltZVNldHRpbmdzLmxvZ0Zvcm1hdCA9IGNvbmZpZy5sb2dGb3JtYXQ7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UnVudGltZVNldHRpbmdzLmNhbGxCYWNrTG9nZ2VyID0gY29uZmlnLmNhbGxCYWNrTG9nZ2VyO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJ1bnRpbWVTZXR0aW5ncy5mb3JtYXR0ZXJMb2dNZXNzYWdlID0gY29uZmlnLmZvcm1hdHRlckxvZ01lc3NhZ2U7XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSByZWFsIGxvZ2dlciwgaXQgbWF5IGhhdmUgY2hhbmdlZC5cbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlciA9IHRoaXMuX2NyZWF0ZUxvZ2dlcihjb25maWcsIHRoaXMuX2NhdGVnb3J5KTtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3dyYXBwZWRMb2dnZXIgaW5zdGFuY2VvZiBDYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGxfMS5DYXRlZ29yeUV4dGVuc2lvbkxvZ2dlckltcGwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3JhcHBlZExvZ2dlciA9IHRoaXMuX2xvZ2dlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlTG9nZ2VyLmRlbGVnYXRlID0gdGhpcy5fd3JhcHBlZExvZ2dlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGlzIGNvbmZpZywgaXQgbWF5IGJlIGZvciB0aGUgY2F0ZWdvcnkgc3BlY2lmaWMsIHRoZSBkZWZhdWx0IGlzIHRoZXJlZm9yZSBub3QgZ29vZCBlbm91Z2guXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0Q29uZmlnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMYXp5U3RhdGUucHJvdG90eXBlLmxvYWRMb2dnZXJPbkRlbWFuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9hZGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlciA9IHRoaXMuX2NyZWF0ZUxvZ2dlcih0aGlzLl9kZWZhdWx0Q29uZmlnKCksIHRoaXMuX2NhdGVnb3J5KTtcbiAgICAgICAgICAgIHRoaXMuX3dyYXBwZWRMb2dnZXIgPSB0aGlzLl9sb2dnZXI7XG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZUxvZ2dlciA9IG5ldyBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbF8xLkNhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsKHRoaXMuX3dyYXBwZWRMb2dnZXIpO1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxSdW50aW1lU2V0dGluZ3MgPSB0aGlzLmluaXROZXdTZXR0aW5ncygpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFJ1bnRpbWVTZXR0aW5ncyA9IHRoaXMuaW5pdE5ld1NldHRpbmdzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExhenlTdGF0ZS5wcm90b3R5cGUuaW5pdE5ld1NldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVmU2V0dGluZ3MgPSB0aGlzLl9kZWZhdWx0Q29uZmlnKCkuY29weSgpO1xuICAgICAgICByZXR1cm4gbmV3IENhdGVnb3J5UnVudGltZVNldHRpbmdzXzEuQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3ModGhpcy5fY2F0ZWdvcnksIGRlZlNldHRpbmdzLmxvZ0xldmVsLCBkZWZTZXR0aW5ncy5sb2dnZXJUeXBlLCBkZWZTZXR0aW5ncy5sb2dGb3JtYXQsIGRlZlNldHRpbmdzLmNhbGxCYWNrTG9nZ2VyLCBkZWZTZXR0aW5ncy5mb3JtYXR0ZXJMb2dNZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBMYXp5U3RhdGU7XG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2F0ZWdvcnlTZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENhdGVnb3J5U2VydmljZV8xID0gcmVxdWlyZShcIi4vQ2F0ZWdvcnlTZXJ2aWNlXCIpO1xuLyoqXG4gKiBDYXRlZ29yaXplZCBzZXJ2aWNlIGZvciBsb2dnaW5nLCB3aGVyZSBsb2dnaW5nIGlzIGJvdW5kIHRvIGNhdGVnb3JpZXMgd2hpY2hcbiAqIGNhbiBsb2cgaG9yaXpvbnRhbGx5IHRocm91Z2ggc3BlY2lmaWMgYXBwbGljYXRpb24gbG9naWMgKHNlcnZpY2VzLCBncm91cChzKSBvZiBjb21wb25lbnRzIGV0YykuXG4gKiBGb3IgdGhlIHN0YW5kYXJkIHdheSBvZiBsb2dnaW5nIGxpa2UgbW9zdCBmcmFtZXdvcmtzIGRvIHRoZXNlIGRheXMsIHVzZSBMRlNlcnZpY2UgaW5zdGVhZC5cbiAqIElmIHlvdSB3YW50IGZpbmUgZ3JhaW5lZCBjb250cm9sIHRvIGRpdmlkZSBzZWN0aW9ucyBvZiB5b3VyIGFwcGxpY2F0aW9uIGluXG4gKiBsb2dpY2FsIHVuaXRzIHRvIGVuYWJsZS9kaXNhYmxlIGxvZ2dpbmcgZm9yLCB0aGlzIGlzIHRoZSBzZXJ2aWNlIHlvdSB3YW50IHRvIHVzZSBpbnN0ZWFkLlxuICogQWxzbyBmb3IgdGhpcyB0eXBlIGEgYnJvd3NlciBwbHVnaW4gd2lsbCBiZSBhdmFpbGFibGUuXG4gKi9cbnZhciBDYXRlZ29yeVNlcnZpY2VGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXRlZ29yeVNlcnZpY2VGYWN0b3J5KCkge1xuICAgICAgICAvLyBQcml2YXRlIGNvbnN0cnVjdG9yLlxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBDYXRlZ29yeUxvZ2dlciBmb3IgZ2l2ZW4gUk9PVCBjYXRlZ29yeSAodGh1cyBoYXMgbm8gcGFyZW50KS5cbiAgICAgKiBZb3UgY2FuIG9ubHkgcmV0cmlldmUgbG9nZ2VycyBmb3IgdGhlaXIgcm9vdCwgd2hlbiBsb2dnaW5nXG4gICAgICogeW91IHNwZWNpZnkgdG8gbG9nIGZvciB3aGF0IChjaGlsZCljYXRlZ29yaWVzLlxuICAgICAqIEBwYXJhbSByb290IENhdGVnb3J5IHJvb3QgKGhhcyBubyBwYXJlbnQpXG4gICAgICogQHJldHVybnMge0NhdGVnb3J5TG9nZ2VyfVxuICAgICAqL1xuICAgIENhdGVnb3J5U2VydmljZUZhY3RvcnkuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgcmV0dXJuIENhdGVnb3J5U2VydmljZV8xLkNhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKS5nZXRMb2dnZXIocm9vdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgZXZlcnl0aGluZywgYW55IHJlZ2lzdGVyZWQgKHJvb3QpY2F0ZWdvcmllcyBhbmQgbG9nZ2Vyc1xuICAgICAqIGFyZSBkaXNjYXJkZWQuIFJlc2V0cyB0byBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIENhdGVnb3J5U2VydmljZV8xLkNhdGVnb3J5U2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKS5jbGVhcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uIE5ldyByb290IGxvZ2dlcnMgY3JlYXRlZCBnZXQgdGhpc1xuICAgICAqIGFwcGxpZWQuIElmIHlvdSB3YW50IHRvIHJlc2V0IGFsbCBjdXJyZW50IGxvZ2dlcnMgdG8gaGF2ZSB0aGlzXG4gICAgICogYXBwbGllZCBhcyB3ZWxsLCBwYXNzIGluIHJlc2V0PXRydWUgKHRoZSBkZWZhdWx0IGlzIGZhbHNlKS4gQWxsXG4gICAgICogY2F0ZWdvcmllcyBydW50aW1lc2V0dGluZ3Mgd2lsbCBiZSByZXNldCB0aGVuIGFzIHdlbGwuXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgbmV3IGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSByZXNldCBJZiB0cnVlLCB3aWxsIHJlc2V0ICphbGwqIHJ1bnRpbWVzZXR0aW5ncyBmb3IgYWxsIGxvZ2dlcnMvY2F0ZWdvcmllcyB0byB0aGVzZS4gRGVmYXVsdCBpcyB0cnVlLlxuICAgICAqL1xuICAgIENhdGVnb3J5U2VydmljZUZhY3Rvcnkuc2V0RGVmYXVsdENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiAoY29uZmlnLCByZXNldCkge1xuICAgICAgICBpZiAocmVzZXQgPT09IHZvaWQgMCkgeyByZXNldCA9IHRydWU7IH1cbiAgICAgICAgQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLnNldERlZmF1bHRDb25maWd1cmF0aW9uKGNvbmZpZywgcmVzZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IG5ldyBjb25maWd1cmF0aW9uIHNldHRpbmdzIGZvciBhIGNhdGVnb3J5IChhbmQgcG9zc2libHkgaXRzIGNoaWxkIGNhdGVnb3JpZXMpXG4gICAgICogQHBhcmFtIGNvbmZpZyBDb25maWdcbiAgICAgKiBAcGFyYW0gY2F0ZWdvcnkgQ2F0ZWdvcnlcbiAgICAgKiBAcGFyYW0gYXBwbHlDaGlsZHJlbiBUcnVlIHRvIGFwcGx5IHRvIGNoaWxkIGNhdGVnb3JpZXMsIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAqL1xuICAgIENhdGVnb3J5U2VydmljZUZhY3Rvcnkuc2V0Q29uZmlndXJhdGlvbkNhdGVnb3J5ID0gZnVuY3Rpb24gKGNvbmZpZywgY2F0ZWdvcnksIGFwcGx5Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGFwcGx5Q2hpbGRyZW4gPT09IHZvaWQgMCkgeyBhcHBseUNoaWxkcmVuID0gZmFsc2U7IH1cbiAgICAgICAgQ2F0ZWdvcnlTZXJ2aWNlXzEuQ2F0ZWdvcnlTZXJ2aWNlSW1wbC5nZXRJbnN0YW5jZSgpLnNldENvbmZpZ3VyYXRpb25DYXRlZ29yeShjb25maWcsIGNhdGVnb3J5LCBhcHBseUNoaWxkcmVuKTtcbiAgICB9O1xuICAgIHJldHVybiBDYXRlZ29yeVNlcnZpY2VGYWN0b3J5O1xufSgpKTtcbmV4cG9ydHMuQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeSA9IENhdGVnb3J5U2VydmljZUZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXRlZ29yeVNlcnZpY2VGYWN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJPcHRpb25zXCIpO1xudmFyIERhdGFTdHJ1Y3R1cmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvRGF0YVN0cnVjdHVyZXNcIik7XG52YXIgTWVzc2FnZVV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvTWVzc2FnZVV0aWxzXCIpO1xudmFyIExvZ01lc3NhZ2VJbnRlcm5hbEltcGwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ01lc3NhZ2VJbnRlcm5hbEltcGwobG9nZ2VyTmFtZSwgbWVzc2FnZSwgZXJyb3JBc1N0YWNrLCBlcnJvciwgbG9nR3JvdXBSdWxlLCBkYXRlLCBsZXZlbCwgcmVhZHkpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JBc1N0YWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLl9sb2dnZXJOYW1lID0gbG9nZ2VyTmFtZTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuX2Vycm9yQXNTdGFjayA9IGVycm9yQXNTdGFjaztcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5fbG9nR3JvdXBSdWxlID0gbG9nR3JvdXBSdWxlO1xuICAgICAgICB0aGlzLl9kYXRlID0gZGF0ZTtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSByZWFkeTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ01lc3NhZ2VJbnRlcm5hbEltcGwucHJvdG90eXBlLCBcImxvZ2dlck5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dnZXJOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dNZXNzYWdlSW50ZXJuYWxJbXBsLnByb3RvdHlwZSwgXCJlcnJvckFzU3RhY2tcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvckFzU3RhY2s7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvckFzU3RhY2sgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ01lc3NhZ2VJbnRlcm5hbEltcGwucHJvdG90eXBlLCBcImVycm9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwibG9nR3JvdXBSdWxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nR3JvdXBSdWxlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nR3JvdXBSdWxlID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dNZXNzYWdlSW50ZXJuYWxJbXBsLnByb3RvdHlwZSwgXCJkYXRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ01lc3NhZ2VJbnRlcm5hbEltcGwucHJvdG90eXBlLCBcImxldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9sZXZlbCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nTWVzc2FnZUludGVybmFsSW1wbC5wcm90b3R5cGUsIFwiaXNNZXNzYWdlTG9nRGF0YVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiAodGhpcy5fbWVzc2FnZSkgIT09IFwic3RyaW5nXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dNZXNzYWdlSW50ZXJuYWxJbXBsLnByb3RvdHlwZSwgXCJyZWFkeVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVhZHkgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ01lc3NhZ2VJbnRlcm5hbEltcGwucHJvdG90eXBlLCBcIm1lc3NhZ2VBc1N0cmluZ1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5fbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlLm1zZztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ01lc3NhZ2VJbnRlcm5hbEltcGwucHJvdG90eXBlLCBcImxvZ0RhdGFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5fbWVzc2FnZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTG9nTWVzc2FnZUludGVybmFsSW1wbDtcbn0oKSk7XG4vKipcbiAqIEFic3RyYWN0IGJhc2UgbG9nZ2VyLCBleHRlbmQgdG8gZWFzaWx5IGltcGxlbWVudCBhIGN1c3RvbSBsb2dnZXIgdGhhdFxuICogbG9ncyB3aGVyZXZlciB5b3Ugd2FudC4gWW91IG9ubHkgbmVlZCB0byBpbXBsZW1lbnQgZG9Mb2cobXNnOiBMb2dNZXNzYWdlKSBhbmRcbiAqIGxvZyB0aGF0IHNvbWV3aGVyZSAoaXQgd2lsbCBjb250YWluIGZvcm1hdCBhbmQgZXZlcnl0aGluZyBlbHNlKS5cbiAqL1xudmFyIEFic3RyYWN0TG9nZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdExvZ2dlcihuYW1lLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9hbGxNZXNzYWdlcyA9IG5ldyBEYXRhU3RydWN0dXJlc18xLkxpbmtlZExpc3QoKTtcbiAgICAgICAgdGhpcy5fb3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyA9IGxvZ0dyb3VwUnVudGltZVNldHRpbmdzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUudHJhY2UgPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5UcmFjZSwgbXNnLCBlcnJvcik7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5EZWJ1ZywgbXNnLCBlcnJvcik7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciA9PT0gdm9pZCAwKSB7IGVycm9yID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkluZm8sIG1zZywgZXJyb3IpO1xuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobXNnLCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IG51bGw7IH1cbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5XYXJuLCBtc2csIGVycm9yKTtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciA9PT0gdm9pZCAwKSB7IGVycm9yID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yLCBtc2csIGVycm9yKTtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5mYXRhbCA9IGZ1bmN0aW9uIChtc2csIGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciA9PT0gdm9pZCAwKSB7IGVycm9yID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkZhdGFsLCBtc2csIGVycm9yKTtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5pc1RyYWNlRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzLmxldmVsID09PSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuVHJhY2U7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuaXNEZWJ1Z0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sZXZlbCA8PSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuRGVidWc7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuaXNJbmZvRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzLmxldmVsIDw9IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5JbmZvO1xuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLmlzV2FybkVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sZXZlbCA8PSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuV2FybjtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5pc0Vycm9yRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzLmxldmVsIDw9IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5FcnJvcjtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5pc0ZhdGFsRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzLmxldmVsIDw9IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5GYXRhbDtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5nZXRMb2dMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzLmxldmVsO1xuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLmlzT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wZW47XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYWxsTWVzc2FnZXMuY2xlYXIoKTtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5jcmVhdGVEZWZhdWx0TG9nTWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgcmV0dXJuIE1lc3NhZ2VVdGlsc18xLk1lc3NhZ2VGb3JtYXRVdGlscy5yZW5kZXJEZWZhdWx0TG9nNGpNZXNzYWdlKG1zZywgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gb3B0aW9uYWwgbWVzc2FnZSBmb3JtYXR0ZXIuIEFsbCBMb2dnZXJUeXBlcyAoZXhjZXB0IGN1c3RvbSkgd2lsbCBzZWUgaWZcbiAgICAgKiB0aGV5IGhhdmUgdGhpcywgYW5kIGlmIHNvIHVzZSBpdCB0byBsb2cuXG4gICAgICogQHJldHVybnMgeygobWVzc2FnZTpMb2dNZXNzYWdlKT0+c3RyaW5nKXxudWxsfVxuICAgICAqL1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5fZ2V0TWVzc2FnZUZvcm1hdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVudGltZVNldHRpbmdzLmZvcm1hdHRlckxvZ01lc3NhZ2U7XG4gICAgfTtcbiAgICBBYnN0cmFjdExvZ2dlci5wcm90b3R5cGUuX2xvZyA9IGZ1bmN0aW9uIChsZXZlbCwgbXNnLCBlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgPT09IHZvaWQgMCkgeyBlcnJvciA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRoaXMuX29wZW4gJiYgdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MubGV2ZWwgPD0gbGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBmdW5jdGlvbk1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtc2cgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbXNnKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGZ1bmN0aW9uRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fYWxsTWVzc2FnZXMuYWRkVGFpbCh0aGlzLmNyZWF0ZU1lc3NhZ2UobGV2ZWwsIGZ1bmN0aW9uTWVzc2FnZSwgZnVuY3Rpb25FcnJvciwgbmV3IERhdGUoKSkpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTWVzc2FnZXMoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJzdHJhY3RMb2dnZXIucHJvdG90eXBlLmNyZWF0ZU1lc3NhZ2UgPSBmdW5jdGlvbiAobGV2ZWwsIG1zZywgZXJyb3IsIGRhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGVycm9yUmVzdWx0ID0gZXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZV8xID0gbmV3IExvZ01lc3NhZ2VJbnRlcm5hbEltcGwodGhpcy5fbmFtZSwgbXNnKCksIG51bGwsIGVycm9yUmVzdWx0LCB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sb2dHcm91cFJ1bGUsIGRhdGUsIGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgICBNZXNzYWdlVXRpbHNfMS5NZXNzYWdlRm9ybWF0VXRpbHMucmVuZGVyRXJyb3IoZXJyb3JSZXN1bHQpLnRoZW4oZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZV8xLmVycm9yQXNTdGFjayA9IHN0YWNrO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VfMS5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc01lc3NhZ2VzKCk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZV8xLmVycm9yQXNTdGFjayA9IFwiPFVOS05PV04+IHVuYWJsZSB0byBnZXQgc3RhY2suXCI7XG4gICAgICAgICAgICAgICAgbWVzc2FnZV8xLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9jZXNzTWVzc2FnZXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VfMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExvZ01lc3NhZ2VJbnRlcm5hbEltcGwodGhpcy5fbmFtZSwgbXNnKCksIG51bGwsIGVycm9yUmVzdWx0LCB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5sb2dHcm91cFJ1bGUsIGRhdGUsIGxldmVsLCB0cnVlKTtcbiAgICB9O1xuICAgIEFic3RyYWN0TG9nZ2VyLnByb3RvdHlwZS5wcm9jZXNzTWVzc2FnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEJhc2ljYWxseSB3ZSB3YWl0IHVudGlsIGVycm9ycyBhcmUgcmVzb2x2ZWQgKHRob3NlIG1lc3NhZ2VzXG4gICAgICAgIC8vIG1heSBub3QgYmUgcmVhZHkpLlxuICAgICAgICB2YXIgbXNncyA9IHRoaXMuX2FsbE1lc3NhZ2VzO1xuICAgICAgICBpZiAobXNncy5nZXRTaXplKCkgPiAwKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IG1zZ3MuZ2V0SGVhZCgpO1xuICAgICAgICAgICAgICAgIGlmIChtc2cgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1zZy5yZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbXNncy5yZW1vdmVIZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIG5ldmVyIGJlIG51bGwgbm9ybWFsbHksIGJ1dCBzdHJpY3QgbnVsbCBjaGVja2luZyAuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zZy5tZXNzYWdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvTG9nKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChtc2dzLmdldFNpemUoKSA+IDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RMb2dnZXI7XG59KCkpO1xuZXhwb3J0cy5BYnN0cmFjdExvZ2dlciA9IEFic3RyYWN0TG9nZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RMb2dnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBYnN0cmFjdExvZ2dlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RMb2dnZXJcIik7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL0xvZ2dlck9wdGlvbnNcIik7XG4vKipcbiAqIFNpbXBsZSBsb2dnZXIsIHRoYXQgbG9ncyB0byB0aGUgY29uc29sZS4gSWYgdGhlIGNvbnNvbGUgaXMgdW5hdmFpbGFibGUgd2lsbCB0aHJvdyBleGNlcHRpb24uXG4gKi9cbnZhciBDb25zb2xlTG9nZ2VySW1wbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnNvbGVMb2dnZXJJbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnNvbGVMb2dnZXJJbXBsKG5hbWUsIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncykgfHwgdGhpcztcbiAgICB9XG4gICAgQ29uc29sZUxvZ2dlckltcGwucHJvdG90eXBlLmRvTG9nID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGxvZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGxvZ0xldmVsID0gbWVzc2FnZS5sZXZlbDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRm9ybWF0dGVyID0gdGhpcy5fZ2V0TWVzc2FnZUZvcm1hdHRlcigpO1xuICAgICAgICAgICAgdmFyIG1zZyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlRm9ybWF0dGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbXNnID0gdGhpcy5jcmVhdGVEZWZhdWx0TG9nTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXR0ZXIobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlICovXG4gICAgICAgICAgICBzd2l0Y2ggKGxvZ0xldmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuVHJhY2U6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cnkgdHJhY2Ugd2UgZG9uJ3Qgd2FudCBhIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkRlYnVnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCB0cnksIHRvbyBtdWNoIGRpZmZlcmVuY2VzIG9mIGNvbnNvbGVzLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbC5JbmZvOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5pbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8obXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWwuV2FybjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yOlxuICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkZhdGFsOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2cgbGV2ZWwgbm90IHN1cHBvcnRlZDogXCIgKyBsb2dMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxvZ2dlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLWNvbnNvbGUgKi9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnNvbGUgaXMgbm90IGRlZmluZWQsIGNhbm5vdCBsb2cgbXNnOiBcIiArIG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb25zb2xlTG9nZ2VySW1wbDtcbn0oQWJzdHJhY3RMb2dnZXJfMS5BYnN0cmFjdExvZ2dlcikpO1xuZXhwb3J0cy5Db25zb2xlTG9nZ2VySW1wbCA9IENvbnNvbGVMb2dnZXJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29uc29sZUxvZ2dlckltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGF0YVN0cnVjdHVyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9EYXRhU3RydWN0dXJlc1wiKTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbnZhciBMb2dnZXJGYWN0b3J5SW1wbF8xID0gcmVxdWlyZShcIi4vTG9nZ2VyRmFjdG9yeUltcGxcIik7XG52YXIgRXh0ZW5zaW9uSGVscGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vZXh0ZW5zaW9uL0V4dGVuc2lvbkhlbHBlclwiKTtcbnZhciBMb2dHcm91cFJ1bGVfMSA9IHJlcXVpcmUoXCIuL0xvZ0dyb3VwUnVsZVwiKTtcbnZhciBMb2dnZXJGYWN0b3J5T3B0aW9uc18xID0gcmVxdWlyZShcIi4vTG9nZ2VyRmFjdG9yeU9wdGlvbnNcIik7XG52YXIgTEZTZXJ2aWNlSW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTEZTZXJ2aWNlSW1wbCgpIHtcbiAgICAgICAgLy8gUHJpdmF0ZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgdGhpcy5fbmFtZUNvdW50ZXIgPSAxO1xuICAgICAgICB0aGlzLl9tYXBGYWN0b3JpZXMgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5TaW1wbGVNYXAoKTtcbiAgICAgICAgRXh0ZW5zaW9uSGVscGVyXzEuRXh0ZW5zaW9uSGVscGVyLnJlZ2lzdGVyKCk7XG4gICAgfVxuICAgIExGU2VydmljZUltcGwuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIExvYWRlZCBvbiBkZW1hbmQuIERvIE5PVCBjaGFuZ2UgYXMgd2VicGFjayBtYXkgcGFjayB0aGluZ3MgaW4gd3Jvbmcgb3JkZXIgb3RoZXJ3aXNlLlxuICAgICAgICBpZiAoTEZTZXJ2aWNlSW1wbC5fSU5TVEFOQ0UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIExGU2VydmljZUltcGwuX0lOU1RBTkNFID0gbmV3IExGU2VydmljZUltcGwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTEZTZXJ2aWNlSW1wbC5fSU5TVEFOQ0U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgTG9nZ2VyRmFjdG9yeSB3aXRoIGdpdmVuIG9wdGlvbnMgKGlmIGFueSkuIElmIG5vIG9wdGlvbnNcbiAgICAgKiBhcmUgc3BlY2lmaWVkLCB0aGUgTG9nZ2VyRmFjdG9yeSwgd2lsbCBhY2NlcHQgYW55IG5hbWVkIGxvZ2dlciBhbmQgd2lsbFxuICAgICAqIGxvZyBvbiBpbmZvIGxldmVsIGJ5IGRlZmF1bHQgZm9yLCB0byB0aGUgY29uc29sZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLCBvcHRpb25hbC5cbiAgICAgKiBAcmV0dXJucyB7TG9nZ2VyRmFjdG9yeX1cbiAgICAgKi9cbiAgICBMRlNlcnZpY2VJbXBsLnByb3RvdHlwZS5jcmVhdGVMb2dnZXJGYWN0b3J5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gbnVsbDsgfVxuICAgICAgICB2YXIgbmFtZSA9IFwiTG9nZ2VyRmFjdG9yeVwiICsgdGhpcy5fbmFtZUNvdW50ZXIrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTmFtZWRMb2dnZXJGYWN0b3J5KG5hbWUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IExvZ2dlckZhY3RvcnkgdXNpbmcgZ2l2ZW4gbmFtZSAodXNlZCBmb3IgY29uc29sZSBhcGkvZXh0ZW5zaW9uKS5cbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIFBpY2sgc29tZXRoaW5nIHNob3J0IGJ1dCBkaXN0aW5ndWlzaGFibGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucywgb3B0aW9uYWxcbiAgICAgKiBAcmV0dXJuIHtMb2dnZXJGYWN0b3J5fVxuICAgICAqL1xuICAgIExGU2VydmljZUltcGwucHJvdG90eXBlLmNyZWF0ZU5hbWVkTG9nZ2VyRmFjdG9yeSA9IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRoaXMuX21hcEZhY3Rvcmllcy5leGlzdHMobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvZ2dlckZhY3Rvcnkgd2l0aCBuYW1lIFwiICsgbmFtZSArIFwiIGFscmVhZHkgZXhpc3RzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmFjdG9yeTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBuZXcgTG9nZ2VyRmFjdG9yeUltcGxfMS5Mb2dnZXJGYWN0b3J5SW1wbChuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZhY3RvcnkgPSBuZXcgTG9nZ2VyRmFjdG9yeUltcGxfMS5Mb2dnZXJGYWN0b3J5SW1wbChuYW1lLCBMRlNlcnZpY2VJbXBsLmNyZWF0ZURlZmF1bHRPcHRpb25zKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcEZhY3Rvcmllcy5wdXQobmFtZSwgZmFjdG9yeSk7XG4gICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFsbCBMb2dnZXJzIGZvciBMb2dnZXJGYWN0b3JpZXMgdGhhdCB3ZXJlIGNyZWF0ZWQuXG4gICAgICogQWZ0ZXIgdGhpcyBjYWxsLCBhbGwgcHJldmlvdXNseSBmZXRjaGVkIExvZ2dlcnMgKGZyb20gdGhlaXJcbiAgICAgKiBmYWN0b3JpZXMpIGFyZSB1bnVzYWJsZS4gVGhlIGZhY3RvcmllcyByZW1haW4gYXMgdGhleSB3ZXJlLlxuICAgICAqL1xuICAgIExGU2VydmljZUltcGwucHJvdG90eXBlLmNsb3NlTG9nZ2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbWFwRmFjdG9yaWVzLnZhbHVlcygpLmZvckVhY2goZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICAgICAgICAgIGZhY3RvcnkuY2xvc2VMb2dnZXJzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tYXBGYWN0b3JpZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbmFtZUNvdW50ZXIgPSAxO1xuICAgIH07XG4gICAgTEZTZXJ2aWNlSW1wbC5wcm90b3R5cGUuZ2V0UnVudGltZVNldHRpbmdzRm9yTG9nZ2VyRmFjdG9yaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuX21hcEZhY3Rvcmllcy5mb3JFYWNoVmFsdWUoZnVuY3Rpb24gKGZhY3RvcnkpIHsgcmV0dXJuIHJlc3VsdC5wdXNoKGZhY3RvcnkpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIExGU2VydmljZUltcGwucHJvdG90eXBlLmdldExvZ0dyb3VwU2V0dGluZ3MgPSBmdW5jdGlvbiAobmFtZUxvZ2dlckZhY3RvcnksIGlkTG9nR3JvdXBSdWxlKSB7XG4gICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy5fbWFwRmFjdG9yaWVzLmdldChuYW1lTG9nZ2VyRmFjdG9yeSk7XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuZ2V0TG9nR3JvdXBSdW50aW1lU2V0dGluZ3NCeUluZGV4KGlkTG9nR3JvdXBSdWxlKTtcbiAgICB9O1xuICAgIExGU2VydmljZUltcGwucHJvdG90eXBlLmdldExvZ2dlckZhY3RvcnlSdW50aW1lU2V0dGluZ3NCeU5hbWUgPSBmdW5jdGlvbiAobmFtZUxvZ2dlckZhY3RvcnkpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX21hcEZhY3Rvcmllcy5nZXQobmFtZUxvZ2dlckZhY3RvcnkpO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIExGU2VydmljZUltcGwuY3JlYXRlRGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyRmFjdG9yeU9wdGlvbnNfMS5Mb2dnZXJGYWN0b3J5T3B0aW9ucygpLmFkZExvZ0dyb3VwUnVsZShuZXcgTG9nR3JvdXBSdWxlXzEuTG9nR3JvdXBSdWxlKG5ldyBSZWdFeHAoXCIuK1wiKSwgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkluZm8pKTtcbiAgICB9O1xuICAgIC8vIExvYWRlZCBvbiBkZW1hbmQuIERvIE5PVCBjaGFuZ2UgYXMgd2VicGFjayBtYXkgcGFjayB0aGluZ3MgaW4gd3Jvbmcgb3JkZXIgb3RoZXJ3aXNlLlxuICAgIExGU2VydmljZUltcGwuX0lOU1RBTkNFID0gbnVsbDtcbiAgICByZXR1cm4gTEZTZXJ2aWNlSW1wbDtcbn0oKSk7XG4vKipcbiAqIENyZWF0ZSBhbmQgY29uZmlndXJlIHlvdXIgTG9nZ2VyRmFjdG9yeSBmcm9tIGhlcmUuXG4gKi9cbnZhciBMRlNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExGU2VydmljZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IExvZ2dlckZhY3Rvcnkgd2l0aCBnaXZlbiBvcHRpb25zIChpZiBhbnkpLiBJZiBubyBvcHRpb25zXG4gICAgICogYXJlIHNwZWNpZmllZCwgdGhlIExvZ2dlckZhY3RvcnksIHdpbGwgYWNjZXB0IGFueSBuYW1lZCBsb2dnZXIgYW5kIHdpbGxcbiAgICAgKiBsb2cgb24gaW5mbyBsZXZlbCBieSBkZWZhdWx0IGZvciwgdG8gdGhlIGNvbnNvbGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucywgb3B0aW9uYWwuXG4gICAgICogQHJldHVybnMge0xvZ2dlckZhY3Rvcnl9XG4gICAgICovXG4gICAgTEZTZXJ2aWNlLmNyZWF0ZUxvZ2dlckZhY3RvcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiBMRlNlcnZpY2UuSU5TVEFOQ0VfU0VSVklDRS5jcmVhdGVMb2dnZXJGYWN0b3J5KG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IExvZ2dlckZhY3RvcnkgdXNpbmcgZ2l2ZW4gbmFtZSAodXNlZCBmb3IgY29uc29sZSBhcGkvZXh0ZW5zaW9uKS5cbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIFBpY2sgc29tZXRoaW5nIHNob3J0IGJ1dCBkaXN0aW5ndWlzaGFibGUuIFRoZSB3b3JkIFwiREVGQVVMVFwiIGlzIHJlc2VydmVkIGFuZCBjYW5ub3QgYmUgdGFrZW4sIGl0IGlzIHVzZWRcbiAgICAgKiBmb3IgdGhlIGRlZmF1bHQgTG9nZ2VyRmFjdG9yeS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLCBvcHRpb25hbFxuICAgICAqIEByZXR1cm4ge0xvZ2dlckZhY3Rvcnl9XG4gICAgICovXG4gICAgTEZTZXJ2aWNlLmNyZWF0ZU5hbWVkTG9nZ2VyRmFjdG9yeSA9IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG51bGw7IH1cbiAgICAgICAgaWYgKG5hbWUgPT09IExGU2VydmljZS5ERUZBVUxUX0xPR0dFUl9GQUNUT1JZX05BTUUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvZ2dlckZhY3RvcnkgbmFtZTogXCIgKyBMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWV9OQU1FICsgXCIgaXMgcmVzZXJ2ZWQgYW5kIGNhbm5vdCBiZSB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTEZTZXJ2aWNlLklOU1RBTkNFX1NFUlZJQ0UuY3JlYXRlTmFtZWRMb2dnZXJGYWN0b3J5KG5hbWUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFsbCBMb2dnZXJzIGZvciBMb2dnZXJGYWN0b3JpZXMgdGhhdCB3ZXJlIGNyZWF0ZWQuXG4gICAgICogQWZ0ZXIgdGhpcyBjYWxsLCBhbGwgcHJldmlvdXNseSBmZXRjaGVkIExvZ2dlcnMgKGZyb20gdGhlaXJcbiAgICAgKiBmYWN0b3JpZXMpIGFyZSB1bnVzYWJsZS4gVGhlIGZhY3RvcmllcyByZW1haW4gYXMgdGhleSB3ZXJlLlxuICAgICAqL1xuICAgIExGU2VydmljZS5jbG9zZUxvZ2dlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMRlNlcnZpY2UuSU5TVEFOQ0VfU0VSVklDRS5jbG9zZUxvZ2dlcnMoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBMRlNlcnZpY2VSdW50aW1lU2V0dGluZ3MgdG8gcmV0cmlldmUgaW5mb3JtYXRpb24gbG9nZ2VyZmFjdG9yaWVzXG4gICAgICogYW5kIHRoZWlyIHJ1bnRpbWUgc2V0dGluZ3MuXG4gICAgICogQHJldHVybnMge0xGU2VydmljZVJ1bnRpbWVTZXR0aW5nc31cbiAgICAgKi9cbiAgICBMRlNlcnZpY2UuZ2V0UnVudGltZVNldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTEZTZXJ2aWNlLklOU1RBTkNFX1NFUlZJQ0U7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTEZTZXJ2aWNlLCBcIkRFRkFVTFRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBwcm9wZXJ0eSByZXR1cm5zIHRoZSBkZWZhdWx0IExvZ2dlckZhY3RvcnkgKGlmIG5vdCB5ZXQgaW5pdGlhbGl6ZWQgaXQgaXMgaW5pdGlhbGl6ZWQpLlxuICAgICAgICAgKiBUaGlzIExvZ2dlckZhY3RvcnkgY2FuIGJlIHVzZWQgdG8gc2hhcmUgYW1vbmcgbXVsdGlwbGVcbiAgICAgICAgICogYXBwbGljYXRpb25zL2xpYnJhcmllcyAtIHRoYXQgd2F5IHlvdSBjYW4gZW5hYmxlL2NoYW5nZSBsb2dnaW5nIG92ZXIgZXZlcnl0aGluZyBmcm9tXG4gICAgICAgICAqIHlvdXIgb3duIGFwcGxpY2F0aW9uIHdoZW4gcmVxdWlyZWQuXG4gICAgICAgICAqIEl0IGlzIHJlY29tbWVuZGVkIHRvIGJlIHVzZWQgYnkgbGlicmFyeSBkZXZlbG9wZXJzIHRvIG1ha2UgbG9nZ2luZyBlYXNpbHkgYXZhaWxhYmxlIGZvciB0aGVcbiAgICAgICAgICogY29uc3VtZXJzIG9mIHRoZWlyIGxpYnJhcmllcy5cbiAgICAgICAgICogSXQgaXMgaGlnaGx5IHJlY29tbWVuZGVkIHRvIHVzZSBMb2dnZXJzIGZyb20gdGhlIExvZ2dlckZhY3Rvcnkgd2l0aCB1bmlxdWUgZ3JvdXBpbmcvbmFtZXMgdG8gcHJldmVudFxuICAgICAgICAgKiBjbGFzaGVzIG9mIExvZ2dlcnMgYmV0d2VlbiBtdWx0aXBsZSBwcm9qZWN0cy5cbiAgICAgICAgICogQHJldHVybnMge0xvZ2dlckZhY3Rvcnl9IFJldHVybnMgdGhlIGRlZmF1bHQgTG9nZ2VyRmFjdG9yeVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTEZTZXJ2aWNlLmdldERlZmF1bHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTEZTZXJ2aWNlLmdldERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgTEZTZXJ2aWNlLkRFRkFVTFRfTE9HR0VSX0ZBQ1RPUlkgPSBMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWSA9IExGU2VydmljZS5JTlNUQU5DRV9TRVJWSUNFLmNyZWF0ZU5hbWVkTG9nZ2VyRmFjdG9yeShMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWV9OQU1FLCBuZXcgTG9nZ2VyRmFjdG9yeU9wdGlvbnNfMS5Mb2dnZXJGYWN0b3J5T3B0aW9ucygpLmFkZExvZ0dyb3VwUnVsZShuZXcgTG9nR3JvdXBSdWxlXzEuTG9nR3JvdXBSdWxlKG5ldyBSZWdFeHAoXCIuK1wiKSwgTG9nZ2VyT3B0aW9uc18xLkxvZ0xldmVsLkVycm9yKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWTtcbiAgICB9O1xuICAgIExGU2VydmljZS5ERUZBVUxUX0xPR0dFUl9GQUNUT1JZX05BTUUgPSBcIkRFRkFVTFRcIjtcbiAgICBMRlNlcnZpY2UuSU5TVEFOQ0VfU0VSVklDRSA9IExGU2VydmljZUltcGwuZ2V0SW5zdGFuY2UoKTtcbiAgICBMRlNlcnZpY2UuREVGQVVMVF9MT0dHRVJfRkFDVE9SWSA9IG51bGw7XG4gICAgcmV0dXJuIExGU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLkxGU2VydmljZSA9IExGU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxGU2VydmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbi8qKlxuICogRGVmaW5lcyBhIExvZ0dyb3VwUnVsZSwgdGhpcyBhbGxvd3MgeW91IHRvIGVpdGhlciBoYXZlIGV2ZXJ5dGhpbmcgY29uZmlndXJlZCB0aGUgc2FtZSB3YXlcbiAqIG9yIGZvciBleGFtcGxlIGxvZ2dlcnMgdGhhdCBzdGFydCB3aXRoIG5hbWUgbW9kZWwuIEl0IGFsbG93cyB5b3UgdG8gZ3JvdXAgbG9nZ2VycyB0b2dldGhlclxuICogdG8gaGF2ZSBhIGNlcnRhaW4gbG9nbGV2ZWwgYW5kIG90aGVyIHNldHRpbmdzLiBZb3UgY2FuIGNvbmZpZ3VyZSB0aGlzIHdoZW4gY3JlYXRpbmcgdGhlXG4gKiBMb2dnZXJGYWN0b3J5ICh3aGljaCBhY2NlcHRzIG11bHRpcGxlIExvZ0dyb3VwUnVsZXMpLlxuICovXG52YXIgTG9nR3JvdXBSdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBMb2dHcm91cFJ1bGUuIEJhc2ljYWxseSB5b3UgZGVmaW5lIHdoYXQgbG9nZ2VyIG5hbWUocykgbWF0Y2ggZm9yIHRoaXMgZ3JvdXAsIHdoYXQgbGV2ZWwgc2hvdWxkIGJlIHVzZWQgd2hhdCBsb2dnZXIgdHlwZSAod2hlcmUgdG8gbG9nKVxuICAgICAqIGFuZCB3aGF0IGZvcm1hdCB0byB3cml0ZSBpbi4gSWYgdGhlIGxvZ2dlclR5cGUgaXMgY3VzdG9tLCB0aGVuIHRoZSBjYWxsQmFja0xvZ2dlciBtdXN0IGJlIHN1cHBsaWVkIGFzIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJldHVybiBhIGN1c3RvbSBsb2dnZXIuXG4gICAgICogQHBhcmFtIHJlZ0V4cCBSZWd1bGFyIGV4cHJlc3Npb24sIHdoYXQgbWF0Y2hlcyBmb3IgeW91ciBsb2dnZXIgbmFtZXMgZm9yIHRoaXMgZ3JvdXBcbiAgICAgKiBAcGFyYW0gbGV2ZWwgTG9nTGV2ZWxcbiAgICAgKiBAcGFyYW0gbG9nRm9ybWF0IExvZ0Zvcm1hdFxuICAgICAqIEBwYXJhbSBsb2dnZXJUeXBlIFR5cGUgb2YgbG9nZ2VyLCBpZiBDdXN0b20sIG1ha2Ugc3VyZSB0byBpbXBsZW1lbnQgY2FsbEJhY2tMb2dnZXIgYW5kIHBhc3MgaW4sIHRoaXMgd2lsbCBiZSBjYWxsZWQgc28geW91IGNhbiByZXR1cm4geW91ciBvd24gbG9nZ2VyLlxuICAgICAqIEBwYXJhbSBjYWxsQmFja0xvZ2dlciBDYWxsYmFjayBmdW5jdGlvbiB0byByZXR1cm4gYSBuZXcgY2xlYW4gY3VzdG9tIGxvZ2dlciAoeW91cnMhKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvZ0dyb3VwUnVsZShyZWdFeHAsIGxldmVsLCBsb2dGb3JtYXQsIGxvZ2dlclR5cGUsIGNhbGxCYWNrTG9nZ2VyKSB7XG4gICAgICAgIGlmIChsb2dGb3JtYXQgPT09IHZvaWQgMCkgeyBsb2dGb3JtYXQgPSBuZXcgTG9nZ2VyT3B0aW9uc18xLkxvZ0Zvcm1hdCgpOyB9XG4gICAgICAgIGlmIChsb2dnZXJUeXBlID09PSB2b2lkIDApIHsgbG9nZ2VyVHlwZSA9IExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkNvbnNvbGU7IH1cbiAgICAgICAgaWYgKGNhbGxCYWNrTG9nZ2VyID09PSB2b2lkIDApIHsgY2FsbEJhY2tMb2dnZXIgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWdFeHAgPSByZWdFeHA7XG4gICAgICAgIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gICAgICAgIHRoaXMuX2xvZ0Zvcm1hdCA9IGxvZ0Zvcm1hdDtcbiAgICAgICAgdGhpcy5fbG9nZ2VyVHlwZSA9IGxvZ2dlclR5cGU7XG4gICAgICAgIHRoaXMuX2NhbGxCYWNrTG9nZ2VyID0gY2FsbEJhY2tMb2dnZXI7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dHcm91cFJ1bGUucHJvdG90eXBlLCBcInJlZ0V4cFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ0V4cDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVsZS5wcm90b3R5cGUsIFwibGV2ZWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVsZS5wcm90b3R5cGUsIFwibG9nZ2VyVHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2dlclR5cGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dHcm91cFJ1bGUucHJvdG90eXBlLCBcImxvZ0Zvcm1hdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0Zvcm1hdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVsZS5wcm90b3R5cGUsIFwiY2FsbEJhY2tMb2dnZXJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsQmFja0xvZ2dlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVsZS5wcm90b3R5cGUsIFwiZm9ybWF0dGVyTG9nTWVzc2FnZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGZvcm1hdHRlckxvZ01lc3NhZ2UgZnVuY3Rpb24sIHNlZSBjb21tZW50IG9uIHRoZSBzZXR0ZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHsoKG1lc3NhZ2U6TG9nTWVzc2FnZSk9PnN0cmluZyl8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGRlZmF1bHQgZm9ybWF0dGVyTG9nTWVzc2FnZSBmdW5jdGlvbiwgaWYgc2V0IGl0IGlzIGFwcGxpZWQgdG8gYWxsIHR5cGUgb2YgbG9nZ2VycyBleGNlcHQgZm9yIGEgY3VzdG9tIGxvZ2dlci5cbiAgICAgICAgICogQnkgZGVmYXVsdCB0aGlzIGlzIG51bGwgKG5vdCBzZXQpLiBZb3UgY2FuIGFzc2lnbiBhIGZ1bmN0aW9uIHRvIGFsbG93IGN1c3RvbSBmb3JtYXR0aW5nIG9mIGEgbG9nIG1lc3NhZ2UuXG4gICAgICAgICAqIEVhY2ggbG9nIG1lc3NhZ2Ugd2lsbCBjYWxsIHRoaXMgZnVuY3Rpb24gdGhlbiBhbmQgZXhwZWN0cyB5b3VyIGZ1bmN0aW9uIHRvIGZvcm1hdCB0aGUgbWVzc2FnZSBhbmQgcmV0dXJuIGEgc3RyaW5nLlxuICAgICAgICAgKiBXaWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSBhdHRlbXB0IHRvIHNldCBhIGZvcm1hdHRlckxvZ01lc3NhZ2UgaWYgdGhlIExvZ2dlclR5cGUgaXMgY3VzdG9tLlxuICAgICAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGZvcm1hdHRlciBmdW5jdGlvbiwgb3IgbnVsbCB0byByZXNldCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdGhpcy5fbG9nZ2VyVHlwZSA9PT0gTG9nZ2VyT3B0aW9uc18xLkxvZ2dlclR5cGUuQ3VzdG9tKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBzcGVjaWZ5IGEgZm9ybWF0dGVyIGZvciBsb2cgbWVzc2FnZXMgaWYgeW91ciBsb2dnZXJUeXBlIGlzIEN1c3RvbVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIExvZ0dyb3VwUnVsZTtcbn0oKSk7XG5leHBvcnRzLkxvZ0dyb3VwUnVsZSA9IExvZ0dyb3VwUnVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvZ0dyb3VwUnVsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyT3B0aW9uc1wiKTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcnVudGltZSBzZXR0aW5ncyBmb3IgYSBMb2dHcm91cCAoTG9nR3JvdXBSdWxlKS5cbiAqL1xudmFyIExvZ0dyb3VwUnVudGltZVNldHRpbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyhsb2dHcm91cFJ1bGUpIHtcbiAgICAgICAgdGhpcy5fZm9ybWF0dGVyTG9nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvZ0dyb3VwUnVsZSA9IGxvZ0dyb3VwUnVsZTtcbiAgICAgICAgdGhpcy5fbGV2ZWwgPSBsb2dHcm91cFJ1bGUubGV2ZWw7XG4gICAgICAgIHRoaXMuX2xvZ2dlclR5cGUgPSBsb2dHcm91cFJ1bGUubG9nZ2VyVHlwZTtcbiAgICAgICAgdGhpcy5fbG9nRm9ybWF0ID0gbmV3IExvZ2dlck9wdGlvbnNfMS5Mb2dGb3JtYXQobmV3IExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0KGxvZ0dyb3VwUnVsZS5sb2dGb3JtYXQuZGF0ZUZvcm1hdC5mb3JtYXRFbnVtLCBsb2dHcm91cFJ1bGUubG9nRm9ybWF0LmRhdGVGb3JtYXQuZGF0ZVNlcGFyYXRvciksIGxvZ0dyb3VwUnVsZS5sb2dGb3JtYXQuc2hvd1RpbWVTdGFtcCwgbG9nR3JvdXBSdWxlLmxvZ0Zvcm1hdC5zaG93TG9nZ2VyTmFtZSk7XG4gICAgICAgIHRoaXMuX2NhbGxCYWNrTG9nZ2VyID0gbG9nR3JvdXBSdWxlLmNhbGxCYWNrTG9nZ2VyO1xuICAgICAgICB0aGlzLl9mb3JtYXR0ZXJMb2dNZXNzYWdlID0gbG9nR3JvdXBSdWxlLmZvcm1hdHRlckxvZ01lc3NhZ2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncy5wcm90b3R5cGUsIFwibG9nR3JvdXBSdWxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgb3JpZ2luYWwgTG9nR3JvdXBSdWxlIChzbyBub3QgcnVudGltZSBzZXR0aW5ncyEpXG4gICAgICAgICAqIEByZXR1cm4ge0xvZ0dyb3VwUnVsZX1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0dyb3VwUnVsZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJsZXZlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xldmVsO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbGV2ZWwgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJsb2dnZXJUeXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nZ2VyVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlclR5cGUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJsb2dGb3JtYXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dGb3JtYXQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dGb3JtYXQgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJjYWxsQmFja0xvZ2dlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxCYWNrTG9nZ2VyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbEJhY2tMb2dnZXIgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ0dyb3VwUnVudGltZVNldHRpbmdzLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJMb2dNZXNzYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0dGVyTG9nTWVzc2FnZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zvcm1hdHRlckxvZ01lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIExvZ0dyb3VwUnVudGltZVNldHRpbmdzO1xufSgpKTtcbmV4cG9ydHMuTG9nR3JvdXBSdW50aW1lU2V0dGluZ3MgPSBMb2dHcm91cFJ1bnRpbWVTZXR0aW5ncztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxvZ0dyb3VwUnVudGltZVNldHRpbmdzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERhdGFTdHJ1Y3R1cmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvRGF0YVN0cnVjdHVyZXNcIik7XG52YXIgTG9nZ2VyT3B0aW9uc18xID0gcmVxdWlyZShcIi4uL0xvZ2dlck9wdGlvbnNcIik7XG52YXIgQ29uc29sZUxvZ2dlckltcGxfMSA9IHJlcXVpcmUoXCIuL0NvbnNvbGVMb2dnZXJJbXBsXCIpO1xudmFyIE1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsXzEgPSByZXF1aXJlKFwiLi9NZXNzYWdlQnVmZmVyTG9nZ2VySW1wbFwiKTtcbnZhciBBYnN0cmFjdExvZ2dlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RMb2dnZXJcIik7XG52YXIgTG9nR3JvdXBSdW50aW1lU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0xvZ0dyb3VwUnVudGltZVNldHRpbmdzXCIpO1xudmFyIExvZ2dlckZhY3RvcnlJbXBsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2dnZXJGYWN0b3J5SW1wbChuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlcnMgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5TaW1wbGVNYXAoKTtcbiAgICAgICAgdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3NJbmRleGVkID0gW107XG4gICAgICAgIHRoaXMuX2xvZ2dlclRvTG9nR3JvdXBTZXR0aW5ncyA9IG5ldyBEYXRhU3RydWN0dXJlc18xLlNpbXBsZU1hcCgpO1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb25maWd1cmUob3B0aW9ucyk7XG4gICAgfVxuICAgIExvZ2dlckZhY3RvcnlJbXBsLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgLy8gQ2xvc2UgYW55IGN1cnJlbnQgb3BlbiBsb2dnZXJzLlxuICAgICAgICB0aGlzLmNsb3NlTG9nZ2VycygpO1xuICAgICAgICB0aGlzLl9sb2dnZXJUb0xvZ0dyb3VwU2V0dGluZ3MuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3NJbmRleGVkID0gW107XG4gICAgICAgIHZhciBsb2dHcm91cFJ1bGVzID0gdGhpcy5fb3B0aW9ucy5sb2dHcm91cFJ1bGVzO1xuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpwcmVmZXItZm9yLW9mICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nR3JvdXBSdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3NJbmRleGVkLnB1c2gobmV3IExvZ0dyb3VwUnVudGltZVNldHRpbmdzXzEuTG9nR3JvdXBSdW50aW1lU2V0dGluZ3MobG9nR3JvdXBSdWxlc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIC8qIHRzbGludDplbmFibGU6cHJlZmVyLWZvci1vZiAqL1xuICAgIH07XG4gICAgTG9nZ2VyRmFjdG9yeUltcGwucHJvdG90eXBlLmdldExvZ2dlciA9IGZ1bmN0aW9uIChuYW1lZCkge1xuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9nZ2VyRmFjdG9yeSBpcyBub3QgZW5hYmxlZCwgcGxlYXNlIGNoZWNrIHlvdXIgb3B0aW9ucyBwYXNzZWQgaW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZ2dlciA9IHRoaXMuX2xvZ2dlcnMuZ2V0KG5hbWVkKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2dnZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBsb2dnZXIgd2l0aCBhcHByb3ByaWF0ZSBsZXZlbFxuICAgICAgICBsb2dnZXIgPSB0aGlzLmxvYWRMb2dnZXIobmFtZWQpO1xuICAgICAgICB0aGlzLl9sb2dnZXJzLnB1dChuYW1lZCwgbG9nZ2VyKTtcbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnlJbXBsLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmVuYWJsZWQ7XG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5SW1wbC5wcm90b3R5cGUuY2xvc2VMb2dnZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2dnZXJzLmZvckVhY2hWYWx1ZShmdW5jdGlvbiAobG9nZ2VyKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4gb25seSBjbG9zZSBpZiBBYnN0cmFjdExvZ2dlciBpcyB1c2VkIChvdXIgbG9nZ2VycywgYnV0IHVzZXIgbG9nZ2VycyBtYXkgbm90IGV4dGVuZCBpdCwgZXZlbiB0aG91Z2ggdW5saWtlbHkpLlxuICAgICAgICAgICAgaWYgKGxvZ2dlciBpbnN0YW5jZW9mIEFic3RyYWN0TG9nZ2VyXzEuQWJzdHJhY3RMb2dnZXIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xvZ2dlcnMuY2xlYXIoKTtcbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnlJbXBsLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnlJbXBsLnByb3RvdHlwZS5nZXRMb2dHcm91cFJ1bnRpbWVTZXR0aW5nc0J5SW5kZXggPSBmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPCB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5nc0luZGV4ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3NJbmRleGVkW2lkeF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5SW1wbC5wcm90b3R5cGUuZ2V0TG9nR3JvdXBSdW50aW1lU2V0dGluZ3NCeUxvZ2dlck5hbWUgPSBmdW5jdGlvbiAobmFtZUxvZ2dlcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fbG9nZ2VyVG9Mb2dHcm91cFNldHRpbmdzLmdldChuYW1lTG9nZ2VyKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5SW1wbC5wcm90b3R5cGUuZ2V0TG9nR3JvdXBSdW50aW1lU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bnRpbWVTZXR0aW5nc0luZGV4ZWQuc2xpY2UoMCk7XG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5SW1wbC5wcm90b3R5cGUubG9hZExvZ2dlciA9IGZ1bmN0aW9uIChuYW1lZCkge1xuICAgICAgICB2YXIgbG9nR3JvdXBSdWxlcyA9IHRoaXMuX29wdGlvbnMubG9nR3JvdXBSdWxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dHcm91cFJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9nR3JvdXBSdWxlID0gbG9nR3JvdXBSdWxlc1tpXTtcbiAgICAgICAgICAgIGlmIChsb2dHcm91cFJ1bGUucmVnRXhwLnRlc3QobmFtZWQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzID0gdGhpcy5fbG9nR3JvdXBSdW50aW1lU2V0dGluZ3NJbmRleGVkW2ldO1xuICAgICAgICAgICAgICAgIHZhciBsb2dnZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChsb2dHcm91cFJ1bGUubG9nZ2VyVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlLkNvbnNvbGU6XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIgPSBuZXcgQ29uc29sZUxvZ2dlckltcGxfMS5Db25zb2xlTG9nZ2VySW1wbChuYW1lZCwgbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTG9nZ2VyT3B0aW9uc18xLkxvZ2dlclR5cGUuTWVzc2FnZUJ1ZmZlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlciA9IG5ldyBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbF8xLk1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsKG5hbWVkLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuTG9nZ2VyVHlwZS5DdXN0b206XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9nR3JvdXBSdWxlLmNhbGxCYWNrTG9nZ2VyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIgPSBsb2dHcm91cFJ1bGUuY2FsbEJhY2tMb2dnZXIobmFtZWQsIGxvZ0dyb3VwUnVudGltZVNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgYSBjdXN0b20gbG9nZ2VyLCBjdXN0b20gY2FsbGJhY2sgaXMgbnVsbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNyZWF0ZSBhIExvZ2dlciBmb3IgTG9nZ2VyVHlwZTogXCIgKyBsb2dHcm91cFJ1bGUubG9nZ2VyVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvciBhIG5ldyBsb2dnZXIgbWFwIGl0IGJ5IGl0cyBuYW1lXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyVG9Mb2dHcm91cFNldHRpbmdzLnB1dChuYW1lZCwgbG9nR3JvdXBSdW50aW1lU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZpbmQgYSBtYXRjaCB0byBjcmVhdGUgYSBMb2dnZXIgZm9yOiBcIiArIG5hbWVkKTtcbiAgICB9O1xuICAgIHJldHVybiBMb2dnZXJGYWN0b3J5SW1wbDtcbn0oKSk7XG5leHBvcnRzLkxvZ2dlckZhY3RvcnlJbXBsID0gTG9nZ2VyRmFjdG9yeUltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2dnZXJGYWN0b3J5SW1wbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogT3B0aW9ucyBvYmplY3QgeW91IGNhbiB1c2UgdG8gY29uZmlndXJlIHRoZSBMb2dnZXJGYWN0b3J5IHlvdSBjcmVhdGUgYXQgTEZTZXJ2aWNlLlxuICovXG52YXIgTG9nZ2VyRmFjdG9yeU9wdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlckZhY3RvcnlPcHRpb25zKCkge1xuICAgICAgICB0aGlzLl9sb2dHcm91cFJ1bGVzID0gW107XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgTG9nR3JvdXBSdWxlLCBzZWUge0xvZ0dyb3VwUnVsZSkgZm9yIGRldGFpbHNcbiAgICAgKiBAcGFyYW0gcnVsZSBSdWxlIHRvIGFkZFxuICAgICAqIEByZXR1cm5zIHtMb2dnZXJGYWN0b3J5T3B0aW9uc30gcmV0dXJucyBpdHNlbGZcbiAgICAgKi9cbiAgICBMb2dnZXJGYWN0b3J5T3B0aW9ucy5wcm90b3R5cGUuYWRkTG9nR3JvdXBSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgdGhpcy5fbG9nR3JvdXBSdWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGxvZ2dpbmcgY29tcGxldGVseSBmb3IgdGhlIExvZ2dlckZhY3RvcnkuXG4gICAgICogQHBhcmFtIGVuYWJsZWQgVHJ1ZSBmb3IgZW5hYmxlZCAoZGVmYXVsdClcbiAgICAgKiBAcmV0dXJucyB7TG9nZ2VyRmFjdG9yeU9wdGlvbnN9IHJldHVybnMgaXRzZWxmXG4gICAgICovXG4gICAgTG9nZ2VyRmFjdG9yeU9wdGlvbnMucHJvdG90eXBlLnNldEVuYWJsZWQgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZW5hYmxlZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nZ2VyRmFjdG9yeU9wdGlvbnMucHJvdG90eXBlLCBcImxvZ0dyb3VwUnVsZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2dHcm91cFJ1bGVzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nZ2VyRmFjdG9yeU9wdGlvbnMucHJvdG90eXBlLCBcImVuYWJsZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gTG9nZ2VyRmFjdG9yeU9wdGlvbnM7XG59KCkpO1xuZXhwb3J0cy5Mb2dnZXJGYWN0b3J5T3B0aW9ucyA9IExvZ2dlckZhY3RvcnlPcHRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9nZ2VyRmFjdG9yeU9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBYnN0cmFjdExvZ2dlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RMb2dnZXJcIik7XG4vKipcbiAqIExvZ2dlciB3aGljaCBidWZmZXJzIGFsbCBtZXNzYWdlcywgdXNlIHdpdGggY2FyZSBkdWUgdG8gcG9zc2libGUgaGlnaCBtZW1vcnkgZm9vdHByaW50LlxuICogQ2FuIGJlIGNvbnZlbmllbnQgaW4gc29tZSBjYXNlcy4gQ2FsbCB0b1N0cmluZygpIGZvciBmdWxsIG91dHB1dCwgb3IgY2FzdCB0byB0aGlzIGNsYXNzXG4gKiBhbmQgY2FsbCBnZXRNZXNzYWdlcygpIHRvIGRvIHNvbWV0aGluZyB3aXRoIGl0IHlvdXJzZWxmLlxuICovXG52YXIgTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbChuYW1lLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBsb2dHcm91cFJ1bnRpbWVTZXR0aW5ncykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5jbG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwucHJvdG90eXBlLmdldE1lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcztcbiAgICB9O1xuICAgIE1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMubWFwKGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbC5wcm90b3R5cGUuZG9Mb2cgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgbWVzc2FnZUZvcm1hdHRlciA9IHRoaXMuX2dldE1lc3NhZ2VGb3JtYXR0ZXIoKTtcbiAgICAgICAgdmFyIGZ1bGxNc2c7XG4gICAgICAgIGlmIChtZXNzYWdlRm9ybWF0dGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICBmdWxsTXNnID0gdGhpcy5jcmVhdGVEZWZhdWx0TG9nTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGxNc2cgPSBtZXNzYWdlRm9ybWF0dGVyKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaChmdWxsTXNnKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbDtcbn0oQWJzdHJhY3RMb2dnZXJfMS5BYnN0cmFjdExvZ2dlcikpO1xuZXhwb3J0cy5NZXNzYWdlQnVmZmVyTG9nZ2VySW1wbCA9IE1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIExvZ0dyb3VwQ29udHJvbF8xID0gcmVxdWlyZShcIi4vY29udHJvbC9Mb2dHcm91cENvbnRyb2xcIik7XG52YXIgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbF8xID0gcmVxdWlyZShcIi4vY29udHJvbC9DYXRlZ29yeVNlcnZpY2VDb250cm9sXCIpO1xudmFyIEV4dGVuc2lvbkhlbHBlcl8xID0gcmVxdWlyZShcIi4vZXh0ZW5zaW9uL0V4dGVuc2lvbkhlbHBlclwiKTtcbmV4cG9ydHMuRXh0ZW5zaW9uSGVscGVyID0gRXh0ZW5zaW9uSGVscGVyXzEuRXh0ZW5zaW9uSGVscGVyO1xuLy8gQ2F0ZWdvcnkgcmVsYXRlZFxudmFyIEFic3RyYWN0Q2F0ZWdvcnlMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL2xvZy9jYXRlZ29yeS9BYnN0cmFjdENhdGVnb3J5TG9nZ2VyXCIpO1xuZXhwb3J0cy5BYnN0cmFjdENhdGVnb3J5TG9nZ2VyID0gQWJzdHJhY3RDYXRlZ29yeUxvZ2dlcl8xLkFic3RyYWN0Q2F0ZWdvcnlMb2dnZXI7XG52YXIgQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbF8xID0gcmVxdWlyZShcIi4vbG9nL2NhdGVnb3J5L0NhdGVnb3J5Q29uc29sZUxvZ2dlckltcGxcIik7XG5leHBvcnRzLkNhdGVnb3J5Q29uc29sZUxvZ2dlckltcGwgPSBDYXRlZ29yeUNvbnNvbGVMb2dnZXJJbXBsXzEuQ2F0ZWdvcnlDb25zb2xlTG9nZ2VySW1wbDtcbnZhciBDYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbF8xID0gcmVxdWlyZShcIi4vbG9nL2NhdGVnb3J5L0NhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsXCIpO1xuZXhwb3J0cy5DYXRlZ29yeURlbGVnYXRlTG9nZ2VySW1wbCA9IENhdGVnb3J5RGVsZWdhdGVMb2dnZXJJbXBsXzEuQ2F0ZWdvcnlEZWxlZ2F0ZUxvZ2dlckltcGw7XG52YXIgQ2F0ZWdvcnlfMSA9IHJlcXVpcmUoXCIuL2xvZy9jYXRlZ29yeS9DYXRlZ29yeVwiKTtcbmV4cG9ydHMuQ2F0ZWdvcnkgPSBDYXRlZ29yeV8xLkNhdGVnb3J5O1xudmFyIENhdGVnb3J5UnVudGltZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9sb2cvY2F0ZWdvcnkvQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3NcIik7XG5leHBvcnRzLkNhdGVnb3J5UnVudGltZVNldHRpbmdzID0gQ2F0ZWdvcnlSdW50aW1lU2V0dGluZ3NfMS5DYXRlZ29yeVJ1bnRpbWVTZXR0aW5ncztcbnZhciBDYXRlZ29yeUNvbmZpZ3VyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2xvZy9jYXRlZ29yeS9DYXRlZ29yeUNvbmZpZ3VyYXRpb25cIik7XG5leHBvcnRzLkNhdGVnb3J5Q29uZmlndXJhdGlvbiA9IENhdGVnb3J5Q29uZmlndXJhdGlvbl8xLkNhdGVnb3J5Q29uZmlndXJhdGlvbjtcbnZhciBDYXRlZ29yeU1lc3NhZ2VCdWZmZXJJbXBsXzEgPSByZXF1aXJlKFwiLi9sb2cvY2F0ZWdvcnkvQ2F0ZWdvcnlNZXNzYWdlQnVmZmVySW1wbFwiKTtcbmV4cG9ydHMuQ2F0ZWdvcnlNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbCA9IENhdGVnb3J5TWVzc2FnZUJ1ZmZlckltcGxfMS5DYXRlZ29yeU1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsO1xudmFyIENhdGVnb3J5U2VydmljZUZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL2xvZy9jYXRlZ29yeS9DYXRlZ29yeVNlcnZpY2VGYWN0b3J5XCIpO1xuZXhwb3J0cy5DYXRlZ29yeVNlcnZpY2VGYWN0b3J5ID0gQ2F0ZWdvcnlTZXJ2aWNlRmFjdG9yeV8xLkNhdGVnb3J5U2VydmljZUZhY3Rvcnk7XG52YXIgTG9nZ2VyRmFjdG9yeU9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2xvZy9zdGFuZGFyZC9Mb2dnZXJGYWN0b3J5T3B0aW9uc1wiKTtcbmV4cG9ydHMuTG9nZ2VyRmFjdG9yeU9wdGlvbnMgPSBMb2dnZXJGYWN0b3J5T3B0aW9uc18xLkxvZ2dlckZhY3RvcnlPcHRpb25zO1xudmFyIExvZ0dyb3VwUnVsZV8xID0gcmVxdWlyZShcIi4vbG9nL3N0YW5kYXJkL0xvZ0dyb3VwUnVsZVwiKTtcbmV4cG9ydHMuTG9nR3JvdXBSdWxlID0gTG9nR3JvdXBSdWxlXzEuTG9nR3JvdXBSdWxlO1xudmFyIExGU2VydmljZV8xID0gcmVxdWlyZShcIi4vbG9nL3N0YW5kYXJkL0xGU2VydmljZVwiKTtcbmV4cG9ydHMuTEZTZXJ2aWNlID0gTEZTZXJ2aWNlXzEuTEZTZXJ2aWNlO1xudmFyIEFic3RyYWN0TG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9sb2cvc3RhbmRhcmQvQWJzdHJhY3RMb2dnZXJcIik7XG5leHBvcnRzLkFic3RyYWN0TG9nZ2VyID0gQWJzdHJhY3RMb2dnZXJfMS5BYnN0cmFjdExvZ2dlcjtcbnZhciBDb25zb2xlTG9nZ2VySW1wbF8xID0gcmVxdWlyZShcIi4vbG9nL3N0YW5kYXJkL0NvbnNvbGVMb2dnZXJJbXBsXCIpO1xuZXhwb3J0cy5Db25zb2xlTG9nZ2VySW1wbCA9IENvbnNvbGVMb2dnZXJJbXBsXzEuQ29uc29sZUxvZ2dlckltcGw7XG52YXIgTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGxfMSA9IHJlcXVpcmUoXCIuL2xvZy9zdGFuZGFyZC9NZXNzYWdlQnVmZmVyTG9nZ2VySW1wbFwiKTtcbmV4cG9ydHMuTWVzc2FnZUJ1ZmZlckxvZ2dlckltcGwgPSBNZXNzYWdlQnVmZmVyTG9nZ2VySW1wbF8xLk1lc3NhZ2VCdWZmZXJMb2dnZXJJbXBsO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2xvZy9Mb2dnZXJPcHRpb25zXCIpO1xuZXhwb3J0cy5DYXRlZ29yeUxvZ0Zvcm1hdCA9IExvZ2dlck9wdGlvbnNfMS5DYXRlZ29yeUxvZ0Zvcm1hdDtcbmV4cG9ydHMuRGF0ZUZvcm1hdCA9IExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0O1xuZXhwb3J0cy5EYXRlRm9ybWF0RW51bSA9IExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0RW51bTtcbmV4cG9ydHMuTG9nRm9ybWF0ID0gTG9nZ2VyT3B0aW9uc18xLkxvZ0Zvcm1hdDtcbmV4cG9ydHMuTG9nZ2VyVHlwZSA9IExvZ2dlck9wdGlvbnNfMS5Mb2dnZXJUeXBlO1xuZXhwb3J0cy5Mb2dMZXZlbCA9IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbDtcbi8vIFV0aWxpdGllc1xudmFyIERhdGFTdHJ1Y3R1cmVzXzEgPSByZXF1aXJlKFwiLi91dGlscy9EYXRhU3RydWN0dXJlc1wiKTtcbmV4cG9ydHMuU2ltcGxlTWFwID0gRGF0YVN0cnVjdHVyZXNfMS5TaW1wbGVNYXA7XG5leHBvcnRzLkxpbmtlZExpc3QgPSBEYXRhU3RydWN0dXJlc18xLkxpbmtlZExpc3Q7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91dGlscy9KU09OSGVscGVyXCIpKTtcbnZhciBNZXNzYWdlVXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL01lc3NhZ2VVdGlsc1wiKTtcbmV4cG9ydHMuTWVzc2FnZUZvcm1hdFV0aWxzID0gTWVzc2FnZVV0aWxzXzEuTWVzc2FnZUZvcm1hdFV0aWxzO1xuLypcbiBGdW5jdGlvbnMgdG8gZXhwb3J0IG9uIFRTTCBsaWJhcmFyeSB2YXIuXG4qL1xuLy8gRXhwb3J0IGhlbHAgZnVuY3Rpb25cbmZ1bmN0aW9uIGhlbHAoKSB7XG4gICAgLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xuICAgIGNvbnNvbGUubG9nKFwiaGVscCgpXFxuICAgKiogU2hvd3MgdGhpcyBoZWxwXFxuXFxuIGdldExvZ0NvbnRyb2woKTogTG9nZ2VyQ29udHJvbFxcbiAgICoqIFJldHVybnMgTG9nZ2VyQ29udHJvbCBPYmplY3QsIHVzZSB0byBkeW5hbWljYWxseSBjaGFuZ2UgbG9nbGV2ZWxzIGZvciBsb2c0aiBsb2dnaW5nLlxcbiAgICoqIENhbGwgLmhlbHAoKSBvbiBMb2dnZXJDb250cm9sIG9iamVjdCBmb3IgYXZhaWxhYmxlIG9wdGlvbnMuXFxuXFxuIGdldENhdGVnb3J5Q29udHJvbCgpOiBDYXRlZ29yeVNlcnZpY2VDb250cm9sXFxuICAgKiogUmV0dXJucyBDYXRlZ29yeVNlcnZpY2VDb250cm9sIE9iamVjdCwgdXNlIHRvIGR5bmFtaWNhbGx5IGNoYW5nZSBsb2dsZXZlbHMgZm9yIGNhdGVnb3J5IGxvZ2dpbmcuXFxuICAgKiogQ2FsbCAuaGVscCgpIG9uIENhdGVnb3J5U2VydmljZUNvbnRyb2wgb2JqZWN0IGZvciBhdmFpbGFibGUgb3B0aW9ucy5cXG5cIik7XG4gICAgLyogdHNsaW50OmVuYWJsZTpuby1jb25zb2xlICovXG59XG5leHBvcnRzLmhlbHAgPSBoZWxwO1xuLy8gRXhwb3J0IExvZ0NvbnRyb2wgZnVuY3Rpb24gKGxvZzRqKVxuZnVuY3Rpb24gZ2V0TG9nQ29udHJvbCgpIHtcbiAgICByZXR1cm4gbmV3IExvZ0dyb3VwQ29udHJvbF8xLkxvZ2dlckNvbnRyb2xJbXBsKCk7XG59XG5leHBvcnRzLmdldExvZ0NvbnRyb2wgPSBnZXRMb2dDb250cm9sO1xuLy8gRXhwb3J0IENhdGVnb3J5Q29udHJvbCBmdW5jdGlvblxuZnVuY3Rpb24gZ2V0Q2F0ZWdvcnlDb250cm9sKCkge1xuICAgIHJldHVybiBuZXcgQ2F0ZWdvcnlTZXJ2aWNlQ29udHJvbF8xLkNhdGVnb3J5U2VydmljZUNvbnRyb2xJbXBsKCk7XG59XG5leHBvcnRzLmdldENhdGVnb3J5Q29udHJvbCA9IGdldENhdGVnb3J5Q29udHJvbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzY3JpcHQtbG9nZ2luZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMaW5rZWROb2RlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMaW5rZWROb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5rZWROb2RlLnByb3RvdHlwZSwgXCJwcmV2aW91c1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXMgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmtlZE5vZGUucHJvdG90eXBlLCBcIm5leHRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZXh0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dCA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGlua2VkTm9kZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIExpbmtlZE5vZGU7XG59KCkpO1xuLyoqXG4gKiBEb3VibGUgbGlua2VkbGlzdCBpbXBsZW1lbnRhdGlvbi5cbiAqL1xudmFyIExpbmtlZExpc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmtlZExpc3QoKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmFkZEhlYWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZUhlYWRJZk5lZWRlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgICAgICAgICAgIHZhciBuZXdIZWFkTm9kZSA9IG5ldyBMaW5rZWROb2RlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9kZS5wcmV2aW91cyA9IG5ld0hlYWROb2RlO1xuICAgICAgICAgICAgICAgICAgICBuZXdIZWFkTm9kZS5uZXh0ID0gbmV4dE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5ld0hlYWROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBsaXN0IGltcGxlbWVudGF0aW9uIGJyb2tlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemUrKztcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmFkZFRhaWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZUhlYWRJZk5lZWRlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBvbGRUYWlsTm9kZSA9IHRoaXMuZ2V0VGFpbE5vZGUoKTtcbiAgICAgICAgICAgIGlmIChvbGRUYWlsTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1RhaWxOb2RlID0gbmV3IExpbmtlZE5vZGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIG9sZFRhaWxOb2RlLm5leHQgPSBuZXdUYWlsTm9kZTtcbiAgICAgICAgICAgICAgICBuZXdUYWlsTm9kZS5wcmV2aW91cyA9IG9sZFRhaWxOb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGlzdCBpbXBsZW1lbnRhdGlvbiBicm9rZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmdldEhlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVhZC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnJlbW92ZUhlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9sZEhlYWQgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvbGRIZWFkLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gb2xkSGVhZC5uZXh0O1xuICAgICAgICAgICAgdGhpcy5zaXplLS07XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5nZXRUYWlsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0VGFpbE5vZGUoKTtcbiAgICAgICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZW1vdmVUYWlsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0VGFpbE5vZGUoKTtcbiAgICAgICAgaWYgKG5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNOb2RlID0gbm9kZS5wcmV2aW91cztcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOb2RlLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGlzdCBpbXBsZW1lbnRhdGlvbiBpcyBicm9rZW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zaXplLS07XG4gICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB2YXIgcmVjdXJzZSA9IGZ1bmN0aW9uIChmbiwgbm9kZSwgdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoZm4obm9kZS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChub2RlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgICAgIGlmIChuZXh0Tm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVjdXJzZShmbiwgbmV4dE5vZGUsIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5oZWFkO1xuICAgICAgICBpZiAoY3VycmVudE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVjdXJzZShmLCBjdXJyZW50Tm9kZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuY3JlYXRlSGVhZElmTmVlZGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gbmV3IExpbmtlZE5vZGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuZ2V0VGFpbE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlIChub2RlLm5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIHJldHVybiBMaW5rZWRMaXN0O1xufSgpKTtcbmV4cG9ydHMuTGlua2VkTGlzdCA9IExpbmtlZExpc3Q7XG4vKipcbiAqIE1hcCBpbXBsZW1lbnRhdGlvbiBrZXllZCBieSBzdHJpbmcgKGFsd2F5cykuXG4gKi9cbnZhciBTaW1wbGVNYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNpbXBsZU1hcCgpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IHt9O1xuICAgIH1cbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXJyYXlba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gICAgU2ltcGxlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5W2tleV07XG4gICAgfTtcbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hcnJheVtrZXldO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIik7XG4gICAgfTtcbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hcnJheVtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hcnJheVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFNpbXBsZU1hcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgcmFuZG9tIHN0dWZmIHRvIGFwcGVhclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG4gICAgU2ltcGxlTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuYXJyYXkpIHtcbiAgICAgICAgICAgIC8vIFRvIHByZXZlbnQgcmFuZG9tIHN0dWZmIHRvIGFwcGVhclxuICAgICAgICAgICAgaWYgKHRoaXMuYXJyYXkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuZ2V0KGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfTtcbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleXMoKS5sZW5ndGg7XG4gICAgfTtcbiAgICBTaW1wbGVNYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUoKSA9PT0gMDtcbiAgICB9O1xuICAgIFNpbXBsZU1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSB7fTtcbiAgICB9O1xuICAgIFNpbXBsZU1hcC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChjYkZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmFycmF5KSB7XG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IHJhbmRvbSBzdHVmZiB0byBhcHBlYXJcbiAgICAgICAgICAgIGlmICh0aGlzLmFycmF5Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmFycmF5W2tleV07XG4gICAgICAgICAgICAgICAgY2JGdW5jdGlvbihrZXksIHZhbHVlLCBjb3VudCk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2ltcGxlTWFwLnByb3RvdHlwZS5mb3JFYWNoVmFsdWUgPSBmdW5jdGlvbiAoY2JGdW5jdGlvbikge1xuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5hcnJheSkge1xuICAgICAgICAgICAgLy8gVG8gcHJldmVudCByYW5kb20gc3R1ZmYgdG8gYXBwZWFyXG4gICAgICAgICAgICBpZiAodGhpcy5hcnJheS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hcnJheVtrZXldO1xuICAgICAgICAgICAgICAgIGNiRnVuY3Rpb24odmFsdWUsIGNvdW50KTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2ltcGxlTWFwO1xufSgpKTtcbmV4cG9ydHMuU2ltcGxlTWFwID0gU2ltcGxlTWFwO1xuLyoqXG4gKiBUdXBsZSB0byBob2xkIHR3byB2YWx1ZXMuXG4gKi9cbnZhciBUdXBsZVBhaXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR1cGxlUGFpcih4LCB5KSB7XG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFR1cGxlUGFpci5wcm90b3R5cGUsIFwieFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl94ID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUdXBsZVBhaXIucHJvdG90eXBlLCBcInlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVHVwbGVQYWlyO1xufSgpKTtcbmV4cG9ydHMuVHVwbGVQYWlyID0gVHVwbGVQYWlyO1xuLyoqXG4gKiBVdGlsaXR5IGNsYXNzIHRvIGJ1aWxkIHVwIGEgc3RyaW5nLlxuICovXG52YXIgU3RyaW5nQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nQnVpbGRlcigpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgfVxuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQgfHwgbGluZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgbXVzdCBiZSBzZXQsIGNhbm5vdCBhcHBlbmQgbnVsbCBvciB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhLnB1c2gobGluZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKGxpbmUgKyBcIlxcblwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTdHJpbmdCdWlsZGVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB9O1xuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHNlcGFyYXRvcikge1xuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDApIHsgc2VwYXJhdG9yID0gXCJcIjsgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdCdWlsZGVyO1xufSgpKTtcbmV4cG9ydHMuU3RyaW5nQnVpbGRlciA9IFN0cmluZ0J1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EYXRhU3RydWN0dXJlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBNb2R1bGUgY29udGFpbmluZyBidW5jaCBvZiBKU09OIHJlbGF0ZWQgc3R1ZmYuXG4gKi9cbnZhciBMb2dnZXJPcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vbG9nL0xvZ2dlck9wdGlvbnNcIik7XG52YXIgRGF0YVN0cnVjdHVyZXNfMSA9IHJlcXVpcmUoXCIuL0RhdGFTdHJ1Y3R1cmVzXCIpO1xudmFyIEpTT05UeXBlSW1wbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSlNPTlR5cGVJbXBsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIEpTT05UeXBlSW1wbC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9O1xuICAgIEpTT05UeXBlSW1wbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9O1xuICAgIHJldHVybiBKU09OVHlwZUltcGw7XG59KCkpO1xudmFyIEpTT05Cb29sZWFuVHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTT05Cb29sZWFuVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKU09OQm9vbGVhblR5cGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHZhbHVlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTkJvb2xlYW5UeXBlO1xufShKU09OVHlwZUltcGwpKTtcbnZhciBKU09OTnVtYmVyVHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTT05OdW1iZXJUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTT05OdW1iZXJUeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEpTT05OdW1iZXJUeXBlO1xufShKU09OVHlwZUltcGwpKTtcbnZhciBKU09OU3RyaW5nVHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTT05TdHJpbmdUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTT05TdHJpbmdUeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgSlNPTlN0cmluZ1R5cGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05TdHJpbmdUeXBlO1xufShKU09OVHlwZUltcGwpKTtcbnZhciBKU09OT2JqZWN0VHlwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEpTT05PYmplY3RUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTT05PYmplY3RUeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEpTT05PYmplY3RUeXBlO1xufShKU09OVHlwZUltcGwpKTtcbnZhciBKU09OQXJyYXlUeXBlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSlNPTkFycmF5VHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBKU09OQXJyYXlUeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgSlNPTkFycmF5VHlwZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9O1xuICAgIHJldHVybiBKU09OQXJyYXlUeXBlO1xufShKU09OVHlwZUltcGwpKTtcbnZhciBKU09OTnVsbFR5cGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhKU09OTnVsbFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSlNPTk51bGxUeXBlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbnVsbCkgfHwgdGhpcztcbiAgICB9XG4gICAgSlNPTk51bGxUeXBlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05OdWxsVHlwZTtcbn0oSlNPTlR5cGVJbXBsKSk7XG52YXIgSlNPTlR5cGVDb252ZXJ0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT05UeXBlQ29udmVydGVyKCkge1xuICAgIH1cbiAgICBKU09OVHlwZUNvbnZlcnRlci50b0pTT05UeXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OTnVsbFR5cGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05TdHJpbmdUeXBlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05OdW1iZXJUeXBlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU09OQm9vbGVhblR5cGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEpTT05PYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNPTk9iamVjdFR5cGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR5cGUgbm90IHN1cHBvcnRlZCBmb3IgdmFsdWU6IFwiICsgdmFsdWUpO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05UeXBlQ29udmVydGVyO1xufSgpKTtcbnZhciBKU09OT2JqZWN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKU09OT2JqZWN0KCkge1xuICAgICAgICB0aGlzLnZhbHVlcyA9IG5ldyBEYXRhU3RydWN0dXJlc18xLlNpbXBsZU1hcCgpO1xuICAgIH1cbiAgICBKU09OT2JqZWN0LnByb3RvdHlwZS5hZGRCb29sZWFuID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tOYW1lKG5hbWUpO1xuICAgICAgICBKU09OT2JqZWN0LmNoZWNrVmFsdWUodmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlcy5wdXQobmFtZSwgbmV3IEpTT05Cb29sZWFuVHlwZSh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEpTT05PYmplY3QucHJvdG90eXBlLmFkZE51bWJlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrTmFtZShuYW1lKTtcbiAgICAgICAgSlNPTk9iamVjdC5jaGVja1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZXMucHV0KG5hbWUsIG5ldyBKU09OTnVtYmVyVHlwZSh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEpTT05PYmplY3QucHJvdG90eXBlLmFkZFN0cmluZyA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrTmFtZShuYW1lKTtcbiAgICAgICAgSlNPTk9iamVjdC5jaGVja1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy52YWx1ZXMucHV0KG5hbWUsIG5ldyBKU09OU3RyaW5nVHlwZSh2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEpTT05PYmplY3QucHJvdG90eXBlLmFkZE51bGwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLmNoZWNrTmFtZShuYW1lKTtcbiAgICAgICAgdGhpcy52YWx1ZXMucHV0KG5hbWUsIG5ldyBKU09OTnVsbFR5cGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSlNPTk9iamVjdC5wcm90b3R5cGUuYWRkQXJyYXkgPSBmdW5jdGlvbiAobmFtZSwgYXJyYXkpIHtcbiAgICAgICAgdGhpcy5jaGVja05hbWUobmFtZSk7XG4gICAgICAgIEpTT05PYmplY3QuY2hlY2tWYWx1ZShhcnJheSk7XG4gICAgICAgIGlmIChhcnJheSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIGFycmF5IGFzIG51bGxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZXMucHV0KG5hbWUsIG5ldyBKU09OQXJyYXlUeXBlKGFycmF5KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSlNPTk9iamVjdC5wcm90b3R5cGUuYWRkT2JqZWN0ID0gZnVuY3Rpb24gKG5hbWUsIG9iamVjdCkge1xuICAgICAgICB0aGlzLmNoZWNrTmFtZShuYW1lKTtcbiAgICAgICAgSlNPTk9iamVjdC5jaGVja1ZhbHVlKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBvYmplY3QgYXMgbnVsbFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlcy5wdXQobmFtZSwgbmV3IEpTT05PYmplY3RUeXBlKG9iamVjdCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEpTT05PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHByZXR0eSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocHJldHR5ID09PSB2b2lkIDApIHsgcHJldHR5ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGNvbW1hID0gZmFsc2U7XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgRGF0YVN0cnVjdHVyZXNfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIGJ1ZmZlci5hcHBlbmQoXCJ7XCIpO1xuICAgICAgICB0aGlzLnZhbHVlcy5rZXlzKCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy52YWx1ZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21tYSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKFwiLFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyLmFwcGVuZCgnXCInKS5hcHBlbmQoa2V5KS5hcHBlbmQoJ1wiOicpLmFwcGVuZCh2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBjb21tYSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXIuYXBwZW5kKFwifVwiKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygpO1xuICAgIH07XG4gICAgSlNPTk9iamVjdC5wcm90b3R5cGUuY2hlY2tOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gbnVsbCB8fCBuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5hbWUgaXMgbnVsbCBvciB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWVzLmV4aXN0cyhuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmFtZSBcIiArIG5hbWUgKyBcIiBpcyBhbHJlYWR5IHByZXNlbnQgZm9yIHRoaXMgb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBKU09OT2JqZWN0LmNoZWNrVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGlzIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEpTT05PYmplY3Q7XG59KCkpO1xuZXhwb3J0cy5KU09OT2JqZWN0ID0gSlNPTk9iamVjdDtcbnZhciBKU09OQXJyYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT05BcnJheSgpIHtcbiAgICAgICAgdGhpcy5vYmplY3RzID0gW107XG4gICAgfVxuICAgIEpTT05BcnJheS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9iamVjdCBpcyBub3QgYWxsb3dlZCB0byBiZSB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goSlNPTlR5cGVDb252ZXJ0ZXIudG9KU09OVHlwZShvYmplY3QpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBKU09OQXJyYXkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHByZXR0eSkge1xuICAgICAgICBpZiAocHJldHR5ID09PSB2b2lkIDApIHsgcHJldHR5ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBEYXRhU3RydWN0dXJlc18xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgYnVmZmVyLmFwcGVuZChcIltcIik7XG4gICAgICAgIHRoaXMub2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuYXBwZW5kKFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5hcHBlbmQodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBidWZmZXIuYXBwZW5kKFwiXVwiKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05BcnJheTtcbn0oKSk7XG5leHBvcnRzLkpTT05BcnJheSA9IEpTT05BcnJheTtcbi8qKlxuICogVXRpbGl0eSBjbGFzcyB0aGF0IGhlbHBzIHVzIGNvbnZlcnQgdGhpbmdzIHRvIGFuZCBmcm9tIGpzb24gKG5vdCBmb3Igbm9ybWFsIHVzYWdlKS5cbiAqL1xudmFyIEpTT05IZWxwZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEpTT05IZWxwZXIoKSB7XG4gICAgfVxuICAgIEpTT05IZWxwZXIuY2F0ZWdvcnlUb0pTT04gPSBmdW5jdGlvbiAoY2F0LCByZWN1cnNpdmUpIHtcbiAgICAgICAgLypcbiAgICAgICAgIHtcbiAgICAgICAgIFwiY2F0ZWdvcmllc1wiOlxuICAgICAgICAgW1xuICAgICAgICAgeyBpZD0xLFxuICAgICAgICAgbmFtZTogXCJ4XCIsXG4gICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICBsb2dMZXZlbDogXCJFcnJvclwiXG4gICAgICAgICB9LFxuICAgICAgICAgeyBpZD0yLFxuICAgICAgICAgbmFtZTogXCJ5XCIsXG4gICAgICAgICBwYXJlbnQ6IDEsXG4gICAgICAgICBsb2dMZXZlbDogXCJFcnJvclwiXG4gICAgICAgICB9XG4gICAgICAgICBdXG4gICAgICAgICB9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYXJyID0gbmV3IEpTT05BcnJheSgpO1xuICAgICAgICBKU09OSGVscGVyLl9jYXRlZ29yeVRvSlNPTihjYXQsIGFyciwgcmVjdXJzaXZlKTtcbiAgICAgICAgdmFyIG9iamVjdCA9IG5ldyBKU09OT2JqZWN0KCk7XG4gICAgICAgIG9iamVjdC5hZGRBcnJheShcImNhdGVnb3JpZXNcIiwgYXJyKTtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9O1xuICAgIEpTT05IZWxwZXIuX2NhdGVnb3J5VG9KU09OID0gZnVuY3Rpb24gKGNhdCwgYXJyLCByZWN1cnNpdmUpIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IG5ldyBKU09OT2JqZWN0KCk7XG4gICAgICAgIG9iamVjdC5hZGROdW1iZXIoXCJpZFwiLCBjYXQuaWQpO1xuICAgICAgICBvYmplY3QuYWRkU3RyaW5nKFwibmFtZVwiLCBjYXQubmFtZSk7XG4gICAgICAgIG9iamVjdC5hZGRTdHJpbmcoXCJsb2dMZXZlbFwiLCBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWxbY2F0LmxvZ0xldmVsXS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKGNhdC5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqZWN0LmFkZE51bWJlcihcInBhcmVudFwiLCBjYXQucGFyZW50LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iamVjdC5hZGROdWxsKFwicGFyZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGFyci5hZGQob2JqZWN0KTtcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgICAgICAgY2F0LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgSlNPTkhlbHBlci5fY2F0ZWdvcnlUb0pTT04oY2hpbGQsIGFyciwgcmVjdXJzaXZlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTkhlbHBlcjtcbn0oKSk7XG5leHBvcnRzLkpTT05IZWxwZXIgPSBKU09OSGVscGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SlNPTkhlbHBlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTVCA9IHJlcXVpcmUoXCJzdGFja3RyYWNlLWpzXCIpO1xudmFyIExvZ2dlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9sb2cvTG9nZ2VyT3B0aW9uc1wiKTtcbi8qKlxuICogU29tZSB1dGlsaXRpZXMgdG8gZm9ybWF0IG1lc3NhZ2VzLlxuICovXG52YXIgTWVzc2FnZUZvcm1hdFV0aWxzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXNzYWdlRm9ybWF0VXRpbHMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlciBnaXZlbiBkYXRlIGluIGdpdmVuIERhdGVGb3JtYXQgYW5kIHJldHVybiBhcyBTdHJpbmcuXG4gICAgICogQHBhcmFtIGRhdGUgRGF0ZVxuICAgICAqIEBwYXJhbSBkYXRlRm9ybWF0IEZvcm1hdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBkYXRlXG4gICAgICovXG4gICAgTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckRhdGUgPSBmdW5jdGlvbiAoZGF0ZSwgZGF0ZUZvcm1hdCkge1xuICAgICAgICB2YXIgbHBhZCA9IGZ1bmN0aW9uICh2YWx1ZSwgY2hhcnMsIHBhZFdpdGgpIHtcbiAgICAgICAgICAgIHZhciBob3dNYW55ID0gY2hhcnMgLSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoaG93TWFueSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvd01hbnk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gcGFkV2l0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmdWxsWWVhciA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSwgNCwgXCIwXCIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbW9udGggPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxwYWQoKGQuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCksIDIsIFwiMFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRheSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldERhdGUoKS50b1N0cmluZygpLCAyLCBcIjBcIik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBob3VycyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldEhvdXJzKCkudG9TdHJpbmcoKSwgMiwgXCIwXCIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWludXRlcyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldE1pbnV0ZXMoKS50b1N0cmluZygpLCAyLCBcIjBcIik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZWNvbmRzID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBscGFkKGQuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCksIDIsIFwiMFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1pbGxpcyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gbHBhZChkLmdldE1pbGxpc2Vjb25kcygpLnRvU3RyaW5nKCksIDMsIFwiMFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRhdGVTZXBhcmF0b3IgPSBkYXRlRm9ybWF0LmRhdGVTZXBhcmF0b3I7XG4gICAgICAgIHZhciBkcyA9IFwiXCI7XG4gICAgICAgIHN3aXRjaCAoZGF0ZUZvcm1hdC5mb3JtYXRFbnVtKSB7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0RW51bS5EZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIHl5eXktbW0tZGQgaGg6bW06c3MsbVxuICAgICAgICAgICAgICAgIGRzID0gZnVsbFllYXIoZGF0ZSkgKyBkYXRlU2VwYXJhdG9yICsgbW9udGgoZGF0ZSkgKyBkYXRlU2VwYXJhdG9yICsgZGF5KGRhdGUpICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICBob3VycyhkYXRlKSArIFwiOlwiICsgbWludXRlcyhkYXRlKSArIFwiOlwiICsgc2Vjb25kcyhkYXRlKSArIFwiLFwiICsgbWlsbGlzKGRhdGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBMb2dnZXJPcHRpb25zXzEuRGF0ZUZvcm1hdEVudW0uWWVhck1vbnRoRGF5VGltZTpcbiAgICAgICAgICAgICAgICBkcyA9IGZ1bGxZZWFyKGRhdGUpICsgZGF0ZVNlcGFyYXRvciArIG1vbnRoKGRhdGUpICsgZGF0ZVNlcGFyYXRvciArIGRheShkYXRlKSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgaG91cnMoZGF0ZSkgKyBcIjpcIiArIG1pbnV0ZXMoZGF0ZSkgKyBcIjpcIiArIHNlY29uZHMoZGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0RW51bS5ZZWFyRGF5TW9udGhXaXRoRnVsbFRpbWU6XG4gICAgICAgICAgICAgICAgZHMgPSBmdWxsWWVhcihkYXRlKSArIGRhdGVTZXBhcmF0b3IgKyBkYXkoZGF0ZSkgKyBkYXRlU2VwYXJhdG9yICsgbW9udGgoZGF0ZSkgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgIGhvdXJzKGRhdGUpICsgXCI6XCIgKyBtaW51dGVzKGRhdGUpICsgXCI6XCIgKyBzZWNvbmRzKGRhdGUpICsgXCIsXCIgKyBtaWxsaXMoZGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExvZ2dlck9wdGlvbnNfMS5EYXRlRm9ybWF0RW51bS5ZZWFyRGF5TW9udGhUaW1lOlxuICAgICAgICAgICAgICAgIGRzID0gZnVsbFllYXIoZGF0ZSkgKyBkYXRlU2VwYXJhdG9yICsgZGF5KGRhdGUpICsgZGF0ZVNlcGFyYXRvciArIG1vbnRoKGRhdGUpICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICBob3VycyhkYXRlKSArIFwiOlwiICsgbWludXRlcyhkYXRlKSArIFwiOlwiICsgc2Vjb25kcyhkYXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0ZSBmb3JtYXQgZW51bTogXCIgKyBkYXRlRm9ybWF0LmZvcm1hdEVudW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgZ2l2ZW4gY2F0ZWdvcnkgbG9nIG1lc3NhZ2UgaW4gZGVmYXVsdCBmb3JtYXQuXG4gICAgICogQHBhcmFtIG1zZyBNZXNzYWdlIHRvIGZvcm1hdFxuICAgICAqIEBwYXJhbSBhZGRTdGFjayBJZiB0cnVlIGFkZHMgdGhlIHN0YWNrIHRvIHRoZSBvdXRwdXQsIG90aGVyd2lzZSBza2lwcyBpdFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBtZXNzYWdlXG4gICAgICovXG4gICAgTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckRlZmF1bHRNZXNzYWdlID0gZnVuY3Rpb24gKG1zZywgYWRkU3RhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIHZhciBsb2dGb3JtYXQgPSBtc2cubG9nRm9ybWF0O1xuICAgICAgICBpZiAobG9nRm9ybWF0LnNob3dUaW1lU3RhbXApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBNZXNzYWdlRm9ybWF0VXRpbHMucmVuZGVyRGF0ZShtc2cuZGF0ZSwgbG9nRm9ybWF0LmRhdGVGb3JtYXQpICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IExvZ2dlck9wdGlvbnNfMS5Mb2dMZXZlbFttc2cubGV2ZWxdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChtc2cuaXNSZXNvbHZlZEVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiIChyZXNvbHZlZClcIjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gXCIgXCI7XG4gICAgICAgIGlmIChsb2dGb3JtYXQuc2hvd0NhdGVnb3J5TmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiW1wiO1xuICAgICAgICAgICAgbXNnLmNhdGVnb3JpZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICAgICAgICAgIGlmIChpZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiwgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZS5uYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBub3JtYWwgc3RyaW5nIG1lc3NhZ2UgZmlyc3RcbiAgICAgICAgdmFyIGFjdHVhbFN0cmluZ01zZyA9IFwiXCI7XG4gICAgICAgIHZhciBkYXRhU3RyaW5nID0gXCJcIjtcbiAgICAgICAgdmFyIG1lc3NhZ2VPckxvZ0RhdGEgPSBtc2cubWVzc2FnZTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlT3JMb2dEYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhY3R1YWxTdHJpbmdNc2cgPSBtZXNzYWdlT3JMb2dEYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxvZ0RhdGEgPSBtZXNzYWdlT3JMb2dEYXRhO1xuICAgICAgICAgICAgYWN0dWFsU3RyaW5nTXNnID0gbG9nRGF0YS5tc2c7XG4gICAgICAgICAgICAvLyBXZSBkbyBoYXZlIGRhdGE/XG4gICAgICAgICAgICBpZiAobG9nRGF0YS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YVN0cmluZyA9IFwiIFtkYXRhXTogXCIgKyAobG9nRGF0YS5kcyA/IGxvZ0RhdGEuZHMobG9nRGF0YS5kYXRhKSA6IEpTT04uc3RyaW5naWZ5KGxvZ0RhdGEuZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIiBcIiArIGFjdHVhbFN0cmluZ01zZyArIFwiXCIgKyBkYXRhU3RyaW5nO1xuICAgICAgICBpZiAoYWRkU3RhY2sgJiYgbXNnLmVycm9yQXNTdGFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCIgKyBtc2cuZXJyb3JBc1N0YWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGdpdmVuIGxvZzRqIGxvZyBtZXNzYWdlIGluIGRlZmF1bHQgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBtc2cgTWVzc2FnZSB0byBmb3JtYXRcbiAgICAgKiBAcGFyYW0gYWRkU3RhY2sgSWYgdHJ1ZSBhZGRzIHRoZSBzdGFjayB0byB0aGUgb3V0cHV0LCBvdGhlcndpc2Ugc2tpcHMgaXRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBGb3JtYXR0ZWQgbWVzc2FnZVxuICAgICAqL1xuICAgIE1lc3NhZ2VGb3JtYXRVdGlscy5yZW5kZXJEZWZhdWx0TG9nNGpNZXNzYWdlID0gZnVuY3Rpb24gKG1zZywgYWRkU3RhY2spIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IG1zZy5sb2dHcm91cFJ1bGUubG9nRm9ybWF0O1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKGZvcm1hdC5zaG93VGltZVN0YW1wKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckRhdGUobXNnLmRhdGUsIGZvcm1hdC5kYXRlRm9ybWF0KSArIFwiIFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBMb2dnZXJPcHRpb25zXzEuTG9nTGV2ZWxbbXNnLmxldmVsXS50b1VwcGVyQ2FzZSgpICsgXCIgXCI7XG4gICAgICAgIGlmIChmb3JtYXQuc2hvd0xvZ2dlck5hbWUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIltcIiArIG1zZy5sb2dnZXJOYW1lICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBub3JtYWwgc3RyaW5nIG1lc3NhZ2UgZmlyc3RcbiAgICAgICAgdmFyIGFjdHVhbFN0cmluZ01zZyA9IFwiXCI7XG4gICAgICAgIHZhciBkYXRhU3RyaW5nID0gXCJcIjtcbiAgICAgICAgaWYgKHR5cGVvZiBtc2cubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWN0dWFsU3RyaW5nTXNnID0gbXNnLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbG9nRGF0YSA9IG1zZy5tZXNzYWdlO1xuICAgICAgICAgICAgYWN0dWFsU3RyaW5nTXNnID0gbG9nRGF0YS5tc2c7XG4gICAgICAgICAgICAvLyBXZSBkbyBoYXZlIGRhdGE/XG4gICAgICAgICAgICBpZiAobG9nRGF0YS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YVN0cmluZyA9IFwiIFtkYXRhXTogXCIgKyAobG9nRGF0YS5kcyA/IGxvZ0RhdGEuZHMobG9nRGF0YS5kYXRhKSA6IEpTT04uc3RyaW5naWZ5KGxvZ0RhdGEuZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIiBcIiArIGFjdHVhbFN0cmluZ01zZyArIFwiXCIgKyBkYXRhU3RyaW5nO1xuICAgICAgICBpZiAoYWRkU3RhY2sgJiYgbXNnLmVycm9yQXNTdGFjayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCIgKyBtc2cuZXJyb3JBc1N0YWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgZXJyb3IgYXMgc3RhY2tcbiAgICAgKiBAcGFyYW0gZXJyb3IgUmV0dXJuIGVycm9yIGFzIFByb21pc2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fFByb21pc2V9IFByb21pc2UgZm9yIHN0YWNrXG4gICAgICovXG4gICAgTWVzc2FnZUZvcm1hdFV0aWxzLnJlbmRlckVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBlcnJvci5uYW1lICsgXCI6IFwiICsgZXJyb3IubWVzc2FnZSArIFwiXFxuQFwiO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgb25lIGhhcyBhIHByb21pc2UgdG9vXG4gICAgICAgICAgICBTVC5mcm9tRXJyb3IoZXJyb3IsIHsgb2ZmbGluZTogdHJ1ZSB9KS50aGVuKGZ1bmN0aW9uIChmcmFtZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tTdHIgPSAoZnJhbWVzLm1hcChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfSkpLmpvaW4oXCJcXG4gIFwiKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cIiArIHN0YWNrU3RyO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVzb2x2ZXMgb3VyIHJldHVybmVkIHByb21pc2VcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gXCJVbmV4cGVjdGVkIGVycm9yIG9iamVjdCB3YXMgcGFzc2VkIGluLiBcIjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJDb3VsZCBub3QgcmVzb2x2ZSBpdCwgc3RyaW5naWZpZWQgb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2Fubm90IHN0cmluZ2lmeSBjYW4gb25seSB0ZWxsIHNvbWV0aGluZyB3YXMgd3JvbmcuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIkNvdWxkIG5vdCByZXNvbHZlIGl0IG9yIHN0cmluZ2lmeSBpdC5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1lc3NhZ2VGb3JtYXRVdGlscztcbn0oKSk7XG5leHBvcnRzLk1lc3NhZ2VGb3JtYXRVdGlscyA9IE1lc3NhZ2VGb3JtYXRVdGlscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc3NhZ2VVdGlscy5qcy5tYXAiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2luZGV4LnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9